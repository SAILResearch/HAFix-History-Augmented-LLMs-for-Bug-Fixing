{
  "id": "11",
  "blame_commit": {
    "commit": {
      "commit_id": "f5c33160573a87486c5f0b7423245a89a6d02e0b",
      "commit_message": "Resolve #738 by requiring positional params to be significant",
      "commit_author": "Erik Bernhardsson",
      "commit_date": "2015-02-10 21:34:32",
      "commit_parent": "11c69ace54ff7167358cb6830fb14142047de3a8"
    },
    "function": {
      "function_name": "get_param_values",
      "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    task_name = cls.task_family\n    exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_task_value(task_name, param_name):\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.task_value(task_name, param_name)\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
      "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    task_name = cls.task_family\n    exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if p.significant]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_task_value(task_name, param_name):\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.task_value(task_name, param_name)\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
      "function_before_start_line": 309,
      "function_before_end_line": 358,
      "function_after_start_line": 309,
      "function_after_end_line": 358,
      "function_before_token_count": 232,
      "function_after_token_count": 236,
      "functions_name_modified_file": [
        "process_resources",
        "output",
        "_requires",
        "id_to_name_and_params",
        "get_params",
        "input",
        "flatten",
        "event_handler",
        "externalize",
        "get_all_params",
        "__hash__",
        "requires",
        "run",
        "get_task_cls",
        "on_failure",
        "on_success",
        "from_str_params",
        "initialized",
        "bulk_complete",
        "__new__",
        "namespace",
        "get_reg",
        "clone",
        "to_str_params",
        "clear_instance_cache",
        "__eq__",
        "trigger_event",
        "__repr__",
        "__init__",
        "__call__",
        "task_family",
        "complete",
        "tasks_str",
        "deps",
        "getpaths",
        "task_module",
        "get_param_values",
        "disable_instance_cache",
        "flatten_output"
      ],
      "functions_name_all_files": [
        "test_use_config_class_with_configuration_2",
        "test_global_param_dep_cmdline",
        "output",
        "test_run",
        "reducer",
        "id_to_name_and_params",
        "get_params",
        "test_x_arg_override",
        "test_y_arg_override_banana",
        "test_failing_job",
        "testHasDefaultNoValue",
        "testDefaultFromTaskName",
        "testTimeDelta8601",
        "testTimeDelta8601NoTimeComponent",
        "test_x_arg_y_arg_override_all",
        "test_create_packages_archive_package_submodule",
        "test_insignificant_parameter",
        "testTimeDeltaMultiple",
        "test_global_param_dep_cmdline_bool",
        "get_all_params",
        "on_failure",
        "testGlobal",
        "from_str_params",
        "test_bool_true",
        "requires_local",
        "bulk_complete",
        "__new__",
        "testHasDefaultWithBoth",
        "testDate",
        "test_forgot_param",
        "setUp",
        "__init__",
        "_assert_package",
        "test_use_config_class_more_args",
        "testDateHour",
        "test_unicode_job",
        "testDefaultFromTaskNameWithDefault",
        "task_module",
        "test_run_2",
        "tearDown",
        "testGlobalAndMissing",
        "testWithDefaultAndMissing",
        "test_unknown_param",
        "testDefaultIntList",
        "get_output",
        "test_instantiate_job",
        "test_task_creation",
        "externalize",
        "requires",
        "test_create_packages_archive_module",
        "testNoSection",
        "run",
        "test_x_arg",
        "test_use_config_class_1",
        "test_default_param_cmdline",
        "initialized",
        "test_x_arg_y_arg",
        "namespace",
        "test_x_arg_override_stupid",
        "to_str_params",
        "test_create_packages_archive_package_submodule_with_absolute_import",
        "clear_instance_cache",
        "testDefaultList",
        "test_global_param_cmdline",
        "test_global_param_shared",
        "task_family",
        "test_misc_1",
        "init_local",
        "tasks_str",
        "test_global_param_cmdline_flipped",
        "testTimeDelta8601MBeforeT",
        "get_param_values",
        "disable_instance_cache",
        "testDateInterval",
        "process_resources",
        "_assert_package_subpackage",
        "_requires",
        "testInt",
        "testWithDefault",
        "input",
        "test_multibool_empty",
        "testTimeDelta8601YearMonthNotSupported",
        "__hash__",
        "combiner",
        "test_multibool",
        "testOverrideSchedulerPort",
        "testTimeDeltaPlural",
        "on_success",
        "mapper",
        "test_use_config_class_2",
        "get_reg",
        "test_y_arg_override_both",
        "test_create_packages_archive_package_subpackage",
        "__eq__",
        "trigger_event",
        "read_wordcount_output",
        "init_hadoop",
        "__repr__",
        "test_forgot_param_in_dep",
        "test_unknown_param_2",
        "__call__",
        "complete",
        "testDefault",
        "deps",
        "getpaths",
        "test_default_param",
        "testTimeDelta",
        "test_create_packages_archive_package",
        "test_map_only",
        "test_create_packages_archive_package_subpackage_submodule",
        "expect_keys",
        "test_create_packages_archive_package_submodule_without_imports",
        "flatten_output",
        "job_runner",
        "test_global_param_override",
        "test_global_param_dep_cmdline_optparse",
        "test_missing_param",
        "testDefaultFromConfigWithTaskNameToo",
        "test_y_arg_override",
        "flatten",
        "test_use_config_class_with_configuration",
        "testTimeDelta8601Weeks",
        "event_handler",
        "testHasDefaultNoSection",
        "get_task_cls",
        "testBool",
        "test_global_param_defaults",
        "_assert_module",
        "test_parameter_registration",
        "clone",
        "test_duplicated_param",
        "testTimeDelta8601MAfterT",
        "testNoValue",
        "test_x_arg_y_arg_override",
        "test_bool_false",
        "requires_hadoop",
        "testDefaultFromTaskNameInt"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_instantiate_job",
        "test_insignificant_parameter"
      ]
    },
    "file": {
      "file_name": "task.py",
      "file_nloc": 358,
      "file_complexity": 111,
      "file_token_count": 1974,
      "file_before": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nimport abc\nimport itertools\nimport logging\nimport traceback\nimport warnings\n\nimport parameter\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\"\n    Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`.\n\n    Acts as a global registry of Tasks with the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"\n        Clear/Reset the instance cache.\n        \"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"\n        Disables the instance cache.\n        \"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls, include_config_without_section=False):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run == NotImplemented:\n                continue\n            if issubclass(cls, ConfigWithoutSection) and not include_config_without_section:\n                continue\n            name = cls.task_family\n\n            if name in reg and reg[name] != cls and \\\n                    reg[name] != cls.AMBIGUOUS_CLASS and \\\n                    not issubclass(cls, reg[name]):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg(include_config_without_section=True).iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, issubclass(task_cls, ConfigWithoutSection), param_name, param_obj\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work.\n\n    The key methods of a Task, which must be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor to resolve values for all Parameters.\n\n        For example, the Task:\n\n        .. code-block:: python\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exists.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n        \"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\nclass MixinNaiveBulkComplete(object):\n    \"\"\"\n    Enables a Task to be efficiently scheduled with e.g. range tools, by providing a bulk_complete implementation which checks completeness in a loop.\n\n    Applicable to tasks whose completeness checking is cheap.\n\n    This doesn't exploit output location specific APIs for speed advantage, nevertheless removes redundant scheduler roundtrips.\n    \"\"\"\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        return [t for t in parameter_tuples if cls(t).complete()]\n\n\ndef externalize(task):\n    \"\"\"\n    Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"\n    Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"\n    Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\nclass Config(Task):\n\n    \"\"\"Used for configuration that's not specific to a certain task\n\n    TODO: let's refactor Task & Config so that it inherits from a common\n    ParamContainer base class\n    \"\"\"\n    pass\n\n\nclass ConfigWithoutSection(Task):\n\n    \"\"\"Used for configuration that doesn't have a particular section\n\n    (eg. --n-workers)\n    \"\"\"\n    pass\n\n\ndef getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> flatten({'a': 'foo', 'b': 'bar'})\n        ['foo', 'bar']\n        >>> flatten(['foo', ['bar', 'troll']])\n        ['foo', 'bar', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
      "file_after": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nimport abc\nimport itertools\nimport logging\nimport traceback\nimport warnings\n\nimport parameter\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\"\n    Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`.\n\n    Acts as a global registry of Tasks with the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"\n        Clear/Reset the instance cache.\n        \"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"\n        Disables the instance cache.\n        \"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls, include_config_without_section=False):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run == NotImplemented:\n                continue\n            if issubclass(cls, ConfigWithoutSection) and not include_config_without_section:\n                continue\n            name = cls.task_family\n\n            if name in reg and reg[name] != cls and \\\n                    reg[name] != cls.AMBIGUOUS_CLASS and \\\n                    not issubclass(cls, reg[name]):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg(include_config_without_section=True).iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, issubclass(task_cls, ConfigWithoutSection), param_name, param_obj\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work.\n\n    The key methods of a Task, which must be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.significant]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor to resolve values for all Parameters.\n\n        For example, the Task:\n\n        .. code-block:: python\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exists.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n        \"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\nclass MixinNaiveBulkComplete(object):\n    \"\"\"\n    Enables a Task to be efficiently scheduled with e.g. range tools, by providing a bulk_complete implementation which checks completeness in a loop.\n\n    Applicable to tasks whose completeness checking is cheap.\n\n    This doesn't exploit output location specific APIs for speed advantage, nevertheless removes redundant scheduler roundtrips.\n    \"\"\"\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        return [t for t in parameter_tuples if cls(t).complete()]\n\n\ndef externalize(task):\n    \"\"\"\n    Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"\n    Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"\n    Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\nclass Config(Task):\n\n    \"\"\"Used for configuration that's not specific to a certain task\n\n    TODO: let's refactor Task & Config so that it inherits from a common\n    ParamContainer base class\n    \"\"\"\n    pass\n\n\nclass ConfigWithoutSection(Task):\n\n    \"\"\"Used for configuration that doesn't have a particular section\n\n    (eg. --n-workers)\n    \"\"\"\n    pass\n\n\ndef getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> flatten({'a': 'foo', 'b': 'bar'})\n        ['foo', 'bar']\n        >>> flatten(['foo', ['bar', 'troll']])\n        ['foo', 'bar', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
      "file_patch": "@@ -326,7 +326,7 @@ class Task(object):\n         exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n \n         # Fill in the positional arguments\n-        positional_params = [(n, p) for n, p in params]\n+        positional_params = [(n, p) for n, p in params if p.significant]\n         for i, arg in enumerate(args):\n             if i >= len(positional_params):\n                 raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n",
      "files_name_in_blame_commit": [
        "parameter_test.py",
        "task.py",
        "hadoop_test.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 100
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "309": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "    def get_param_values(cls, params, args, kwargs):",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "310": {
        "commit_id": "580cd8deea5c37cf2bb21b2cb156560c3bc4c6b2",
        "line_code": "        \"\"\"",
        "commit_date": "2015-02-03 10:48:30",
        "valid": 1
      },
      "311": {
        "commit_id": "580cd8deea5c37cf2bb21b2cb156560c3bc4c6b2",
        "line_code": "        Get the values of the parameters from the args and kwargs.",
        "commit_date": "2015-02-03 10:48:30",
        "valid": 1
      },
      "312": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 0
      },
      "313": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "        :param params: list of (param_name, Parameter).",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 1
      },
      "314": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "        :param args: positional arguments",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 1
      },
      "315": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "        :param kwargs: keyword arguments.",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 1
      },
      "316": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "        :returns: list of `(name, value)` tuples, one for each parameter.",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 1
      },
      "317": {
        "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
        "line_code": "        \"\"\"",
        "commit_date": "2014-02-10 18:41:27",
        "valid": 1
      },
      "318": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "        result = {}",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "319": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 0
      },
      "320": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "        params_dict = dict(params)",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "321": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 0
      },
      "322": {
        "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
        "line_code": "        task_name = cls.task_family",
        "commit_date": "2015-01-31 16:27:30",
        "valid": 1
      },
      "323": {
        "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
        "line_code": "",
        "commit_date": "2015-01-31 16:27:30",
        "valid": 0
      },
      "324": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "        # In case any exceptions are thrown, create a helpful description of how the Task was invoked",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "325": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "326": {
        "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
        "line_code": "        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)",
        "commit_date": "2015-01-31 16:27:30",
        "valid": 1
      },
      "327": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 0
      },
      "328": {
        "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
        "line_code": "        # Fill in the positional arguments",
        "commit_date": "2012-01-18 16:50:29",
        "valid": 1
      },
      "329": {
        "commit_id": "a78338c77d8d79497a7f89bbfde78ba9877acb36",
        "line_code": "        positional_params = [(n, p) for n, p in params]",
        "commit_date": "2015-01-21 19:10:24",
        "valid": 1
      },
      "330": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "        for i, arg in enumerate(args):",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "331": {
        "commit_id": "8cfda10729272c6f757660de92ba639e82897f15",
        "line_code": "            if i >= len(positional_params):",
        "commit_date": "2012-08-21 15:46:00",
        "valid": 1
      },
      "332": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "333": {
        "commit_id": "adf929568dd6c1cb7de790688fe6ed5924f76a8b",
        "line_code": "            param_name, param_obj = positional_params[i]",
        "commit_date": "2012-08-08 13:14:47",
        "valid": 1
      },
      "334": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "            result[param_name] = arg",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "335": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 0
      },
      "336": {
        "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
        "line_code": "        # Then the optional arguments",
        "commit_date": "2012-01-18 16:50:29",
        "valid": 1
      },
      "337": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "        for param_name, arg in kwargs.iteritems():",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "338": {
        "commit_id": "8cfda10729272c6f757660de92ba639e82897f15",
        "line_code": "            if param_name in result:",
        "commit_date": "2012-08-21 15:46:00",
        "valid": 1
      },
      "339": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "340": {
        "commit_id": "8cfda10729272c6f757660de92ba639e82897f15",
        "line_code": "            if param_name not in params_dict:",
        "commit_date": "2012-08-21 15:46:00",
        "valid": 1
      },
      "341": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "342": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "            result[param_name] = arg",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "343": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 0
      },
      "344": {
        "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
        "line_code": "        # Then use the defaults for anything not filled in",
        "commit_date": "2012-01-18 16:50:29",
        "valid": 1
      },
      "345": {
        "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
        "line_code": "        for param_name, param_obj in params:",
        "commit_date": "2012-01-18 16:50:29",
        "valid": 1
      },
      "346": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "            if param_name not in result:",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 1
      },
      "347": {
        "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
        "line_code": "                if not param_obj.has_task_value(task_name, param_name):",
        "commit_date": "2015-01-31 16:27:30",
        "valid": 1
      },
      "348": {
        "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
        "line_code": "                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))",
        "commit_date": "2013-04-18 11:44:53",
        "valid": 1
      },
      "349": {
        "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
        "line_code": "                result[param_name] = param_obj.task_value(task_name, param_name)",
        "commit_date": "2015-01-31 16:27:30",
        "valid": 1
      },
      "350": {
        "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
        "line_code": "",
        "commit_date": "2012-01-03 11:44:48",
        "valid": 0
      },
      "351": {
        "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
        "line_code": "        def list_to_tuple(x):",
        "commit_date": "2012-08-02 12:16:46",
        "valid": 1
      },
      "352": {
        "commit_id": "ce6ac951343cad17bc2187b5a07a67aa48bd2f05",
        "line_code": "            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"",
        "commit_date": "2013-08-01 14:38:46",
        "valid": 1
      },
      "353": {
        "commit_id": "ce6ac951343cad17bc2187b5a07a67aa48bd2f05",
        "line_code": "            if isinstance(x, list) or isinstance(x, set):",
        "commit_date": "2013-08-01 14:38:46",
        "valid": 1
      },
      "354": {
        "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
        "line_code": "                return tuple(x)",
        "commit_date": "2012-08-02 12:16:46",
        "valid": 1
      },
      "355": {
        "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
        "line_code": "            else:",
        "commit_date": "2012-08-02 12:16:46",
        "valid": 1
      },
      "356": {
        "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
        "line_code": "                return x",
        "commit_date": "2012-08-02 12:16:46",
        "valid": 1
      },
      "357": {
        "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
        "line_code": "        # Sort it by the correct order and make a list",
        "commit_date": "2012-01-18 16:50:29",
        "valid": 1
      },
      "358": {
        "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
        "line_code": "        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]",
        "commit_date": "2012-08-02 12:16:46",
        "valid": 1
      }
    },
    "commits": {
      "580cd8deea5c37cf2bb21b2cb156560c3bc4c6b2": {
        "commit": {
          "commit_id": "580cd8deea5c37cf2bb21b2cb156560c3bc4c6b2",
          "commit_message": "docstring standardization.\n\nadded newlines to improve readability.\nchanged the wording in the \"For the purpose of this exercise\" paragraph.\n\nfixed sphinx underline complaint.\n\nPython code now has proper syntax highlighting.\n\nadded docs env in tox.ini.\n\nadded declaration for ini code-block.\nchanged python code declaration to code-block.\n\nfixed typo.",
          "commit_author": "steenzout",
          "commit_date": "2015-02-03 10:48:30",
          "commit_parent": "90a1d44d9aaf6db446627103c24054cdf16fb243"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    task_name = cls.task_family\n    exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_task_value(task_name, param_name):\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.task_value(task_name, param_name)\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    task_name = cls.task_family\n    exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_task_value(task_name, param_name):\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.task_value(task_name, param_name)\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 281,
          "function_before_end_line": 329,
          "function_after_start_line": 302,
          "function_after_end_line": 351,
          "function_before_token_count": 232,
          "function_after_token_count": 232,
          "functions_name_modified_file": [
            "process_resources",
            "output",
            "_requires",
            "id_to_name_and_params",
            "get_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "get_all_params",
            "__hash__",
            "requires",
            "run",
            "get_task_cls",
            "on_failure",
            "on_success",
            "from_str_params",
            "initialized",
            "bulk_complete",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "to_str_params",
            "clear_instance_cache",
            "__eq__",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "tasks_str",
            "deps",
            "getpaths",
            "task_module",
            "get_param_values",
            "disable_instance_cache",
            "flatten_output"
          ],
          "functions_name_all_files": [
            "pipe_writer",
            "get_scala_jars",
            "_get_jars",
            "docs",
            "create_table",
            "s3_load_path",
            "id_to_name_and_params",
            "tmppath",
            "_list_existing",
            "mkdir",
            "walk",
            "_get_value",
            "task_started",
            "get_provided_jars",
            "get_all_params",
            "_add_task_event",
            "fix_time",
            "move",
            "parser_dest",
            "_run_task",
            "run_job",
            "_server_already_running",
            "get_data",
            "task_scheduled",
            "download",
            "_constrain_glob",
            "stop",
            "task_module",
            "init_combiner",
            "extract_packages_archive",
            "writeLine",
            "connect",
            "getpcmd",
            "_recurse_deps",
            "copy_json_options",
            "get_configured_hdfs_client",
            "aws_secret_access_key",
            "rename_dont_move",
            "update_resources",
            "_update_priority",
            "requires",
            "rows",
            "externalize",
            "fs",
            "run",
            "is_dir",
            "_get_per_location_glob",
            "create_packages_archive",
            "copy_options",
            "to_str_params",
            "create_marker_table",
            "parse_task",
            "_docs",
            "_request",
            "aws_access_key_id",
            "move_dir",
            "_flush_buffer",
            "_reduce_input",
            "get_configured_hadoop_version",
            "_flush_batch_incr_counter",
            "get_param_values",
            "_schedulable",
            "chmod",
            "check_pid",
            "_requires",
            "_email_unexpected_error",
            "has_value",
            "_validate_dependency",
            "get_active_tasks",
            "list_path",
            "on_success",
            "add_to_cmdline_parser",
            "get_scalding_core",
            "mapper",
            "serialize",
            "_is_root",
            "graph",
            "init_hadoop",
            "__call__",
            "deps",
            "_setup_links",
            "_abort",
            "_update_task_history",
            "get_spool_handler",
            "job_class",
            "incr_counter",
            "settings",
            "check_output",
            "table_location",
            "get_active_workers",
            "_host_ref",
            "has_task",
            "get_task_cls",
            "touch",
            "dep_graph",
            "put",
            "marker_index_hist_size",
            "timeout",
            "get_task_parameters",
            "clone",
            "update",
            "send_email_smtp",
            "get_scalding_jars",
            "abort",
            "call_check",
            "write_pid",
            "_get_with_default",
            "raise_on_error",
            "job_args",
            "put_multipart",
            "user",
            "listdir",
            "spark_heartbeat",
            "run_api_threaded",
            "load",
            "inverse_dependencies",
            "_add_path_delimiter",
            "_scp",
            "_has_resources",
            "wrap_traceback",
            "_serialize_task",
            "__getattr__",
            "on_failure",
            "glob_exists",
            "from_str_params",
            "_chained_call",
            "getint",
            "jsonpath",
            "atomic_output",
            "daemonize",
            "clear",
            "add_global_parameters",
            "_incr_counter",
            "getmerge",
            "inverse_dep_graph",
            "_finish",
            "generate_email",
            "jar",
            "get_template_path",
            "group",
            "create_remote_scheduler",
            "_session",
            "__str__",
            "source",
            "extra_modules",
            "port",
            "program",
            "add_worker",
            "_emit_metrics",
            "apply_async",
            "_init_connection",
            "_get",
            "disable_instance_cache",
            "process_resources",
            "_generate_worker_info",
            "instance",
            "find_all_by_parameters",
            "_is_writable",
            "ensure_hist_size",
            "spark_options",
            "writer",
            "worker_list",
            "__hash__",
            "moving_start",
            "reader",
            "trigger_event",
            "__repr__",
            "fetch_task_failures",
            "add_config_path",
            "_init_api",
            "get_task",
            "env_params",
            "_get_s3_config",
            "pipe_reader",
            "doc_type",
            "num_failures",
            "pickle_reader",
            "get_key",
            "moving_stop",
            "__iter__",
            "password",
            "load_hive_cmd",
            "hiverc",
            "exists",
            "close",
            "_process_args",
            "create_local_scheduler",
            "table_exists",
            "get",
            "hdfs_reader",
            "chown",
            "parse",
            "pickle_writer",
            "sample",
            "reload",
            "output",
            "task_finished",
            "can_disable",
            "_post",
            "get_params",
            "list",
            "check_complete",
            "hdfs_writer",
            "previous",
            "create_worker",
            "add_info",
            "finite_datetimes",
            "path",
            "requires_local",
            "send_email_sendgrid",
            "__new__",
            "missing_datetimes",
            "__init__",
            "connection_string",
            "setup_interface_logging",
            "internal_writer",
            "_map_input",
            "getintdict",
            "upload",
            "set_global",
            "isdir",
            "send_email_ses",
            "table",
            "_log_unexpected_error",
            "get_all_data",
            "_log_remote_tasks",
            "get_config",
            "open",
            "run_reducer",
            "_add_worker",
            "hiveconfs",
            "email_type",
            "attach",
            "parse_from_input",
            "task_family",
            "init_local",
            "find_task_by_id",
            "finish",
            "_parseIso8601",
            "load_task",
            "dereference",
            "input",
            "__enter__",
            "chunk_size",
            "get_libjars",
            "add_link",
            "partition_spec",
            "get_reg",
            "acquire_for",
            "delegates",
            "most_common",
            "is_writable",
            "complete",
            "getfloat",
            "update_id",
            "set_global_parameters",
            "run_hive_script",
            "kill_job",
            "set",
            "_wait",
            "_format_range",
            "extra_files",
            "internal_reader",
            "remove",
            "get_worker",
            "http_auth",
            "get_info",
            "task_list",
            "_existing_partitions",
            "rename",
            "error_task_names",
            "parameter_to_datetime",
            "_connect",
            "put_string",
            "index",
            "relpath",
            "_setup_remote",
            "common_params",
            "_replacer",
            "set_status",
            "get_extra_files",
            "_validate_task",
            "prepare_outputs",
            "get_hive_syntax",
            "set_global_from_args",
            "get_work",
            "app",
            "add_failure",
            "host",
            "readlines",
            "has_task_value",
            "marker_index_document_id",
            "makedirs",
            "create_index",
            "_rm_recursive",
            "add_task",
            "reset_global",
            "table_schema",
            "_apply_regex",
            "parse_from_args",
            "_get_work",
            "bulk_complete",
            "mapping",
            "datetime_to_parameter",
            "map_column",
            "get_previous_completed",
            "extra_jars",
            "inactivate_workers",
            "deprecate_kwarg",
            "prune",
            "fn",
            "run_hive_cmd",
            "_upstream_status",
            "create_hadoopcli_client",
            "_email_complete_error",
            "ping",
            "_editdistance",
            "tmp_path",
            "_traverse_inverse_deps",
            "print_exception",
            "send_email",
            "create_marker_index",
            "_parseSimple",
            "_add_to_buffer",
            "write",
            "getboolean",
            "main",
            "infer_bulk_complete_from_fs",
            "load_hadoop_cmd",
            "get_autoconfig_client",
            "_prepare_cmd",
            "initialized",
            "build",
            "namespace",
            "_keep_alive",
            "_create_scheduler",
            "clear_instance_cache",
            "count",
            "value",
            "purge_existing_index",
            "tasks_str",
            "_log_complete_error",
            "get_build_dir",
            "find_latest_runs",
            "_find_or_create_task",
            "_get_task",
            "_prefix",
            "has_excessive_failures",
            "build_job_jar",
            "create_subprocess",
            "read",
            "py_files",
            "skip",
            "initialize",
            "send_error_email",
            "fix_paths",
            "_path_to_bucket_and_key",
            "add_task_parameters",
            "run_combiner",
            "task_history",
            "get_job_class",
            "run_and_track_hadoop_job",
            "init_reducer",
            "_handle_next_task",
            "input_local",
            "find_all_by_name",
            "__eq__",
            "re_enable",
            "dump",
            "inactivate_tasks",
            "Popen",
            "get_tmp_job_jar",
            "dependency_jars",
            "_check_complete_value",
            "copy",
            "getpaths",
            "_rank",
            "run_hive",
            "database",
            "run_mapper",
            "flatten_output",
            "get_worker_ids",
            "_get_filesystems_and_globs",
            "job_runner",
            "task_wraps",
            "delete_index",
            "_purge_children",
            "get_pending_tasks",
            "tunnel",
            "args",
            "task_search",
            "get_bite",
            "fork_linked_workers",
            "task_value",
            "flatten",
            "event_handler",
            "get_log_format",
            "_used_resources",
            "add",
            "_write_sparkey_file",
            "track_progress",
            "query",
            "_make_method",
            "_get_value_from_config",
            "serialize_to_input",
            "init_mapper",
            "init_copy",
            "jobconfs",
            "_sleeper",
            "_get_default",
            "_format_datetime",
            "input_hadoop",
            "__del__",
            "get_running_tasks",
            "requires_hadoop",
            "_add",
            "re_enable_task",
            "fetch_error",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "process_resources",
            "output",
            "_requires",
            "get_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "get_all_params",
            "requires",
            "run",
            "get_task_cls",
            "on_failure",
            "on_success",
            "from_str_params",
            "initialized",
            "bulk_complete",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "clear_instance_cache",
            "trigger_event",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "tasks_str",
            "getpaths",
            "disable_instance_cache",
            "flatten_output"
          ],
          "functions_name_co_evolved_all_files": [
            "_get_with_default",
            "add_failure",
            "raise_on_error",
            "output",
            "job_args",
            "docs",
            "create_table",
            "s3_load_path",
            "listdir",
            "get_params",
            "id_to_name_and_params",
            "_list_existing",
            "run_api_threaded",
            "check_complete",
            "host",
            "mkdir",
            "previous",
            "marker_index_document_id",
            "makedirs",
            "create_index",
            "add_task",
            "get_all_params",
            "finite_datetimes",
            "table_schema",
            "path",
            "on_failure",
            "from_str_params",
            "requires_local",
            "move",
            "bulk_complete",
            "__new__",
            "mapping",
            "missing_datetimes",
            "jsonpath",
            "__init__",
            "internal_writer",
            "map_column",
            "_map_input",
            "_constrain_glob",
            "stop",
            "atomic_output",
            "extra_jars",
            "set_global",
            "isdir",
            "deprecate_kwarg",
            "run_hive_cmd",
            "clear",
            "create_hadoopcli_client",
            "_incr_counter",
            "connect",
            "getpcmd",
            "_finish",
            "get_config",
            "create_marker_index",
            "copy_json_options",
            "jar",
            "get_configured_hdfs_client",
            "open",
            "aws_secret_access_key",
            "main",
            "rename_dont_move",
            "_update_priority",
            "requires",
            "rows",
            "externalize",
            "infer_bulk_complete_from_fs",
            "fs",
            "run",
            "run_reducer",
            "get_autoconfig_client",
            "_get_per_location_glob",
            "create_packages_archive",
            "initialized",
            "hiveconfs",
            "build",
            "namespace",
            "copy_options",
            "_keep_alive",
            "create_marker_table",
            "clear_instance_cache",
            "source",
            "attach",
            "value",
            "_docs",
            "purge_existing_index",
            "port",
            "aws_access_key_id",
            "move_dir",
            "task_family",
            "_emit_metrics",
            "init_local",
            "_reduce_input",
            "tasks_str",
            "get_configured_hadoop_version",
            "find_task_by_id",
            "_flush_batch_incr_counter",
            "find_latest_runs",
            "disable_instance_cache",
            "process_resources",
            "_prefix",
            "_requires",
            "load_task",
            "find_all_by_parameters",
            "py_files",
            "skip",
            "ensure_hist_size",
            "has_value",
            "input",
            "writer",
            "send_error_email",
            "fix_paths",
            "chunk_size",
            "on_success",
            "mapper",
            "partition_spec",
            "run_and_track_hadoop_job",
            "moving_start",
            "serialize",
            "get_reg",
            "_handle_next_task",
            "find_all_by_name",
            "reader",
            "acquire_for",
            "trigger_event",
            "delegates",
            "dump",
            "most_common",
            "Popen",
            "fetch_task_failures",
            "__call__",
            "complete",
            "dependency_jars",
            "copy",
            "deps",
            "getpaths",
            "_rank",
            "run_hive",
            "_abort",
            "update_id",
            "run_mapper",
            "flatten_output",
            "run_hive_script",
            "_get_filesystems_and_globs",
            "job_runner",
            "job_class",
            "delete_index",
            "incr_counter",
            "_purge_children",
            "doc_type",
            "tunnel",
            "args",
            "extra_files",
            "num_failures",
            "internal_reader",
            "task_search",
            "settings",
            "remove",
            "fork_linked_workers",
            "check_output",
            "flatten",
            "event_handler",
            "http_auth",
            "moving_stop",
            "task_list",
            "rename",
            "add",
            "hiverc",
            "get_task_cls",
            "track_progress",
            "touch",
            "exists",
            "_connect",
            "marker_index_hist_size",
            "index",
            "table_exists",
            "timeout",
            "clone",
            "relpath",
            "init_copy",
            "common_params",
            "update",
            "__del__",
            "parse",
            "prepare_outputs",
            "__exit__"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 331,
          "file_complexity": 105,
          "file_token_count": 1892,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg().iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, param_name, param_obj\n\n\nclass Task(object):\n\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"Creates an instance from a str->str hash\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return ``False``.\n\n            However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        '''\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        '''\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n\n    >>> flatten({'a': 'foo', 'b': 'bar'})\n    ['foo', 'bar']\n    >>> flatten(['foo', ['bar', 'troll']])\n    ['foo', 'bar', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\"\n    Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`.\n\n    Acts as a global registry of Tasks with the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"\n        Clear/Reset the instance cache.\n        \"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"\n        Disables the instance cache.\n        \"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"\n        Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg().iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, param_name, param_obj\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work.\n\n    The key methods of a Task, which must be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor to resolve values for all Parameters.\n\n        For example, the Task:\n\n        .. code-block:: python\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exists.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n        \"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"\n    Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"\n    Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"\n    Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> flatten({'a': 'foo', 'b': 'bar'})\n        ['foo', 'bar']\n        >>> flatten(['foo', ['bar', 'troll']])\n        ['foo', 'bar', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_patch": "@@ -24,7 +24,8 @@ logger = logging.getLogger('luigi-interface')\n \n \n def namespace(namespace=None):\n-    \"\"\" Call to set namespace of tasks declared after the call.\n+    \"\"\"\n+    Call to set namespace of tasks declared after the call.\n \n     If called without arguments or with ``None`` as the namespace, the namespace\n     is reset, which is recommended to do at the end of any file where the\n@@ -41,10 +42,10 @@ def id_to_name_and_params(task_id):\n \n \n class Register(abc.ABCMeta):\n-\n     \"\"\"\n-    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n-    the following properties:\n+    The Metaclass of :py:class:`Task`.\n+\n+    Acts as a global registry of Tasks with the following properties:\n \n     1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n        same object.\n@@ -59,9 +60,12 @@ class Register(abc.ABCMeta):\n     an error.\"\"\"\n \n     def __new__(metacls, classname, bases, classdict):\n-        \"\"\" Custom class creation for namespacing. Also register all subclasses\n+        \"\"\"\n+        Custom class creation for namespacing.\n \n-        Set the task namespace to whatever the currently declared namespace is\n+        Also register all subclasses.\n+\n+        Set the task namespace to whatever the currently declared namespace is.\n         \"\"\"\n         if \"task_namespace\" not in classdict:\n             classdict[\"task_namespace\"] = metacls._default_namespace\n@@ -72,10 +76,12 @@ class Register(abc.ABCMeta):\n         return cls\n \n     def __call__(cls, *args, **kwargs):\n-        \"\"\" Custom class instantiation utilizing instance cache.\n+        \"\"\"\n+        Custom class instantiation utilizing instance cache.\n \n         If a Task has already been instantiated with the same parameters,\n-        the previous instance is returned to reduce number of object instances.\"\"\"\n+        the previous instance is returned to reduce number of object instances.\n+        \"\"\"\n         def instantiate():\n             return super(Register, cls).__call__(*args, **kwargs)\n \n@@ -102,17 +108,22 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def clear_instance_cache(cls):\n-        \"\"\"Clear/Reset the instance cache.\"\"\"\n+        \"\"\"\n+        Clear/Reset the instance cache.\n+        \"\"\"\n         Register.__instance_cache = {}\n \n     @classmethod\n     def disable_instance_cache(cls):\n-        \"\"\"Disables the instance cache.\"\"\"\n+        \"\"\"\n+        Disables the instance cache.\n+        \"\"\"\n         Register.__instance_cache = None\n \n     @property\n     def task_family(cls):\n-        \"\"\"The task family for the given class.\n+        \"\"\"\n+        The task family for the given class.\n \n         If ``cls.task_namespace is None`` then it's the name of the class.\n         Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n@@ -124,7 +135,8 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def get_reg(cls):\n-        \"\"\"Return all of the registery classes.\n+        \"\"\"\n+        Return all of the registery classes.\n \n         :return:  a ``dict`` of task_family -> class\n         \"\"\"\n@@ -147,13 +159,15 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def tasks_str(cls):\n-        \"\"\"Human-readable register contents dump.\n+        \"\"\"\n+        Human-readable register contents dump.\n         \"\"\"\n         return repr(sorted(Register.get_reg().keys()))\n \n     @classmethod\n     def get_task_cls(cls, name):\n-        \"\"\"Returns an unambiguous class or raises an exception.\n+        \"\"\"\n+        Returns an unambiguous class or raises an exception.\n         \"\"\"\n         task_cls = Register.get_reg().get(name)\n         if not task_cls:\n@@ -164,7 +178,8 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def get_all_params(cls):\n-        \"\"\"Compiles and returns all parameters for all :py:class:`Task`.\n+        \"\"\"\n+        Compiles and returns all parameters for all :py:class:`Task`.\n \n         :return: a ``dict`` of parameter name -> parameter.\n         \"\"\"\n@@ -176,12 +191,12 @@ class Register(abc.ABCMeta):\n \n \n class Task(object):\n-\n     \"\"\"\n     This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n \n-    A Luigi Task describes a unit or work. The key methods of a Task, which must\n-    be implemented in a subclass are:\n+    A Luigi Task describes a unit or work.\n+\n+    The key methods of a Task, which must be implemented in a subclass are:\n \n     * :py:meth:`run` - the computation done by this task.\n     * :py:meth:`requires` - the list of Tasks that this Task depends on.\n@@ -189,6 +204,8 @@ class Task(object):\n \n     Parameters to the Task should be declared as members of the class, e.g.::\n \n+    .. code-block:: python\n+\n         class MyTask(luigi.Task):\n             count = luigi.IntParameter()\n \n@@ -226,15 +243,17 @@ class Task(object):\n \n     @classmethod\n     def event_handler(cls, event):\n-        \"\"\" Decorator for adding event handlers \"\"\"\n+        \"\"\"\n+        Decorator for adding event handlers.\n+        \"\"\"\n         def wrapped(callback):\n             cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n             return callback\n         return wrapped\n \n     def trigger_event(self, event, *args, **kwargs):\n-        \"\"\"Trigger that calls all of the specified events associated with this\n-        class.\n+        \"\"\"\n+        Trigger that calls all of the specified events associated with this class.\n         \"\"\"\n         for event_class, event_callbacks in self._event_callbacks.iteritems():\n             if not isinstance(self, event_class):\n@@ -256,14 +275,16 @@ class Task(object):\n \n     @property\n     def task_family(self):\n-        \"\"\"Convenience method since a property on the metaclass isn't directly\n-        accessible through the class instances.\n+        \"\"\"\n+        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n         \"\"\"\n         return self.__class__.task_family\n \n     @classmethod\n     def get_params(cls):\n-        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n+        \"\"\"\n+        Returns all of the Parameters for this Task.\n+        \"\"\"\n         # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n         params = []\n         for param_name in dir(cls):\n@@ -279,7 +300,8 @@ class Task(object):\n \n     @classmethod\n     def get_param_values(cls, params, args, kwargs):\n-        \"\"\"Get the values of the parameters from the args and kwargs.\n+        \"\"\"\n+        Get the values of the parameters from the args and kwargs.\n \n         :param params: list of (param_name, Parameter).\n         :param args: positional arguments\n@@ -329,9 +351,12 @@ class Task(object):\n         return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n \n     def __init__(self, *args, **kwargs):\n-        \"\"\"Constructor to resolve values for all Parameters.\n+        \"\"\"\n+        Constructor to resolve values for all Parameters.\n \n-        For example, the Task::\n+        For example, the Task:\n+\n+        .. code-block:: python\n \n             class MyTask(luigi.Task):\n                 count = luigi.IntParameter()\n@@ -360,12 +385,15 @@ class Task(object):\n         self.__hash = hash(self.task_id)\n \n     def initialized(self):\n-        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n+        \"\"\"\n+        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n+        \"\"\"\n         return hasattr(self, 'task_id')\n \n     @classmethod\n     def from_str_params(cls, params_str=None):\n-        \"\"\"Creates an instance from a str->str hash\n+        \"\"\"\n+        Creates an instance from a str->str hash.\n \n         :param params_str: dict of param name -> value.\n         \"\"\"\n@@ -388,12 +416,18 @@ class Task(object):\n         return params_str\n \n     def clone(self, cls=None, **kwargs):\n-        ''' Creates a new instance from an existing instance where some of the args have changed.\n+        \"\"\"\n+        Creates a new instance from an existing instance where some of the args have changed.\n+\n+        There's at least two scenarios where this is useful (see test/clone_test.py):\n+\n+        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n+        * there's task inheritance and some logic is on the base class\n \n-        There's at least two scenarios where this is useful (see test/clone_test.py)\n-        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n-        - There's task inheritance and some logic is on the base class\n-        '''\n+        :param cls:\n+        :param kwargs:\n+        :return:\n+        \"\"\"\n         k = self.param_kwargs.copy()\n         k.update(kwargs.iteritems())\n \n@@ -418,10 +452,10 @@ class Task(object):\n \n     def complete(self):\n         \"\"\"\n-            If the task has any outputs, return ``True`` if all outputs exists.\n-            Otherwise, return ``False``.\n+        If the task has any outputs, return ``True`` if all outputs exists.\n+        Otherwise, return ``False``.\n \n-            However, you may freely override this method with custom logic.\n+        However, you may freely override this method with custom logic.\n         \"\"\"\n         outputs = flatten(self.output())\n         if len(outputs) == 0:\n@@ -435,7 +469,8 @@ class Task(object):\n \n     @classmethod\n     def bulk_complete(cls, parameter_tuples):\n-        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n+        \"\"\"\n+        Returns those of parameter_tuples for which this Task is complete.\n \n         Override (with an efficient implementation) for efficient scheduling\n         with range tools. Keep the logic consistent with that of complete().\n@@ -443,7 +478,8 @@ class Task(object):\n         raise NotImplementedError\n \n     def output(self):\n-        \"\"\"The output that this Task produces.\n+        \"\"\"\n+        The output that this Task produces.\n \n         The output of the Task determines if the Task needs to be run--the task\n         is considered finished iff the outputs all exist. Subclasses should\n@@ -458,7 +494,8 @@ class Task(object):\n         return []  # default impl\n \n     def requires(self):\n-        \"\"\"The Tasks that this Task depends on.\n+        \"\"\"\n+        The Tasks that this Task depends on.\n \n         A Task will only run if all of the Tasks that it requires are completed.\n         If your Task does not require any other Tasks, then you don't need to\n@@ -469,7 +506,7 @@ class Task(object):\n         return []  # default impl\n \n     def _requires(self):\n-        '''\n+        \"\"\"\n         Override in \"template\" tasks which themselves are supposed to be\n         subclassed and thus have their requires() overridden (name preserved to\n         provide consistent end-user experience), yet need to introduce\n@@ -477,19 +514,20 @@ class Task(object):\n \n         Must return an iterable which among others contains the _requires() of\n         the superclass.\n-        '''\n+        \"\"\"\n         return flatten(self.requires())  # base impl\n \n     def process_resources(self):\n-        '''\n+        \"\"\"\n         Override in \"template\" tasks which provide common resource functionality\n         but allow subclasses to specify additional resources while preserving\n         the name for consistent end-user experience.\n-        '''\n+        \"\"\"\n         return self.resources  # default impl\n \n     def input(self):\n-        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n+        \"\"\"\n+        Returns the outputs of the Tasks returned by :py:meth:`requires`\n \n         :return: a list of :py:class:`Target` objects which are specified as\n                  outputs of all required Tasks.\n@@ -497,7 +535,8 @@ class Task(object):\n         return getpaths(self.requires())\n \n     def deps(self):\n-        \"\"\"Internal method used by the scheduler\n+        \"\"\"\n+        Internal method used by the scheduler.\n \n         Returns the flattened list of requires.\n         \"\"\"\n@@ -505,11 +544,14 @@ class Task(object):\n         return flatten(self._requires())\n \n     def run(self):\n-        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n+        \"\"\"\n+        The task run method, to be overridden in a subclass.\n+        \"\"\"\n         pass  # default impl\n \n     def on_failure(self, exception):\n-        \"\"\" Override for custom error handling\n+        \"\"\"\n+        Override for custom error handling.\n \n         This method gets called if an exception is raised in :py:meth:`run`.\n         Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n@@ -521,16 +563,20 @@ class Task(object):\n         return \"Runtime error:\\n%s\" % traceback_string\n \n     def on_success(self):\n-        \"\"\" Override for doing custom completion handling for a larger class of tasks\n+        \"\"\"\n+        Override for doing custom completion handling for a larger class of tasks\n \n         This method gets called when :py:meth:`run` completes without raising any exceptions.\n+\n         The returned value is json encoded and sent to the scheduler as the `expl` argument.\n+\n         Default behavior is to send an None value\"\"\"\n         pass\n \n \n def externalize(task):\n-    \"\"\"Returns an externalized version of the Task.\n+    \"\"\"\n+    Returns an externalized version of the Task.\n \n     See :py:class:`ExternalTask`.\n     \"\"\"\n@@ -539,8 +585,8 @@ def externalize(task):\n \n \n class ExternalTask(Task):\n-\n-    \"\"\"Subclass for references to external dependencies.\n+    \"\"\"\n+    Subclass for references to external dependencies.\n \n     An ExternalTask's does not have a `run` implementation, which signifies to\n     the framework that this Task's :py:meth:`output` is generated outside of\n@@ -550,9 +596,8 @@ class ExternalTask(Task):\n \n \n class WrapperTask(Task):\n-\n-    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n-    if all their requirements exist.\n+    \"\"\"\n+    Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist.\n     \"\"\"\n \n     def complete(self):\n@@ -560,7 +605,9 @@ class WrapperTask(Task):\n \n \n def getpaths(struct):\n-    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n+    \"\"\"\n+    Maps all Tasks in a structured data object to their .output().\n+    \"\"\"\n     if isinstance(struct, Task):\n         return struct.output()\n     elif isinstance(struct, dict):\n@@ -579,16 +626,19 @@ def getpaths(struct):\n \n \n def flatten(struct):\n-    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n-\n-    >>> flatten({'a': 'foo', 'b': 'bar'})\n-    ['foo', 'bar']\n-    >>> flatten(['foo', ['bar', 'troll']])\n-    ['foo', 'bar', 'troll']\n-    >>> flatten('foo')\n-    ['foo']\n-    >>> flatten(42)\n-    [42]\n+    \"\"\"\n+    Creates a flat list of all all items in structured output (dicts, lists, items):\n+\n+    .. code-block:: python\n+\n+        >>> flatten({'a': 'foo', 'b': 'bar'})\n+        ['foo', 'bar']\n+        >>> flatten(['foo', ['bar', 'troll']])\n+        ['foo', 'bar', 'troll']\n+        >>> flatten('foo')\n+        ['foo']\n+        >>> flatten(42)\n+        [42]\n     \"\"\"\n     if struct is None:\n         return []\n@@ -612,7 +662,8 @@ def flatten(struct):\n \n \n def flatten_output(task):\n-    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n+    \"\"\"\n+    Lists all output targets by recursively walking output-less (wrapper) tasks.\n \n     FIXME order consistently.\n     \"\"\"\n",
          "files_name_in_blame_commit": [
            "hive.py",
            "target.py",
            "ssh.py",
            "notifications.py",
            "format.py",
            "process.py",
            "__init__.py",
            "deprecate_kwarg.py",
            "hadoop.py",
            "task_history.py",
            "ftp.py",
            "interface.py",
            "redshift.py",
            "postgres.py",
            "mysqldb.py",
            "db_task_history.py",
            "parameter.py",
            "task.py",
            "task_status.py",
            "util.py",
            "hadoop_jar.py",
            "spark.py",
            "parse_task.py",
            "hdfs.py",
            "range.py",
            "rdbms.py",
            "esindex.py",
            "mrrunner.py",
            "mock.py",
            "scheduler.py",
            "sqla.py",
            "webhdfs.py",
            "scalding.py",
            "server.py",
            "worker.py",
            "s3.py",
            "configuration.py",
            "file.py",
            "rpc.py",
            "sparkey.py",
            "lock.py"
          ]
        }
      },
      "f91248c2fd60336cf67b194be99d6f7e9fa26c08": {
        "commit": {
          "commit_id": "f91248c2fd60336cf67b194be99d6f7e9fa26c08",
          "commit_message": "Use default values pulled from configuration for all parameters",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2015-01-31 16:27:30",
          "commit_parent": "7e34b26f2ee57c90e1ea07d33a140a2c05113f84"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_value:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.value\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    task_name = cls.task_family\n    exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_task_value(task_name, param_name):\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.task_value(task_name, param_name)\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 281,
          "function_before_end_line": 327,
          "function_after_start_line": 281,
          "function_after_end_line": 329,
          "function_before_token_count": 219,
          "function_after_token_count": 232,
          "functions_name_modified_file": [
            "process_resources",
            "output",
            "_requires",
            "id_to_name_and_params",
            "get_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "get_all_params",
            "__hash__",
            "requires",
            "run",
            "get_task_cls",
            "on_failure",
            "on_success",
            "from_str_params",
            "initialized",
            "bulk_complete",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "to_str_params",
            "clear_instance_cache",
            "__eq__",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "tasks_str",
            "deps",
            "getpaths",
            "task_module",
            "get_param_values",
            "disable_instance_cache",
            "flatten_output"
          ],
          "functions_name_all_files": [
            "test_global_param_dep_cmdline",
            "output",
            "id_to_name_and_params",
            "get_params",
            "test_x_arg_override",
            "test_y_arg_override_banana",
            "testHasDefaultNoValue",
            "testDefaultFromTaskName",
            "testTimeDelta8601",
            "testTimeDelta8601NoTimeComponent",
            "_get_value",
            "has_task_value",
            "test_x_arg_y_arg_override_all",
            "test_insignificant_parameter",
            "reset_global",
            "testTimeDeltaMultiple",
            "test_global_param_dep_cmdline_bool",
            "get_all_params",
            "_apply_regex",
            "on_failure",
            "testGlobal",
            "from_str_params",
            "test_bool_true",
            "parse_from_args",
            "parser_dest",
            "bulk_complete",
            "__new__",
            "testHasDefaultWithBoth",
            "testDate",
            "test_forgot_param",
            "setUp",
            "__init__",
            "testDateHour",
            "task_module",
            "set_global",
            "testGlobalAndMissing",
            "testWithDefaultAndMissing",
            "test_unknown_param",
            "testDefaultIntList",
            "_parseSimple",
            "test_task_creation",
            "externalize",
            "requires",
            "testNoSection",
            "run",
            "test_x_arg",
            "test_default_param_cmdline",
            "initialized",
            "test_x_arg_y_arg",
            "namespace",
            "test_x_arg_override_stupid",
            "to_str_params",
            "clear_instance_cache",
            "testDefaultList",
            "test_global_param_cmdline",
            "value",
            "parse_from_input",
            "test_global_param_shared",
            "task_family",
            "tasks_str",
            "testTimeDelta8601MBeforeT",
            "get_param_values",
            "disable_instance_cache",
            "testDateInterval",
            "process_resources",
            "_parseIso8601",
            "_requires",
            "has_value",
            "testInt",
            "testWithDefault",
            "input",
            "test_multibool_empty",
            "testTimeDelta8601YearMonthNotSupported",
            "__hash__",
            "test_multibool",
            "testOverrideSchedulerPort",
            "testTimeDeltaPlural",
            "on_success",
            "add_to_cmdline_parser",
            "serialize",
            "get_reg",
            "test_y_arg_override_both",
            "__eq__",
            "trigger_event",
            "__repr__",
            "test_forgot_param_in_dep",
            "test_unknown_param_2",
            "__call__",
            "complete",
            "testDefault",
            "deps",
            "getpaths",
            "test_default_param",
            "testTimeDelta",
            "expect_keys",
            "flatten_output",
            "test_global_param_override",
            "test_global_param_dep_cmdline_optparse",
            "test_missing_param",
            "testDefaultFromConfigWithTaskNameToo",
            "task_value",
            "test_y_arg_override",
            "flatten",
            "testTimeDelta8601Weeks",
            "event_handler",
            "testHasDefaultNoSection",
            "get_task_cls",
            "testBool",
            "test_global_param_defaults",
            "_get_value_from_config",
            "test_parameter_registration",
            "clone",
            "test_duplicated_param",
            "serialize_to_input",
            "testTimeDelta8601MAfterT",
            "parse",
            "testNoValue",
            "test_x_arg_y_arg_override",
            "test_bool_false",
            "set_global_from_args"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "task_value",
            "_get_value_from_config",
            "_get_value",
            "testDefaultFromTaskName",
            "has_task_value",
            "testDefaultFromConfigWithTaskNameToo"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 326,
          "file_complexity": 105,
          "file_token_count": 1892,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg().iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, param_name, param_obj\n\n\nclass Task(object):\n\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_value:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.value\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"Creates an instance from a str->str hash\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return ``False``.\n\n            However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        '''\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        '''\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n\n    >>> flatten({'a': 'foo', 'b': 'bar'})\n    ['foo', 'bar']\n    >>> flatten(['foo', ['bar', 'troll']])\n    ['foo', 'bar', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)\n\n\nclass Register(abc.ABCMeta):\n\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(cls):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(cls):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_all_params(cls):\n        \"\"\"Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in cls.get_reg().iteritems():\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, param_name, param_obj\n\n\nclass Task(object):\n\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str=None):\n        \"\"\"Creates an instance from a str->str hash\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.iteritems())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return ``False``.\n\n            However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        '''\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        '''\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n\n    >>> flatten({'a': 'foo', 'b': 'bar'})\n    ['foo', 'bar']\n    >>> flatten(['foo', ['bar', 'troll']])\n    ['foo', 'bar', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_patch": "@@ -290,9 +290,11 @@ class Task(object):\n \n         params_dict = dict(params)\n \n+        task_name = cls.task_family\n+\n         # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n         # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n-        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n+        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n \n         # Fill in the positional arguments\n         positional_params = [(n, p) for n, p in params]\n@@ -313,9 +315,9 @@ class Task(object):\n         # Then use the defaults for anything not filled in\n         for param_name, param_obj in params:\n             if param_name not in result:\n-                if not param_obj.has_value:\n+                if not param_obj.has_task_value(task_name, param_name):\n                     raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n-                result[param_name] = param_obj.value\n+                result[param_name] = param_obj.task_value(task_name, param_name)\n \n         def list_to_tuple(x):\n             \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n",
          "files_name_in_blame_commit": [
            "parameter_test.py",
            "task.py",
            "parameter.py"
          ]
        }
      },
      "a78338c77d8d79497a7f89bbfde78ba9877acb36": {
        "commit": {
          "commit_id": "a78338c77d8d79497a7f89bbfde78ba9877acb36",
          "commit_message": "removed an is_global check, not sure why it wasn't caught by unit tests",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2015-01-21 19:10:24",
          "commit_parent": "4cecc7fd6e4d6fb60f6c685ef5d26690f8cb851b"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_value:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.value\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_value:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.value\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 332,
          "function_before_end_line": 378,
          "function_after_start_line": 332,
          "function_after_end_line": 378,
          "function_before_token_count": 224,
          "function_after_token_count": 219,
          "functions_name_modified_file": [
            "process_resources",
            "output",
            "_requires",
            "get_nonglobal_params",
            "id_to_name_and_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "get_task_cls",
            "on_failure",
            "on_success",
            "from_str_params",
            "initialized",
            "bulk_complete",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "to_str_params",
            "clear_instance_cache",
            "__eq__",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "tasks_str",
            "deps",
            "getpaths",
            "task_module",
            "get_param_values",
            "disable_instance_cache",
            "flatten_output"
          ],
          "functions_name_all_files": [
            "process_resources",
            "output",
            "_requires",
            "get_nonglobal_params",
            "id_to_name_and_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "get_task_cls",
            "on_failure",
            "on_success",
            "from_str_params",
            "initialized",
            "bulk_complete",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "to_str_params",
            "clear_instance_cache",
            "__eq__",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "tasks_str",
            "deps",
            "getpaths",
            "task_module",
            "get_param_values",
            "disable_instance_cache",
            "flatten_output"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 366,
          "file_complexity": 117,
          "file_token_count": 2281,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\nimport pyparsing as pp\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with ``Foo(bar=bar, baz=baz)`` returns\n        ``('Foo', {'bar': 'bar', 'baz': 'baz'})``\n    '''\n    name_chars = pp.alphanums + '_'\n    # modified version of pp.printables. Removed '[]', '()', ','\n    value_chars = pp.alphanums + '\\'!\"#$%&*+-./:;<=>?@\\\\^_`{|}~'\n    parameter = (\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         ((pp.Literal('(').suppress() | pp.Literal('[').suppress()) +\n          pp.ZeroOrMore(pp.Word(value_chars) +\n                        pp.ZeroOrMore(pp.Literal(',')).suppress()) +\n          (pp.Literal(')').suppress() |\n           pp.Literal(']').suppress()))).setResultsName('list_params',\n                                                        listAllMatches=True) |\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         pp.Word(value_chars)).setResultsName('params', listAllMatches=True))\n\n    parser = (\n        pp.Word(name_chars).setResultsName('task') +\n        pp.Literal('(').suppress() +\n        pp.ZeroOrMore(parameter + (pp.Literal(',')).suppress()) +\n        pp.ZeroOrMore(parameter) +\n        pp.Literal(')').suppress())\n\n    parsed = parser.parseString(task_id).asDict()\n    task_name = parsed['task']\n\n    params = {}\n    if 'params' in parsed:\n        for k, v in parsed['params']:\n            params[k] = v\n    if 'list_params' in parsed:\n        for x in parsed['list_params']:\n            params[x[0]] = x[1:]\n    return task_name, params\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Compiles and returns the global parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        global_params = {}\n        for t_name, t_cls in cls.get_reg().iteritems():\n            if t_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in t_cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n                    pass\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Return the global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        \"\"\"Return the non-global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_value:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.value\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str={}, global_params=[]):\n        \"\"\"Creates an instance from a str->str hash\n\n        This method is for parsing of command line arguments or other\n        non-programmatic invocations.\n\n        :param params_str: dict of param name -> value.\n        :param global_params: dict of param name -> value, the global params.\n        \"\"\"\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params_str[param_name])\n            param.set_global(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        \"\"\"Opposite of from_str_params\"\"\"\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_nonglobal_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return ``False``.\n\n            However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        '''\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        '''\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n\n    >>> flatten({'a': 'foo', 'b': 'bar'})\n    ['foo', 'bar']\n    >>> flatten(['foo', ['bar', 'troll']])\n    ['foo', 'bar', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\nimport itertools\nimport pyparsing as pp\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with ``Foo(bar=bar, baz=baz)`` returns\n        ``('Foo', {'bar': 'bar', 'baz': 'baz'})``\n    '''\n    name_chars = pp.alphanums + '_'\n    # modified version of pp.printables. Removed '[]', '()', ','\n    value_chars = pp.alphanums + '\\'!\"#$%&*+-./:;<=>?@\\\\^_`{|}~'\n    parameter = (\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         ((pp.Literal('(').suppress() | pp.Literal('[').suppress()) +\n          pp.ZeroOrMore(pp.Word(value_chars) +\n                        pp.ZeroOrMore(pp.Literal(',')).suppress()) +\n          (pp.Literal(')').suppress() |\n           pp.Literal(']').suppress()))).setResultsName('list_params',\n                                                        listAllMatches=True) |\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         pp.Word(value_chars)).setResultsName('params', listAllMatches=True))\n\n    parser = (\n        pp.Word(name_chars).setResultsName('task') +\n        pp.Literal('(').suppress() +\n        pp.ZeroOrMore(parameter + (pp.Literal(',')).suppress()) +\n        pp.ZeroOrMore(parameter) +\n        pp.Literal(')').suppress())\n\n    parsed = parser.parseString(task_id).asDict()\n    task_name = parsed['task']\n\n    params = {}\n    if 'params' in parsed:\n        for k, v in parsed['params']:\n            params[k] = v\n    if 'list_params' in parsed:\n        for x in parsed['list_params']:\n            params[x[0]] = x[1:]\n    return task_name, params\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run != NotImplemented:\n                name = cls.task_family\n                if name in reg and reg[name] != cls and \\\n                        reg[name] != cls.AMBIGUOUS_CLASS and \\\n                        not issubclass(cls, reg[name]):\n                    # Registering two different classes - this means we can't instantiate them by name\n                    # The only exception is if one class is a subclass of the other. In that case, we\n                    # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                    reg[name] = cls.AMBIGUOUS_CLASS\n                else:\n                    reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def tasks_str(cls):\n        \"\"\"Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))\n\n    @classmethod\n    def get_task_cls(cls, name):\n        \"\"\"Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Compiles and returns the global parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        global_params = {}\n        for t_name, t_cls in cls.get_reg().iteritems():\n            if t_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in t_cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n    _event_callbacks = {}\n\n    # Priority of the task: the scheduler should favor available\n    # tasks with higher priority values first.\n    priority = 0\n    disabled = False\n\n    # Resources used by the task. Should be formatted like {\"scp\": 1} to indicate that the\n    # task requires 1 unit of the scp resource.\n    resources = {}\n\n    # Number of seconds after which to time out the run function. No timeout if set to 0. Defaults\n    # to 0 or value in client.cfg\n    worker_timeout = None\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n                    pass\n\n    @property\n    def task_module(self):\n        # Returns what Python module to import to get access to this class\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Return the global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        \"\"\"Return the non-global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_value:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.value\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_str_params(cls, params_str={}, global_params=[]):\n        \"\"\"Creates an instance from a str->str hash\n\n        This method is for parsing of command line arguments or other\n        non-programmatic invocations.\n\n        :param params_str: dict of param name -> value.\n        :param global_params: dict of param name -> value, the global params.\n        \"\"\"\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params_str[param_name])\n            param.set_global(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def to_str_params(self):\n        \"\"\"Opposite of from_str_params\"\"\"\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in self.param_kwargs.iteritems():\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_nonglobal_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return ``False``.\n\n            However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(itertools.imap(lambda output: output.exists(), outputs))\n\n    @classmethod\n    def bulk_complete(cls, parameter_tuples):\n        \"\"\"Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def process_resources(self):\n        '''\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        '''\n        return self.resources  # default impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        pass\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See :py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Creates a flat list of all all items in structured output (dicts, lists, items)\n\n    >>> flatten({'a': 'foo', 'b': 'bar'})\n    ['foo', 'bar']\n    >>> flatten(['foo', ['bar', 'troll']])\n    ['foo', 'bar', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n\n\ndef flatten_output(task):\n    \"\"\"Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r\n",
          "file_patch": "@@ -346,7 +346,7 @@ class Task(object):\n         exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n \n         # Fill in the positional arguments\n-        positional_params = [(n, p) for n, p in params if not p.is_global]\n+        positional_params = [(n, p) for n, p in params]\n         for i, arg in enumerate(args):\n             if i >= len(positional_params):\n                 raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n",
          "files_name_in_blame_commit": [
            "task.py"
          ]
        }
      },
      "d12023f77810adb04835ef24cb86d5e3d31247ec": {
        "commit": {
          "commit_id": "d12023f77810adb04835ef24cb86d5e3d31247ec",
          "commit_message": "Update documentation for luigi.task.",
          "commit_author": "Joe Crobak",
          "commit_date": "2014-02-10 18:41:27",
          "commit_parent": "5df0a2da587edc8bd3cdde17d7c3bfc90b8bcb99"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 208,
          "function_before_end_line": 249,
          "function_after_start_line": 266,
          "function_after_end_line": 314,
          "function_before_token_count": 244,
          "function_after_token_count": 245,
          "functions_name_modified_file": [
            "output",
            "_requires",
            "get_nonglobal_params",
            "id_to_name_and_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "initialized",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "clear_instance_cache",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "output",
            "_requires",
            "get_nonglobal_params",
            "id_to_name_and_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "event_handler",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "initialized",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "clear_instance_cache",
            "trigger_event",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_modified_file": [
            "output",
            "get_nonglobal_params",
            "get_params",
            "id_to_name_and_params",
            "get_global_params",
            "input",
            "flatten",
            "externalize",
            "requires",
            "run",
            "from_input",
            "initialized",
            "get_reg",
            "namespace",
            "clear_instance_cache",
            "trigger_event",
            "__init__",
            "task_family",
            "complete",
            "deps",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_all_files": [
            "output",
            "get_nonglobal_params",
            "get_params",
            "id_to_name_and_params",
            "get_global_params",
            "input",
            "flatten",
            "externalize",
            "requires",
            "run",
            "from_input",
            "initialized",
            "get_reg",
            "namespace",
            "clear_instance_cache",
            "trigger_event",
            "__init__",
            "task_family",
            "complete",
            "deps",
            "disable_instance_cache"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 304,
          "file_complexity": 101,
          "file_token_count": 1777,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with 'Foo(bar=bar, baz=baz)' returns ('Foo', {'bar': 'bar', 'baz': 'baz'})\n    '''\n    lparen = task_id.index('(')\n    task_family = task_id[:lparen]\n    params = task_id[lparen + 1:-1]\n\n    def split_equals(x):\n        equals = x.index('=')\n        return x[:equals], x[equals + 1:]\n    if params:\n        param_list = map(split_equals, params.split(', '))  # TODO: param values with ', ' in them will break this\n    else:\n        param_list = []\n    return task_family, dict(param_list)\n\n\n\nclass Register(abc.ABCMeta):\n    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n    # 2. Keep track of all subclasses of Task and expose them\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\n\nclass Task(object):\n    __metaclass__ = Register\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n    _event_callbacks = {}\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\" Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n                    pass\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        ''' Creates an instance from a str->str hash (to be used for cmd line interaction etc) '''\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        if cls is None:\n            cls = self.__class__\n        \n        new_k = {}\n        for param_name, param_class in cls.get_nonglobal_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with ``None`` as the namespace, the namespace\n    is reset, which is recommended to do at the end of any file where the\n    namespace is set to avoid unintentionally setting namespace on tasks outside\n    of the scope of the current file.\n    \"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with ``Foo(bar=bar, baz=baz)`` returns\n        ``('Foo', {'bar': 'bar', 'baz': 'baz'})``\n    '''\n    lparen = task_id.index('(')\n    task_family = task_id[:lparen]\n    params = task_id[lparen + 1:-1]\n\n    def split_equals(x):\n        equals = x.index('=')\n        return x[:equals], x[equals + 1:]\n    if params:\n        param_list = map(split_equals, params.split(', '))  # TODO: param values with ', ' in them will break this\n    else:\n        param_list = []\n    return task_family, dict(param_list)\n\n\n\nclass Register(abc.ABCMeta):\n    \"\"\"\n    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n    the following properties:\n\n    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n       same object.\n    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n    \"\"\"\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n    an error.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        \"\"\"Clear/Reset the instance cache.\"\"\"\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        \"\"\"Disables the instance cache.\"\"\"\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        \"\"\"The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Compiles and returns the global parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\n\nclass Task(object):\n    \"\"\"\n    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n\n    A Luigi Task describes a unit or work. The key methods of a Task, which must\n    be implemented in a subclass are:\n\n    * :py:meth:`run` - the computation done by this task.\n    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n\n    Parameters to the Task should be declared as members of the class, e.g.::\n\n        class MyTask(luigi.Task):\n            count = luigi.IntParameter()\n\n    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n\n    In addition to any declared properties and methods, there are a few\n    non-declared properties, which are created by the :py:class:`Register`\n    metaclass:\n\n    ``Task.task_namespace``\n      optional string which is prepended to the task name for the sake of\n      scheduling. If it isn't overridden in a Task, whatever was last declared\n      using `luigi.namespace` will be used.\n\n    ``Task._parameters``\n      list of ``(parameter_name, parameter)`` tuples for this task class\n    \"\"\"\n    __metaclass__ = Register\n\n\n    _event_callbacks = {}\n\n    @classmethod\n    def event_handler(cls, event):\n        \"\"\" Decorator for adding event handlers \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped\n\n    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"Trigger that calls all of the specified events associated with this\n        class.\n        \"\"\"\n        for event_class, event_callbacks in self._event_callbacks.iteritems():\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except:\n                    logger.exception(\"Error in event callback for %r\", event)\n                    pass\n\n    @property\n    def task_family(self):\n        \"\"\"Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        \"\"\"Return the global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        \"\"\"Return the non-global parameters for this Task.\"\"\"\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor to resolve values for all Parameters.\n\n        For example, the Task::\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        \"\"\"Creates an instance from a str->str hash\n\n        This method is for parsing of command line arguments or other\n        non-programmatic invocations.\n\n        :param params: dict of param name -> value.\n        :param global_params: dict of param name -> value, the global params.\n        \"\"\"\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def clone(self, cls=None, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        if cls is None:\n            cls = self.__class__\n        \n        new_k = {}\n        for param_name, param_class in cls.get_nonglobal_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return ``True`` if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        \"\"\"The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl\n\n    def requires(self):\n        \"\"\"The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def input(self):\n        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())\n\n    def deps(self):\n        \"\"\"Internal method used by the scheduler\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n\n\ndef externalize(task):\n    \"\"\"Returns an externalized version of the Task.\n\n    See py:class:`ExternalTask`.\n    \"\"\"\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies.\n\n    An ExternalTask's does not have a `run` implementation, which signifies to\n    the framework that this Task's :py:meth:`output` is generated outside of\n    Luigi.\n    \"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n    if all their requirements exist.\n    \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples::\n\n        > _flatten({'a': foo, b: bar})\n        [foo, bar]\n        > _flatten([foo, [bar, troll]])\n        [foo, bar, troll]\n        > _flatten(foo)\n        [foo]\n\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -25,13 +25,18 @@ logger = logging.getLogger('luigi-interface')\n def namespace(namespace=None):\n     \"\"\" Call to set namespace of tasks declared after the call.\n \n-    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n+    If called without arguments or with ``None`` as the namespace, the namespace\n+    is reset, which is recommended to do at the end of any file where the\n+    namespace is set to avoid unintentionally setting namespace on tasks outside\n+    of the scope of the current file.\n+    \"\"\"\n     Register._default_namespace = namespace\n \n \n def id_to_name_and_params(task_id):\n     ''' Turn a task_id into a (task_family, {params}) tuple.\n-        E.g. calling with 'Foo(bar=bar, baz=baz)' returns ('Foo', {'bar': 'bar', 'baz': 'baz'})\n+        E.g. calling with ``Foo(bar=bar, baz=baz)`` returns\n+        ``('Foo', {'bar': 'bar', 'baz': 'baz'})``\n     '''\n     lparen = task_id.index('(')\n     task_family = task_id[:lparen]\n@@ -49,12 +54,21 @@ def id_to_name_and_params(task_id):\n \n \n class Register(abc.ABCMeta):\n-    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n-    # 2. Keep track of all subclasses of Task and expose them\n+    \"\"\"\n+    The Metaclass of :py:class:`Task`. Acts as a global registry of Tasks with\n+    the following properties:\n+\n+    1. Cache instances of objects so that eg. ``X(1, 2, 3)`` always returns the\n+       same object.\n+    2. Keep track of all subclasses of :py:class:`Task` and expose them.\n+    \"\"\"\n     __instance_cache = {}\n     _default_namespace = None\n     _reg = []\n     AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n+    \"\"\"If this value is returned by :py:meth:`get_reg` then there is an\n+    ambiguous task name (two :py:class:`Task` have the same name). This denotes\n+    an error.\"\"\"\n \n     def __new__(metacls, classname, bases, classdict):\n         \"\"\" Custom class creation for namespacing. Also register all subclasses\n@@ -100,14 +114,21 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def clear_instance_cache(self):\n+        \"\"\"Clear/Reset the instance cache.\"\"\"\n         Register.__instance_cache = {}\n \n     @classmethod\n     def disable_instance_cache(self):\n+        \"\"\"Disables the instance cache.\"\"\"\n         Register.__instance_cache = None\n \n     @property\n     def task_family(cls):\n+        \"\"\"The task family for the given class.\n+\n+        If ``cls.task_namespace is None`` then it's the name of the class.\n+        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n+        \"\"\"\n         if cls.task_namespace is None:\n             return cls.__name__\n         else:\n@@ -115,6 +136,10 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def get_reg(cls):\n+        \"\"\"Return all of the registery classes.\n+\n+        :return:  a ``dict`` of task_family -> class\n+        \"\"\"\n         reg = {}\n         for cls in cls._reg:\n             name = cls.task_family\n@@ -128,6 +153,10 @@ class Register(abc.ABCMeta):\n \n     @classmethod\n     def get_global_params(cls):\n+        \"\"\"Compiles and returns the global parameters for all :py:class:`Task`.\n+\n+        :return: a ``dict`` of parameter name -> parameter.\n+        \"\"\"\n         global_params = {}\n         for cls in cls._reg:\n             for param_name, param_obj in cls.get_global_params():\n@@ -140,16 +169,39 @@ class Register(abc.ABCMeta):\n \n \n class Task(object):\n-    __metaclass__ = Register\n-\n     \"\"\"\n-    non-declared properties: (created in metaclass):\n+    This is the base class of all Luigi Tasks, the base unit of work in Luigi.\n \n-    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n-    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n+    A Luigi Task describes a unit or work. The key methods of a Task, which must\n+    be implemented in a subclass are:\n \n-    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n+    * :py:meth:`run` - the computation done by this task.\n+    * :py:meth:`requires` - the list of Tasks that this Task depends on.\n+    * :py:meth:`output` - the output :py:class:`Target` that this Task creates.\n+\n+    Parameters to the Task should be declared as members of the class, e.g.::\n+\n+        class MyTask(luigi.Task):\n+            count = luigi.IntParameter()\n+\n+    Each Task exposes a constructor accepting all :py:class:`Parameter` (and\n+    values) as kwargs. e.g. ``MyTask(count=10)`` would instantiate `MyTask`.\n+\n+    In addition to any declared properties and methods, there are a few\n+    non-declared properties, which are created by the :py:class:`Register`\n+    metaclass:\n+\n+    ``Task.task_namespace``\n+      optional string which is prepended to the task name for the sake of\n+      scheduling. If it isn't overridden in a Task, whatever was last declared\n+      using `luigi.namespace` will be used.\n+\n+    ``Task._parameters``\n+      list of ``(parameter_name, parameter)`` tuples for this task class\n     \"\"\"\n+    __metaclass__ = Register\n+\n+\n     _event_callbacks = {}\n \n     @classmethod\n@@ -161,7 +213,8 @@ class Task(object):\n         return wrapped\n \n     def trigger_event(self, event, *args, **kwargs):\n-        \"\"\" Trigger that calls all of the specified events associated with this class.\n+        \"\"\"Trigger that calls all of the specified events associated with this\n+        class.\n         \"\"\"\n         for event_class, event_callbacks in self._event_callbacks.iteritems():\n             if not isinstance(self, event_class):\n@@ -178,11 +231,14 @@ class Task(object):\n \n     @property\n     def task_family(self):\n-        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n+        \"\"\"Convenience method since a property on the metaclass isn't directly\n+        accessible through the class instances.\n+        \"\"\"\n         return self.__class__.task_family\n \n     @classmethod\n     def get_params(cls):\n+        \"\"\"Returns all of the Parameters for this Task.\"\"\"\n         # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n         params = []\n         for param_name in dir(cls):\n@@ -198,14 +254,23 @@ class Task(object):\n \n     @classmethod\n     def get_global_params(cls):\n+        \"\"\"Return the global parameters for this Task.\"\"\"\n         return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n \n     @classmethod\n     def get_nonglobal_params(cls):\n+        \"\"\"Return the non-global parameters for this Task.\"\"\"\n         return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n \n     @classmethod\n     def get_param_values(cls, params, args, kwargs):\n+        \"\"\"Get the values of the parameters from the args and kwargs.\n+\n+        :param params: list of (param_name, Parameter).\n+        :param args: positional arguments\n+        :param kwargs: keyword arguments.\n+        :returns: list of `(name, value)` tuples, one for each parameter.\n+        \"\"\"\n         result = {}\n \n         params_dict = dict(params)\n@@ -249,6 +314,15 @@ class Task(object):\n         return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n \n     def __init__(self, *args, **kwargs):\n+        \"\"\"Constructor to resolve values for all Parameters.\n+\n+        For example, the Task::\n+\n+            class MyTask(luigi.Task):\n+                count = luigi.IntParameter()\n+\n+        can be instantiated as ``MyTask(count=10)``.\n+        \"\"\"\n         params = self.get_params()\n         param_values = self.get_param_values(params, args, kwargs)\n \n@@ -271,11 +345,19 @@ class Task(object):\n         self.__hash = hash(self.task_id)\n \n     def initialized(self):\n+        \"\"\"Returns ``True`` if the Task is initialized and ``False`` otherwise.\"\"\"\n         return hasattr(self, 'task_id')\n \n     @classmethod\n     def from_input(cls, params, global_params):\n-        ''' Creates an instance from a str->str hash (to be used for cmd line interaction etc) '''\n+        \"\"\"Creates an instance from a str->str hash\n+\n+        This method is for parsing of command line arguments or other\n+        non-programmatic invocations.\n+\n+        :param params: dict of param name -> value.\n+        :param global_params: dict of param name -> value, the global params.\n+        \"\"\"\n         for param_name, param in global_params:\n             value = param.parse_from_input(param_name, params[param_name])\n             param.set_default(value)\n@@ -315,7 +397,7 @@ class Task(object):\n \n     def complete(self):\n         \"\"\"\n-            If the task has any outputs, return true if all outputs exists.\n+            If the task has any outputs, return ``True`` if all outputs exists.\n             Otherwise, return whether or not the task has run or not\n         \"\"\"\n         outputs = flatten(self.output())\n@@ -331,9 +413,29 @@ class Task(object):\n             return True\n \n     def output(self):\n+        \"\"\"The output that this Task produces.\n+\n+        The output of the Task determines if the Task needs to be run--the task\n+        is considered finished iff the outputs all exist. Subclasses should\n+        override this method to return a single :py:class:`Target` or a list of\n+        :py:class:`Target` instances.\n+\n+        Implementation note\n+          If running multiple workers, the output must be a resource that is accessible\n+          by all workers, such as a DFS or database. Otherwise, workers might compute\n+          the same output since they don't see the work done by other workers.\n+        \"\"\"\n         return []  # default impl\n \n     def requires(self):\n+        \"\"\"The Tasks that this Task depends on.\n+\n+        A Task will only run if all of the Tasks that it requires are completed.\n+        If your Task does not require any other Tasks, then you don't need to\n+        override this method. Otherwise, a Subclasses can override this method\n+        to return a single Task, a list of Task instances, or a dict whose\n+        values are Task instances.\n+        \"\"\"\n         return []  # default impl\n \n     def _requires(self):\n@@ -349,13 +451,23 @@ class Task(object):\n         return flatten(self.requires())  # base impl\n \n     def input(self):\n+        \"\"\"Returns the outputs of the Tasks returned by :py:meth:`requires`\n+\n+        :return: a list of :py:class:`Target` objects which are specified as\n+                 outputs of all required Tasks.\n+        \"\"\"\n         return getpaths(self.requires())\n \n     def deps(self):\n+        \"\"\"Internal method used by the scheduler\n+\n+        Returns the flattened list of requires.\n+        \"\"\"\n         # used by scheduler\n         return flatten(self._requires())\n \n     def run(self):\n+        \"\"\"The task run method, to be overridden in a subclass.\"\"\"\n         pass  # default impl\n \n     def on_failure(self, exception):\n@@ -379,17 +491,28 @@ class Task(object):\n \n \n def externalize(task):\n+    \"\"\"Returns an externalized version of the Task.\n+\n+    See py:class:`ExternalTask`.\n+    \"\"\"\n     task.run = NotImplemented\n     return task\n \n \n class ExternalTask(Task):\n-    \"\"\"Subclass for references to external dependencies\"\"\"\n+    \"\"\"Subclass for references to external dependencies.\n+\n+    An ExternalTask's does not have a `run` implementation, which signifies to\n+    the framework that this Task's :py:meth:`output` is generated outside of\n+    Luigi.\n+    \"\"\"\n     run = NotImplemented\n \n \n class WrapperTask(Task):\n-    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n+    \"\"\"Use for tasks that only wrap other tasks and that by definition are done\n+    if all their requirements exist.\n+    \"\"\"\n     def complete(self):\n         return all(r.complete() for r in flatten(self.requires()))\n \n@@ -415,13 +538,15 @@ def getpaths(struct):\n \n def flatten(struct):\n     \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n-    Examples:\n-    > _flatten({'a': foo, b: bar})\n-    [foo, bar]\n-    > _flatten([foo, [bar, troll]])\n-    [foo, bar, troll]\n-    > _flatten(foo)\n-    [foo]\n+    Examples::\n+\n+        > _flatten({'a': foo, b: bar})\n+        [foo, bar]\n+        > _flatten([foo, [bar, troll]])\n+        [foo, bar, troll]\n+        > _flatten(foo)\n+        [foo]\n+\n     \"\"\"\n     if struct is None:\n         return []\n",
          "files_name_in_blame_commit": [
            "task.py"
          ]
        }
      },
      "ce6ac951343cad17bc2187b5a07a67aa48bd2f05": {
        "commit": {
          "commit_id": "ce6ac951343cad17bc2187b5a07a67aa48bd2f05",
          "commit_message": "Adding a manifest file for distutils so that bin/luigid is included in the source tarball that gets built\nHadoop binary path can now be specified in config.  Sets are converted to tuples in Task class.\nAdditional unit tests in the hdfs module and a new hive client command class supporting the Apache release of Hive, which returns a non-zero exit status if tables and partitions dont exist",
          "commit_author": "Adam Tebbe",
          "commit_date": "2013-08-01 14:38:46",
          "commit_parent": "7795d559ff467a21adbf53ce1f5da121cf957baa"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n        if isinstance(x, list) or isinstance(x, set):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 179,
          "function_before_end_line": 220,
          "function_after_start_line": 182,
          "function_after_end_line": 223,
          "function_before_token_count": 244,
          "function_after_token_count": 244,
          "functions_name_modified_file": [
            "output",
            "_requires",
            "get_nonglobal_params",
            "id_to_name_and_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "initialized",
            "__new__",
            "namespace",
            "get_reg",
            "clone",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "pipe_writer",
            "output",
            "reducer",
            "listdir",
            "id_to_name_and_params",
            "get_params",
            "tmppath",
            "mkdir",
            "_run_mapper",
            "hdfs_writer",
            "get_global_params",
            "test_luigi_tmp",
            "test_client_def",
            "test_default_table_location",
            "test_table_exists",
            "table_schema",
            "_deprecated",
            "path",
            "on_failure",
            "glob_exists",
            "test_mkdir_exists",
            "requires_local",
            "move",
            "get_fn",
            "__new__",
            "test_cdh3_client",
            "test_get",
            "run_job",
            "has_default",
            "test_put",
            "setUp",
            "__init__",
            "internal_writer",
            "_map_input",
            "test_apache1_client",
            "atomic_output",
            "test_rename_no_parent",
            "init_combiner",
            "test_readback",
            "tearDown",
            "fn",
            "run_hive_cmd",
            "_incr_counter",
            "_run_combiner",
            "getmerge",
            "jar",
            "_get_default_from_config",
            "open",
            "main",
            "externalize",
            "test_getmerge",
            "requires",
            "put_file",
            "get_hdfs_syntax",
            "group",
            "run",
            "load_hadoop_cmd",
            "create_packages_archive",
            "initialized",
            "hiveconfs",
            "namespace",
            "_run_reducer",
            "clear_instance_cache",
            "attach",
            "count",
            "test_with_exception",
            "parse_from_input",
            "extra_modules",
            "move_dir",
            "task_family",
            "test_multifile",
            "init_local",
            "_reduce_input",
            "test_with_write_success",
            "_flush_batch_incr_counter",
            "test_with_noclose",
            "test_run_hive_script_not_exists",
            "test_table_schema",
            "get_param_values",
            "disable_instance_cache",
            "from_input",
            "finish",
            "chmod",
            "_requires",
            "test_with_close",
            "dereference",
            "_is_writable",
            "create_file",
            "test_tmp_cleanup",
            "input",
            "writer",
            "test_slow_exists",
            "fix_paths",
            "test_create_parents",
            "__enter__",
            "__hash__",
            "test_apacheclient_table_exists",
            "on_success",
            "mapper",
            "partition_spec",
            "test_connection_refused",
            "run_and_track_hadoop_job",
            "serialize",
            "get_reg",
            "init_reducer",
            "mock_hive_cmd",
            "set_default",
            "input_local",
            "reader",
            "test_partition_spec",
            "default",
            "_dump",
            "init_hadoop",
            "__repr__",
            "test_atomicity",
            "is_writable",
            "fetch_task_failures",
            "__call__",
            "complete",
            "test_with_write_failure",
            "copy",
            "deps",
            "_setup_links",
            "getpaths",
            "run_hive",
            "test_run_hive_command",
            "run_hive_script",
            "job_runner",
            "test_tmp_move",
            "incr_counter",
            "test_run_hive_script_exists",
            "kill_job",
            "get_nonglobal_params",
            "extra_files",
            "args",
            "test_apacheclient_table_schema",
            "internal_reader",
            "remove",
            "pickle_reader",
            "table_location",
            "flatten",
            "rename",
            "load_hive_cmd",
            "hiverc",
            "query",
            "exists",
            "close",
            "put",
            "table_exists",
            "clone",
            "get",
            "init_mapper",
            "jobconfs",
            "_setup_remote",
            "_add_link",
            "chown",
            "hdfs_reader",
            "test_glob_exists",
            "input_hadoop",
            "__del__",
            "pickle_writer",
            "parse",
            "get_extra_files",
            "test_create_parent_dirs",
            "prepare_outputs",
            "sample",
            "requires_hadoop",
            "get_hive_syntax",
            "abort",
            "call_check",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__call__"
          ],
          "functions_name_co_evolved_all_files": [
            "run_hive_cmd",
            "chmod",
            "test_run_hive_script_exists",
            "listdir",
            "_is_writable",
            "getmerge",
            "mkdir",
            "test_apacheclient_table_schema",
            "remove",
            "table_location",
            "test_client_def",
            "test_default_table_location",
            "test_table_exists",
            "__enter__",
            "rename",
            "table_schema",
            "load_hadoop_cmd",
            "hiverc",
            "test_apacheclient_table_exists",
            "query",
            "exists",
            "testRunHiveCommand",
            "partition_spec",
            "put",
            "hiveconfs",
            "test_cdh3_client",
            "table_exists",
            "run_job",
            "mock_hive_cmd",
            "testRunHiveScriptNotExists",
            "get",
            "test_partition_spec",
            "chown",
            "count",
            "__init__",
            "setUp",
            "__call__",
            "copy",
            "get_hive_syntax",
            "test_apache1_client",
            "run_hive",
            "test_run_hive_command",
            "test_run_hive_script_not_exists",
            "test_table_schema",
            "testRunHiveScriptExists"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 243,
          "file_complexity": 92,
          "file_token_count": 1615,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with 'Foo(bar=bar, baz=baz)' returns ('Foo', {'bar': 'bar', 'baz': 'baz'})\n    '''\n    lparen = task_id.index('(')\n    task_family = task_id[:lparen]\n    params = task_id[lparen + 1:-1]\n\n    def split_equals(x):\n        equals = x.index('=')\n        return x[:equals], x[equals + 1:]\n    if params:\n        param_list = map(split_equals, params.split(', '))  # TODO: param values with ', ' in them will break this\n    else:\n        param_list = []\n    return task_family, dict(param_list)\n\n\n\nclass Register(abc.ABCMeta):\n    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n    # 2. Keep track of all subclasses of Task and expose them\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\nclass Task(object):\n    __metaclass__ = Register\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        ''' Creates an instance from a str->str hash (to be used for cmd line interaction etc) '''\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def clone(self, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        # remove global params\n        for param_name, param_class in self.get_params():\n            if param_class.is_global:\n                k.pop(param_name)\n\n        return self.__class__(**k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport logging\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\nlogger = logging.getLogger('luigi-interface')\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    Register._default_namespace = namespace\n\n\ndef id_to_name_and_params(task_id):\n    ''' Turn a task_id into a (task_family, {params}) tuple.\n        E.g. calling with 'Foo(bar=bar, baz=baz)' returns ('Foo', {'bar': 'bar', 'baz': 'baz'})\n    '''\n    lparen = task_id.index('(')\n    task_family = task_id[:lparen]\n    params = task_id[lparen + 1:-1]\n\n    def split_equals(x):\n        equals = x.index('=')\n        return x[:equals], x[equals + 1:]\n    if params:\n        param_list = map(split_equals, params.split(', '))  # TODO: param values with ', ' in them will break this\n    else:\n        param_list = []\n    return task_family, dict(param_list)\n\n\n\nclass Register(abc.ABCMeta):\n    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n    # 2. Keep track of all subclasses of Task and expose them\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\nclass Task(object):\n    __metaclass__ = Register\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        ''' Creates an instance from a str->str hash (to be used for cmd line interaction etc) '''\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def clone(self, **kwargs):\n        ''' Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py)\n        - Remove a lot of boiler plate when you have recursive dependencies and lots of args\n        - There's task inheritance and some logic is on the base class\n        '''\n        k = self.param_kwargs.copy()\n        k.update(kwargs.items())\n\n        # remove global params\n        for param_name, param_class in self.get_params():\n            if param_class.is_global:\n                k.pop(param_name)\n\n        return self.__class__(**k)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def _requires(self):\n        '''\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        '''\n        return flatten(self.requires())  # base impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self._requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -13,11 +13,13 @@\n # the License.\n \n import abc\n+import logging\n import parameter\n import warnings\n import traceback\n \n Parameter = parameter.Parameter\n+logger = logging.getLogger('luigi-interface')\n \n \n def namespace(namespace=None):\n@@ -88,6 +90,7 @@ class Register(abc.ABCMeta):\n         try:\n             hash(k)\n         except TypeError:\n+            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n             return instantiate()  # unhashable types in parameters\n \n         if k not in h:\n@@ -211,8 +214,8 @@ class Task(object):\n                 result[param_name] = param_obj.default\n \n         def list_to_tuple(x):\n-            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n-            if isinstance(x, list):\n+            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n+            if isinstance(x, list) or isinstance(x, set):\n                 return tuple(x)\n             else:\n                 return x\n",
          "files_name_in_blame_commit": [
            "hive.py",
            "hadoop.py",
            "task.py",
            "parameter.py",
            "_hdfs_test.py",
            "hadoop_jar.py",
            "hive_test.py",
            "hdfs.py"
          ]
        }
      },
      "ff8f7d7c880cf68b56a906b857e6297b7ae97c03": {
        "commit": {
          "commit_id": "ff8f7d7c880cf68b56a906b857e6297b7ae97c03",
          "commit_message": "slightly more verbose parameter exceptions",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2013-04-18 11:44:53",
          "commit_parent": "2f0e710c630c312d609f7f00de8325a9253fe07f"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('Class %s: can not override global parameter %s' % (cls.__name__, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n    positional_params = [(n, p) for (n, p) in params if not p.is_global]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n        if params_dict[param_name].is_global:\n            raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 160,
          "function_before_end_line": 197,
          "function_after_start_line": 160,
          "function_after_end_line": 201,
          "function_before_token_count": 241,
          "function_after_token_count": 244,
          "functions_name_modified_file": [
            "output",
            "get_nonglobal_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "initialized",
            "__new__",
            "namespace",
            "get_reg",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "output",
            "get_nonglobal_params",
            "get_params",
            "get_global_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "initialized",
            "__new__",
            "namespace",
            "get_reg",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 216,
          "file_complexity": 83,
          "file_token_count": 1396,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    Register._default_namespace = namespace\n\n\nclass Register(abc.ABCMeta):\n    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n    # 2. Keep track of all subclasses of Task and expose them\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\nclass Task(object):\n    __metaclass__ = Register\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('Class %s: can not override global parameter %s' % (cls.__name__, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        task_id_parts = []\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (str(param_name), str(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport abc\nimport parameter\nimport warnings\nimport traceback\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    Register._default_namespace = namespace\n\n\nclass Register(abc.ABCMeta):\n    # 1. Cache instances of objects so that eg. X(1, 2, 3) always returns the same object\n    # 2. Keep track of all subclasses of Task and expose them\n    __instance_cache = {}\n    _default_namespace = None\n    _reg = []\n    AMBIGUOUS_CLASS = object()  # Placeholder denoting an error\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing. Also register all subclasses\n\n        Set the task namespace to whatever the currently declared namespace is\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        if cls.run != NotImplemented:\n            metacls._reg.append(cls)\n        return cls\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        Register.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        Register.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n    @classmethod\n    def get_reg(cls):\n        reg = {}\n        for cls in cls._reg:\n            name = cls.task_family\n            if name in reg and reg[name] != cls:\n                # Registering two different classes - this means we can't instantiate them by name\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg\n\n    @classmethod\n    def get_global_params(cls):\n        global_params = {}\n        for cls in cls._reg:\n            for param_name, param_obj in cls.get_global_params():\n                if param_name in global_params and global_params[param_name] != param_obj:\n                    # Could be registered multiple times in case there's subclasses\n                    raise Exception('Global parameter %r registered by multiple classes' % param_name)\n                global_params[param_name] = param_obj\n        return global_params.iteritems()\n\n\nclass Task(object):\n    __metaclass__ = Register\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_global_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if param_obj.is_global]\n\n    @classmethod\n    def get_nonglobal_params(cls):\n        return [(param_name, param_obj) for param_name, param_obj in cls.get_params() if not param_obj.is_global]\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if not p.is_global]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            if params_dict[param_name].is_global:\n                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        task_id_parts = []\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (str(param_name), str(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)\n\n    def initialized(self):\n        return hasattr(self, 'task_id')\n\n    @classmethod\n    def from_input(cls, params, global_params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        for param_name, param in global_params:\n            value = param.parse_from_input(param_name, params[param_name])\n            param.set_default(value)\n\n        kwargs = {}\n        for param_name, param in cls.get_nonglobal_params():\n            value = param.parse_from_input(param_name, params[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -162,29 +162,33 @@ class Task(object):\n \n         params_dict = dict(params)\n \n+        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n+        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n+        exc_desc = '%s[args=%s, kwargs=%s]' % (cls.__name__, args, kwargs)\n+\n         # Fill in the positional arguments\n         positional_params = [(n, p) for n, p in params if not p.is_global]\n         for i, arg in enumerate(args):\n             if i >= len(positional_params):\n-                raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n+                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n             param_name, param_obj = positional_params[i]\n             result[param_name] = arg\n \n         # Then the optional arguments\n         for param_name, arg in kwargs.iteritems():\n             if param_name in result:\n-                raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n+                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n             if param_name not in params_dict:\n-                raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n+                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n             if params_dict[param_name].is_global:\n-                raise parameter.ParameterException('Class %s: can not override global parameter %s' % (cls.__name__, param_name))\n+                raise parameter.ParameterException('%s: can not override global parameter %s' % (exc_desc, param_name))\n             result[param_name] = arg\n \n         # Then use the defaults for anything not filled in\n         for param_name, param_obj in params:\n             if param_name not in result:\n                 if not param_obj.has_default:\n-                    raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n+                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                 result[param_name] = param_obj.default\n \n         def list_to_tuple(x):\n",
          "files_name_in_blame_commit": [
            "task.py"
          ]
        }
      },
      "8cfda10729272c6f757660de92ba639e82897f15": {
        "commit": {
          "commit_id": "8cfda10729272c6f757660de92ba639e82897f15",
          "commit_message": "added better exceptions for broken parameters, added tests\n\nChange-Id: Ia392f112de7d8b00298323e00ea859a9fa7f27e5\nReviewed-on: https://gerrit.spotify.net/gerrit/20163\nTC-Compile-And-Test: teamcity teamcity <teamcity@spotify.com>\nReviewed-by: Erik Bernhardsson <erikbern@spotify.com>",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2012-08-21 15:46:00",
          "commit_parent": "fe9613d9364fd1b18f79ce36dfc06c18e99c4e3b"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    positional_params = [p for p in params if not p[1].keyword_only]\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    positional_params = [p for p in params if not p[1].keyword_only]\n    for (i, arg) in enumerate(args):\n        if i >= len(positional_params):\n            raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        if param_name in result:\n            raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n        if param_name not in params_dict:\n            raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 104,
          "function_before_end_line": 135,
          "function_after_start_line": 103,
          "function_after_end_line": 138,
          "function_before_token_count": 152,
          "function_after_token_count": 215,
          "functions_name_modified_file": [
            "output",
            "get_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "__new__",
            "namespace",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "output",
            "get_params",
            "test_unknown_param",
            "test_missing_param",
            "test_task_creation",
            "input",
            "test_multibool_empty",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "test_multibool",
            "on_failure",
            "on_success",
            "from_input",
            "test_bool_true",
            "test_default_param_cmdline",
            "test_parameter_registration",
            "__new__",
            "namespace",
            "test_duplicated_param",
            "test_forgot_param",
            "has_default",
            "clear_instance_cache",
            "default",
            "__repr__",
            "test_forgot_param_in_dep",
            "__init__",
            "parse_from_input",
            "test_unknown_param_2",
            "parse",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "test_default_param",
            "test_bool_false",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_default_param_cmdline",
            "test_unknown_param_2",
            "test_duplicated_param",
            "test_default_param",
            "test_unknown_param",
            "test_missing_param"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 167,
          "file_complexity": 62,
          "file_token_count": 1083,
          "file_before": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    TaskMetaclass._default_namespace = namespace\n\n\nclass TaskMetaclass(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    _default_namespace = None\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing\n\n        Set the task namespace to whatever the currently declared namespace is\"\"\"\n\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        return type.__new__(metacls, classname, bases, classdict)\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n\n        h = TaskMetaclass.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        TaskMetaclass.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        TaskMetaclass.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n\nclass Task(object):\n    __metaclass__ = TaskMetaclass\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        positional_params = [p for p in params if not p[1].keyword_only]\n        for i, arg in enumerate(args):\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            kwargs[param_name] = param.parse_from_input(param_name, params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    TaskMetaclass._default_namespace = namespace\n\nclass TaskMetaclass(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    _default_namespace = None\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing\n\n        Set the task namespace to whatever the currently declared namespace is\"\"\"\n\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        return type.__new__(metacls, classname, bases, classdict)\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n\n        h = TaskMetaclass.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        TaskMetaclass.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        TaskMetaclass.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n\nclass Task(object):\n    __metaclass__ = TaskMetaclass\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        positional_params = [p for p in params if not p[1].keyword_only]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            if param_name in result:\n                raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise parameter.MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            kwargs[param_name] = param.parse_from_input(param_name, params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -10,7 +10,6 @@ def namespace(namespace=None):\n     If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n     TaskMetaclass._default_namespace = namespace\n \n-\n class TaskMetaclass(type):\n     # If we already have an instance of this class, then just return it from the cache\n     # The idea is that a Task object X should be able to set up heavy data structures that\n@@ -109,13 +108,17 @@ class Task(object):\n         # Fill in the positional arguments\n         positional_params = [p for p in params if not p[1].keyword_only]\n         for i, arg in enumerate(args):\n+            if i >= len(positional_params):\n+                raise parameter.UnknownParameterException('Class %s: takes at most %d parameters (%d given)' % (cls.__name__, len(positional_params), len(args)))\n             param_name, param_obj = positional_params[i]\n             result[param_name] = arg\n \n         # Then the optional arguments\n         for param_name, arg in kwargs.iteritems():\n-            assert param_name not in result\n-            assert param_name in params_dict\n+            if param_name in result:\n+                raise parameter.DuplicateParameterException('Class %s: parameter %s was already set as a positional parameter' % (cls.__name__, param_name))\n+            if param_name not in params_dict:\n+                raise parameter.UnknownParameterException('Class %s: unknown parameter %s' % (cls.__name__, param_name))\n             result[param_name] = arg\n \n         # Then use the defaults for anything not filled in\n",
          "files_name_in_blame_commit": [
            "parameter_test.py",
            "task.py",
            "parameter.py"
          ]
        }
      },
      "adf929568dd6c1cb7de790688fe6ed5924f76a8b": {
        "commit": {
          "commit_id": "adf929568dd6c1cb7de790688fe6ed5924f76a8b",
          "commit_message": "Fix test flag support: add keyword_only option for parameters.\n\nThere parameters cannot be set by positional arguments.\n\nChange-Id: If05fcb593410e05f1a099af2ede425da28f93190\nReviewed-on: https://gerrit.spotify.net/gerrit/19039\nTC-Compile-And-Test: teamcity teamcity <teamcity@spotify.com>\nReviewed-by: Fabian Alenius <fabian@spotify.com>",
          "commit_author": "Daniel Andersson",
          "commit_date": "2012-08-08 13:14:47",
          "commit_parent": "5c77d782b1cad537b63559fa162c61999a371f23"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    positional_params = [p for p in params if not p[1].keyword_only]\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = positional_params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 108,
          "function_before_end_line": 138,
          "function_after_start_line": 108,
          "function_after_end_line": 139,
          "function_before_token_count": 133,
          "function_after_token_count": 150,
          "functions_name_modified_file": [
            "output",
            "get_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "__new__",
            "namespace",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "output",
            "get_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "__new__",
            "namespace",
            "has_default",
            "clear_instance_cache",
            "default",
            "__repr__",
            "__init__",
            "parse_from_input",
            "parse",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "__init__"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 165,
          "file_complexity": 59,
          "file_token_count": 1025,
          "file_before": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    TaskMetaclass._default_namespace = namespace\n\n\nclass TaskMetaclass(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    _default_namespace = None\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing\n\n        Set the task namespace to whatever the currently declared namespace is\"\"\"\n\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        return type.__new__(metacls, classname, bases, classdict)\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n\n        h = TaskMetaclass.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        TaskMetaclass.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        TaskMetaclass.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n\nclass MissingParameterException(Exception):\n    pass\n\n\nclass Task(object):\n    __metaclass__ = TaskMetaclass\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        for i, arg in enumerate(args):\n            param_name, param_obj = params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            kwargs[param_name] = param.parse_from_input(param_name, params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    TaskMetaclass._default_namespace = namespace\n\n\nclass TaskMetaclass(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    _default_namespace = None\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing\n\n        Set the task namespace to whatever the currently declared namespace is\"\"\"\n\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        return type.__new__(metacls, classname, bases, classdict)\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n\n        h = TaskMetaclass.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        TaskMetaclass.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        TaskMetaclass.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n\nclass MissingParameterException(Exception):\n    pass\n\n\nclass Task(object):\n    __metaclass__ = TaskMetaclass\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        positional_params = [p for p in params if not p[1].keyword_only]\n        for i, arg in enumerate(args):\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            kwargs[param_name] = param.parse_from_input(param_name, params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -111,8 +111,9 @@ class Task(object):\n         params_dict = dict(params)\n \n         # Fill in the positional arguments\n+        positional_params = [p for p in params if not p[1].keyword_only]\n         for i, arg in enumerate(args):\n-            param_name, param_obj = params[i]\n+            param_name, param_obj = positional_params[i]\n             result[param_name] = arg\n \n         # Then the optional arguments\n",
          "files_name_in_blame_commit": [
            "task.py",
            "parameter.py"
          ]
        }
      },
      "8b5c826294ecc2baf552c83256fc7c3f6a6114b4": {
        "commit": {
          "commit_id": "8b5c826294ecc2baf552c83256fc7c3f6a6114b4",
          "commit_message": "Refactored Task metaclass for better namespace support and parameter intialization. Added support for list parameters\n\nChange-Id: Ib43edb4c76c12d14f3fad0ff896ac50e3ff07dba\nReviewed-on: https://gerrit.spotify.net/gerrit/18506\nTC-Compile-And-Test: teamcity teamcity <teamcity@spotify.com>\nReviewed-by: Fabian Alenius <fabian@spotify.com>",
          "commit_author": "Elias Freider",
          "commit_date": "2012-08-02 12:16:46",
          "commit_parent": "49e9a38fbd4912a6ec88211ef25fa3e32bf78169"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n    return [(param_name, result[param_name]) for (param_name, param_obj) in params]",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            if not param_obj.has_default:\n                raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n            result[param_name] = param_obj.default\n\n    def list_to_tuple(x):\n        \"\"\" Make tuples out of lists to allow hashing \"\"\"\n        if isinstance(x, list):\n            return tuple(x)\n        else:\n            return x\n    return [(param_name, list_to_tuple(result[param_name])) for (param_name, param_obj) in params]",
          "function_before_start_line": 67,
          "function_before_end_line": 91,
          "function_after_start_line": 113,
          "function_after_end_line": 143,
          "function_before_token_count": 128,
          "function_after_token_count": 133,
          "functions_name_modified_file": [
            "output",
            "get_params",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "on_failure",
            "on_success",
            "from_input",
            "__new__",
            "namespace",
            "clear_instance_cache",
            "__repr__",
            "__init__",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_all_files": [
            "output",
            "get_params",
            "expose",
            "load_config",
            "test_namespace",
            "expose_main",
            "test_task_creation",
            "input",
            "flatten",
            "externalize",
            "__hash__",
            "requires",
            "run",
            "get_main",
            "on_failure",
            "on_success",
            "from_input",
            "test_vanilla",
            "_process_args",
            "test_parameter_registration",
            "get_reg",
            "namespace",
            "__new__",
            "has_default",
            "clear_instance_cache",
            "default",
            "__repr__",
            "__init__",
            "setup_interface_logging",
            "parse",
            "__call__",
            "task_family",
            "complete",
            "deps",
            "getpaths",
            "get_param_values",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "__call__",
            "clear",
            "task_family",
            "__new__",
            "namespace",
            "get_params",
            "disable",
            "clear_instance_cache",
            "disable_instance_cache"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "test_namespace",
            "__call__",
            "clear",
            "task_family",
            "test_task_creation",
            "test_parameter_registration",
            "__new__",
            "namespace",
            "get_params",
            "expose",
            "disable",
            "clear_instance_cache",
            "run",
            "test_vanilla",
            "disable_instance_cache"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 173,
          "file_complexity": 61,
          "file_token_count": 1062,
          "file_before": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\nclass InstanceCache(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n\n    def __call__(cls, *args, **kwargs):\n        def instantiate():\n            return super(InstanceCache, cls).__call__(*args, **kwargs)\n\n        h = InstanceCache.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear(self):\n        InstanceCache.__instance_cache = {}\n\n    @classmethod\n    def disable(self):\n        InstanceCache.__instance_cache = None\n\n\nclass MissingParameterException(Exception):\n    pass\n\n\nclass Task(object):\n    __metaclass__ = InstanceCache\n    task_namespace = \"default\"\n\n    @classmethod\n    def get_params(cls):\n        # Extract all Argument instances from the class\n        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        for i, arg in enumerate(args):\n            param_name, param_obj = params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        # Sort it by the correct order and make a list\n        return [(param_name, result[param_name]) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        if self.task_namespace == \"default\":\n            self.task_family = self.__class__.__name__\n        else:\n            self.task_family = \"%s.%s\" % (self.task_namespace, self.__class__.__name__)\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if params[param_name] != None:\n                kwargs[param_name] = param.parse(params[param_name])\n            else:\n                if param.has_default:\n                    kwargs[param_name] = param.default\n                else:\n                    raise MissingParameterException(\"No value for '%s' submitted and no default value has been assigned.\" % param_name)\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "import parameter\nimport warnings\n\nParameter = parameter.Parameter\n\n\ndef namespace(namespace=None):\n    \"\"\" Call to set namespace of tasks declared after the call.\n\n    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n    TaskMetaclass._default_namespace = namespace\n\n\nclass TaskMetaclass(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    _default_namespace = None\n\n    def __new__(metacls, classname, bases, classdict):\n        \"\"\" Custom class creation for namespacing\n\n        Set the task namespace to whatever the currently declared namespace is\"\"\"\n\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        params = []\n        for b in bases:  # transfer parameters from base classes first\n            if isinstance(b, TaskMetaclass):\n                params.extend(b._parameters)\n\n        for ivar_name, ivar in classdict.iteritems():\n            if not isinstance(ivar, Parameter):\n                continue\n\n            params.append((ivar_name, ivar))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        classdict[\"_parameters\"] = params\n\n        return type.__new__(metacls, classname, bases, classdict)\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\" Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\"\"\"\n        def instantiate():\n            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n\n        h = TaskMetaclass.__instance_cache\n\n        if h == None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear_instance_cache(self):\n        TaskMetaclass.__instance_cache = {}\n\n    @classmethod\n    def disable_instance_cache(self):\n        TaskMetaclass.__instance_cache = None\n\n    @property\n    def task_family(cls):\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n\n\nclass MissingParameterException(Exception):\n    pass\n\n\nclass Task(object):\n    __metaclass__ = TaskMetaclass\n\n    \"\"\"\n    non-declared properties: (created in metaclass):\n\n    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n\n    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n    \"\"\"\n\n    @property\n    def task_family(self):\n        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n        return self.__class__.task_family\n\n    @classmethod\n    def get_params(cls):\n        # Extract all Argument instances from the class\n        return cls._parameters\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        for i, arg in enumerate(args):\n            param_name, param_obj = params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_default:\n                    raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                result[param_name] = param_obj.default\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n            if isinstance(x, list):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n        self.__hash = hash(self.task_id)\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if params[param_name] != None:\n                kwargs[param_name] = param.parse(params[param_name])\n            else:\n                if param.has_default:\n                    kwargs[param_name] = param.default\n                else:\n                    raise MissingParameterException(\"No value for '%s' submitted and no default value has been assigned.\" % param_name)\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.task_id\n\n    def complete(self):\n        \"\"\"\n            If the task has any outputs, return true if all outputs exists.\n            Otherwise, return whether or not the task has run or not\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            # TODO: unclear if tasks without outputs should always run or never run\n            warnings.warn(\"Task %r without outputs has no custom complete() method\" % self)\n            return False\n\n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n\n    def output(self):\n        return []  # default impl\n\n    def requires(self):\n        return []  # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n\n    def run(self):\n        pass  # default impl\n\n    def on_failure(self, exception, traceback):\n        \"\"\" Override for custom error handling\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to return a string representation of the exception and traceback.\n        \"\"\"\n        return {\"exception\": str(exception),\n                \"traceback\": str(traceback)}\n\n    def on_success(self):\n        \"\"\" Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n        Default behavior is to send an None value\"\"\"\n        return None\n\n\ndef externalize(task):\n    task.run = NotImplemented\n    return task\n\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\n\nclass WrapperTask(Task):\n    \"\"\"Use for tasks that only wrap other tasks and that by definition are done if all their requirements exist. \"\"\"\n    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))\n\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]\n\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -4,18 +4,55 @@ import warnings\n Parameter = parameter.Parameter\n \n \n-class InstanceCache(type):\n+def namespace(namespace=None):\n+    \"\"\" Call to set namespace of tasks declared after the call.\n+\n+    If called without arguments or with None as the namespace, the namespace is reset, which is recommended to do at the end of any file where the namespace is set to avoid unintentionally setting namespace on tasks outside of the scope of the current file.\"\"\"\n+    TaskMetaclass._default_namespace = namespace\n+\n+\n+class TaskMetaclass(type):\n     # If we already have an instance of this class, then just return it from the cache\n     # The idea is that a Task object X should be able to set up heavy data structures that\n     # can be accessed from other Task objects (with dependencies on X). But we need to make\n     # sure that X is not instantiated many times.\n     __instance_cache = {}\n+    _default_namespace = None\n+\n+    def __new__(metacls, classname, bases, classdict):\n+        \"\"\" Custom class creation for namespacing\n+\n+        Set the task namespace to whatever the currently declared namespace is\"\"\"\n+\n+        if \"task_namespace\" not in classdict:\n+            classdict[\"task_namespace\"] = metacls._default_namespace\n+\n+        params = []\n+        for b in bases:  # transfer parameters from base classes first\n+            if isinstance(b, TaskMetaclass):\n+                params.extend(b._parameters)\n+\n+        for ivar_name, ivar in classdict.iteritems():\n+            if not isinstance(ivar, Parameter):\n+                continue\n+\n+            params.append((ivar_name, ivar))\n+\n+        # The order the parameters are created matters. See Parameter class\n+        params.sort(key=lambda t: t[1].counter)\n+        classdict[\"_parameters\"] = params\n+\n+        return type.__new__(metacls, classname, bases, classdict)\n \n     def __call__(cls, *args, **kwargs):\n+        \"\"\" Custom class instantiation utilizing instance cache.\n+\n+        If a Task has already been instantiated with the same parameters,\n+        the previous instance is returned to reduce number of object instances.\"\"\"\n         def instantiate():\n-            return super(InstanceCache, cls).__call__(*args, **kwargs)\n+            return super(TaskMetaclass, cls).__call__(*args, **kwargs)\n \n-        h = InstanceCache.__instance_cache\n+        h = TaskMetaclass.__instance_cache\n \n         if h == None:  # disabled\n             return instantiate()\n@@ -31,12 +68,19 @@ class InstanceCache(type):\n         return h[k]\n \n     @classmethod\n-    def clear(self):\n-        InstanceCache.__instance_cache = {}\n+    def clear_instance_cache(self):\n+        TaskMetaclass.__instance_cache = {}\n \n     @classmethod\n-    def disable(self):\n-        InstanceCache.__instance_cache = None\n+    def disable_instance_cache(self):\n+        TaskMetaclass.__instance_cache = None\n+\n+    @property\n+    def task_family(cls):\n+        if cls.task_namespace is None:\n+            return cls.__name__\n+        else:\n+            return \"%s.%s\" % (cls.task_namespace, cls.__name__)\n \n \n class MissingParameterException(Exception):\n@@ -44,24 +88,26 @@ class MissingParameterException(Exception):\n \n \n class Task(object):\n-    __metaclass__ = InstanceCache\n-    task_namespace = \"default\"\n+    __metaclass__ = TaskMetaclass\n+\n+    \"\"\"\n+    non-declared properties: (created in metaclass):\n+\n+    `Task.task_namespace` - optional string which is prepended to the task name for the sake of scheduling.\n+    If it isn't overridden in a Task, whatever was last declared using `luigi.namespace` will be used.\n+\n+    `Task._parameters` - list of (parameter_name, parameter) tuples for this task class\n+    \"\"\"\n+\n+    @property\n+    def task_family(self):\n+        \"\"\" Convenience method since a property on the metaclass isn't directly accessible through the class instances\"\"\"\n+        return self.__class__.task_family\n \n     @classmethod\n     def get_params(cls):\n         # Extract all Argument instances from the class\n-        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n-        params = []\n-        for param_name in dir(cls):\n-            param_obj = getattr(cls, param_name)\n-            if not isinstance(param_obj, Parameter):\n-                continue\n-\n-            params.append((param_name, param_obj))\n-\n-        # The order the parameters are created matters. See Parameter class\n-        params.sort(key=lambda t: t[1].counter)\n-        return params\n+        return cls._parameters\n \n     @classmethod\n     def get_param_values(cls, params, args, kwargs):\n@@ -87,8 +133,14 @@ class Task(object):\n                     raise MissingParameterException(\"'%s' tasks requires the '%s' parameter to be set\" % (cls.__name__, param_name))\n                 result[param_name] = param_obj.default\n \n+        def list_to_tuple(x):\n+            \"\"\" Make tuples out of lists to allow hashing \"\"\"\n+            if isinstance(x, list):\n+                return tuple(x)\n+            else:\n+                return x\n         # Sort it by the correct order and make a list\n-        return [(param_name, result[param_name]) for param_name, param_obj in params]\n+        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]\n \n     def __init__(self, *args, **kwargs):\n         params = self.get_params()\n@@ -98,10 +150,6 @@ class Task(object):\n         for key, value in param_values:\n             setattr(self, key, value)\n \n-        if self.task_namespace == \"default\":\n-            self.task_family = self.__class__.__name__\n-        else:\n-            self.task_family = \"%s.%s\" % (self.task_namespace, self.__class__.__name__)\n         self.task_id = '%s(%s)' % (self.task_family, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n         self.__hash = hash(self.task_id)\n \n",
          "files_name_in_blame_commit": [
            "interface.py",
            "task.py",
            "parameter.py",
            "parameter_test.py",
            "__init__.py",
            "namespace_test.py",
            "namespace_test_helper.py"
          ]
        }
      },
      "79762b3c355cbb51fdf01439131b71dc6b4361c0": {
        "commit": {
          "commit_id": "79762b3c355cbb51fdf01439131b71dc6b4361c0",
          "commit_message": "fixed incorrect order of params in the str repr of tasks",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2012-01-18 16:50:29",
          "commit_parent": "a9fea138262e2ca95e2bccd90eb4b86037f2cf24"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param) in params:\n        if param_name not in result:\n            result[param_name] = param.default\n    return result",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param_obj) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param_obj) in params:\n        if param_name not in result:\n            result[param_name] = param_obj.default\n    return [(param_name, result[param_name]) for (param_name, param_obj) in params]",
          "function_before_start_line": 59,
          "function_before_end_line": 77,
          "function_after_start_line": 59,
          "function_after_end_line": 81,
          "function_before_token_count": 94,
          "function_after_token_count": 109,
          "functions_name_modified_file": [
            "__init__",
            "__call__",
            "clear",
            "complete",
            "output",
            "input",
            "flatten",
            "get_params",
            "deps",
            "getpaths",
            "__hash__",
            "disable",
            "requires",
            "run",
            "get_param_values",
            "from_input",
            "__repr__"
          ],
          "functions_name_all_files": [
            "__init__",
            "__call__",
            "clear",
            "complete",
            "output",
            "input",
            "flatten",
            "get_params",
            "deps",
            "getpaths",
            "__hash__",
            "disable",
            "requires",
            "run",
            "get_param_values",
            "from_input",
            "__repr__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "__call__",
            "get_params"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "__call__",
            "get_params"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 116,
          "file_complexity": 43,
          "file_token_count": 769,
          "file_before": "import parameter\n\nParameter = parameter.Parameter\n\nclass InstanceCache(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    def __call__(cls, *args, **kwargs):\n        def instantiate():\n            return super(InstanceCache, cls).__call__(*args, **kwargs)\n\n        h = InstanceCache.__instance_cache\n\n        if h == None: #disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values.iteritems()))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear(self):\n        InstanceCache.__instance_cache = {}\n\n    @classmethod\n    def disable(self):\n        InstanceCache.__instance_cache = None\n\nclass Task(object):\n    # Something like this...\n\n    __metaclass__ = InstanceCache\n\n    @classmethod\n    def get_params(cls):\n        # Extract all Argument instances from the class\n        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n        params = []\n        for param_name in dir(cls):\n            param = getattr(cls, param_name)\n            if not isinstance(param, Parameter): continue\n            \n            params.append((param_name, param))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key = lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        for i, arg in enumerate(args):\n            param_name, param = params[i]\n            result[param_name] = arg\n\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        for param_name, param in params:\n            if param_name not in result:\n                result[param_name] = param.default\n\n        return result\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n\n        for key, value in param_values.iteritems():\n            setattr(self, key, value)\n\n        self.__hash = hash(tuple(param_values.iteritems()))\n        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values.iteritems()]))\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if params[param_name] != None:\n                kwargs[param_name] = param.parse(params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.__repr\n\n    def complete(self):\n        outputs = flatten(self.output())\n        if len(outputs) == 0: return False\n        \n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n        \n    def output(self):\n        return [] # default impl\n    \n    def requires(self):\n        return [] # default impl\n\n    def input(self):\n        requires = self.requires()\n        data = getpaths(requires)\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n    \n    def run(self):\n        pass # default impl\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n            \n        return [getpaths(r) for r in s]\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_after": "import parameter\n\nParameter = parameter.Parameter\n\nclass InstanceCache(type):\n    # If we already have an instance of this class, then just return it from the cache\n    # The idea is that a Task object X should be able to set up heavy data structures that\n    # can be accessed from other Task objects (with dependencies on X). But we need to make\n    # sure that X is not instantiated many times.\n    __instance_cache = {}\n    def __call__(cls, *args, **kwargs):\n        def instantiate():\n            return super(InstanceCache, cls).__call__(*args, **kwargs)\n\n        h = InstanceCache.__instance_cache\n\n        if h == None: #disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]\n\n    @classmethod\n    def clear(self):\n        InstanceCache.__instance_cache = {}\n\n    @classmethod\n    def disable(self):\n        InstanceCache.__instance_cache = None\n\nclass Task(object):\n    # Something like this...\n\n    __metaclass__ = InstanceCache\n\n    @classmethod\n    def get_params(cls):\n        # Extract all Argument instances from the class\n        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter): continue\n            \n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key = lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        # Fill in the positional arguments\n        for i, arg in enumerate(args):\n            param_name, param_obj = params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                result[param_name] = param_obj.default\n\n        # Sort it by the correct order and make a list\n        return [(param_name, result[param_name]) for param_name, param_obj in params]\n\n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        self.__hash = hash(tuple(param_values))\n        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if params[param_name] != None:\n                kwargs[param_name] = param.parse(params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.__repr\n\n    def complete(self):\n        outputs = flatten(self.output())\n        if len(outputs) == 0: return False\n        \n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n        \n    def output(self):\n        return [] # default impl\n    \n    def requires(self):\n        return [] # default impl\n\n    def input(self):\n        requires = self.requires()\n        data = getpaths(requires)\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n    \n    def run(self):\n        pass # default impl\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n            \n        return [getpaths(r) for r in s]\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -20,7 +20,7 @@ class InstanceCache(type):\n         params = cls.get_params()\n         param_values = cls.get_param_values(params, args, kwargs)\n \n-        k = (cls, tuple(param_values.iteritems()))\n+        k = (cls, tuple(param_values))\n \n         if k not in h:\n             h[k] = instantiate()\n@@ -46,10 +46,10 @@ class Task(object):\n         # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n         params = []\n         for param_name in dir(cls):\n-            param = getattr(cls, param_name)\n-            if not isinstance(param, Parameter): continue\n+            param_obj = getattr(cls, param_name)\n+            if not isinstance(param_obj, Parameter): continue\n             \n-            params.append((param_name, param))\n+            params.append((param_name, param_obj))\n \n         # The order the parameters are created matters. See Parameter class\n         params.sort(key = lambda t: t[1].counter)\n@@ -61,32 +61,35 @@ class Task(object):\n \n         params_dict = dict(params)\n \n+        # Fill in the positional arguments\n         for i, arg in enumerate(args):\n-            param_name, param = params[i]\n+            param_name, param_obj = params[i]\n             result[param_name] = arg\n \n+        # Then the optional arguments\n         for param_name, arg in kwargs.iteritems():\n             assert param_name not in result\n             assert param_name in params_dict\n             result[param_name] = arg\n \n-        for param_name, param in params:\n+        # Then use the defaults for anything not filled in\n+        for param_name, param_obj in params:\n             if param_name not in result:\n-                result[param_name] = param.default\n+                result[param_name] = param_obj.default\n \n-        return result\n+        # Sort it by the correct order and make a list\n+        return [(param_name, result[param_name]) for param_name, param_obj in params]\n \n     def __init__(self, *args, **kwargs):\n         params = self.get_params()\n         param_values = self.get_param_values(params, args, kwargs)\n \n         # Set all values on class instance\n-\n-        for key, value in param_values.iteritems():\n+        for key, value in param_values:\n             setattr(self, key, value)\n \n-        self.__hash = hash(tuple(param_values.iteritems()))\n-        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values.iteritems()]))\n+        self.__hash = hash(tuple(param_values))\n+        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values]))\n \n     @classmethod\n     def from_input(cls, params):\n",
          "files_name_in_blame_commit": [
            "task.py"
          ]
        }
      },
      "de513d2cfcb4e8d756043d936b9f2e35debdc26c": {
        "commit": {
          "commit_id": "de513d2cfcb4e8d756043d936b9f2e35debdc26c",
          "commit_message": "moved a bunch of files",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2012-01-03 11:44:48",
          "commit_parent": "ba3ceeefffdb45023a9490cdc92398c7d082e4d1"
        },
        "function": {
          "function_name": "get_param_values",
          "function_code_before": "",
          "function_code_after": "@classmethod\ndef get_param_values(cls, params, args, kwargs):\n    result = {}\n    params_dict = dict(params)\n    for (i, arg) in enumerate(args):\n        (param_name, param) = params[i]\n        result[param_name] = arg\n    for (param_name, arg) in kwargs.iteritems():\n        assert param_name not in result\n        assert param_name in params_dict\n        result[param_name] = arg\n    for (param_name, param) in params:\n        if param_name not in result:\n            result[param_name] = param.default\n    return result",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 26,
          "function_after_end_line": 44,
          "function_before_token_count": 0,
          "function_after_token_count": 94,
          "functions_name_modified_file": [
            "__init__",
            "complete",
            "output",
            "input",
            "__new__",
            "flatten",
            "get_params",
            "deps",
            "getpaths",
            "__hash__",
            "requires",
            "run",
            "get_param_values",
            "from_input",
            "__repr__"
          ],
          "functions_name_all_files": [
            "prune",
            "output",
            "status",
            "ping",
            "get_params",
            "expose",
            "work",
            "remove",
            "input",
            "open",
            "flatten",
            "task",
            "__hash__",
            "requires",
            "request",
            "add",
            "run",
            "draw",
            "exists",
            "process",
            "__new__",
            "dep",
            "has_default",
            "default",
            "__repr__",
            "__init__",
            "parse",
            "complete",
            "deps",
            "getpaths",
            "autoupdate",
            "get_param_values",
            "from_input"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "input",
            "output",
            "complete",
            "__new__",
            "flatten",
            "get_params",
            "deps",
            "getpaths",
            "requires",
            "__hash__",
            "run",
            "from_input",
            "__repr__"
          ],
          "functions_name_co_evolved_all_files": [
            "prune",
            "output",
            "status",
            "ping",
            "get_params",
            "expose",
            "work",
            "remove",
            "input",
            "open",
            "flatten",
            "task",
            "requires",
            "__hash__",
            "request",
            "add",
            "run",
            "draw",
            "exists",
            "process",
            "__new__",
            "dep",
            "has_default",
            "default",
            "__repr__",
            "__init__",
            "parse",
            "complete",
            "deps",
            "getpaths",
            "autoupdate",
            "from_input"
          ]
        },
        "file": {
          "file_name": "task.py",
          "file_nloc": 102,
          "file_complexity": 38,
          "file_token_count": 715,
          "file_before": null,
          "file_after": "import parameter\n\nParameter = parameter.Parameter\n\nclass Task(object):\n    # Something like this...\n\n    __instance_cache = {}\n\n    @classmethod\n    def get_params(cls):\n        # Extract all Argument instances from the class\n        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n        params = []\n        for param_name in dir(cls):\n            param = getattr(cls, param_name)\n            if not isinstance(param, Parameter): continue\n            \n            params.append((param_name, param))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key = lambda t: t[1].counter)\n        return params\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        result = {}\n\n        params_dict = dict(params)\n\n        for i, arg in enumerate(args):\n            param_name, param = params[i]\n            result[param_name] = arg\n\n        for param_name, arg in kwargs.iteritems():\n            assert param_name not in result\n            assert param_name in params_dict\n            result[param_name] = arg\n\n        for param_name, param in params:\n            if param_name not in result:\n                result[param_name] = param.default\n\n        return result\n\n    def __new__(cls, *args, **kwargs):\n        # If we already have an instance of this class, then just return it from the cache\n        # The idea is that a Task object X should be able to set up heavy data structures that\n        # can be accessed from other Task objects (with dependencies on X). But we need to make\n        # sure that X is not instantiated many times.\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values.iteritems()))\n        if k not in Task.__instance_cache:\n            Task.__instance_cache[k] = super(Task, cls).__new__(cls)\n            Task.__instance_cache[k].__init__(*args, **kwargs)\n\n        return Task.__instance_cache[k]\n    \n    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n\n        for key, value in param_values.iteritems():\n            setattr(self, key, value)\n\n        self.__hash = hash(tuple(param_values.iteritems()))\n        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values.iteritems()]))\n\n    @classmethod\n    def from_input(cls, params):\n        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if params[param_name] != None:\n                kwargs[param_name] = param.parse(params[param_name])\n\n        return cls(**kwargs)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return self.__repr\n\n    def complete(self):\n        outputs = flatten(self.output())\n        if len(outputs) == 0: return False\n        \n        for output in outputs:\n            if not output.exists():\n                return False\n        else:\n            return True\n        \n    def output(self):\n        return [] # default impl\n    \n    def requires(self):\n        return [] # default impl\n\n    def input(self):\n        return getpaths(self.requires())\n\n    def deps(self):\n        # used by scheduler\n        return flatten(self.requires())\n    \n    def run(self):\n        pass # default impl\n\nclass ExternalTask(Task):\n    \"\"\"Subclass for references to external dependencies\"\"\"\n    run = NotImplemented\n\ndef getpaths(struct):\n    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in struct.iteritems():\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n            \n        return [getpaths(r) for r in s]\n\ndef flatten(struct):\n    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n    Examples:\n    > _flatten({'a': foo, b: bar})\n    [foo, bar]\n    > _flatten([foo, [bar, troll]])\n    [foo, bar, troll]\n    > _flatten(foo)\n    [foo]\n    \"\"\"\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.iteritems():\n            flat += flatten(result)\n        return flat\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]\n",
          "file_patch": "@@ -0,0 +1,162 @@\n+import parameter\n+\n+Parameter = parameter.Parameter\n+\n+class Task(object):\n+    # Something like this...\n+\n+    __instance_cache = {}\n+\n+    @classmethod\n+    def get_params(cls):\n+        # Extract all Argument instances from the class\n+        # TODO: not really necessary to do multiple times, can we make it run once when the class is created?\n+        params = []\n+        for param_name in dir(cls):\n+            param = getattr(cls, param_name)\n+            if not isinstance(param, Parameter): continue\n+            \n+            params.append((param_name, param))\n+\n+        # The order the parameters are created matters. See Parameter class\n+        params.sort(key = lambda t: t[1].counter)\n+        return params\n+\n+    @classmethod\n+    def get_param_values(cls, params, args, kwargs):\n+        result = {}\n+\n+        params_dict = dict(params)\n+\n+        for i, arg in enumerate(args):\n+            param_name, param = params[i]\n+            result[param_name] = arg\n+\n+        for param_name, arg in kwargs.iteritems():\n+            assert param_name not in result\n+            assert param_name in params_dict\n+            result[param_name] = arg\n+\n+        for param_name, param in params:\n+            if param_name not in result:\n+                result[param_name] = param.default\n+\n+        return result\n+\n+    def __new__(cls, *args, **kwargs):\n+        # If we already have an instance of this class, then just return it from the cache\n+        # The idea is that a Task object X should be able to set up heavy data structures that\n+        # can be accessed from other Task objects (with dependencies on X). But we need to make\n+        # sure that X is not instantiated many times.\n+\n+        params = cls.get_params()\n+        param_values = cls.get_param_values(params, args, kwargs)\n+\n+        k = (cls, tuple(param_values.iteritems()))\n+        if k not in Task.__instance_cache:\n+            Task.__instance_cache[k] = super(Task, cls).__new__(cls)\n+            Task.__instance_cache[k].__init__(*args, **kwargs)\n+\n+        return Task.__instance_cache[k]\n+    \n+    def __init__(self, *args, **kwargs):\n+        params = self.get_params()\n+        param_values = self.get_param_values(params, args, kwargs)\n+\n+        # Set all values on class instance\n+\n+        for key, value in param_values.iteritems():\n+            setattr(self, key, value)\n+\n+        self.__hash = hash(tuple(param_values.iteritems()))\n+        self.__repr = '%s(%s)' % (self.__class__.__name__, ', '.join(['%s=%s' % (str(k), str(v)) for k, v in param_values.iteritems()]))\n+\n+    @classmethod\n+    def from_input(cls, params):\n+        # Creates an instance from a str->str hash (to be used for cmd line interaction etc)\n+        kwargs = {}\n+        for param_name, param in cls.get_params():\n+            if params[param_name] != None:\n+                kwargs[param_name] = param.parse(params[param_name])\n+\n+        return cls(**kwargs)\n+\n+    def __hash__(self):\n+        return self.__hash\n+\n+    def __repr__(self):\n+        return self.__repr\n+\n+    def complete(self):\n+        outputs = flatten(self.output())\n+        if len(outputs) == 0: return False\n+        \n+        for output in outputs:\n+            if not output.exists():\n+                return False\n+        else:\n+            return True\n+        \n+    def output(self):\n+        return [] # default impl\n+    \n+    def requires(self):\n+        return [] # default impl\n+\n+    def input(self):\n+        return getpaths(self.requires())\n+\n+    def deps(self):\n+        # used by scheduler\n+        return flatten(self.requires())\n+    \n+    def run(self):\n+        pass # default impl\n+\n+class ExternalTask(Task):\n+    \"\"\"Subclass for references to external dependencies\"\"\"\n+    run = NotImplemented\n+\n+def getpaths(struct):\n+    \"\"\" Maps all Tasks in a structured data object to their .output()\"\"\"\n+    if isinstance(struct, Task):\n+        return struct.output()\n+    elif isinstance(struct, dict):\n+        r = {}\n+        for k, v in struct.iteritems():\n+            r[k] = getpaths(v)\n+        return r\n+    else:\n+        # Remaining case: assume r is iterable...\n+        try:\n+            s = list(struct)\n+        except TypeError:\n+            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n+            \n+        return [getpaths(r) for r in s]\n+\n+def flatten(struct):\n+    \"\"\"Cleates a flat list of all all items in structured output (dicts, lists, items)\n+    Examples:\n+    > _flatten({'a': foo, b: bar})\n+    [foo, bar]\n+    > _flatten([foo, [bar, troll]])\n+    [foo, bar, troll]\n+    > _flatten(foo)\n+    [foo]\n+    \"\"\"\n+    flat = []\n+    if isinstance(struct, dict):\n+        for key, result in struct.iteritems():\n+            flat += flatten(result)\n+        return flat\n+\n+    try:\n+        # if iterable\n+        for result in struct:\n+            flat += flatten(result)\n+        return flat\n+    except TypeError:\n+        pass\n+\n+    return [struct]\n",
          "files_name_in_blame_commit": [
            "scheduler.py",
            "interface.py",
            "target.py",
            "task.py",
            "server.py",
            "parameter.py",
            "file.py",
            "__init__.py",
            "mock.py"
          ]
        }
      }
    }
  }
}
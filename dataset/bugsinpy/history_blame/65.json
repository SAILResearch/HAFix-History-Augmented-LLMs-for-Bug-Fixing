{
  "id": "65",
  "blame_commit": {
    "commit": {
      "commit_id": "fb87d772b0b55d5d7a110dae44d3a691ebc2bf3e",
      "commit_message": "Remove some more 1-tuples.",
      "commit_author": "Antony Lee",
      "commit_date": "2019-01-04 22:28:06",
      "commit_parent": "af8a720136be3e642cdd134f89b290cc207bdedc"
    },
    "function": {
      "function_name": "set_label",
      "function_code_before": "def set_label(self, label, **kw):\n    \"\"\"\n        Label the long axis of the colorbar\n        \"\"\"\n    self._label = '%s' % (label,)\n    self._labelkw = kw\n    self._set_label()",
      "function_code_after": "def set_label(self, label, **kw):\n    \"\"\"Label the long axis of the colorbar.\"\"\"\n    self._label = str(label)\n    self._labelkw = kw\n    self._set_label()",
      "function_before_start_line": 640,
      "function_before_end_line": 646,
      "function_after_start_line": 640,
      "function_after_end_line": 644,
      "function_before_token_count": 31,
      "function_after_token_count": 29,
      "functions_name_modified_file": [
        "add_lines",
        "_extend_upper",
        "_config_axes",
        "set_ticklabels",
        "get_ticks",
        "_find_range",
        "set_alpha",
        "_get_extension_lengths",
        "_proportional_y",
        "draw_all",
        "_extend_lower",
        "make_axes",
        "remove",
        "_patch_ax",
        "_extended_N",
        "_add_solids",
        "_ticker",
        "_central_N",
        "_locate",
        "colorbar_factory",
        "_process_values",
        "_uniform_y",
        "minorticks_off",
        "_set_ticks_on_axis_warn",
        "_mesh",
        "make_axes_gridspec",
        "tick_values",
        "set_ticks",
        "_set_label",
        "config_axis",
        "update_normal",
        "on_mappable_changed",
        "minorticks_on",
        "set_label",
        "__init__",
        "_use_auto_colorbar_locator",
        "__call__",
        "update_ticks",
        "_edges",
        "_outline",
        "update_bruteforce",
        "_get_ticker_locator_formatter"
      ],
      "functions_name_all_files": [
        "set_autoscalez_on",
        "_set_dpi",
        "set_markersize",
        "get_marker",
        "tricontour",
        "_exception_printer",
        "_makefill",
        "plot_surface",
        "_get_wrapped_text",
        "gca",
        "disconnect",
        "_get_ref_xy",
        "_repr_html_",
        "get_xdata",
        "_set_logger_verbose_level",
        "is_first_col",
        "get_path",
        "set_drawstyle",
        "set_markeredgewidth",
        "set_vertical",
        "axis",
        "set_ymargin",
        "get_unit",
        "execute_constrained_layout",
        "set_locator",
        "format_zdata",
        "boxplot_stats",
        "xaxis_date",
        "get_size_inches",
        "get_dash_joinstyle",
        "get_data",
        "update_ticks",
        "set_picker",
        "_unmultiplied_rgba8888_to_premultiplied_argb32",
        "set_xlim3d",
        "set_color",
        "new_locator",
        "test_if_rctemplate_would_be_valid",
        "_get_layout",
        "get_renderer_cache",
        "can_zoom",
        "_get_data_path",
        "_outline",
        "update_bbox_position_size",
        "set_zscale",
        "get_yaxis_text2_transform",
        "set_fontname",
        "connect",
        "_makeline",
        "get_ygridlines",
        "_proportional_y",
        "_gci",
        "get_xscale",
        "_get_xy_transform",
        "apply_aspect",
        "get_backend",
        "set_yticks",
        "__contains__",
        "get_linestyle",
        "get_markerfacecolor",
        "get_legend",
        "checkdep_ps_distiller",
        "waitforbuttonpress",
        "onpick",
        "get_fontproperties",
        "safe_first_element",
        "set_zbound",
        "get_constrained_layout_pads",
        "use",
        "get_rotation",
        "_gen_axes_spines",
        "_stale_figure_callback",
        "add_axes",
        "_get_position_xy",
        "set_fontproperties",
        "__getstate__",
        "get_markerfacecoloralt",
        "is_dashed",
        "get_autoscalez_on",
        "set_linestyle",
        "xyann",
        "disable_mouse_rotation",
        "label",
        "pts_to_midstep",
        "get_data_ratio_log",
        "get_tightbbox",
        "get_sample_data",
        "_extend_upper",
        "set_linespacing",
        "iterable",
        "add_conversion_fn",
        "checkdep_ghostscript",
        "autofmt_xdate",
        "test_validator_invalid",
        "set_yticklabels",
        "align_labels",
        "set_dashpad",
        "draw",
        "_process_values",
        "get_yminorticklabels",
        "is_hashable",
        "add_container",
        "safezip",
        "set_constrained_layout",
        "_topmost_artist",
        "__array__",
        "get_zbound",
        "get_figure",
        "get_xminorticklabels",
        "index_of",
        "_set_label",
        "_get_wrap_line_width",
        "strip_math",
        "config_axis",
        "safe_masked_invalid",
        "get_yaxis",
        "__call__",
        "_label_from_arg",
        "test_rcparams_init",
        "get_locator",
        "get_autoscale_on",
        "_open_file_or_url",
        "add_subplot",
        "test_if_rctemplate_is_up_to_date",
        "set_aspect",
        "set_top_view",
        "get_xticks",
        "joined",
        "_make_key",
        "get_yaxis_transform",
        "set_ylim",
        "simple_linear_interpolation",
        "set_bbox",
        "test_RcParams_class",
        "get_linewidth",
        "_split_drawstyle_linestyle",
        "get_yticks",
        "add_contour_set",
        "mouse_init",
        "get_home",
        "_check_versions",
        "suptitle",
        "_uniform_y",
        "set_tight_layout",
        "get_xlim",
        "get_pickradius",
        "_init_tests",
        "make_axes_gridspec",
        "update_coords",
        "get_rotation_mode",
        "_generate_normals",
        "add_artist",
        "relim",
        "_preprocess_data",
        "set_xscale",
        "update",
        "test_mfc_rcparams",
        "xaxis_inverted",
        "rc",
        "__getattribute__",
        "set_figheight",
        "get_navigate_mode",
        "pts_to_prestep",
        "get_navigate",
        "update_positions",
        "has_data",
        "_update_image_limits",
        "_set_lim_and_transforms",
        "test_rcparams",
        "get_aspect",
        "set_x",
        "tick_params",
        "margins",
        "_update_title_position",
        "get_geometry",
        "set_xmargin",
        "cla",
        "_get_dash_pattern",
        "_draw_bbox",
        "format_ydata",
        "_scale_dashes",
        "set_frame_on",
        "test_rcparams_update",
        "__getattr__",
        "add_gridspec",
        "_update_patch_limits",
        "get_test_data",
        "mkdirs",
        "_get_view",
        "align_iterators",
        "can_pan",
        "get_ylim3d",
        "_on_units_changed",
        "clean",
        "subplots_adjust",
        "__getitem__",
        "set_dpi",
        "checkdep_pdftops",
        "get_lines",
        "matplotlib_fname",
        "convert_zunits",
        "get_py2exe_datafiles",
        "figimage",
        "get_fillstyle",
        "set_dashrotation",
        "update_bruteforce",
        "sanitize_sequence",
        "set_clip_on",
        "set_fontstretch",
        "tricontourf",
        "clear",
        "draggable",
        "set_patchprops",
        "empty",
        "delaxes",
        "get_fontfamily",
        "get_xticklabels",
        "print_cycles",
        "get_ticks",
        "_process_unit_info",
        "_get_extension_lengths",
        "_get_scale",
        "locate",
        "rad_fn",
        "_logged_cached",
        "get_proj",
        "set_title",
        "align_xlabels",
        "_warn_external",
        "figaspect",
        "make_axes_locatable",
        "is_scalar_or_string",
        "violin_stats",
        "contour",
        "set_markerfacecoloralt",
        "set_zmargin",
        "get_ybound",
        "__str__",
        "set_proj_type",
        "get_rasterization_zorder",
        "get_stretch",
        "current_key_axes",
        "_check_1d",
        "invert_zaxis",
        "get_dashpad",
        "checkdep_inkscape",
        "set_constrained_layout_pads",
        "set_rasterization_zorder",
        "get_axes_locator",
        "get_xbound",
        "addition_rule",
        "get_xaxis",
        "new_vertical",
        "_string_to_bool",
        "get_solid_joinstyle",
        "_check_xy",
        "set_zlim3d",
        "grid",
        "get_unitless_position",
        "get_horizontalalignment",
        "get_zticklabels",
        "autoscale",
        "set_axis_off",
        "get_xlim3d",
        "get_yscale",
        "_get_xdg_config_dir",
        "_update_clip_properties",
        "tight_layout",
        "_get_new_axes",
        "__get__",
        "_transform_path",
        "mouseover_set",
        "add_table",
        "unit_bbox",
        "__hash__",
        "major_ticklabels",
        "set_position",
        "add_callback",
        "_remove_ax",
        "get_fontsize",
        "to_filehandle",
        "minorticks_off",
        "process",
        "rc_file",
        "_plot_args",
        "set_size_inches",
        "get_dashlength",
        "test_select_step360",
        "__repr__",
        "set_dashdirection",
        "_get_xy",
        "get_siblings",
        "contourf",
        "dms2float",
        "set_xticklabels",
        "make_axes_area_auto_adjustable",
        "is_writable_file_like",
        "get_dashdirection",
        "get_position_runtime",
        "get_markeredgecolor",
        "__setitem__",
        "set_ybound",
        "drag_pan",
        "get_label",
        "test_mec_rcparams",
        "get_window_extent",
        "get_annotation_clip",
        "get_dashrotation",
        "set_solid_capstyle",
        "set_rotation_mode",
        "_entry_from_axes",
        "toggle",
        "get_subplotspec",
        "add_auto_adjustable_area",
        "set_alpha",
        "set_multialignment",
        "set_remove_method",
        "test_Bug_2543",
        "have_units",
        "bar",
        "get_wrap",
        "_get_rendered_text_width",
        "_add_text",
        "segment_hits",
        "_setattr_cm",
        "rc_params_from_file",
        "add_collection3d",
        "_parse_commandline",
        "__iter__",
        "get_xaxis_transform",
        "set_autoscale_on",
        "set_fontsize",
        "set_text",
        "msg_backend_obsolete",
        "append_axes",
        "get_zminorticklabels",
        "add_contourf_set",
        "tick_values",
        "invert_yaxis",
        "_reshape_2D",
        "_xy_from_xy",
        "get",
        "set_axis_on",
        "colorbar",
        "get_usetex",
        "minorticks_on",
        "get_verticalalignment",
        "set_markeredgecolor",
        "set_autoscaley_on",
        "reset_position",
        "set_anchor",
        "get_position",
        "_get_dpi",
        "_create_tmp_config_or_cache_dir",
        "msg_depr",
        "clf",
        "test_Issue_1713",
        "_premultiplied_argb32_to_unmultiplied_rgba8888",
        "_remove_proxy",
        "get_horizontal",
        "convert",
        "_array_perimeter",
        "unicode_safe",
        "_config_axes",
        "msg_depr_set",
        "major_ticks",
        "clabel",
        "get_solid_capstyle",
        "get_horizontal_sizes",
        "get_bbox_patch",
        "set_level",
        "_get_transformed_path",
        "locatable_axes_factory",
        "get_constrained_layout",
        "get_markevery",
        "locator_params",
        "get_xaxis_text1_transform",
        "_button_press",
        "sca",
        "set_linewidth",
        "_set_ticks_on_axis_warn",
        "_picklable_subplot_class_constructor",
        "__new__",
        "yaxis_inverted",
        "set_yscale",
        "is_numlike",
        "format_coord",
        "__init__",
        "plot_trisurf",
        "_setdefaults",
        "is_last_col",
        "get_zlim3d",
        "set_pickradius",
        "local_over_kwdict",
        "test_validator_valid",
        "contains",
        "_calc_offsets",
        "set_subplotspec",
        "savefig",
        "text",
        "change_geometry",
        "_init_axis_artists",
        "subplots",
        "invert_xaxis",
        "multiplication_rule",
        "__fallback",
        "push",
        "set_visible",
        "get_axis_position",
        "_wrap_text",
        "add_child_axes",
        "set_lineprops",
        "set_wrap",
        "plot",
        "in_axes",
        "contains_point",
        "set_fontfamily",
        "set_marker",
        "get_drawstyle",
        "set_autoscalex_on",
        "get_vsize_hsize",
        "tk_window_focus",
        "set_dash_capstyle",
        "_ticker",
        "unit_cube",
        "get_data_path",
        "set_navigate",
        "get_shared_y_axes",
        "set_unit",
        "update_from",
        "report_memory",
        "get_color",
        "set_fileo",
        "_mesh",
        "auto_scale_xyz",
        "get_yaxis_text1_transform",
        "start_pan",
        "add_axobserver",
        "__rmul__",
        "set_annotation_clip",
        "set_data",
        "_get_textbox",
        "is_interactive",
        "axes",
        "get_gridspec",
        "_update_this",
        "_update_position_xytext",
        "legend",
        "get_next_color",
        "_get_axis_list",
        "__len__",
        "set_facecolor",
        "rc_params",
        "normalize_kwargs",
        "_get_markerfacecolor",
        "twinx",
        "_set_position",
        "_is_sorted",
        "_patch_ax",
        "plot_wireframe",
        "_add_solids",
        "rc_file_defaults",
        "get_fontweight",
        "get_fontvariant",
        "__enter__",
        "get_zticks",
        "_lock_path",
        "set_rotation",
        "_process_plot_format",
        "pchanged",
        "update_params",
        "set_ticks",
        "set_solid_joinstyle",
        "_update_line_limits",
        "set_markevery",
        "_get_multialignment",
        "on_mappable_changed",
        "subplot_class_factory",
        "set_prop_cycle",
        "set_xdata",
        "set_fontvariant",
        "test_select_step",
        "listFiles",
        "get_children",
        "get_zmajorticklabels",
        "get_anchor",
        "get_xticklines",
        "set_zticks",
        "set_zlabel",
        "is_first_row",
        "append_size",
        "checkdep_usetex",
        "_gen_axes_patch",
        "get_w_lims",
        "get_zlabel",
        "get_dash_capstyle",
        "get_compressed_copy",
        "test_keymaps",
        "get_yticklines",
        "set_ylim3d",
        "set_y",
        "get_prop_tup",
        "_set_title_offset_trans",
        "_set_view_from_bbox",
        "remove_callback",
        "get_images",
        "_determine_lims",
        "pts_to_poststep",
        "set_figure",
        "set_fillstyle",
        "remove",
        "home",
        "get_adjustable",
        "set_figwidth",
        "get_conversion_fn",
        "get_cachedir",
        "get_data_ratio",
        "interactive",
        "set_frameon",
        "get_ymajorticklabels",
        "get_value",
        "_get_xdg_cache_dir",
        "draw_artist",
        "update_normal",
        "get_axes",
        "set_usetex",
        "bar3d",
        "set_label",
        "format_xdata",
        "_replacer",
        "get_fontstyle",
        "get_facecolor",
        "get_configdir",
        "file_requires_unicode",
        "redraw_in_frame",
        "set_transform",
        "set_axes_locator",
        "_get_ticker_locator_formatter",
        "get_antialiased",
        "ge",
        "convert_to",
        "zaxis_inverted",
        "msg_obsolete",
        "add_image",
        "get_autoscalex_on",
        "_find_range",
        "_validate_converted_limits",
        "_extend_lower",
        "make_axes",
        "is_url",
        "yaxis_date",
        "_str_lower_equal",
        "_locate",
        "forward",
        "_get_config_or_cache_dir",
        "add_conversion_factor",
        "set_horizontalalignment",
        "dedent",
        "test_legend_colors",
        "_3d_extend_contour",
        "_update_transScale",
        "_determine_karray",
        "cos",
        "add_collection",
        "delete_masked_points",
        "ticklabel_format",
        "as_list",
        "show",
        "back",
        "quiver",
        "get_dashpush",
        "_calc_k",
        "set_dashpush",
        "get_yticklabels",
        "_define_aliases",
        "set_markerfacecolor",
        "_edges",
        "get_ylim",
        "_get_axes",
        "__setstate__",
        "set_xbound",
        "axisinfo",
        "is_math_text",
        "get_frameon",
        "_make_twin_axes",
        "get_xgridlines",
        "scatter",
        "checkdep_dvipng",
        "add_lines",
        "get_autoscaley_on",
        "update_datalim",
        "wrap",
        "set_dashlength",
        "_set_view",
        "get_vertical",
        "get_axisbelow",
        "add_line",
        "autoscale_view",
        "add_patch",
        "_str_equal",
        "test",
        "get_frame_on",
        "colorbar_factory",
        "set_antialiased",
        "_get_dist_to_box",
        "report",
        "get_figheight",
        "rcdefaults",
        "contiguous_regions",
        "end_pan",
        "label_outer",
        "get_ydata",
        "set_clip_box",
        "_to_unmasked_float_array",
        "set_dash_joinstyle",
        "__reduce__",
        "get_zscale",
        "set_ydata",
        "test_select_step24",
        "_check_and_log_subprocess",
        "set_edgecolor",
        "_use_auto_colorbar_locator",
        "set_fontweight",
        "get_edgecolor",
        "open_file_cm",
        "set_backgroundcolor",
        "set_horizontal",
        "_set_artist_props",
        "get_zticklines",
        "_extended_N",
        "get_fontname",
        "_combine_masks",
        "set_navigate_mode",
        "__mul__",
        "get_default_bbox_extra_artists",
        "set_ticklabels",
        "get_text",
        "get_vertical_sizes",
        "set_adjustable",
        "process_selected",
        "_shade_colors",
        "new_horizontal",
        "get_markersize",
        "discard",
        "get_dpi",
        "recache",
        "get_figwidth",
        "default_units",
        "compare_versions",
        "is_last_row",
        "tunit_cube",
        "voxels",
        "get_xaxis_text2_transform",
        "__eq__",
        "set_xlim",
        "update_datalim_bounds",
        "get_realpath_and_stat",
        "twiny",
        "copy",
        "align_ylabels",
        "_central_N",
        "_mark_every_path",
        "msg_depr_ignore",
        "get_tight_layout",
        "_on_move",
        "init_layoutbox",
        "_init_axis",
        "set_fontstyle",
        "set_xticks",
        "draw_all",
        "_add_data_doc",
        "_rc_params_in_file",
        "set_clip_path",
        "_getdefaults",
        "get_xmajorticklabels",
        "get_xydata",
        "set_axisbelow",
        "_get_xy_display",
        "flatten",
        "tunit_edges",
        "use_sticky_edges",
        "ginput",
        "zaxis_date",
        "add",
        "get_shared_x_axes",
        "set_canvas",
        "generate_validator_testcases",
        "anncoords",
        "__array_wrap__",
        "view_init",
        "test_formatters",
        "recache_always",
        "_button_release",
        "get_markeredgewidth",
        "find_all",
        "set_zticklabels",
        "convert_value_to",
        "_sci",
        "set_verticalalignment",
        "bubble",
        "join",
        "test_rcparams_reset_after_fail",
        "__exit__",
        "set_dashes"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "__init__",
        "set_text",
        "__new__",
        "test_formatters",
        "_mark_every_path",
        "__setstate__",
        "margins",
        "__setitem__",
        "print_cycles",
        "__str__",
        "test_legend_colors",
        "__repr__",
        "rad_fn"
      ]
    },
    "file": {
      "file_name": "colorbar.py",
      "file_nloc": 1096,
      "file_complexity": 200,
      "file_token_count": 7246,
      "file_before": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n\n'''\n\nimport logging\n\nimport numpy as np\n\nimport matplotlib as mpl\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.collections as collections\nimport matplotlib.colors as colors\nimport matplotlib.contour as contour\nimport matplotlib.cm as cm\nimport matplotlib.gridspec as gridspec\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\nimport matplotlib.ticker as ticker\nimport matplotlib.transforms as mtransforms\nimport matplotlib._layoutbox as layoutbox\nimport matplotlib._constrained_layout as constrained_layout\nfrom matplotlib import docstring\n\n_log = logging.getLogger(__name__)\n\nmake_axes_kw_doc = '''\n\n    ============= ====================================================\n    Property      Description\n    ============= ====================================================\n    *orientation* vertical or horizontal\n    *fraction*    0.15; fraction of original axes to use for colorbar\n    *pad*         0.05 if vertical, 0.15 if horizontal; fraction\n                  of original axes between colorbar and new image axes\n    *shrink*      1.0; fraction by which to multiply the size of the colorbar\n    *aspect*      20; ratio of long to short dimensions\n    *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;\n                  the anchor point of the colorbar axes\n    *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;\n                  the anchor point of the colorbar parent axes. If\n                  False, the parent axes' anchor will be unchanged\n    ============= ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ============  ====================================================\n    Property      Description\n    ============  ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *extendfrac*  [ *None* | 'auto' | length | lengths ]\n                  If set to *None*, both the minimum and maximum\n                  triangular colorbar extensions with have a length of\n                  5% of the interior colorbar length (this is the\n                  default setting). If set to 'auto', makes the\n                  triangular colorbar extensions the same lengths as\n                  the interior boxes (when *spacing* is set to\n                  'uniform') or the same lengths as the respective\n                  adjacent interior boxes (when *spacing* is set to\n                  'proportional'). If a scalar, indicates the length\n                  of both the minimum and maximum triangular colorbar\n                  extensions as a fraction of the interior colorbar\n                  length. A two-element sequence of fractions may also\n                  be given, indicating the lengths of the minimum and\n                  maximum colorbar extensions respectively as a\n                  fraction of the interior colorbar length.\n    *extendrect*  bool\n                  If *False* the minimum and maximum colorbar extensions\n                  will be triangular (the default). If *True* the\n                  extensions will be rectangular.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g., '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   bool\n                  Whether to draw lines at color boundaries.\n    ============  ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`~matplotlib.figure.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\nParameters\n----------\nmappable\n    The `~matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.Image`,\n    `~matplotlib.contour.ContourSet`, etc.) to which the colorbar applies.\n    This argument is mandatory for the `.Figure.colorbar` method but optional\n    for the `.pyplot.colorbar` function, which sets the default to the current\n    image.\n\ncax : :class:`~matplotlib.axes.Axes` object, optional\n    Axes into which the colorbar will be drawn.\n\nax : :class:`~matplotlib.axes.Axes`, list of Axes, optional\n    Parent axes from which space for a new colorbar axes will be stolen.\n    If a list of axes is given they will all be resized to make room for the\n    colorbar axes.\n\nuse_gridspec : bool, optional\n    If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If\n    *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is\n    created as an instance of Subplot using the :mod:`~.gridspec` module.\n\nReturns\n-------\ncolorbar : `~matplotlib.colorbar.Colorbar`\n    See also its base class, `~matplotlib.colorbar.ColorbarBase`.  Use\n    `~.ColorbarBase.set_label` to label the colorbar.\n\nNotes\n-----\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nThe *shrink* kwarg provides a simple way to scale the colorbar with respect\nto the axes. Note that if *cax* is specified, it determines the size of the\ncolorbar and *shrink* and *aspect* kwargs are ignored.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n\nIt is known that some vector graphics viewers (svg and pdf) renders white gaps\nbetween segments of the colorbar.  This is due to bugs in the viewers, not\nMatplotlib.  As a workaround, the colorbar can be rendered with overlapping\nsegments::\n\n    cbar = colorbar()\n    cbar.solids.set_edgecolor(\"face\")\n    draw()\n\nHowever this has negative consequences in other circumstances, e.g. with\nsemi-transparent images (alpha < 1) and colorbar extensions; therefore, this\nworkaround is not used by default (see issue #1188).\n\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\ndocstring.interpd.update(colorbar_doc=colorbar_doc)\n\n\ndef _set_ticks_on_axis_warn(*args, **kw):\n    # a top level function which gets put in at the axes'\n    # set_xticks set_yticks by _patch_ax\n    cbook._warn_external(\"Use the colorbar set_ticks() method instead.\")\n\n\nclass _ColorbarAutoLocator(ticker.MaxNLocator):\n    \"\"\"\n    AutoLocator for Colorbar\n\n    This locator is just a `.MaxNLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so ticks don't\n    extrude into the \"extend regions\".\n    \"\"\"\n\n    def __init__(self, colorbar):\n        \"\"\"\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.  Otherwise it is the same as\n        `~.ticker.AutoLocator`.\n        \"\"\"\n\n        self._colorbar = colorbar\n        nbins = 'auto'\n        steps = [1, 2, 2.5, 5, 10]\n        super().__init__(nbins=nbins, steps=steps)\n\n    def tick_values(self, vmin, vmax):\n        vmin = max(vmin, self._colorbar.norm.vmin)\n        vmax = min(vmax, self._colorbar.norm.vmax)\n        ticks = super().tick_values(vmin, vmax)\n        rtol = (vmax - vmin) * 1e-10\n        return ticks[(ticks >= vmin - rtol) & (ticks <= vmax + rtol)]\n\n\nclass _ColorbarAutoMinorLocator(ticker.AutoMinorLocator):\n    \"\"\"\n    AutoMinorLocator for Colorbar\n\n    This locator is just a `.AutoMinorLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so that the minorticks\n    don't extrude into the \"extend regions\".\n    \"\"\"\n\n    def __init__(self, colorbar, n=None):\n        \"\"\"\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.\n        \"\"\"\n        self._colorbar = colorbar\n        self.ndivs = n\n        super().__init__(n=None)\n\n    def __call__(self):\n        vmin = self._colorbar.norm.vmin\n        vmax = self._colorbar.norm.vmax\n        ticks = super().__call__()\n        rtol = (vmax - vmin) * 1e-10\n        return ticks[(ticks >= vmin - rtol) & (ticks <= vmax + rtol)]\n\n\nclass _ColorbarLogLocator(ticker.LogLocator):\n    \"\"\"\n    LogLocator for Colorbarbar\n\n    This locator is just a `.LogLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so ticks don't\n    extrude into the \"extend regions\".\n\n    \"\"\"\n    def __init__(self, colorbar, *args, **kwargs):\n        \"\"\"\n        _ColorbarLogLocator(colorbar, *args, **kwargs)\n\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.  Otherwise it is the same as\n        `~.ticker.LogLocator`.  The ``*args`` and ``**kwargs`` are the\n        same as `~.ticker.LogLocator`.\n        \"\"\"\n        self._colorbar = colorbar\n        super().__init__(*args, **kwargs)\n\n    def tick_values(self, vmin, vmax):\n        vmin = self._colorbar.norm.vmin\n        vmax = self._colorbar.norm.vmax\n        ticks = super().tick_values(vmin, vmax)\n        rtol = (np.log10(vmax) - np.log10(vmin)) * 1e-10\n        ticks = ticks[(np.log10(ticks) >= np.log10(vmin) - rtol) &\n              (np.log10(ticks) <= np.log10(vmax) + rtol)]\n        return ticks\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` function and the\n    :meth:`~matplotlib.figure.Figure.colorbar` method, which are the\n    usual ways of creating a colorbar.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    Attributes\n    ----------\n    ax : Axes\n        The `Axes` instance in which the colorbar is drawn.\n\n    lines : list\n        A list of `LineCollection` if lines were drawn, otherwise\n        an empty list.\n\n    dividers : LineCollection\n        A LineCollection if *drawedges* is ``True``, otherwise ``None``.\n    '''\n    _slice_dict = {'neither': slice(0, None),\n                   'both': slice(1, -1),\n                   'min': slice(1, None),\n                   'max': slice(0, -1)}\n\n    n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n\n    def __init__(self, ax, cmap=None,\n                 norm=None,\n                 alpha=None,\n                 values=None,\n                 boundaries=None,\n                 orientation='vertical',\n                 ticklocation='auto',\n                 extend='neither',\n                 spacing='uniform',  # uniform or proportional\n                 ticks=None,\n                 format=None,\n                 drawedges=False,\n                 filled=True,\n                 extendfrac=None,\n                 extendrect=False,\n                 label='',\n                 ):\n        #: The axes that this colorbar lives in.\n        self.ax = ax\n        self._patch_ax()\n        if cmap is None:\n            cmap = cm.get_cmap()\n        if norm is None:\n            norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self.solids = None\n        self.lines = list()\n        self.outline = None\n        self.patch = None\n        self.dividers = None\n        self._manual_tick_data_values = None\n\n        if ticklocation == 'auto':\n            ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n        self.ticklocation = ticklocation\n\n        self.set_label(label)\n        if np.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatterSciNotation()\n            elif isinstance(self.norm, colors.SymLogNorm):\n                self.formatter = ticker.LogFormatterSciNotation(\n                                        linthresh=self.norm.linthresh)\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif isinstance(format, str):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def _extend_lower(self):\n        \"\"\"Returns whether the lower limit is open ended.\"\"\"\n        return self.extend in ('both', 'min')\n\n    def _extend_upper(self):\n        \"\"\"Returns whether the uper limit is open ended.\"\"\"\n        return self.extend in ('both', 'max')\n\n    def _patch_ax(self):\n        # bind some methods to the axes to warn users\n        # against using those methods.\n        self.ax.set_xticks = _set_ticks_on_axis_warn\n        self.ax.set_yticks = _set_ticks_on_axis_warn\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n\n        # sets self._boundaries and self._values in real data units.\n        # takes into account extend values:\n        self._process_values()\n        # sets self.vmin and vmax in data units, but just for\n        # the part of the colorbar that is not part of the extend\n        # patch:\n        self._find_range()\n        # returns the X and Y mesh, *but* this was/is in normalized\n        # units:\n        X, Y = self._mesh()\n        C = self._values[:, np.newaxis]\n        self.config_axis()\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n\n    def config_axis(self):\n        ax = self.ax\n        if (isinstance(self.norm, colors.LogNorm)\n                and self._use_auto_colorbar_locator()):\n            # *both* axes are made log so that determining the\n            # mid point is easier.\n            ax.set_xscale('log')\n            ax.set_yscale('log')\n\n        if self.orientation == 'vertical':\n            long_axis, short_axis = ax.yaxis, ax.xaxis\n        else:\n            long_axis, short_axis = ax.xaxis, ax.yaxis\n\n        long_axis.set_label_position(self.ticklocation)\n        long_axis.set_ticks_position(self.ticklocation)\n        short_axis.set_ticks([])\n        short_axis.set_ticks([], minor=True)\n        self._set_label()\n\n    def _get_ticker_locator_formatter(self):\n        \"\"\"\n        This code looks at the norm being used by the colorbar\n        and decides what locator and formatter to use.  If ``locator`` has\n        already been set by hand, it just returns\n        ``self.locator, self.formatter``.\n        \"\"\"\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv / 10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = _ColorbarLogLocator(self)\n                elif isinstance(self.norm, colors.SymLogNorm):\n                    # The subs setting here should be replaced\n                    # by logic in the locator.\n                    locator = ticker.SymmetricalLogLocator(\n                                      subs=np.arange(1, 10),\n                                      linthresh=self.norm.linthresh,\n                                      base=10)\n                else:\n                    if mpl.rcParams['_internal.classic_mode']:\n                        locator = ticker.MaxNLocator()\n                    else:\n                        locator = _ColorbarAutoLocator(self)\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        _log.debug('locator: %r', locator)\n        return locator, formatter\n\n    def _use_auto_colorbar_locator(self):\n        \"\"\"\n        Return if we should use an adjustable tick locator or a fixed\n        one.  (check is used twice so factored out here...)\n        \"\"\"\n        return (self.boundaries is None\n                and self.values is None\n                and ((type(self.norm) == colors.Normalize)\n                    or (type(self.norm) == colors.LogNorm)))\n\n    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        # get the locator and formatter.  Defaults to\n        # self.locator if not None..\n        locator, formatter = self._get_ticker_locator_formatter()\n\n        if self.orientation == 'vertical':\n            long_axis, short_axis = ax.yaxis, ax.xaxis\n        else:\n            long_axis, short_axis = ax.xaxis, ax.yaxis\n\n        if self._use_auto_colorbar_locator():\n            _log.debug('Using auto colorbar locator on colorbar')\n            _log.debug('locator: %r', locator)\n            long_axis.set_major_locator(locator)\n            long_axis.set_major_formatter(formatter)\n            if type(self.norm) == colors.LogNorm:\n                long_axis.set_minor_locator(_ColorbarLogLocator(self,\n                            base=10., subs='auto'))\n                long_axis.set_minor_formatter(\n                    ticker.LogFormatterSciNotation()\n                )\n        else:\n            _log.debug('Using fixed locator on colorbar')\n            ticks, ticklabels, offset_string = self._ticker(locator, formatter)\n            long_axis.set_ticks(ticks)\n            long_axis.set_ticklabels(ticklabels)\n            long_axis.get_major_formatter().set_offset_string(offset_string)\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        Set tick locations.\n\n        Parameters\n        ----------\n        ticks : {None, sequence, :class:`~matplotlib.ticker.Locator` instance}\n            If None, a default Locator will be used.\n\n        update_ticks : {True, False}, optional\n            If True, tick locations are updated immediately.  If False,\n            use :meth:`update_ticks` to manually update the ticks.\n\n        \"\"\"\n        if np.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks\n\n        if update_ticks:\n            self.update_ticks()\n        self.stale = True\n\n    def get_ticks(self, minor=False):\n        \"\"\"Return the x ticks as a list of locations\"\"\"\n        if self._manual_tick_data_values is None:\n            ax = self.ax\n            if self.orientation == 'vertical':\n                long_axis, short_axis = ax.yaxis, ax.xaxis\n            else:\n                long_axis, short_axis = ax.xaxis, ax.yaxis\n            return long_axis.get_majorticklocs()\n        else:\n            # We made the axes manually, the old way, and the ylim is 0-1,\n            # so the majorticklocs are in those units, not data units.\n            return self._manual_tick_data_values\n\n    def set_ticklabels(self, ticklabels, update_ticks=True):\n        \"\"\"\n        set tick labels. Tick labels are updated immediately unless\n        update_ticks is *False*. To manually update the ticks, call\n        *update_ticks* method explicitly.\n        \"\"\"\n        if isinstance(self.locator, ticker.FixedLocator):\n            self.formatter = ticker.FixedFormatter(ticklabels)\n            if update_ticks:\n                self.update_ticks()\n        else:\n            cbook._warn_external(\"set_ticks() must have been called.\")\n        self.stale = True\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = mpatches.Polygon(\n            xy, edgecolor=mpl.rcParams['axes.edgecolor'],\n            facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'],\n            closed=True,\n            zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                                      facecolor=c,\n                                      linewidth=0.01,\n                                      zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n        self.stale = True\n\n    def set_label(self, label, **kw):\n        '''\n        Label the long axis of the colorbar\n        '''\n        self._label = '%s' % (label, )\n        self._labelkw = kw\n        self._set_label()\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N - 2, N - 1, 2 * N - 1, 2 * N - 2, N + 1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [list(zip(X[i], Y[i])) for i in range(1, N - 1)]\n        else:\n            return [list(zip(Y[i], X[i])) for i in range(1, N - 1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        _log.debug('Setting pcolormesh')\n        col = self.ax.pcolormesh(*args, **kw)\n        # self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            linewidths = (0.5 * mpl.rcParams['axes.linewidth'],)\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=linewidths)\n            self.ax.add_collection(self.dividers)\n        elif len(self._y) >= self.n_rasterize:\n            self.solids.set_rasterized(True)\n\n    def add_lines(self, levels, colors, linewidths, erase=True):\n        '''\n        Draw lines on the colorbar.\n\n        *colors* and *linewidths* must be scalars or\n        sequences the same length as *levels*.\n\n        Set *erase* to False to add lines without first\n        removing any previously added lines.\n        '''\n        y = self._locate(levels)\n        rtol = (self._y[-1] - self._y[0]) * 1e-10\n        igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n        y = y[igood]\n        if np.iterable(colors):\n            colors = np.asarray(colors)[igood]\n        if np.iterable(linewidths):\n            linewidths = np.asarray(linewidths)[igood]\n        X, Y = np.meshgrid([self._y[0], self._y[-1]], y)\n        if self.orientation == 'vertical':\n            xy = np.stack([X, Y], axis=-1)\n        else:\n            xy = np.stack([Y, X], axis=-1)\n        col = collections.LineCollection(xy, linewidths=linewidths)\n\n        if erase and self.lines:\n            for lc in self.lines:\n                lc.remove()\n            self.lines = []\n        self.lines.append(col)\n        col.set_color(colors)\n        self.ax.add_collection(col)\n        self.stale = True\n\n    def _ticker(self, locator, formatter):\n        '''\n        Return the sequence of ticks (colorbar data locations),\n        ticklabels (strings), and the corresponding offset string.\n        '''\n        if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis(minpos=intv[0])\n        formatter.create_dummy_axis(minpos=intv[0])\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n\n        b = np.array(locator())\n        if isinstance(locator, ticker.LogLocator):\n            eps = 1e-10\n            b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]\n        else:\n            eps = (intv[1] - intv[0]) * 1e-10\n            b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]\n        self._manual_tick_data_values = b\n        ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5 * (self._boundaries[:-1]\n                                      + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] - self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N + 1) * self.cmap.N - 0.5\n            v = np.zeros(len(b) - 1, dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0] - 1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros(len(b) - 1)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5 * (bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin,\n                self.norm.vmax,\n                expander=0.1)\n\n            b = self.norm.inverse(self._uniform_y(self.cmap.N + 1))\n\n            if isinstance(self.norm, (colors.PowerNorm, colors.LogNorm)):\n                # If using a lognorm or powernorm, ensure extensions don't\n                # go negative\n                if self._extend_lower():\n                    b[0] = 0.9 * b[0]\n                if self._extend_upper():\n                    b[-1] = 1.1 * b[-1]\n            else:\n                if self._extend_lower():\n                    b[0] = b[0] - 1\n                if self._extend_upper():\n                    b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n        '''\n        Get the lengths of colorbar extensions.\n\n        A helper method for _uniform_y and _proportional_y.\n        '''\n        # Set the default value.\n        extendlength = np.array([default, default])\n        if isinstance(frac, str):\n            if frac.lower() == 'auto':\n                # Use the provided values when 'auto' is required.\n                extendlength[:] = [automin, automax]\n            else:\n                # Any other string is invalid.\n                raise ValueError('invalid value for extendfrac')\n        elif frac is not None:\n            try:\n                # Try to set min and max extension fractions directly.\n                extendlength[:] = frac\n                # If frac is a sequence containing None then NaN may\n                # be encountered. This is an error.\n                if np.isnan(extendlength).any():\n                    raise ValueError()\n            except (TypeError, ValueError):\n                # Raise an error on encountering an invalid value for frac.\n                raise ValueError('invalid value for extendfrac')\n        return extendlength\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n            y = np.ma.filled(y, np.nan)\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        elif self.extend == 'both':\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        if self.extend in ('both', 'min', 'max'):\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = np.ma.filled(norm(yi), np.nan)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        # if boundaries and values are None, then we can go ahead and\n        # scale this up for Auto tick location.  Otherwise we\n        # want to keep normalized between 0 and 1 and use manual tick\n        # locations.\n\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        if self._use_auto_colorbar_locator():\n            y = self.norm.inverse(y)\n            x = self.norm.inverse(x)\n        self._y = y\n        X, Y = np.meshgrid(x, y)\n        if self._use_auto_colorbar_locator():\n            xmid = self.norm.inverse(0.5)\n        else:\n            xmid = 0.5\n        if self._extend_lower() and not self.extendrect:\n            X[0, :] = xmid\n        if self._extend_upper() and not self.extendrect:\n            X[-1, :] = xmid\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n\n        # The rest is linear interpolation with extrapolation at ends.\n        ii = np.searchsorted(b, xn)\n        i0 = ii - 1\n        itop = (ii == len(b))\n        ibot = (ii == 0)\n        i0[itop] -= 1\n        ii[itop] -= 1\n        i0[ibot] += 1\n        ii[ibot] += 1\n\n        db = np.take(b, ii) - np.take(b, i0)\n        y = self._y\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn - np.take(b, i0)) * dy / db\n        return z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\n    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure\n        \"\"\"\n\n        fig = self.ax.figure\n        fig.delaxes(self.ax)\n\n\nclass Colorbar(ColorbarBase):\n    \"\"\"\n    This class connects a :class:`ColorbarBase` to a\n    :class:`~matplotlib.cm.ScalarMappable` such as a\n    :class:`~matplotlib.image.AxesImage` generated via\n    :meth:`~matplotlib.axes.Axes.imshow`.\n\n    It is not intended to be instantiated directly; instead,\n    use :meth:`~matplotlib.figure.Figure.colorbar` or\n    :func:`~matplotlib.pyplot.colorbar` to make your colorbar.\n\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # Ensure the given mappable's norm has appropriate vmin and vmax set\n        # even if mappable.draw has not yet been called.\n        if mappable.get_array() is not None:\n            mappable.autoscale_None()\n\n        self.mappable = mappable\n        kw['cmap'] = cmap = mappable.cmap\n        kw['norm'] = mappable.norm\n\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['alpha'] = mappable.get_alpha()\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            if getattr(cmap, 'colorbar_extend', False) is not False:\n                kw.setdefault('extend', cmap.colorbar_extend)\n\n            if isinstance(mappable, martist.Artist):\n                kw['alpha'] = mappable.get_alpha()\n\n            ColorbarBase.__init__(self, ax, **kw)\n\n    def on_mappable_changed(self, mappable):\n        \"\"\"\n        Updates this colorbar to match the mappable's properties.\n\n        Typically this is automatically registered as an event handler\n        by :func:`colorbar_factory` and should not be called manually.\n\n        \"\"\"\n        self.set_cmap(mappable.get_cmap())\n        self.set_clim(mappable.get_clim())\n        self.update_normal(mappable)\n\n    def add_lines(self, CS, erase=True):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n\n        Set *erase* to False if these lines should be added to\n        any pre-existing lines.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths,\n                               erase=erase)\n\n    def update_normal(self, mappable):\n        '''\n        update solid, lines, etc. Unlike update_bruteforce, it does\n        not clear the axes.  This is meant to be called when the image\n        or contour plot to which this colorbar belongs is changed.\n        '''\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True\n\n    def update_bruteforce(self, mappable):\n        '''\n        Destroy and rebuild the colorbar.  This is\n        intended to become obsolete, and will probably be\n        deprecated and then removed.  It is not called when\n        the pyplot.colorbar function or the Figure.colorbar\n        method are used to create the colorbar.\n\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        # clearing the axes will delete outline, patch, solids, and lines:\n        self.outline = None\n        self.patch = None\n        self.solids = None\n        self.lines = list()\n        self.dividers = None\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        self.norm = mappable.norm\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\n    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure.  If the colorbar was created with\n        ``use_gridspec=True`` then restore the gridspec to its previous value.\n        \"\"\"\n\n        ColorbarBase.remove(self)\n        self.mappable.callbacksSM.disconnect(self.mappable.colorbar_cid)\n        self.mappable.colorbar = None\n        self.mappable.colorbar_cid = None\n\n        try:\n            ax = self.mappable.axes\n        except AttributeError:\n            return\n\n        try:\n            gs = ax.get_subplotspec().get_gridspec()\n            subplotspec = gs.get_topmost_subplotspec()\n        except AttributeError:\n            # use_gridspec was False\n            pos = ax.get_position(original=True)\n            ax._set_position(pos)\n        else:\n            # use_gridspec was True\n            ax.set_subplotspec(subplotspec)\n\n    def minorticks_on(self):\n        \"\"\"\n        Turns on the minor ticks on the colorbar without extruding\n        into the \"extend regions\".\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        if long_axis.get_scale() == 'log':\n            cbook._warn_external('minorticks_on() has no effect on a '\n                                 'logarithmic colorbar axis')\n        else:\n            long_axis.set_minor_locator(_ColorbarAutoMinorLocator(self))\n\n    def minorticks_off(self):\n        \"\"\"\n        Turns off the minor ticks on the colorbar.\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        if long_axis.get_scale() == 'log':\n            cbook._warn_external('minorticks_off() has no effect on a '\n                                 'logarithmic colorbar axis')\n        else:\n            long_axis.set_minor_locator(ticker.NullLocator())\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes(parents, location=None, orientation=None, fraction=0.15,\n              shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition parent axes, and return a child\n    axes suitable for a colorbar.\n\n    Keyword arguments may include the following (with defaults):\n\n        location : [None|'left'|'right'|'top'|'bottom']\n            The position, relative to **parents**, where the colorbar axes\n            should be created. If None, the value will either come from the\n            given ``orientation``, else it will default to 'right'.\n\n        orientation :  [None|'vertical'|'horizontal']\n            The orientation of the colorbar. Typically, this keyword shouldn't\n            be used, as it can be derived from the ``location`` keyword.\n\n    %s\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    locations = [\"left\", \"right\", \"top\", \"bottom\"]\n    if orientation is not None and location is not None:\n        raise TypeError('position and orientation are mutually exclusive. '\n                        'Consider setting the position to any of {}'\n                        .format(', '.join(locations)))\n\n    # provide a default location\n    if location is None and orientation is None:\n        location = 'right'\n\n    # allow the user to not specify the location by specifying the\n    # orientation instead\n    if location is None:\n        location = 'right' if orientation == 'vertical' else 'bottom'\n\n    if location not in locations:\n        raise ValueError('Invalid colorbar location. Must be one '\n                         'of %s' % ', '.join(locations))\n\n    default_location_settings = {'left':   {'anchor': (1.0, 0.5),\n                                            'panchor': (0.0, 0.5),\n                                            'pad': 0.10,\n                                            'orientation': 'vertical'},\n                                 'right':  {'anchor': (0.0, 0.5),\n                                            'panchor': (1.0, 0.5),\n                                            'pad': 0.05,\n                                            'orientation': 'vertical'},\n                                 'top':    {'anchor': (0.5, 0.0),\n                                            'panchor': (0.5, 1.0),\n                                            'pad': 0.05,\n                                            'orientation': 'horizontal'},\n                                 'bottom': {'anchor': (0.5, 1.0),\n                                            'panchor': (0.5, 0.0),\n                                            'pad': 0.15,  # backwards compat\n                                            'orientation': 'horizontal'},\n                                 }\n\n    loc_settings = default_location_settings[location]\n\n    # put appropriate values into the kw dict for passing back to\n    # the Colorbar class\n    kw['orientation'] = loc_settings['orientation']\n    kw['ticklocation'] = location\n\n    anchor = kw.pop('anchor', loc_settings['anchor'])\n    parent_anchor = kw.pop('panchor', loc_settings['panchor'])\n\n    parents_iterable = np.iterable(parents)\n    # turn parents into a list if it is not already. We do this w/ np\n    # because `plt.subplots` can return an ndarray and is natural to\n    # pass to `colorbar`.\n    parents = np.atleast_1d(parents).ravel()\n\n    # check if using constrained_layout:\n    try:\n        gs = parents[0].get_subplotspec().get_gridspec()\n        using_constrained_layout = (gs._layoutbox is not None)\n    except AttributeError:\n        using_constrained_layout = False\n\n    # defaults are not appropriate for constrained_layout:\n    pad0 = loc_settings['pad']\n    if using_constrained_layout:\n        pad0 = 0.02\n    pad = kw.pop('pad', pad0)\n\n    fig = parents[0].get_figure()\n    if not all(fig is ax.get_figure() for ax in parents):\n        raise ValueError('Unable to create a colorbar axes as not all '\n                         'parents share the same figure.')\n\n    # take a bounding box around all of the given axes\n    parents_bbox = mtransforms.Bbox.union(\n        [ax.get_position(original=True).frozen() for ax in parents])\n\n    pb = parents_bbox\n    if location in ('left', 'right'):\n        if location == 'left':\n            pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n    else:\n        if location == 'bottom':\n            pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n\n        # define the aspect ratio in terms of y's per x rather than x's per y\n        aspect = 1.0 / aspect\n\n    # define a transform which takes us from old axes coordinates to\n    # new axes coordinates\n    shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n\n    # transform each of the axes in parents using the new transform\n    for ax in parents:\n        new_posn = shrinking_trans.transform(ax.get_position(original=True))\n        new_posn = mtransforms.Bbox(new_posn)\n        ax._set_position(new_posn)\n        if parent_anchor is not False:\n            ax.set_anchor(parent_anchor)\n\n    cax = fig.add_axes(pbcb)\n\n    # OK, now make a layoutbox for the cb axis.  Later, we will use this\n    # to make the colorbar fit nicely.\n    if not using_constrained_layout:\n        # no layout boxes:\n        lb = None\n        lbpos = None\n        # and we need to set the aspect ratio by hand...\n        cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    else:\n        if not parents_iterable:\n            # this is a single axis...\n            ax = parents[0]\n            lb, lbpos = constrained_layout.layoutcolorbarsingle(\n                    ax, cax, shrink, aspect, location, pad=pad)\n        else:  # there is more than one parent, so lets use gridspec\n            # the colorbar will be a sibling of this gridspec, so the\n            # parent is the same parent as the gridspec.  Either the figure,\n            # or a subplotspec.\n\n            lb, lbpos = constrained_layout.layoutcolorbargridspec(\n                    parents, cax, shrink, aspect, location, pad)\n\n    cax._layoutbox = lb\n    cax._poslayoutbox = lbpos\n\n    return cax, kw\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child axes\n    suitable for a colorbar. This function is similar to\n    make_axes. Prmary differences are\n\n     * *make_axes_gridspec* only handles the *orientation* keyword\n       and cannot handle the \"location\" keyword.\n\n     * *make_axes_gridspec* should only be used with a subplot parent.\n\n     * *make_axes* creates an instance of Axes. *make_axes_gridspec*\n        creates an instance of Subplot.\n\n     * *make_axes* updates the position of the\n        parent. *make_axes_gridspec* replaces the grid_spec attribute\n        of the parent with a new one.\n\n    While this function is meant to be compatible with *make_axes*,\n    there could be some minor differences.\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical' or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    kw['ticklocation'] = 'auto'\n\n    x1 = 1 - fraction\n\n    # for shrinking\n    pad_s = (1 - shrink) * 0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    # we need to none the tree of layoutboxes because\n    # constrained_layout can't remove and replace the tree\n    # hierarchy w/o a seg fault.\n    gs = parent.get_subplotspec().get_gridspec()\n    layoutbox.nonetree(gs._layoutbox)\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios)\n        aspect = 1 / aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent._set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1])\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\nclass ColorbarPatch(Colorbar):\n    \"\"\"\n    A Colorbar which is created using :class:`~matplotlib.patches.Patch`\n    rather than the default :func:`~matplotlib.axes.pcolor`.\n\n    It uses a list of Patch instances instead of a\n    :class:`~matplotlib.collections.PatchCollection` because the\n    latter does not allow the hatch pattern to vary among the\n    members of the collection.\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # we do not want to override the behaviour of solids\n        # so add a new attribute which will be a list of the\n        # colored patches in the colorbar\n        self.solids_patches = []\n        Colorbar.__init__(self, ax, mappable, **kw)\n\n    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using :class:`~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        n_segments = len(C)\n\n        # ensure there are sufficient hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in range(len(X) - 1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]],\n                           [X[i][1], Y[i][0]],\n                           [X[i + 1][1], Y[i + 1][0]],\n                           [X[i + 1][0], Y[i + 1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch, linewidth=0,\n                                       antialiased=False, alpha=self.alpha)\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=(0.5 * mpl.rcParams['axes.linewidth'],))\n            self.ax.add_collection(self.dividers)\n\n\ndef colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Creates a colorbar on the given axes for the given mappable.\n\n    Typically, for automatic colorbar placement given only a mappable use\n    :meth:`~matplotlib.figure.Figure.colorbar`.\n\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet)\n            and any(hatch is not None for hatch in mappable.hatches)):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    cid = mappable.callbacksSM.connect('changed', cb.on_mappable_changed)\n    mappable.colorbar = cb\n    mappable.colorbar_cid = cid\n\n    return cb\n",
      "file_after": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n\n'''\n\nimport logging\n\nimport numpy as np\n\nimport matplotlib as mpl\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.collections as collections\nimport matplotlib.colors as colors\nimport matplotlib.contour as contour\nimport matplotlib.cm as cm\nimport matplotlib.gridspec as gridspec\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\nimport matplotlib.ticker as ticker\nimport matplotlib.transforms as mtransforms\nimport matplotlib._layoutbox as layoutbox\nimport matplotlib._constrained_layout as constrained_layout\nfrom matplotlib import docstring\n\n_log = logging.getLogger(__name__)\n\nmake_axes_kw_doc = '''\n\n    ============= ====================================================\n    Property      Description\n    ============= ====================================================\n    *orientation* vertical or horizontal\n    *fraction*    0.15; fraction of original axes to use for colorbar\n    *pad*         0.05 if vertical, 0.15 if horizontal; fraction\n                  of original axes between colorbar and new image axes\n    *shrink*      1.0; fraction by which to multiply the size of the colorbar\n    *aspect*      20; ratio of long to short dimensions\n    *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;\n                  the anchor point of the colorbar axes\n    *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;\n                  the anchor point of the colorbar parent axes. If\n                  False, the parent axes' anchor will be unchanged\n    ============= ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ============  ====================================================\n    Property      Description\n    ============  ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *extendfrac*  [ *None* | 'auto' | length | lengths ]\n                  If set to *None*, both the minimum and maximum\n                  triangular colorbar extensions with have a length of\n                  5% of the interior colorbar length (this is the\n                  default setting). If set to 'auto', makes the\n                  triangular colorbar extensions the same lengths as\n                  the interior boxes (when *spacing* is set to\n                  'uniform') or the same lengths as the respective\n                  adjacent interior boxes (when *spacing* is set to\n                  'proportional'). If a scalar, indicates the length\n                  of both the minimum and maximum triangular colorbar\n                  extensions as a fraction of the interior colorbar\n                  length. A two-element sequence of fractions may also\n                  be given, indicating the lengths of the minimum and\n                  maximum colorbar extensions respectively as a\n                  fraction of the interior colorbar length.\n    *extendrect*  bool\n                  If *False* the minimum and maximum colorbar extensions\n                  will be triangular (the default). If *True* the\n                  extensions will be rectangular.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g., '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   bool\n                  Whether to draw lines at color boundaries.\n    ============  ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`~matplotlib.figure.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\nParameters\n----------\nmappable\n    The `~matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.Image`,\n    `~matplotlib.contour.ContourSet`, etc.) to which the colorbar applies.\n    This argument is mandatory for the `.Figure.colorbar` method but optional\n    for the `.pyplot.colorbar` function, which sets the default to the current\n    image.\n\ncax : :class:`~matplotlib.axes.Axes` object, optional\n    Axes into which the colorbar will be drawn.\n\nax : :class:`~matplotlib.axes.Axes`, list of Axes, optional\n    Parent axes from which space for a new colorbar axes will be stolen.\n    If a list of axes is given they will all be resized to make room for the\n    colorbar axes.\n\nuse_gridspec : bool, optional\n    If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If\n    *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is\n    created as an instance of Subplot using the :mod:`~.gridspec` module.\n\nReturns\n-------\ncolorbar : `~matplotlib.colorbar.Colorbar`\n    See also its base class, `~matplotlib.colorbar.ColorbarBase`.  Use\n    `~.ColorbarBase.set_label` to label the colorbar.\n\nNotes\n-----\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nThe *shrink* kwarg provides a simple way to scale the colorbar with respect\nto the axes. Note that if *cax* is specified, it determines the size of the\ncolorbar and *shrink* and *aspect* kwargs are ignored.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n\nIt is known that some vector graphics viewers (svg and pdf) renders white gaps\nbetween segments of the colorbar.  This is due to bugs in the viewers, not\nMatplotlib.  As a workaround, the colorbar can be rendered with overlapping\nsegments::\n\n    cbar = colorbar()\n    cbar.solids.set_edgecolor(\"face\")\n    draw()\n\nHowever this has negative consequences in other circumstances, e.g. with\nsemi-transparent images (alpha < 1) and colorbar extensions; therefore, this\nworkaround is not used by default (see issue #1188).\n\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\ndocstring.interpd.update(colorbar_doc=colorbar_doc)\n\n\ndef _set_ticks_on_axis_warn(*args, **kw):\n    # a top level function which gets put in at the axes'\n    # set_xticks set_yticks by _patch_ax\n    cbook._warn_external(\"Use the colorbar set_ticks() method instead.\")\n\n\nclass _ColorbarAutoLocator(ticker.MaxNLocator):\n    \"\"\"\n    AutoLocator for Colorbar\n\n    This locator is just a `.MaxNLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so ticks don't\n    extrude into the \"extend regions\".\n    \"\"\"\n\n    def __init__(self, colorbar):\n        \"\"\"\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.  Otherwise it is the same as\n        `~.ticker.AutoLocator`.\n        \"\"\"\n\n        self._colorbar = colorbar\n        nbins = 'auto'\n        steps = [1, 2, 2.5, 5, 10]\n        super().__init__(nbins=nbins, steps=steps)\n\n    def tick_values(self, vmin, vmax):\n        vmin = max(vmin, self._colorbar.norm.vmin)\n        vmax = min(vmax, self._colorbar.norm.vmax)\n        ticks = super().tick_values(vmin, vmax)\n        rtol = (vmax - vmin) * 1e-10\n        return ticks[(ticks >= vmin - rtol) & (ticks <= vmax + rtol)]\n\n\nclass _ColorbarAutoMinorLocator(ticker.AutoMinorLocator):\n    \"\"\"\n    AutoMinorLocator for Colorbar\n\n    This locator is just a `.AutoMinorLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so that the minorticks\n    don't extrude into the \"extend regions\".\n    \"\"\"\n\n    def __init__(self, colorbar, n=None):\n        \"\"\"\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.\n        \"\"\"\n        self._colorbar = colorbar\n        self.ndivs = n\n        super().__init__(n=None)\n\n    def __call__(self):\n        vmin = self._colorbar.norm.vmin\n        vmax = self._colorbar.norm.vmax\n        ticks = super().__call__()\n        rtol = (vmax - vmin) * 1e-10\n        return ticks[(ticks >= vmin - rtol) & (ticks <= vmax + rtol)]\n\n\nclass _ColorbarLogLocator(ticker.LogLocator):\n    \"\"\"\n    LogLocator for Colorbarbar\n\n    This locator is just a `.LogLocator` except the min and max are\n    clipped by the norm's min and max (i.e. vmin/vmax from the\n    image/pcolor/contour object).  This is necessary so ticks don't\n    extrude into the \"extend regions\".\n\n    \"\"\"\n    def __init__(self, colorbar, *args, **kwargs):\n        \"\"\"\n        _ColorbarLogLocator(colorbar, *args, **kwargs)\n\n        This ticker needs to know the *colorbar* so that it can access\n        its *vmin* and *vmax*.  Otherwise it is the same as\n        `~.ticker.LogLocator`.  The ``*args`` and ``**kwargs`` are the\n        same as `~.ticker.LogLocator`.\n        \"\"\"\n        self._colorbar = colorbar\n        super().__init__(*args, **kwargs)\n\n    def tick_values(self, vmin, vmax):\n        vmin = self._colorbar.norm.vmin\n        vmax = self._colorbar.norm.vmax\n        ticks = super().tick_values(vmin, vmax)\n        rtol = (np.log10(vmax) - np.log10(vmin)) * 1e-10\n        ticks = ticks[(np.log10(ticks) >= np.log10(vmin) - rtol) &\n              (np.log10(ticks) <= np.log10(vmax) + rtol)]\n        return ticks\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` function and the\n    :meth:`~matplotlib.figure.Figure.colorbar` method, which are the\n    usual ways of creating a colorbar.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    Attributes\n    ----------\n    ax : Axes\n        The `Axes` instance in which the colorbar is drawn.\n\n    lines : list\n        A list of `LineCollection` if lines were drawn, otherwise\n        an empty list.\n\n    dividers : LineCollection\n        A LineCollection if *drawedges* is ``True``, otherwise ``None``.\n    '''\n    _slice_dict = {'neither': slice(0, None),\n                   'both': slice(1, -1),\n                   'min': slice(1, None),\n                   'max': slice(0, -1)}\n\n    n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n\n    def __init__(self, ax, cmap=None,\n                 norm=None,\n                 alpha=None,\n                 values=None,\n                 boundaries=None,\n                 orientation='vertical',\n                 ticklocation='auto',\n                 extend='neither',\n                 spacing='uniform',  # uniform or proportional\n                 ticks=None,\n                 format=None,\n                 drawedges=False,\n                 filled=True,\n                 extendfrac=None,\n                 extendrect=False,\n                 label='',\n                 ):\n        #: The axes that this colorbar lives in.\n        self.ax = ax\n        self._patch_ax()\n        if cmap is None:\n            cmap = cm.get_cmap()\n        if norm is None:\n            norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self.solids = None\n        self.lines = list()\n        self.outline = None\n        self.patch = None\n        self.dividers = None\n        self._manual_tick_data_values = None\n\n        if ticklocation == 'auto':\n            ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n        self.ticklocation = ticklocation\n\n        self.set_label(label)\n        if np.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatterSciNotation()\n            elif isinstance(self.norm, colors.SymLogNorm):\n                self.formatter = ticker.LogFormatterSciNotation(\n                                        linthresh=self.norm.linthresh)\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif isinstance(format, str):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def _extend_lower(self):\n        \"\"\"Returns whether the lower limit is open ended.\"\"\"\n        return self.extend in ('both', 'min')\n\n    def _extend_upper(self):\n        \"\"\"Returns whether the uper limit is open ended.\"\"\"\n        return self.extend in ('both', 'max')\n\n    def _patch_ax(self):\n        # bind some methods to the axes to warn users\n        # against using those methods.\n        self.ax.set_xticks = _set_ticks_on_axis_warn\n        self.ax.set_yticks = _set_ticks_on_axis_warn\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n\n        # sets self._boundaries and self._values in real data units.\n        # takes into account extend values:\n        self._process_values()\n        # sets self.vmin and vmax in data units, but just for\n        # the part of the colorbar that is not part of the extend\n        # patch:\n        self._find_range()\n        # returns the X and Y mesh, *but* this was/is in normalized\n        # units:\n        X, Y = self._mesh()\n        C = self._values[:, np.newaxis]\n        self.config_axis()\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n\n    def config_axis(self):\n        ax = self.ax\n        if (isinstance(self.norm, colors.LogNorm)\n                and self._use_auto_colorbar_locator()):\n            # *both* axes are made log so that determining the\n            # mid point is easier.\n            ax.set_xscale('log')\n            ax.set_yscale('log')\n\n        if self.orientation == 'vertical':\n            long_axis, short_axis = ax.yaxis, ax.xaxis\n        else:\n            long_axis, short_axis = ax.xaxis, ax.yaxis\n\n        long_axis.set_label_position(self.ticklocation)\n        long_axis.set_ticks_position(self.ticklocation)\n        short_axis.set_ticks([])\n        short_axis.set_ticks([], minor=True)\n        self._set_label()\n\n    def _get_ticker_locator_formatter(self):\n        \"\"\"\n        This code looks at the norm being used by the colorbar\n        and decides what locator and formatter to use.  If ``locator`` has\n        already been set by hand, it just returns\n        ``self.locator, self.formatter``.\n        \"\"\"\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv / 10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = _ColorbarLogLocator(self)\n                elif isinstance(self.norm, colors.SymLogNorm):\n                    # The subs setting here should be replaced\n                    # by logic in the locator.\n                    locator = ticker.SymmetricalLogLocator(\n                                      subs=np.arange(1, 10),\n                                      linthresh=self.norm.linthresh,\n                                      base=10)\n                else:\n                    if mpl.rcParams['_internal.classic_mode']:\n                        locator = ticker.MaxNLocator()\n                    else:\n                        locator = _ColorbarAutoLocator(self)\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        _log.debug('locator: %r', locator)\n        return locator, formatter\n\n    def _use_auto_colorbar_locator(self):\n        \"\"\"\n        Return if we should use an adjustable tick locator or a fixed\n        one.  (check is used twice so factored out here...)\n        \"\"\"\n        return (self.boundaries is None\n                and self.values is None\n                and ((type(self.norm) == colors.Normalize)\n                    or (type(self.norm) == colors.LogNorm)))\n\n    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        # get the locator and formatter.  Defaults to\n        # self.locator if not None..\n        locator, formatter = self._get_ticker_locator_formatter()\n\n        if self.orientation == 'vertical':\n            long_axis, short_axis = ax.yaxis, ax.xaxis\n        else:\n            long_axis, short_axis = ax.xaxis, ax.yaxis\n\n        if self._use_auto_colorbar_locator():\n            _log.debug('Using auto colorbar locator on colorbar')\n            _log.debug('locator: %r', locator)\n            long_axis.set_major_locator(locator)\n            long_axis.set_major_formatter(formatter)\n            if type(self.norm) == colors.LogNorm:\n                long_axis.set_minor_locator(_ColorbarLogLocator(self,\n                            base=10., subs='auto'))\n                long_axis.set_minor_formatter(\n                    ticker.LogFormatterSciNotation()\n                )\n        else:\n            _log.debug('Using fixed locator on colorbar')\n            ticks, ticklabels, offset_string = self._ticker(locator, formatter)\n            long_axis.set_ticks(ticks)\n            long_axis.set_ticklabels(ticklabels)\n            long_axis.get_major_formatter().set_offset_string(offset_string)\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        Set tick locations.\n\n        Parameters\n        ----------\n        ticks : {None, sequence, :class:`~matplotlib.ticker.Locator` instance}\n            If None, a default Locator will be used.\n\n        update_ticks : {True, False}, optional\n            If True, tick locations are updated immediately.  If False,\n            use :meth:`update_ticks` to manually update the ticks.\n\n        \"\"\"\n        if np.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks\n\n        if update_ticks:\n            self.update_ticks()\n        self.stale = True\n\n    def get_ticks(self, minor=False):\n        \"\"\"Return the x ticks as a list of locations\"\"\"\n        if self._manual_tick_data_values is None:\n            ax = self.ax\n            if self.orientation == 'vertical':\n                long_axis, short_axis = ax.yaxis, ax.xaxis\n            else:\n                long_axis, short_axis = ax.xaxis, ax.yaxis\n            return long_axis.get_majorticklocs()\n        else:\n            # We made the axes manually, the old way, and the ylim is 0-1,\n            # so the majorticklocs are in those units, not data units.\n            return self._manual_tick_data_values\n\n    def set_ticklabels(self, ticklabels, update_ticks=True):\n        \"\"\"\n        set tick labels. Tick labels are updated immediately unless\n        update_ticks is *False*. To manually update the ticks, call\n        *update_ticks* method explicitly.\n        \"\"\"\n        if isinstance(self.locator, ticker.FixedLocator):\n            self.formatter = ticker.FixedFormatter(ticklabels)\n            if update_ticks:\n                self.update_ticks()\n        else:\n            cbook._warn_external(\"set_ticks() must have been called.\")\n        self.stale = True\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = mpatches.Polygon(\n            xy, edgecolor=mpl.rcParams['axes.edgecolor'],\n            facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'],\n            closed=True,\n            zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                                      facecolor=c,\n                                      linewidth=0.01,\n                                      zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n        self.stale = True\n\n    def set_label(self, label, **kw):\n        \"\"\"Label the long axis of the colorbar.\"\"\"\n        self._label = str(label)\n        self._labelkw = kw\n        self._set_label()\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N - 2, N - 1, 2 * N - 1, 2 * N - 2, N + 1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [list(zip(X[i], Y[i])) for i in range(1, N - 1)]\n        else:\n            return [list(zip(Y[i], X[i])) for i in range(1, N - 1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        _log.debug('Setting pcolormesh')\n        col = self.ax.pcolormesh(*args, **kw)\n        # self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            linewidths = (0.5 * mpl.rcParams['axes.linewidth'],)\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=linewidths)\n            self.ax.add_collection(self.dividers)\n        elif len(self._y) >= self.n_rasterize:\n            self.solids.set_rasterized(True)\n\n    def add_lines(self, levels, colors, linewidths, erase=True):\n        '''\n        Draw lines on the colorbar.\n\n        *colors* and *linewidths* must be scalars or\n        sequences the same length as *levels*.\n\n        Set *erase* to False to add lines without first\n        removing any previously added lines.\n        '''\n        y = self._locate(levels)\n        rtol = (self._y[-1] - self._y[0]) * 1e-10\n        igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n        y = y[igood]\n        if np.iterable(colors):\n            colors = np.asarray(colors)[igood]\n        if np.iterable(linewidths):\n            linewidths = np.asarray(linewidths)[igood]\n        X, Y = np.meshgrid([self._y[0], self._y[-1]], y)\n        if self.orientation == 'vertical':\n            xy = np.stack([X, Y], axis=-1)\n        else:\n            xy = np.stack([Y, X], axis=-1)\n        col = collections.LineCollection(xy, linewidths=linewidths)\n\n        if erase and self.lines:\n            for lc in self.lines:\n                lc.remove()\n            self.lines = []\n        self.lines.append(col)\n        col.set_color(colors)\n        self.ax.add_collection(col)\n        self.stale = True\n\n    def _ticker(self, locator, formatter):\n        '''\n        Return the sequence of ticks (colorbar data locations),\n        ticklabels (strings), and the corresponding offset string.\n        '''\n        if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis(minpos=intv[0])\n        formatter.create_dummy_axis(minpos=intv[0])\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n\n        b = np.array(locator())\n        if isinstance(locator, ticker.LogLocator):\n            eps = 1e-10\n            b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]\n        else:\n            eps = (intv[1] - intv[0]) * 1e-10\n            b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]\n        self._manual_tick_data_values = b\n        ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5 * (self._boundaries[:-1]\n                                      + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] - self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N + 1) * self.cmap.N - 0.5\n            v = np.zeros(len(b) - 1, dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0] - 1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros(len(b) - 1)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5 * (bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin,\n                self.norm.vmax,\n                expander=0.1)\n\n            b = self.norm.inverse(self._uniform_y(self.cmap.N + 1))\n\n            if isinstance(self.norm, (colors.PowerNorm, colors.LogNorm)):\n                # If using a lognorm or powernorm, ensure extensions don't\n                # go negative\n                if self._extend_lower():\n                    b[0] = 0.9 * b[0]\n                if self._extend_upper():\n                    b[-1] = 1.1 * b[-1]\n            else:\n                if self._extend_lower():\n                    b[0] = b[0] - 1\n                if self._extend_upper():\n                    b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n        '''\n        Get the lengths of colorbar extensions.\n\n        A helper method for _uniform_y and _proportional_y.\n        '''\n        # Set the default value.\n        extendlength = np.array([default, default])\n        if isinstance(frac, str):\n            if frac.lower() == 'auto':\n                # Use the provided values when 'auto' is required.\n                extendlength[:] = [automin, automax]\n            else:\n                # Any other string is invalid.\n                raise ValueError('invalid value for extendfrac')\n        elif frac is not None:\n            try:\n                # Try to set min and max extension fractions directly.\n                extendlength[:] = frac\n                # If frac is a sequence containing None then NaN may\n                # be encountered. This is an error.\n                if np.isnan(extendlength).any():\n                    raise ValueError()\n            except (TypeError, ValueError):\n                # Raise an error on encountering an invalid value for frac.\n                raise ValueError('invalid value for extendfrac')\n        return extendlength\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n            y = np.ma.filled(y, np.nan)\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        elif self.extend == 'both':\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        if self.extend in ('both', 'min', 'max'):\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = np.ma.filled(norm(yi), np.nan)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        # if boundaries and values are None, then we can go ahead and\n        # scale this up for Auto tick location.  Otherwise we\n        # want to keep normalized between 0 and 1 and use manual tick\n        # locations.\n\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        if self._use_auto_colorbar_locator():\n            y = self.norm.inverse(y)\n            x = self.norm.inverse(x)\n        self._y = y\n        X, Y = np.meshgrid(x, y)\n        if self._use_auto_colorbar_locator():\n            xmid = self.norm.inverse(0.5)\n        else:\n            xmid = 0.5\n        if self._extend_lower() and not self.extendrect:\n            X[0, :] = xmid\n        if self._extend_upper() and not self.extendrect:\n            X[-1, :] = xmid\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n\n        # The rest is linear interpolation with extrapolation at ends.\n        ii = np.searchsorted(b, xn)\n        i0 = ii - 1\n        itop = (ii == len(b))\n        ibot = (ii == 0)\n        i0[itop] -= 1\n        ii[itop] -= 1\n        i0[ibot] += 1\n        ii[ibot] += 1\n\n        db = np.take(b, ii) - np.take(b, i0)\n        y = self._y\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn - np.take(b, i0)) * dy / db\n        return z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\n    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure\n        \"\"\"\n\n        fig = self.ax.figure\n        fig.delaxes(self.ax)\n\n\nclass Colorbar(ColorbarBase):\n    \"\"\"\n    This class connects a :class:`ColorbarBase` to a\n    :class:`~matplotlib.cm.ScalarMappable` such as a\n    :class:`~matplotlib.image.AxesImage` generated via\n    :meth:`~matplotlib.axes.Axes.imshow`.\n\n    It is not intended to be instantiated directly; instead,\n    use :meth:`~matplotlib.figure.Figure.colorbar` or\n    :func:`~matplotlib.pyplot.colorbar` to make your colorbar.\n\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # Ensure the given mappable's norm has appropriate vmin and vmax set\n        # even if mappable.draw has not yet been called.\n        if mappable.get_array() is not None:\n            mappable.autoscale_None()\n\n        self.mappable = mappable\n        kw['cmap'] = cmap = mappable.cmap\n        kw['norm'] = mappable.norm\n\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['alpha'] = mappable.get_alpha()\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            if getattr(cmap, 'colorbar_extend', False) is not False:\n                kw.setdefault('extend', cmap.colorbar_extend)\n\n            if isinstance(mappable, martist.Artist):\n                kw['alpha'] = mappable.get_alpha()\n\n            ColorbarBase.__init__(self, ax, **kw)\n\n    def on_mappable_changed(self, mappable):\n        \"\"\"\n        Updates this colorbar to match the mappable's properties.\n\n        Typically this is automatically registered as an event handler\n        by :func:`colorbar_factory` and should not be called manually.\n\n        \"\"\"\n        self.set_cmap(mappable.get_cmap())\n        self.set_clim(mappable.get_clim())\n        self.update_normal(mappable)\n\n    def add_lines(self, CS, erase=True):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n\n        Set *erase* to False if these lines should be added to\n        any pre-existing lines.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths,\n                               erase=erase)\n\n    def update_normal(self, mappable):\n        '''\n        update solid, lines, etc. Unlike update_bruteforce, it does\n        not clear the axes.  This is meant to be called when the image\n        or contour plot to which this colorbar belongs is changed.\n        '''\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True\n\n    def update_bruteforce(self, mappable):\n        '''\n        Destroy and rebuild the colorbar.  This is\n        intended to become obsolete, and will probably be\n        deprecated and then removed.  It is not called when\n        the pyplot.colorbar function or the Figure.colorbar\n        method are used to create the colorbar.\n\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        # clearing the axes will delete outline, patch, solids, and lines:\n        self.outline = None\n        self.patch = None\n        self.solids = None\n        self.lines = list()\n        self.dividers = None\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        self.norm = mappable.norm\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\n    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure.  If the colorbar was created with\n        ``use_gridspec=True`` then restore the gridspec to its previous value.\n        \"\"\"\n\n        ColorbarBase.remove(self)\n        self.mappable.callbacksSM.disconnect(self.mappable.colorbar_cid)\n        self.mappable.colorbar = None\n        self.mappable.colorbar_cid = None\n\n        try:\n            ax = self.mappable.axes\n        except AttributeError:\n            return\n\n        try:\n            gs = ax.get_subplotspec().get_gridspec()\n            subplotspec = gs.get_topmost_subplotspec()\n        except AttributeError:\n            # use_gridspec was False\n            pos = ax.get_position(original=True)\n            ax._set_position(pos)\n        else:\n            # use_gridspec was True\n            ax.set_subplotspec(subplotspec)\n\n    def minorticks_on(self):\n        \"\"\"\n        Turns on the minor ticks on the colorbar without extruding\n        into the \"extend regions\".\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        if long_axis.get_scale() == 'log':\n            cbook._warn_external('minorticks_on() has no effect on a '\n                                 'logarithmic colorbar axis')\n        else:\n            long_axis.set_minor_locator(_ColorbarAutoMinorLocator(self))\n\n    def minorticks_off(self):\n        \"\"\"\n        Turns off the minor ticks on the colorbar.\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        if long_axis.get_scale() == 'log':\n            cbook._warn_external('minorticks_off() has no effect on a '\n                                 'logarithmic colorbar axis')\n        else:\n            long_axis.set_minor_locator(ticker.NullLocator())\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes(parents, location=None, orientation=None, fraction=0.15,\n              shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition parent axes, and return a child\n    axes suitable for a colorbar.\n\n    Keyword arguments may include the following (with defaults):\n\n        location : [None|'left'|'right'|'top'|'bottom']\n            The position, relative to **parents**, where the colorbar axes\n            should be created. If None, the value will either come from the\n            given ``orientation``, else it will default to 'right'.\n\n        orientation :  [None|'vertical'|'horizontal']\n            The orientation of the colorbar. Typically, this keyword shouldn't\n            be used, as it can be derived from the ``location`` keyword.\n\n    %s\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    locations = [\"left\", \"right\", \"top\", \"bottom\"]\n    if orientation is not None and location is not None:\n        raise TypeError('position and orientation are mutually exclusive. '\n                        'Consider setting the position to any of {}'\n                        .format(', '.join(locations)))\n\n    # provide a default location\n    if location is None and orientation is None:\n        location = 'right'\n\n    # allow the user to not specify the location by specifying the\n    # orientation instead\n    if location is None:\n        location = 'right' if orientation == 'vertical' else 'bottom'\n\n    if location not in locations:\n        raise ValueError('Invalid colorbar location. Must be one '\n                         'of %s' % ', '.join(locations))\n\n    default_location_settings = {'left':   {'anchor': (1.0, 0.5),\n                                            'panchor': (0.0, 0.5),\n                                            'pad': 0.10,\n                                            'orientation': 'vertical'},\n                                 'right':  {'anchor': (0.0, 0.5),\n                                            'panchor': (1.0, 0.5),\n                                            'pad': 0.05,\n                                            'orientation': 'vertical'},\n                                 'top':    {'anchor': (0.5, 0.0),\n                                            'panchor': (0.5, 1.0),\n                                            'pad': 0.05,\n                                            'orientation': 'horizontal'},\n                                 'bottom': {'anchor': (0.5, 1.0),\n                                            'panchor': (0.5, 0.0),\n                                            'pad': 0.15,  # backwards compat\n                                            'orientation': 'horizontal'},\n                                 }\n\n    loc_settings = default_location_settings[location]\n\n    # put appropriate values into the kw dict for passing back to\n    # the Colorbar class\n    kw['orientation'] = loc_settings['orientation']\n    kw['ticklocation'] = location\n\n    anchor = kw.pop('anchor', loc_settings['anchor'])\n    parent_anchor = kw.pop('panchor', loc_settings['panchor'])\n\n    parents_iterable = np.iterable(parents)\n    # turn parents into a list if it is not already. We do this w/ np\n    # because `plt.subplots` can return an ndarray and is natural to\n    # pass to `colorbar`.\n    parents = np.atleast_1d(parents).ravel()\n\n    # check if using constrained_layout:\n    try:\n        gs = parents[0].get_subplotspec().get_gridspec()\n        using_constrained_layout = (gs._layoutbox is not None)\n    except AttributeError:\n        using_constrained_layout = False\n\n    # defaults are not appropriate for constrained_layout:\n    pad0 = loc_settings['pad']\n    if using_constrained_layout:\n        pad0 = 0.02\n    pad = kw.pop('pad', pad0)\n\n    fig = parents[0].get_figure()\n    if not all(fig is ax.get_figure() for ax in parents):\n        raise ValueError('Unable to create a colorbar axes as not all '\n                         'parents share the same figure.')\n\n    # take a bounding box around all of the given axes\n    parents_bbox = mtransforms.Bbox.union(\n        [ax.get_position(original=True).frozen() for ax in parents])\n\n    pb = parents_bbox\n    if location in ('left', 'right'):\n        if location == 'left':\n            pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n    else:\n        if location == 'bottom':\n            pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n\n        # define the aspect ratio in terms of y's per x rather than x's per y\n        aspect = 1.0 / aspect\n\n    # define a transform which takes us from old axes coordinates to\n    # new axes coordinates\n    shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n\n    # transform each of the axes in parents using the new transform\n    for ax in parents:\n        new_posn = shrinking_trans.transform(ax.get_position(original=True))\n        new_posn = mtransforms.Bbox(new_posn)\n        ax._set_position(new_posn)\n        if parent_anchor is not False:\n            ax.set_anchor(parent_anchor)\n\n    cax = fig.add_axes(pbcb)\n\n    # OK, now make a layoutbox for the cb axis.  Later, we will use this\n    # to make the colorbar fit nicely.\n    if not using_constrained_layout:\n        # no layout boxes:\n        lb = None\n        lbpos = None\n        # and we need to set the aspect ratio by hand...\n        cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    else:\n        if not parents_iterable:\n            # this is a single axis...\n            ax = parents[0]\n            lb, lbpos = constrained_layout.layoutcolorbarsingle(\n                    ax, cax, shrink, aspect, location, pad=pad)\n        else:  # there is more than one parent, so lets use gridspec\n            # the colorbar will be a sibling of this gridspec, so the\n            # parent is the same parent as the gridspec.  Either the figure,\n            # or a subplotspec.\n\n            lb, lbpos = constrained_layout.layoutcolorbargridspec(\n                    parents, cax, shrink, aspect, location, pad)\n\n    cax._layoutbox = lb\n    cax._poslayoutbox = lbpos\n\n    return cax, kw\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child axes\n    suitable for a colorbar. This function is similar to\n    make_axes. Prmary differences are\n\n     * *make_axes_gridspec* only handles the *orientation* keyword\n       and cannot handle the \"location\" keyword.\n\n     * *make_axes_gridspec* should only be used with a subplot parent.\n\n     * *make_axes* creates an instance of Axes. *make_axes_gridspec*\n        creates an instance of Subplot.\n\n     * *make_axes* updates the position of the\n        parent. *make_axes_gridspec* replaces the grid_spec attribute\n        of the parent with a new one.\n\n    While this function is meant to be compatible with *make_axes*,\n    there could be some minor differences.\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical' or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    kw['ticklocation'] = 'auto'\n\n    x1 = 1 - fraction\n\n    # for shrinking\n    pad_s = (1 - shrink) * 0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    # we need to none the tree of layoutboxes because\n    # constrained_layout can't remove and replace the tree\n    # hierarchy w/o a seg fault.\n    gs = parent.get_subplotspec().get_gridspec()\n    layoutbox.nonetree(gs._layoutbox)\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios)\n        aspect = 1 / aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent._set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1])\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\nclass ColorbarPatch(Colorbar):\n    \"\"\"\n    A Colorbar which is created using :class:`~matplotlib.patches.Patch`\n    rather than the default :func:`~matplotlib.axes.pcolor`.\n\n    It uses a list of Patch instances instead of a\n    :class:`~matplotlib.collections.PatchCollection` because the\n    latter does not allow the hatch pattern to vary among the\n    members of the collection.\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # we do not want to override the behaviour of solids\n        # so add a new attribute which will be a list of the\n        # colored patches in the colorbar\n        self.solids_patches = []\n        Colorbar.__init__(self, ax, mappable, **kw)\n\n    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using :class:`~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        n_segments = len(C)\n\n        # ensure there are sufficient hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in range(len(X) - 1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]],\n                           [X[i][1], Y[i][0]],\n                           [X[i + 1][1], Y[i + 1][0]],\n                           [X[i + 1][0], Y[i + 1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch, linewidth=0,\n                                       antialiased=False, alpha=self.alpha)\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=(0.5 * mpl.rcParams['axes.linewidth'],))\n            self.ax.add_collection(self.dividers)\n\n\ndef colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Creates a colorbar on the given axes for the given mappable.\n\n    Typically, for automatic colorbar placement given only a mappable use\n    :meth:`~matplotlib.figure.Figure.colorbar`.\n\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet)\n            and any(hatch is not None for hatch in mappable.hatches)):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    cid = mappable.callbacksSM.connect('changed', cb.on_mappable_changed)\n    mappable.colorbar = cb\n    mappable.colorbar_cid = cid\n\n    return cb\n",
      "file_patch": "@@ -638,10 +638,8 @@ class ColorbarBase(cm.ScalarMappable):\n         self.stale = True\n \n     def set_label(self, label, **kw):\n-        '''\n-        Label the long axis of the colorbar\n-        '''\n-        self._label = '%s' % (label, )\n+        \"\"\"Label the long axis of the colorbar.\"\"\"\n+        self._label = str(label)\n         self._labelkw = kw\n         self._set_label()\n \n",
      "files_name_in_blame_commit": [
        "UnitDblConverter.py",
        "colorbar.py",
        "lines.py",
        "axes_divider.py",
        "test_axisartist_angle_helper.py",
        "figure.py",
        "axes3d.py",
        "container.py",
        "basic_units.py",
        "text.py",
        "_subplots.py",
        "mpl_axes.py",
        "test_rcparams.py",
        "_base.py",
        "__init__.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 216
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "640": {
        "commit_id": "e573c25ea5451a73f5c9d18fe8acdaa6de6c1a07",
        "line_code": "    def set_label(self, label, **kw):",
        "commit_date": "2007-10-25 14:10:16",
        "valid": 1
      },
      "641": {
        "commit_id": "0e260f66cdf1b6f72df7a7c4d400cf3a477006f2",
        "line_code": "        '''",
        "commit_date": "2008-09-17 22:19:20",
        "valid": 1
      },
      "642": {
        "commit_id": "0e260f66cdf1b6f72df7a7c4d400cf3a477006f2",
        "line_code": "        Label the long axis of the colorbar",
        "commit_date": "2008-09-17 22:19:20",
        "valid": 1
      },
      "643": {
        "commit_id": "0e260f66cdf1b6f72df7a7c4d400cf3a477006f2",
        "line_code": "        '''",
        "commit_date": "2008-09-17 22:19:20",
        "valid": 1
      },
      "644": {
        "commit_id": "b092bfdd1124f65f6c337b3f9cf24b5fe2c9ca75",
        "line_code": "        self._label = '%s' % (label, )",
        "commit_date": "2012-08-19 16:49:44",
        "valid": 1
      },
      "645": {
        "commit_id": "e573c25ea5451a73f5c9d18fe8acdaa6de6c1a07",
        "line_code": "        self._labelkw = kw",
        "commit_date": "2007-10-25 14:10:16",
        "valid": 1
      },
      "646": {
        "commit_id": "e573c25ea5451a73f5c9d18fe8acdaa6de6c1a07",
        "line_code": "        self._set_label()",
        "commit_date": "2007-10-25 14:10:16",
        "valid": 1
      }
    },
    "commits": {
      "b092bfdd1124f65f6c337b3f9cf24b5fe2c9ca75": {
        "commit": {
          "commit_id": "b092bfdd1124f65f6c337b3f9cf24b5fe2c9ca75",
          "commit_message": "Added %s support for labels.",
          "commit_author": "pelson",
          "commit_date": "2012-08-19 16:49:44",
          "commit_parent": "2847ad34b665340f56d0b8d91a1da2dddac3f104"
        },
        "function": {
          "function_name": "set_label",
          "function_code_before": "def set_label(self, label, **kw):\n    \"\"\"\n        Label the long axis of the colorbar\n        \"\"\"\n    self._label = label\n    self._labelkw = kw\n    self._set_label()",
          "function_code_after": "def set_label(self, label, **kw):\n    \"\"\"\n        Label the long axis of the colorbar\n        \"\"\"\n    self._label = '%s' % (label,)\n    self._labelkw = kw\n    self._set_label()",
          "function_before_start_line": 400,
          "function_before_end_line": 406,
          "function_after_start_line": 400,
          "function_after_end_line": 406,
          "function_before_token_count": 26,
          "function_after_token_count": 31,
          "functions_name_modified_file": [
            "add_lines",
            "_extend_upper",
            "_config_axes",
            "set_ticklabels",
            "_find_range",
            "set_alpha",
            "_get_extension_lengths",
            "_proportional_y",
            "_extend_lower",
            "draw_all",
            "make_axes",
            "_patch_ax",
            "_extended_N",
            "_add_solids",
            "_ticker",
            "_locate",
            "colorbar_factory",
            "_process_values",
            "_uniform_y",
            "_mesh",
            "make_axes_gridspec",
            "set_ticks",
            "_set_label",
            "config_axis",
            "update_normal",
            "on_mappable_changed",
            "set_label",
            "__init__",
            "update_ticks",
            "_edges",
            "_outline",
            "update_bruteforce",
            "_central_N"
          ],
          "functions_name_all_files": [
            "set_url",
            "get_transform",
            "get_transformed_clip_path_and_affine",
            "_config_axes",
            "_find_range",
            "aliased_name",
            "_extend_lower",
            "make_axes",
            "get_agg_filter",
            "get_snap",
            "_locate",
            "convert_xunits",
            "get_picker",
            "__new__",
            "__init__",
            "get_url",
            "set_picker",
            "allow_rasterization",
            "update_ticks",
            "_edges",
            "get_visible",
            "_outline",
            "contains",
            "update_bruteforce",
            "set_animated",
            "set_clip_on",
            "add_lines",
            "pprint_setters_rest",
            "set_visible",
            "_get_extension_lengths",
            "_proportional_y",
            "get_aliases",
            "is_transform_set",
            "_ticker",
            "colorbar_factory",
            "is_figure_set",
            "update_from",
            "_mesh",
            "set_clip_box",
            "kwdoc",
            "set_gid",
            "test_legend_auto1",
            "_set_gc_clip",
            "set_contains",
            "properties",
            "test_various_labels",
            "get_setters",
            "_extended_N",
            "_extend_upper",
            "set_ticklabels",
            "pickable",
            "get_alpha",
            "_patch_ax",
            "get_valid_values",
            "_add_solids",
            "get_clip_box",
            "draw",
            "_process_values",
            "add_callback",
            "get_animated",
            "pchanged",
            "get_figure",
            "set_agg_filter",
            "get_rasterized",
            "setp",
            "set_ticks",
            "_set_label",
            "config_axis",
            "on_mappable_changed",
            "_get_setters_and_targets",
            "__repr__",
            "set_rasterized",
            "get_children",
            "get_zorder",
            "findobj",
            "set_zorder",
            "get_label",
            "pick",
            "_central_N",
            "get_clip_on",
            "set",
            "convert_yunits",
            "set_alpha",
            "test_legend_auto2",
            "set_remove_method",
            "remove_callback",
            "have_units",
            "draw_all",
            "set_figure",
            "set_lod",
            "remove",
            "set_clip_path",
            "get_gid",
            "get_contains",
            "_uniform_y",
            "set_snap",
            "aliased_name_rest",
            "pprint_getters",
            "make_axes_gridspec",
            "pprint_setters",
            "get_clip_path",
            "getp",
            "get_axes",
            "update_normal",
            "set_label",
            "set_axes",
            "update",
            "is_alias",
            "set_transform",
            "hitlist"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_various_labels"
          ]
        },
        "file": {
          "file_name": "colorbar.py",
          "file_nloc": 837,
          "file_complexity": 137,
          "file_token_count": 5482,
          "file_before": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n\n'''\nfrom __future__ import print_function\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.collections as collections\nimport matplotlib.colors as colors\nimport matplotlib.contour as contour\nimport matplotlib.cm as cm\nimport matplotlib.gridspec as gridspec\nimport matplotlib.lines as lines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\nimport matplotlib.ticker as ticker\n\nfrom matplotlib import docstring\n\nmake_axes_kw_doc = '''\n\n    ============= ====================================================\n    Property      Description\n    ============= ====================================================\n    *orientation* vertical or horizontal\n    *fraction*    0.15; fraction of original axes to use for colorbar\n    *pad*         0.05 if vertical, 0.15 if horizontal; fraction\n                  of original axes between colorbar and new image axes\n    *shrink*      1.0; fraction by which to shrink the colorbar\n    *aspect*      20; ratio of long to short dimensions\n    *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;\n                  the anchor point of the colorbar axes\n    *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;\n                  the anchor point of the colorbar parent axes\n    ============= ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ============  ====================================================\n    Property      Description\n    ============  ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *extendfrac*  [ *None* | 'auto' | length | lengths ]\n                  If set to *None*, both the minimum and maximum\n                  triangular colorbar extensions with have a length of\n                  5% of the interior colorbar length (this is the\n                  default setting). If set to 'auto', makes the\n                  triangular colorbar extensions the same lengths as\n                  the interior boxes (when *spacing* is set to\n                  'uniform') or the same lengths as the respective\n                  adjacent interior boxes (when *spacing* is set to\n                  'proportional'). If a scalar, indicates the length\n                  of both the minimum and maximum triangular colorbar\n                  extensions as a fraction of the interior colorbar\n                  length. A two-element sequence of fractions may also\n                  be given, indicating the lengths of the minimum and\n                  maximum colorbar extensions respectively as a\n                  fraction of the interior colorbar length.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g. '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   [ False | True ] If true, draw lines at color\n                  boundaries.\n    ============  ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`~matplotlib.figure.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\narguments:\n\n  *mappable*\n    the :class:`~matplotlib.image.Image`,\n    :class:`~matplotlib.contour.ContourSet`, etc. to\n    which the colorbar applies; this argument is mandatory for the\n    :meth:`~matplotlib.figure.Figure.colorbar` method but optional for the\n    :func:`~matplotlib.pyplot.colorbar` function, which sets the\n    default to the current image.\n\nkeyword arguments:\n\n  *cax*\n    None | axes object into which the colorbar will be drawn\n  *ax*\n    None | parent axes object from which space for a new\n    colorbar axes will be stolen\n  *use_gridspec*\n    False | If *cax* is None, a new *cax* is created as an instance of\n    Axes. If *ax* is an instance of Subplot and *use_gridspec* is True,\n    *cax* is created as an instance of Subplot using the\n    grid_spec module.\n\n\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nNote that the *shrink* kwarg provides a simple way to keep a vertical\ncolorbar, for example, from being taller than the axes of the mappable\nto which the colorbar is attached; but it is a manual method requiring\nsome trial and error. If the colorbar is too tall (or a horizontal\ncolorbar is too wide) use a smaller value of *shrink*.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n\nreturns:\n    :class:`~matplotlib.colorbar.Colorbar` instance; see also its base class,\n    :class:`~matplotlib.colorbar.ColorbarBase`.  Call the\n    :meth:`~matplotlib.colorbar.ColorbarBase.set_label` method\n    to label the colorbar.\n\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\ndocstring.interpd.update(colorbar_doc=colorbar_doc)\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` function and the\n    :meth:`~matplotlib.figure.Figure.colorbar` method, which are the\n    usual ways of creating a colorbar.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    Useful attributes:\n\n        :attr:`ax`\n            the Axes instance in which the colorbar is drawn\n\n        :attr:`lines`\n            a list of LineCollection if lines were drawn, otherwise\n            an empty list\n\n        :attr:`dividers`\n            a LineCollection if *drawedges* is True, otherwise None\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    '''\n    _slice_dict = {'neither': slice(0, None),\n                   'both': slice(1, -1),\n                   'min': slice(1, None),\n                   'max': slice(0, -1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=None,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           extendfrac=None,\n                           ):\n        self.ax = ax\n        self._patch_ax()\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.extendfrac = extendfrac\n        self.solids = None\n        self.lines = list()\n        self.outline = None\n        self.patch = None\n        self.dividers = None\n        self.set_label('')\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatterMathtext()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.config_axis()\n        self.draw_all()\n\n    def _extend_lower(self):\n        \"\"\"Returns whether the lower limit is open ended.\"\"\"\n        return self.extend in ('both', 'min')\n\n    def _extend_upper(self):\n        \"\"\"Returns whether the uper limit is open ended.\"\"\"\n        return self.extend in ('both', 'max')\n\n    def _patch_ax(self):\n        def _warn(*args, **kw):\n            warnings.warn(\"Use the colorbar set_ticks() method instead.\")\n\n        self.ax.set_xticks = _warn\n        self.ax.set_yticks = _warn\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:, np.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n\n    def config_axis(self):\n        ax = self.ax\n        if self.orientation == 'vertical':\n            ax.xaxis.set_ticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n        else:\n            ax.yaxis.set_ticks([])\n            ax.xaxis.set_label_position('bottom')\n\n        self._set_label()\n\n    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.yaxis.set_ticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.xaxis.set_ticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        set tick locations. Tick locations are updated immediately unless update_ticks is\n        *False*. To manually update the ticks, call *update_ticks* method explicitly.\n        \"\"\"\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks\n\n        if update_ticks:\n            self.update_ticks()\n\n    def set_ticklabels(self, ticklabels, update_ticks=True):\n        \"\"\"\n        set tick labels. Tick labels are updated immediately unless update_ticks is\n        *False*. To manually update the ticks, call *update_ticks* method explicitly.\n        \"\"\"\n        if isinstance(self.locator, ticker.FixedLocator):\n            self.formatter = ticker.FixedFormatter(ticklabels)\n            if update_ticks:\n                self.update_ticks()\n        else:\n            warnings.warn(\"set_ticks() must have been called.\")\n\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = lines.Line2D(xy[:, 0], xy[:, 1], color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n\n    def set_label(self, label, **kw):\n        '''\n        Label the long axis of the colorbar\n        '''\n        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in xrange(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in xrange(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n        col = self.ax.pcolormesh(*args, **kw)\n        self.ax.hold(_hold)\n        #self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths, erase=True):\n        '''\n        Draw lines on the colorbar.\n\n        *colors* and *linewidths* must be scalars or\n        sequences the same length as *levels*.\n\n        Set *erase* to False to add lines without first\n        removing any previously added lines.\n        '''\n        y = self._locate(levels)\n        nlevs = len(levels)\n        igood = (y < 1.001) & (y > -0.001)\n        y = y[igood]\n        if cbook.iterable(colors):\n            colors = np.asarray(colors)[igood]\n        if cbook.iterable(linewidths):\n            linewidths = np.asarray(linewidths)[igood]\n        N = len(y)\n        x = np.array([0.0, 1.0])\n        X, Y = np.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in xrange(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in xrange(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n\n        if erase and self.lines:\n            for lc in self.lines:\n                lc.remove()\n            self.lines = []\n        self.lines.append(col)\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n\n        # the dummy axis is expecting a minpos\n        locator.axis.get_minpos = lambda : intv[0]\n        formatter.axis.get_minpos = lambda : intv[0]\n        b = np.array(locator())\n        ticks = self._locate(b)\n        inrange = (ticks > -0.001) & (ticks < 1.001)\n        ticks = ticks[inrange]\n        b = b[inrange]\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = np.zeros((len(b)-1,), dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0]-1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros((len(b)-1,), dtype=float)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5*(bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self._extend_lower():\n                b[0] = b[0] - 1\n            if self._extend_upper():\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n        '''\n        Get the lengths of colorbar extensions.\n\n        A helper method for _uniform_y and _proportional_y.\n        '''\n        # Set the default value.\n        extendlength = np.array([default, default])\n        if isinstance(frac, str):\n            if frac.lower() == 'auto':\n                # Use the provided values when 'auto' is required.\n                extendlength[0] = automin\n                extendlength[1] = automax\n            else:\n                # Any other string is invalid.\n                raise ValueError('invalid value for extendfrac')\n        elif frac is not None:\n            try:\n                # Try to set min and max extension fractions directly.\n                extendlength[:] = frac\n                # If frac is a sequence contaning None then NaN may\n                # be encountered. This is an error.\n                if np.isnan(extendlength).any():\n                    raise ValueError()\n            except (TypeError, ValueError):\n                # Raise an error on encountering an invalid value for frac.\n                raise ValueError('invalid value for extendfrac')\n        return extendlength\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                    automin, automax, default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            b = self._boundaries[self._inside]\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        else:\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        extendlength = self._get_extension_lengths(self.extendfrac,\n                automin, automax, default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = np.meshgrid(x,y)\n        if self._extend_lower():\n            X[0, :] = 0.5\n        if self._extend_upper():\n            X[-1, :] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n        # The rest is linear interpolation with extrapolation at ends.\n        y = self._y\n        N = len(b)\n        ii = np.searchsorted(b, xn)\n        i0 = ii - 1\n        itop = (ii == N)\n        ibot = (ii == 0)\n        i0[itop] -= 1\n        ii[itop] -= 1\n        i0[ibot] += 1\n        ii[ibot] += 1\n\n        #db = b[ii] - b[i0]\n        db = np.take(b, ii) - np.take(b, i0)\n        #dy = y[ii] - y[i0]\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn-np.take(b,i0))*dy/db\n\n        return z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\n\nclass Colorbar(ColorbarBase):\n    \"\"\"\n    This class connects a :class:`ColorbarBase` to a\n    :class:`~matplotlib.cm.ScalarMappable` such as a\n    :class:`~matplotlib.image.AxesImage` generated via\n    :meth:`~matplotlib.axes.Axes.imshow`.\n\n    It is not intended to be instantiated directly; instead,\n    use :meth:`~matplotlib.figure.Figure.colorbar` or\n    :func:`~matplotlib.pyplot.colorbar` to make your colorbar.\n\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['alpha'] = mappable.get_alpha()\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            if isinstance(mappable, martist.Artist):\n                kw['alpha'] = mappable.get_alpha()\n\n            ColorbarBase.__init__(self, ax, **kw)\n\n    def on_mappable_changed(self, mappable):\n        \"\"\"\n        Updates this colorbar to match the mappable's properties.\n\n        Typically this is automatically registered as an event handler\n        by :func:`colorbar_factory` and should not be called manually.\n\n        \"\"\"\n        self.set_cmap(mappable.get_cmap())\n        self.set_clim(mappable.get_clim())\n        self.update_normal(mappable)\n\n    def add_lines(self, CS, erase=True):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n\n        Set *erase* to False if these lines should be added to\n        any pre-existing lines.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths,\n                                erase=erase)\n\n    def update_normal(self, mappable):\n        '''\n        update solid, lines, etc. Unlike update_bruteforce, it does\n        not clear the axes.  This is meant to be called when the image\n        or contour plot to which this colorbar belongs is changed.\n        '''\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n\n\n    def update_bruteforce(self, mappable):\n        '''\n        Destroy and rebuild the colorbar.  This is\n        intended to become obsolete, and will probably be\n        deprecated and then removed.  It is not called when\n        the pyplot.colorbar function or the Figure.colorbar\n        method are used to create the colorbar.\n\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        # clearing the axes will delete outline, patch, solids, and lines:\n        self.outline = None\n        self.patch = None\n        self.solids = None\n        self.lines = list()\n        self.dividers = None\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        self.norm = mappable.norm\n        self.config_axis()\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes(parent, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar::\n\n        cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = kw.pop('anchor', (0.0, 0.5))\n        panchor = kw.pop('panchor', (1.0, 0.5))\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = kw.pop('anchor', (0.5, 1.0))\n        panchor = kw.pop('panchor', (0.5, 0.0))\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes_gridspec(parent, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child axes\n    suitable for a colorbar. This function is similar to\n    make_axes. Prmary differences are\n\n     * *make_axes_gridspec* should only be used with a subplot parent.\n\n     * *make_axes* creates an instance of Axes. *make_axes_gridspec*\n        creates an instance of Subplot.\n\n     * *make_axes* updates the position of the\n        parent. *make_axes_gridspec* replaces the grid_spec attribute\n        of the parent with a new one.\n\n    While this function is meant to be compatible with *make_axes*,\n    there could be some minor differences.::\n\n        cax, kw = make_axes_gridspec(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n\n    x1 = 1.0-fraction\n\n    # for shrinking\n    pad_s = (1.-shrink)*0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2*pad/(1-pad)\n\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1-pad, fraction]\n                                 )\n\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios,\n                                  )\n\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2*pad/(1-pad)\n\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1-pad, fraction]\n                                 )\n\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios,\n                                  )\n\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent.set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1])\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\nclass ColorbarPatch(Colorbar):\n    \"\"\"\n    A Colorbar which is created using :class:`~matplotlib.patches.Patch`\n    rather than the default :func:`~matplotlib.axes.pcolor`.\n\n    It uses a list of Patch instances instead of a\n    :class:`~matplotlib.collections.PatchCollection` because the\n    latter does not allow the hatch pattern to vary among the\n    members of the collection.\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # we do not want to override the behaviour of solids\n        # so add a new attribute which will be a list of the\n        # colored patches in the colorbar\n        self.solids_patches = []\n        Colorbar.__init__(self, ax, mappable, **kw)\n\n    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using :class:`~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n\n        kw = {'alpha':self.alpha,}\n\n        n_segments = len(C)\n\n        # ensure there are sufficent hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in xrange(len(X)-1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]], [X[i][1], Y[i][0]],\n                          [X[i+1][1], Y[i+1][0]], [X[i+1][0], Y[i+1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch,\n                                       edgecolor='none', linewidth=0,\n                                       antialiased=False, **kw\n                                       )\n\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n        self.ax.hold(_hold)\n\n\ndef colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Creates a colorbar on the given axes for the given mappable.\n\n    Typically, for automatic colorbar placement given only a mappable use\n    :meth:`~matplotlib.figure.Figure.colorbar`.\n\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet) \\\n            and any([hatch is not None for hatch in mappable.hatches])):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    mappable.callbacksSM.connect('changed', cb.on_mappable_changed)\n    mappable.set_colorbar(cb, cax)\n\n    return cb\n\n",
          "file_after": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n\n'''\nfrom __future__ import print_function\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.collections as collections\nimport matplotlib.colors as colors\nimport matplotlib.contour as contour\nimport matplotlib.cm as cm\nimport matplotlib.gridspec as gridspec\nimport matplotlib.lines as lines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\nimport matplotlib.ticker as ticker\n\nfrom matplotlib import docstring\n\nmake_axes_kw_doc = '''\n\n    ============= ====================================================\n    Property      Description\n    ============= ====================================================\n    *orientation* vertical or horizontal\n    *fraction*    0.15; fraction of original axes to use for colorbar\n    *pad*         0.05 if vertical, 0.15 if horizontal; fraction\n                  of original axes between colorbar and new image axes\n    *shrink*      1.0; fraction by which to shrink the colorbar\n    *aspect*      20; ratio of long to short dimensions\n    *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;\n                  the anchor point of the colorbar axes\n    *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;\n                  the anchor point of the colorbar parent axes\n    ============= ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ============  ====================================================\n    Property      Description\n    ============  ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *extendfrac*  [ *None* | 'auto' | length | lengths ]\n                  If set to *None*, both the minimum and maximum\n                  triangular colorbar extensions with have a length of\n                  5% of the interior colorbar length (this is the\n                  default setting). If set to 'auto', makes the\n                  triangular colorbar extensions the same lengths as\n                  the interior boxes (when *spacing* is set to\n                  'uniform') or the same lengths as the respective\n                  adjacent interior boxes (when *spacing* is set to\n                  'proportional'). If a scalar, indicates the length\n                  of both the minimum and maximum triangular colorbar\n                  extensions as a fraction of the interior colorbar\n                  length. A two-element sequence of fractions may also\n                  be given, indicating the lengths of the minimum and\n                  maximum colorbar extensions respectively as a\n                  fraction of the interior colorbar length.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g. '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   [ False | True ] If true, draw lines at color\n                  boundaries.\n    ============  ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`~matplotlib.figure.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\narguments:\n\n  *mappable*\n    the :class:`~matplotlib.image.Image`,\n    :class:`~matplotlib.contour.ContourSet`, etc. to\n    which the colorbar applies; this argument is mandatory for the\n    :meth:`~matplotlib.figure.Figure.colorbar` method but optional for the\n    :func:`~matplotlib.pyplot.colorbar` function, which sets the\n    default to the current image.\n\nkeyword arguments:\n\n  *cax*\n    None | axes object into which the colorbar will be drawn\n  *ax*\n    None | parent axes object from which space for a new\n    colorbar axes will be stolen\n  *use_gridspec*\n    False | If *cax* is None, a new *cax* is created as an instance of\n    Axes. If *ax* is an instance of Subplot and *use_gridspec* is True,\n    *cax* is created as an instance of Subplot using the\n    grid_spec module.\n\n\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nNote that the *shrink* kwarg provides a simple way to keep a vertical\ncolorbar, for example, from being taller than the axes of the mappable\nto which the colorbar is attached; but it is a manual method requiring\nsome trial and error. If the colorbar is too tall (or a horizontal\ncolorbar is too wide) use a smaller value of *shrink*.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n\nreturns:\n    :class:`~matplotlib.colorbar.Colorbar` instance; see also its base class,\n    :class:`~matplotlib.colorbar.ColorbarBase`.  Call the\n    :meth:`~matplotlib.colorbar.ColorbarBase.set_label` method\n    to label the colorbar.\n\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\ndocstring.interpd.update(colorbar_doc=colorbar_doc)\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` function and the\n    :meth:`~matplotlib.figure.Figure.colorbar` method, which are the\n    usual ways of creating a colorbar.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    Useful attributes:\n\n        :attr:`ax`\n            the Axes instance in which the colorbar is drawn\n\n        :attr:`lines`\n            a list of LineCollection if lines were drawn, otherwise\n            an empty list\n\n        :attr:`dividers`\n            a LineCollection if *drawedges* is True, otherwise None\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    '''\n    _slice_dict = {'neither': slice(0, None),\n                   'both': slice(1, -1),\n                   'min': slice(1, None),\n                   'max': slice(0, -1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=None,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           extendfrac=None,\n                           ):\n        self.ax = ax\n        self._patch_ax()\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.extendfrac = extendfrac\n        self.solids = None\n        self.lines = list()\n        self.outline = None\n        self.patch = None\n        self.dividers = None\n        self.set_label('')\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatterMathtext()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.config_axis()\n        self.draw_all()\n\n    def _extend_lower(self):\n        \"\"\"Returns whether the lower limit is open ended.\"\"\"\n        return self.extend in ('both', 'min')\n\n    def _extend_upper(self):\n        \"\"\"Returns whether the uper limit is open ended.\"\"\"\n        return self.extend in ('both', 'max')\n\n    def _patch_ax(self):\n        def _warn(*args, **kw):\n            warnings.warn(\"Use the colorbar set_ticks() method instead.\")\n\n        self.ax.set_xticks = _warn\n        self.ax.set_yticks = _warn\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:, np.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n\n    def config_axis(self):\n        ax = self.ax\n        if self.orientation == 'vertical':\n            ax.xaxis.set_ticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n        else:\n            ax.yaxis.set_ticks([])\n            ax.xaxis.set_label_position('bottom')\n\n        self._set_label()\n\n    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.yaxis.set_ticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.xaxis.set_ticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        set tick locations. Tick locations are updated immediately unless update_ticks is\n        *False*. To manually update the ticks, call *update_ticks* method explicitly.\n        \"\"\"\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks\n\n        if update_ticks:\n            self.update_ticks()\n\n    def set_ticklabels(self, ticklabels, update_ticks=True):\n        \"\"\"\n        set tick labels. Tick labels are updated immediately unless update_ticks is\n        *False*. To manually update the ticks, call *update_ticks* method explicitly.\n        \"\"\"\n        if isinstance(self.locator, ticker.FixedLocator):\n            self.formatter = ticker.FixedFormatter(ticklabels)\n            if update_ticks:\n                self.update_ticks()\n        else:\n            warnings.warn(\"set_ticks() must have been called.\")\n\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = lines.Line2D(xy[:, 0], xy[:, 1], color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n\n    def set_label(self, label, **kw):\n        '''\n        Label the long axis of the colorbar\n        '''\n        self._label = '%s' % (label, )\n        self._labelkw = kw\n        self._set_label()\n\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in xrange(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in xrange(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n        col = self.ax.pcolormesh(*args, **kw)\n        self.ax.hold(_hold)\n        #self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths, erase=True):\n        '''\n        Draw lines on the colorbar.\n\n        *colors* and *linewidths* must be scalars or\n        sequences the same length as *levels*.\n\n        Set *erase* to False to add lines without first\n        removing any previously added lines.\n        '''\n        y = self._locate(levels)\n        nlevs = len(levels)\n        igood = (y < 1.001) & (y > -0.001)\n        y = y[igood]\n        if cbook.iterable(colors):\n            colors = np.asarray(colors)[igood]\n        if cbook.iterable(linewidths):\n            linewidths = np.asarray(linewidths)[igood]\n        N = len(y)\n        x = np.array([0.0, 1.0])\n        X, Y = np.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in xrange(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in xrange(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n\n        if erase and self.lines:\n            for lc in self.lines:\n                lc.remove()\n            self.lines = []\n        self.lines.append(col)\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n\n        # the dummy axis is expecting a minpos\n        locator.axis.get_minpos = lambda : intv[0]\n        formatter.axis.get_minpos = lambda : intv[0]\n        b = np.array(locator())\n        ticks = self._locate(b)\n        inrange = (ticks > -0.001) & (ticks < 1.001)\n        ticks = ticks[inrange]\n        b = b[inrange]\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = np.zeros((len(b)-1,), dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0]-1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros((len(b)-1,), dtype=float)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5*(bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self._extend_lower():\n                b[0] = b[0] - 1\n            if self._extend_upper():\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n        '''\n        Get the lengths of colorbar extensions.\n\n        A helper method for _uniform_y and _proportional_y.\n        '''\n        # Set the default value.\n        extendlength = np.array([default, default])\n        if isinstance(frac, str):\n            if frac.lower() == 'auto':\n                # Use the provided values when 'auto' is required.\n                extendlength[0] = automin\n                extendlength[1] = automax\n            else:\n                # Any other string is invalid.\n                raise ValueError('invalid value for extendfrac')\n        elif frac is not None:\n            try:\n                # Try to set min and max extension fractions directly.\n                extendlength[:] = frac\n                # If frac is a sequence contaning None then NaN may\n                # be encountered. This is an error.\n                if np.isnan(extendlength).any():\n                    raise ValueError()\n            except (TypeError, ValueError):\n                # Raise an error on encountering an invalid value for frac.\n                raise ValueError('invalid value for extendfrac')\n        return extendlength\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                    automin, automax, default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            b = self._boundaries[self._inside]\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        else:\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        extendlength = self._get_extension_lengths(self.extendfrac,\n                automin, automax, default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = np.meshgrid(x,y)\n        if self._extend_lower():\n            X[0, :] = 0.5\n        if self._extend_upper():\n            X[-1, :] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n        # The rest is linear interpolation with extrapolation at ends.\n        y = self._y\n        N = len(b)\n        ii = np.searchsorted(b, xn)\n        i0 = ii - 1\n        itop = (ii == N)\n        ibot = (ii == 0)\n        i0[itop] -= 1\n        ii[itop] -= 1\n        i0[ibot] += 1\n        ii[ibot] += 1\n\n        #db = b[ii] - b[i0]\n        db = np.take(b, ii) - np.take(b, i0)\n        #dy = y[ii] - y[i0]\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn-np.take(b,i0))*dy/db\n\n        return z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\n\nclass Colorbar(ColorbarBase):\n    \"\"\"\n    This class connects a :class:`ColorbarBase` to a\n    :class:`~matplotlib.cm.ScalarMappable` such as a\n    :class:`~matplotlib.image.AxesImage` generated via\n    :meth:`~matplotlib.axes.Axes.imshow`.\n\n    It is not intended to be instantiated directly; instead,\n    use :meth:`~matplotlib.figure.Figure.colorbar` or\n    :func:`~matplotlib.pyplot.colorbar` to make your colorbar.\n\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['alpha'] = mappable.get_alpha()\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            if isinstance(mappable, martist.Artist):\n                kw['alpha'] = mappable.get_alpha()\n\n            ColorbarBase.__init__(self, ax, **kw)\n\n    def on_mappable_changed(self, mappable):\n        \"\"\"\n        Updates this colorbar to match the mappable's properties.\n\n        Typically this is automatically registered as an event handler\n        by :func:`colorbar_factory` and should not be called manually.\n\n        \"\"\"\n        self.set_cmap(mappable.get_cmap())\n        self.set_clim(mappable.get_clim())\n        self.update_normal(mappable)\n\n    def add_lines(self, CS, erase=True):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n\n        Set *erase* to False if these lines should be added to\n        any pre-existing lines.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths,\n                                erase=erase)\n\n    def update_normal(self, mappable):\n        '''\n        update solid, lines, etc. Unlike update_bruteforce, it does\n        not clear the axes.  This is meant to be called when the image\n        or contour plot to which this colorbar belongs is changed.\n        '''\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n\n\n    def update_bruteforce(self, mappable):\n        '''\n        Destroy and rebuild the colorbar.  This is\n        intended to become obsolete, and will probably be\n        deprecated and then removed.  It is not called when\n        the pyplot.colorbar function or the Figure.colorbar\n        method are used to create the colorbar.\n\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        # clearing the axes will delete outline, patch, solids, and lines:\n        self.outline = None\n        self.patch = None\n        self.solids = None\n        self.lines = list()\n        self.dividers = None\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        self.norm = mappable.norm\n        self.config_axis()\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes(parent, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar::\n\n        cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = kw.pop('anchor', (0.0, 0.5))\n        panchor = kw.pop('panchor', (1.0, 0.5))\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = kw.pop('anchor', (0.5, 1.0))\n        panchor = kw.pop('panchor', (0.5, 0.0))\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\n@docstring.Substitution(make_axes_kw_doc)\ndef make_axes_gridspec(parent, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child axes\n    suitable for a colorbar. This function is similar to\n    make_axes. Prmary differences are\n\n     * *make_axes_gridspec* should only be used with a subplot parent.\n\n     * *make_axes* creates an instance of Axes. *make_axes_gridspec*\n        creates an instance of Subplot.\n\n     * *make_axes* updates the position of the\n        parent. *make_axes_gridspec* replaces the grid_spec attribute\n        of the parent with a new one.\n\n    While this function is meant to be compatible with *make_axes*,\n    there could be some minor differences.::\n\n        cax, kw = make_axes_gridspec(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n\n    x1 = 1.0-fraction\n\n    # for shrinking\n    pad_s = (1.-shrink)*0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2*pad/(1-pad)\n\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1-pad, fraction]\n                                 )\n\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios,\n                                  )\n\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2*pad/(1-pad)\n\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1-pad, fraction]\n                                 )\n\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios,\n                                  )\n\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent.set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1])\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\n\n\nclass ColorbarPatch(Colorbar):\n    \"\"\"\n    A Colorbar which is created using :class:`~matplotlib.patches.Patch`\n    rather than the default :func:`~matplotlib.axes.pcolor`.\n\n    It uses a list of Patch instances instead of a\n    :class:`~matplotlib.collections.PatchCollection` because the\n    latter does not allow the hatch pattern to vary among the\n    members of the collection.\n    \"\"\"\n    def __init__(self, ax, mappable, **kw):\n        # we do not want to override the behaviour of solids\n        # so add a new attribute which will be a list of the\n        # colored patches in the colorbar\n        self.solids_patches = []\n        Colorbar.__init__(self, ax, mappable, **kw)\n\n    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using :class:`~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n\n        kw = {'alpha':self.alpha,}\n\n        n_segments = len(C)\n\n        # ensure there are sufficent hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in xrange(len(X)-1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]], [X[i][1], Y[i][0]],\n                          [X[i+1][1], Y[i+1][0]], [X[i+1][0], Y[i+1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch,\n                                       edgecolor='none', linewidth=0,\n                                       antialiased=False, **kw\n                                       )\n\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n        self.ax.hold(_hold)\n\n\ndef colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Creates a colorbar on the given axes for the given mappable.\n\n    Typically, for automatic colorbar placement given only a mappable use\n    :meth:`~matplotlib.figure.Figure.colorbar`.\n\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet) \\\n            and any([hatch is not None for hatch in mappable.hatches])):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    mappable.callbacksSM.connect('changed', cb.on_mappable_changed)\n    mappable.set_colorbar(cb, cax)\n\n    return cb\n\n",
          "file_patch": "@@ -401,7 +401,7 @@ class ColorbarBase(cm.ScalarMappable):\n         '''\n         Label the long axis of the colorbar\n         '''\n-        self._label = label\n+        self._label = '%s' % (label, )\n         self._labelkw = kw\n         self._set_label()\n \n",
          "files_name_in_blame_commit": [
            "container.py",
            "colorbar.py",
            "test_legend.py",
            "artist.py"
          ]
        }
      },
      "0e260f66cdf1b6f72df7a7c4d400cf3a477006f2": {
        "commit": {
          "commit_id": "0e260f66cdf1b6f72df7a7c4d400cf3a477006f2",
          "commit_message": "colorbar docstring improvements: work in progress\n\nsvn path=/trunk/matplotlib/; revision=6103",
          "commit_author": "Eric Firing",
          "commit_date": "2008-09-17 22:19:20",
          "commit_parent": "b5e37ec692fc34bf8fc1b46c81eedd67212dac01"
        },
        "function": {
          "function_name": "set_label",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "add_lines",
            "_config_axes",
            "_find_range",
            "set_alpha",
            "_proportional_y",
            "draw_all",
            "make_axes",
            "_add_solids",
            "_ticker",
            "_central_N",
            "_locate",
            "_process_values",
            "_uniform_y",
            "_mesh",
            "_set_label",
            "set_label",
            "__init__",
            "_edges",
            "_outline",
            "update_bruteforce",
            "_extended_N"
          ],
          "functions_name_all_files": [
            "add_lines",
            "_config_axes",
            "_find_range",
            "set_alpha",
            "_proportional_y",
            "draw_all",
            "make_axes",
            "_add_solids",
            "_ticker",
            "_central_N",
            "_locate",
            "_process_values",
            "_uniform_y",
            "_mesh",
            "_set_label",
            "set_label",
            "__init__",
            "_edges",
            "_outline",
            "update_bruteforce",
            "_extended_N"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__"
          ]
        },
        "file": {
          "file_name": "colorbar.py",
          "file_nloc": 582,
          "file_complexity": 89,
          "file_token_count": 3681,
          "file_before": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`matplotlib.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`matplotlib.Figure.colorbar`.\n\n'''\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.colors as colors\nimport matplotlib.cm as cm\nimport matplotlib.ticker as ticker\nimport matplotlib.cbook as cbook\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.collections as collections\nimport matplotlib.contour as contour\n\nmake_axes_kw_doc = '''\n\n    ==========   ====================================================\n    Property     Description\n    ==========   ====================================================\n    *fraction*   0.15; fraction of original axes to use for colorbar\n    *pad*        0.05 if vertical, 0.15 if horizontal; fraction\n                 of original axes between colorbar and new image axes\n    *shrink*     1.0; fraction by which to shrink the colorbar\n    *aspect*     20; ratio of long to short dimensions\n    ==========   ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ===========   ====================================================\n    Property      Description\n    ===========   ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g. '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   [ False | True ] If true, draw lines at color\n                  boundaries.\n    ===========   ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`matplotlib.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\narguments:\n\n  *mappable*\n    the image, :class:`~matplotlib.contours.ContourSet`, etc. to\n    which the colorbar applies; this argument is mandatory for the\n    :meth:`matplotlib.Figure.colorbar` method but optional for the\n    :func:`matplotlib.pyplot.colorbar` function, which sets the\n    default to the current image.\n\nkeyword arguments:\n\n  *cax*\n    None | axes object into which the colorbar will be drawn\n  *ax*\n    None | parent axes object from which space for a new\n    colorbar axes will be stolen\n\n\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf mappable is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nNote that the *shrink* kwarg provides a simple way to keep a vertical\ncolorbar, for example, from being taller than the axes of the mappable\nto which the colorbar is attached; but it is a manual method requiring\nsome trial and error. If the colorbar is too tall (or a horizontal\ncolorbar is too wide) use a smaller value of *shrink*.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` method and pylab\n    function.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    '''\n    _slice_dict = {'neither': slice(0,1000000),\n                   'both': slice(1,-1),\n                   'min': slice(1,1000000),\n                   'max': slice(0,-1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=1.0,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           ):\n        self.ax = ax\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.solids = None\n        self.lines = None\n        self.set_label('')\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatter()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:,np.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n        self._set_label()\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        self.outline = lines.Line2D(xy[:, 0], xy[:, 1], color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        self.patch = patches.Polygon(xy, edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.set_xticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n            ax.set_yticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.set_yticks([])\n            ax.xaxis.set_label_position('bottom')\n            ax.set_xticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n\n    def set_label(self, label, **kw):\n        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in range(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in range(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolor`;\n        optionally add separators.\n        '''\n        ## Change to pcolorfast after fixing bugs in some backends...\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = {'cmap':self.cmap, 'norm':self.norm,\n                    'shading':'flat', 'alpha':self.alpha}\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n        col = self.ax.pcolor(*args, **kw)\n        self.ax.hold(_hold)\n        #self.add_observer(col) # We should observe, not be observed...\n        self.solids = col\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths):\n        '''\n        Draw lines on the colorbar.\n        '''\n        N = len(levels)\n        dummy, y = self._locate(levels)\n        if len(y) <> N:\n            raise ValueError(\"levels are outside colorbar range\")\n        x = np.array([0.0, 1.0])\n        X, Y = np.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in range(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in range(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n        self.lines = col\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n        b = np.array(locator())\n        b, ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = np.zeros((len(b)-1,), dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self.extend in ('both', 'min'):\n                v[0] = -1\n            if self.extend in ('both', 'max'):\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self.extend in ('both', 'min'):\n                b = [b[0]-1] + b\n            if self.extend in ('both', 'max'):\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros((len(b)-1,), dtype=float)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5*(bi[:-1] + bi[1:])\n            if self.extend in ('both', 'min'):\n                v[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self.extend in ('both', 'min'):\n                b[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = -0.05\n                y[-1] = 1.05\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = -0.05\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1.05\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            b = self._boundaries[self._inside]\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n        if self.extend in ('both', 'min'):\n            y[0] = -0.05\n        if self.extend in ('both', 'max'):\n            y[-1] = 1.05\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = np.meshgrid(x,y)\n        if self.extend in ('min', 'both'):\n            X[0,:] = 0.5\n        if self.extend in ('max', 'both'):\n            X[-1,:] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a possible set of color data values, return the ones\n        within range, together with their corresponding colorbar\n        data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n            xout = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            # We do our own clipping so that we can allow a tiny\n            # bit of slop in the end point ticks to allow for\n            # floating point errors.\n            xn = self.norm(x, clip=False).filled()\n            in_cond = (xn > -0.001) & (xn < 1.001)\n            xn = np.compress(in_cond, xn)\n            xout = np.compress(in_cond, x)\n        # The rest is linear interpolation with clipping.\n        y = self._y\n        N = len(b)\n        ii = np.minimum(np.searchsorted(b, xn), N-1)\n        i0 = np.maximum(ii - 1, 0)\n        #db = b[ii] - b[i0]\n        db = np.take(b, ii) - np.take(b, i0)\n        db = np.where(i0==ii, 1.0, db)\n        #dy = y[ii] - y[i0]\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn-np.take(b,i0))*dy/db\n        return xout, z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\nclass Colorbar(ColorbarBase):\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n        kw['alpha'] = mappable.get_alpha()\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            ColorbarBase.__init__(self, ax, **kw)\n\n\n    def add_lines(self, CS):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths)\n\n    def update_bruteforce(self, mappable):\n        '''\n        Manually change any contour line colors.  This is called\n        when the image or contour plot to which this colorbar belongs\n        is changed.\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        self.draw_all()\n        #if self.vmin != self.norm.vmin or self.vmax != self.norm.vmax:\n        #    self.ax.cla()\n        #    self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\ndef make_axes(parent, **kw):\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\nmake_axes.__doc__ ='''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar::\n\n        cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''  % make_axes_kw_doc\n\n\n",
          "file_after": "'''\nColorbar toolkit with two classes and a function:\n\n    :class:`ColorbarBase`\n        the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    :class:`Colorbar`\n        the derived class for use with images or contour plots.\n\n    :func:`make_axes`\n        a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\nand :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\nis a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n\n'''\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.colors as colors\nimport matplotlib.cm as cm\nimport matplotlib.ticker as ticker\nimport matplotlib.cbook as cbook\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.collections as collections\nimport matplotlib.contour as contour\n\nmake_axes_kw_doc = '''\n\n    ==========   ====================================================\n    Property     Description\n    ==========   ====================================================\n    *fraction*   0.15; fraction of original axes to use for colorbar\n    *pad*        0.05 if vertical, 0.15 if horizontal; fraction\n                 of original axes between colorbar and new image axes\n    *shrink*     1.0; fraction by which to shrink the colorbar\n    *aspect*     20; ratio of long to short dimensions\n    ==========   ====================================================\n\n'''\n\ncolormap_kw_doc = '''\n\n    ===========   ====================================================\n    Property      Description\n    ===========   ====================================================\n    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n                  If not 'neither', make pointed end(s) for out-of-\n                  range values.  These are set for a given colormap\n                  using the colormap set_under and set_over methods.\n    *spacing*     [ 'uniform' | 'proportional' ]\n                  Uniform spacing gives each discrete color the same\n                  space; proportional makes the space proportional to\n                  the data interval.\n    *ticks*       [ None | list of ticks | Locator object ]\n                  If None, ticks are determined automatically from the\n                  input.\n    *format*      [ None | format string | Formatter object ]\n                  If None, the\n                  :class:`~matplotlib.ticker.ScalarFormatter` is used.\n                  If a format string is given, e.g. '%.3f', that is\n                  used. An alternative\n                  :class:`~matplotlib.ticker.Formatter` object may be\n                  given instead.\n    *drawedges*   [ False | True ] If true, draw lines at color\n                  boundaries.\n    ===========   ====================================================\n\n    The following will probably be useful only in the context of\n    indexed colors (that is, when the mappable has norm=NoNorm()),\n    or other unusual circumstances.\n\n    ============   ===================================================\n    Property       Description\n    ============   ===================================================\n    *boundaries*   None or a sequence\n    *values*       None or a sequence which must be of length 1 less\n                   than the sequence of *boundaries*. For each region\n                   delimited by adjacent entries in *boundaries*, the\n                   color mapped to the corresponding value in values\n                   will be used.\n    ============   ===================================================\n\n'''\n\ncolorbar_doc = '''\n\nAdd a colorbar to a plot.\n\nFunction signatures for the :mod:`~matplotlib.pyplot` interface; all\nbut the first are also method signatures for the\n:meth:`~matplotlib.figure.Figure.colorbar` method::\n\n  colorbar(**kwargs)\n  colorbar(mappable, **kwargs)\n  colorbar(mappable, cax=cax, **kwargs)\n  colorbar(mappable, ax=ax, **kwargs)\n\narguments:\n\n  *mappable*\n    the :class:`matplotlib.image.Image`,\n    :class:`matplotlib.contour.ContourSet`, etc. to\n    which the colorbar applies; this argument is mandatory for the\n    :meth:`matplotlib.figure.Figure.colorbar` method but optional for the\n    :func:`matplotlib.pyplot.colorbar` function, which sets the\n    default to the current image.\n\nkeyword arguments:\n\n  *cax*\n    None | axes object into which the colorbar will be drawn\n  *ax*\n    None | parent axes object from which space for a new\n    colorbar axes will be stolen\n\n\nAdditional keyword arguments are of two kinds:\n\n  axes properties:\n%s\n  colorbar properties:\n%s\n\nIf *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\nkwarg is included automatically.\n\nNote that the *shrink* kwarg provides a simple way to keep a vertical\ncolorbar, for example, from being taller than the axes of the mappable\nto which the colorbar is attached; but it is a manual method requiring\nsome trial and error. If the colorbar is too tall (or a horizontal\ncolorbar is too wide) use a smaller value of *shrink*.\n\nFor more precise control, you can manually specify the positions of\nthe axes objects in which the mappable and the colorbar are drawn.  In\nthis case, do not use any of the axes properties kwargs.\n\nreturns:\n    :class:`Colorbar` instance; see also its base class,\n    :class:`ColorbarBase`.  Call the :meth:`set_label` method\n    to label the colorbar\n\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the :class:`Colorbar` class, which is the\n    basis for the :func:`~matplotlib.pyplot.colorbar` method and pylab\n    function.\n\n    It is also useful by itself for showing a colormap.  If the *cmap*\n    kwarg is given but *boundaries* and *values* are left as None,\n    then the colormap will be displayed on a 0-1 scale. To show the\n    under- and over-value colors, specify the *norm* as::\n\n        colors.Normalize(clip=False)\n\n    To show the colors versus index instead of on the 0-1 scale,\n    use::\n\n        norm=colors.NoNorm.\n\n    Useful attributes:\n\n        :attr:`ax`\n            the Axes instance in which the colorbar is drawn\n\n        :attr:`lines`\n            a LineCollection if lines were drawn, otherwise None\n\n        :attr:`dividers`\n            a LineCollection if *drawedges* is True, otherwise None\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    '''\n    _slice_dict = {'neither': slice(0,1000000),\n                   'both': slice(1,-1),\n                   'min': slice(1,1000000),\n                   'max': slice(0,-1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=1.0,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           ):\n        self.ax = ax\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.solids = None\n        self.lines = None\n        self.dividers = None\n        self.set_label('')\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatter()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:,np.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n        self._set_label()\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        self.outline = lines.Line2D(xy[:, 0], xy[:, 1], color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        self.patch = patches.Polygon(xy, edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.set_xticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n            ax.set_yticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.set_yticks([])\n            ax.xaxis.set_label_position('bottom')\n            ax.set_xticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n\n    def set_label(self, label, **kw):\n        '''\n        Label the long axis of the colorbar\n        '''\n        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = np.take(np.ravel(np.transpose(X)), ii)\n        y = np.take(np.ravel(np.transpose(Y)), ii)\n        x = x.reshape((len(x), 1))\n        y = y.reshape((len(y), 1))\n        if self.orientation == 'horizontal':\n            return np.hstack((y, x))\n        return np.hstack((x, y))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in range(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in range(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolor`;\n        optionally add separators.\n        '''\n        ## Change to pcolorfast after fixing bugs in some backends...\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = {'cmap':self.cmap, 'norm':self.norm,\n                    'shading':'flat', 'alpha':self.alpha}\n        # Save, set, and restore hold state to keep pcolor from\n        # clearing the axes. Ordinarily this will not be needed,\n        # since the axes object should already have hold set.\n        _hold = self.ax.ishold()\n        self.ax.hold(True)\n        col = self.ax.pcolor(*args, **kw)\n        self.ax.hold(_hold)\n        #self.add_observer(col) # We should observe, not be observed...\n        self.solids = col\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths):\n        '''\n        Draw lines on the colorbar.\n        '''\n        N = len(levels)\n        dummy, y = self._locate(levels)\n        if len(y) <> N:\n            raise ValueError(\"levels are outside colorbar range\")\n        x = np.array([0.0, 1.0])\n        X, Y = np.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in range(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in range(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n        self.lines = col\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n        b = np.array(locator())\n        b, ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t, i) for i, t in enumerate(b)]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n                return\n            self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = np.zeros((len(b)-1,), dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self.extend in ('both', 'min'):\n                v[0] = -1\n            if self.extend in ('both', 'max'):\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self.extend in ('both', 'min'):\n                b = [b[0]-1] + b\n            if self.extend in ('both', 'max'):\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros((len(b)-1,), dtype=float)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5*(bi[:-1] + bi[1:])\n            if self.extend in ('both', 'min'):\n                v[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self.extend in ('both', 'min'):\n                b[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries **before** extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = -0.05\n                y[-1] = 1.05\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = -0.05\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1.05\n            y[self._inside] = np.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            b = self._boundaries[self._inside]\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n        if self.extend in ('both', 'min'):\n            y[0] = -0.05\n        if self.extend in ('both', 'max'):\n            y[-1] = 1.05\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = np.meshgrid(x,y)\n        if self.extend in ('min', 'both'):\n            X[0,:] = 0.5\n        if self.extend in ('max', 'both'):\n            X[-1,:] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a possible set of color data values, return the ones\n        within range, together with their corresponding colorbar\n        data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n            xout = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            # We do our own clipping so that we can allow a tiny\n            # bit of slop in the end point ticks to allow for\n            # floating point errors.\n            xn = self.norm(x, clip=False).filled()\n            in_cond = (xn > -0.001) & (xn < 1.001)\n            xn = np.compress(in_cond, xn)\n            xout = np.compress(in_cond, x)\n        # The rest is linear interpolation with clipping.\n        y = self._y\n        N = len(b)\n        ii = np.minimum(np.searchsorted(b, xn), N-1)\n        i0 = np.maximum(ii - 1, 0)\n        #db = b[ii] - b[i0]\n        db = np.take(b, ii) - np.take(b, i0)\n        db = np.where(i0==ii, 1.0, db)\n        #dy = y[ii] - y[i0]\n        dy = np.take(y, ii) - np.take(y, i0)\n        z = np.take(y, i0) + (xn-np.take(b,i0))*dy/db\n        return xout, z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\nclass Colorbar(ColorbarBase):\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n        kw['alpha'] = mappable.get_alpha()\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            ColorbarBase.__init__(self, ax, **kw)\n\n\n    def add_lines(self, CS):\n        '''\n        Add the lines from a non-filled\n        :class:`~matplotlib.contour.ContourSet` to the colorbar.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths)\n\n    def update_bruteforce(self, mappable):\n        '''\n        Manually change any contour line colors.  This is called\n        when the image or contour plot to which this colorbar belongs\n        is changed.\n        '''\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        self.draw_all()\n        #if self.vmin != self.norm.vmin or self.vmax != self.norm.vmax:\n        #    self.ax.cla()\n        #    self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\ndef make_axes(parent, **kw):\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\nmake_axes.__doc__ ='''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar::\n\n        cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical'  or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''  % make_axes_kw_doc\n\n\n",
          "file_patch": "@@ -13,9 +13,9 @@ Colorbar toolkit with two classes and a function:\n         a function for resizing an axes and adding a second axes\n         suitable for a colorbar\n \n-The :meth:`matplotlib.Figure.colorbar` method uses :func:`make_axes`\n-and :class:`Colorbar`; the :func:`matplotlib.pyplot.colorbar` function\n-is a thin wrapper over :meth:`matplotlib.Figure.colorbar`.\n+The :meth:`~matplotlib.figure.Figure.colorbar` method uses :func:`make_axes`\n+and :class:`Colorbar`; the :func:`~matplotlib.pyplot.colorbar` function\n+is a thin wrapper over :meth:`~matplotlib.figure.Figure.colorbar`.\n \n '''\n \n@@ -94,7 +94,7 @@ Add a colorbar to a plot.\n \n Function signatures for the :mod:`~matplotlib.pyplot` interface; all\n but the first are also method signatures for the\n-:meth:`matplotlib.Figure.colorbar` method::\n+:meth:`~matplotlib.figure.Figure.colorbar` method::\n \n   colorbar(**kwargs)\n   colorbar(mappable, **kwargs)\n@@ -104,9 +104,10 @@ but the first are also method signatures for the\n arguments:\n \n   *mappable*\n-    the image, :class:`~matplotlib.contours.ContourSet`, etc. to\n+    the :class:`matplotlib.image.Image`,\n+    :class:`matplotlib.contour.ContourSet`, etc. to\n     which the colorbar applies; this argument is mandatory for the\n-    :meth:`matplotlib.Figure.colorbar` method but optional for the\n+    :meth:`matplotlib.figure.Figure.colorbar` method but optional for the\n     :func:`matplotlib.pyplot.colorbar` function, which sets the\n     default to the current image.\n \n@@ -126,7 +127,7 @@ Additional keyword arguments are of two kinds:\n   colorbar properties:\n %s\n \n-If mappable is a :class:`~matplotlib.contours.ContourSet`, its *extend*\n+If *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\n kwarg is included automatically.\n \n Note that the *shrink* kwarg provides a simple way to keep a vertical\n@@ -138,6 +139,12 @@ colorbar is too wide) use a smaller value of *shrink*.\n For more precise control, you can manually specify the positions of\n the axes objects in which the mappable and the colorbar are drawn.  In\n this case, do not use any of the axes properties kwargs.\n+\n+returns:\n+    :class:`Colorbar` instance; see also its base class,\n+    :class:`ColorbarBase`.  Call the :meth:`set_label` method\n+    to label the colorbar\n+\n ''' % (make_axes_kw_doc, colormap_kw_doc)\n \n \n@@ -162,6 +169,19 @@ class ColorbarBase(cm.ScalarMappable):\n \n         norm=colors.NoNorm.\n \n+    Useful attributes:\n+\n+        :attr:`ax`\n+            the Axes instance in which the colorbar is drawn\n+\n+        :attr:`lines`\n+            a LineCollection if lines were drawn, otherwise None\n+\n+        :attr:`dividers`\n+            a LineCollection if *drawedges* is True, otherwise None\n+\n+    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n+\n     '''\n     _slice_dict = {'neither': slice(0,1000000),\n                    'both': slice(1,-1),\n@@ -196,6 +216,7 @@ class ColorbarBase(cm.ScalarMappable):\n         self.filled = filled\n         self.solids = None\n         self.lines = None\n+        self.dividers = None\n         self.set_label('')\n         if cbook.iterable(ticks):\n             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n@@ -272,6 +293,9 @@ class ColorbarBase(cm.ScalarMappable):\n             self.ax.set_xlabel(self._label, **self._labelkw)\n \n     def set_label(self, label, **kw):\n+        '''\n+        Label the long axis of the colorbar\n+        '''\n         self._label = label\n         self._labelkw = kw\n         self._set_label()\n",
          "files_name_in_blame_commit": [
            "colorbar.py"
          ]
        }
      },
      "e573c25ea5451a73f5c9d18fe8acdaa6de6c1a07": {
        "commit": {
          "commit_id": "e573c25ea5451a73f5c9d18fe8acdaa6de6c1a07",
          "commit_message": "Merged revisions 3984-4000 via svnmerge from \nhttp://matplotlib.svn.sf.net/svnroot/matplotlib/trunk/matplotlib\n\n........\n  r3991 | efiring | 2007-10-23 17:25:24 -0400 (Tue, 23 Oct 2007) | 2 lines\n  \n  Bugfix: save colorbar axis label so it won't get lost\n........\n  r3999 | efiring | 2007-10-24 18:14:57 -0400 (Wed, 24 Oct 2007) | 2 lines\n  \n  Added ax kwarg to pyplot.colorbar and Figure.colorbar\n........\n\nsvn path=/branches/transforms/; revision=4001",
          "commit_author": "Michael Droettboom",
          "commit_date": "2007-10-25 14:10:16",
          "commit_parent": "52d462fc3b0d830220e44b6d9704e1da69b24482"
        },
        "function": {
          "function_name": "set_label",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "notify",
            "add_lines",
            "_config_axes",
            "_find_range",
            "set_alpha",
            "_proportional_y",
            "draw_all",
            "make_axes",
            "_add_solids",
            "_ticker",
            "_central_N",
            "_locate",
            "_process_values",
            "_uniform_y",
            "_mesh",
            "_set_label",
            "set_label",
            "__init__",
            "_edges",
            "_outline",
            "_extended_N"
          ],
          "functions_name_all_files": [
            "_set_dpi",
            "_config_axes",
            "_find_range",
            "clabel",
            "gca",
            "make_axes",
            "cla",
            "disconnect",
            "hsv",
            "jet",
            "step",
            "_locate",
            "get_plot_commands",
            "axhspan",
            "summer",
            "sca",
            "axis",
            "subplot",
            "annotate",
            "psd",
            "quiver",
            "get_size_inches",
            "subplots_adjust",
            "__init__",
            "axvspan",
            "set_dpi",
            "axhline",
            "_edges",
            "xlabel",
            "errorbar",
            "yticks",
            "xticks",
            "semilogy",
            "figimage",
            "pink",
            "_outline",
            "quiverkey",
            "contains",
            "clim",
            "get_frameon",
            "savefig",
            "text",
            "gci",
            "scatter",
            "notify",
            "add_lines",
            "clear",
            "table",
            "delaxes",
            "hot",
            "connect",
            "plot",
            "prism",
            "_proportional_y",
            "hold",
            "cool",
            "winter",
            "broken_barh",
            "loglog",
            "_ticker",
            "get_figheight",
            "rcdefaults",
            "isinteractive",
            "ylim",
            "figaspect",
            "barh",
            "_mesh",
            "ishold",
            "getname_val",
            "plotting",
            "xcorr",
            "contour",
            "add_axobserver",
            "acorr",
            "add_axes",
            "xlim",
            "__str__",
            "hist",
            "axes",
            "autumn",
            "_update_this",
            "set_edgecolor",
            "matshow",
            "arrow",
            "legend",
            "get_edgecolor",
            "stem",
            "pie",
            "pcolormesh",
            "set_facecolor",
            "_set_artist_props",
            "_extended_N",
            "gray",
            "ion",
            "grid",
            "specgram",
            "colors",
            "csd",
            "twinx",
            "set_figsize_inches",
            "autofmt_xdate",
            "switch_backend",
            "over",
            "flag",
            "_add_solids",
            "get_dpi",
            "box",
            "get_current_fig_manager",
            "_process_values",
            "draw",
            "figure",
            "get_figwidth",
            "gcf",
            "hlines",
            "pcolor",
            "colormaps",
            "spring",
            "setp",
            "_set_label",
            "polar",
            "subplot_tool",
            "imshow",
            "bone",
            "set_size_inches",
            "spy",
            "get_children",
            "twiny",
            "axvline",
            "contourf",
            "plot_date",
            "add_subplot",
            "ylabel",
            "thetagrids",
            "sci",
            "imread",
            "semilogx",
            "_central_N",
            "vlines",
            "get_window_extent",
            "copper",
            "_make_key",
            "figlegend",
            "set_alpha",
            "spectral",
            "draw_all",
            "bar",
            "title",
            "set_figwidth",
            "cohere",
            "plotfile",
            "set_canvas",
            "_uniform_y",
            "boxplot",
            "close",
            "set_frameon",
            "ioff",
            "colorbar",
            "get_axes",
            "draw_artist",
            "fill",
            "set_label",
            "update",
            "get_facecolor",
            "rc",
            "figtext",
            "set_figheight",
            "_get_dpi",
            "clf",
            "rgrids"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "notify",
            "draw_all",
            "_set_label"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "notify",
            "_set_label",
            "colorbar",
            "draw_all"
          ]
        },
        "file": {
          "file_name": "colorbar.py",
          "file_nloc": 525,
          "file_complexity": 82,
          "file_token_count": 3328,
          "file_before": "'''\nColorbar toolkit with two classes and a function:\n\n    ColorbarBase is the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    Colorbar is the derived class for use with images or contour plots.\n\n    make_axes is a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe Figure.colorbar() method uses make_axes and Colorbar; the pylab.colorbar()\nfunction is a thin wrapper over Figure.colorbar().\n\n'''\n\nimport numpy as npy\nimport matplotlib as mpl\nimport matplotlib.colors as colors\nimport matplotlib.cm as cm\nimport matplotlib.ticker as ticker\nimport matplotlib.cbook as cbook\nimport matplotlib.transforms as transforms\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.collections as collections\nimport matplotlib.contour as contour\n\nmake_axes_kw_doc = '''\n        fraction    = 0.15; fraction of original axes to use for colorbar\n        pad         = 0.05 if vertical, 0.15 if horizontal; fraction\n                              of original axes between colorbar and\n                              new image axes\n        shrink      = 1.0; fraction by which to shrink the colorbar\n        aspect      = 20; ratio of long to short dimensions\n\n'''\n\ncolormap_kw_doc = '''\n        extend='neither', 'both', 'min', 'max'\n                If not 'neither', make pointed end(s) for out-of-range\n                values.  These are set for a given colormap using the\n                colormap set_under and set_over methods.\n        spacing='uniform', 'proportional'\n                Uniform spacing gives each discrete color the same space;\n                proportional makes the space proportional to the data interval.\n        ticks=None, list of ticks, Locator object\n                If None, ticks are determined automatically from the input.\n        format=None, format string, Formatter object\n                If none, the ScalarFormatter is used.\n                If a format string is given, e.g. '%.3f', that is used.\n                An alternative Formatter object may be given instead.\n        drawedges=False, True\n                If true, draw lines at color boundaries.\n\n        The following will probably be useful only in the context of\n        indexed colors (that is, when the mappable has norm=NoNorm()),\n        or other unusual circumstances.\n\n        boundaries=None or a sequence\n        values=None or a sequence which must be of length 1 less than the\n                sequence of boundaries.\n                For each region delimited by adjacent entries in\n                boundaries, the color mapped to the corresponding\n                value in values will be used.\n\n'''\n\ncolorbar_doc = '''\nAdd a colorbar to a plot.\n\nFunction signatures:\n\n    colorbar(**kwargs)\n\n    colorbar(mappable, **kwargs)\n\n    colorbar(mappable, cax, **kwargs)\n\nThe optional arguments mappable and cax may be included in the kwargs;\nthey are image, ContourSet, etc. to which the colorbar applies, and\nthe axes object in which the colorbar will be drawn.  Defaults are\nthe current image and a new axes object created next to that image\nafter resizing the image.\n\nkwargs are in two groups:\n    axes properties:\n%s\n    colorbar properties:\n%s\n\nIf mappable is a ContourSet, its extend kwarg is included automatically.\n\nNote that the shrink kwarg provides a simple way to keep\na vertical colorbar, for example, from being taller than\nthe axes of the mappable to which the colorbar is attached;\nbut it is a manual method requiring some trial and error.\nIf the colorbar is too tall (or a horizontal colorbar is\ntoo wide) use a smaller value of shrink.\n\nFor more precise control, you can manually specify the\npositions of the axes objects in which the mappable and\nthe colorbar are drawn.  In this case, do not use any of the\naxes properties kwargs.\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the Colorbar class, which is\n    the basis for the colorbar method and pylab function.\n\n    It is also useful by itself for showing a colormap.  If\n    the cmap kwarg is given but boundaries and values are left\n    as None, then the colormap will be displayed on a 0-1 scale.\n    To show the under- and over-value colors, specify the norm\n    as colors.Normalize(clip=False).\n    To show the colors versus index instead of on the 0-1 scale,\n    use norm=colors.NoNorm.\n    '''\n    _slice_dict = {'neither': slice(0,1000000),\n                   'both': slice(1,-1),\n                   'min': slice(1,1000000),\n                   'max': slice(0,-1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=1.0,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           ):\n        self.ax = ax\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.solids = None\n        self.lines = None\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatter()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:,npy.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        x, y = self._outline(X, Y)\n        ax.set_xlim(npy.amin(x), npy.amax(x))\n        ax.set_ylim(npy.amin(y), npy.amax(y))\n        ax.update_datalim_numerix(x, y)\n        self.outline = lines.Line2D(x, y, color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        c = mpl.rcParams['axes.facecolor']\n        self.patch = patches.Polygon(zip(x,y), edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.set_xticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n            ax.set_yticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.set_yticks([])\n            ax.xaxis.set_label_position('bottom')\n            ax.set_xticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def set_label(self, label, **kw):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(label, **kw)\n        else:\n            self.ax.set_xlabel(label, **kw)\n\n    def _outline(self, X, Y):\n        '''\n        Return x, y arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = npy.take(npy.ravel(npy.transpose(X)), ii)\n        y = npy.take(npy.ravel(npy.transpose(Y)), ii)\n        if self.orientation == 'horizontal':\n            return y,x\n        return x,y\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in range(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in range(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using pcolor; optionally add separators.\n        '''\n        ## Change to pcolormesh if/when it is fixed to handle alpha\n        ## correctly.\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (npy.transpose(Y), npy.transpose(X), npy.transpose(C))\n        kw = {'cmap':self.cmap, 'norm':self.norm,\n                    'shading':'flat', 'alpha':self.alpha}\n        col = self.ax.pcolor(*args, **kw)\n        #self.add_observer(col) # We should observe, not be observed...\n        self.solids = col\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths):\n        '''\n        Draw lines on the colorbar.\n        '''\n        N = len(levels)\n        dummy, y = self._locate(levels)\n        if len(y) <> N:\n            raise ValueError(\"levels are outside colorbar range\")\n        x = npy.array([0.0, 1.0])\n        X, Y = npy.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in range(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in range(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n        self.lines = col\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n        b = npy.array(locator())\n        b, ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t) for t in b]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the _boundaries and _values attributes based on\n        the input boundaries and values.  Input boundaries can\n        be self.boundaries or the argument b.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = npy.array(b)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(npy.int16)\n                return\n            self._values = npy.array(self.values)\n            return\n        if self.values is not None:\n            self._values = npy.array(self.values)\n            if self.boundaries is None:\n                b = npy.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = npy.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = npy.zeros((len(b)-1,), dtype=npy.int16)\n            v[self._inside] = npy.arange(self.cmap.N, dtype=npy.int16)\n            if self.extend in ('both', 'min'):\n                v[0] = -1\n            if self.extend in ('both', 'max'):\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self.extend in ('both', 'min'):\n                b[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set vmin and vmax attributes to the first and last\n        boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries *before* extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for N uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = npy.linspace(0, 1, N)\n        else:\n            if self.extend == 'both':\n                y = npy.zeros(N + 2, 'd')\n                y[0] = -0.05\n                y[-1] = 1.05\n            elif self.extend == 'min':\n                y = npy.zeros(N + 1, 'd')\n                y[0] = -0.05\n            else:\n                y = npy.zeros(N + 1, 'd')\n                y[-1] = 1.05\n            y[self._inside] = npy.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        y = self.norm(self._boundaries.copy())\n        if self.extend in ('both', 'min'):\n            y[0] = -0.05\n        if self.extend in ('both', 'max'):\n            y[-1] = 1.05\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = npy.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = npy.meshgrid(x,y)\n        if self.extend in ('min', 'both'):\n            X[0,:] = 0.5\n        if self.extend in ('max', 'both'):\n            X[-1,:] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a possible set of color data values, return the ones\n        within range, together with their corresponding colorbar\n        data coordinates.\n        '''\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._boundaries\n            xn = x\n            xout = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            # We do our own clipping so that we can allow a tiny\n            # bit of slop in the end point ticks to allow for\n            # floating point errors.\n            xn = self.norm(x, clip=False).filled()\n            in_cond = (xn > -0.001) & (xn < 1.001)\n            xn = npy.compress(in_cond, xn)\n            xout = npy.compress(in_cond, x)\n        # The rest is linear interpolation with clipping.\n        y = self._y\n        N = len(b)\n        ii = npy.minimum(npy.searchsorted(b, xn), N-1)\n        i0 = npy.maximum(ii - 1, 0)\n        #db = b[ii] - b[i0]  (does not work with Numeric)\n        db = npy.take(b, ii) - npy.take(b, i0)\n        db = npy.where(i0==ii, 1.0, db)\n        #dy = y[ii] - y[i0]\n        dy = npy.take(y, ii) - npy.take(y, i0)\n        z = npy.take(y, i0) + (xn-npy.take(b,i0))*dy/db\n        return xout, z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\nclass Colorbar(ColorbarBase):\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n        kw['alpha'] = mappable.get_alpha()\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            ColorbarBase.__init__(self, ax, **kw)\n\n\n    def add_lines(self, CS):\n        '''\n        Add the lines from a non-filled ContourSet to the colorbar.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths)\n\n    def notify(self, mappable):\n        '''Manually change any contour line colors.  This is called\n        when the image or contour plot to which this colorbar belongs\n        is changed.\n        '''\n        cm.ScalarMappable.notify(self, mappable)\n        self.ax.cla()\n        self.draw_all()\n        #if self.vmin != self.norm.vmin or self.vmax != self.norm.vmax:\n        #    self.ax.cla()\n        #    self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\ndef make_axes(parent, **kw):\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\nmake_axes.__doc__ ='''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar.\n\n    cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n        orientation = 'vertical'  or 'horizontal'\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''  % make_axes_kw_doc\n\n\n'''\nThe following does not work correctly.  The problem seems to be that\nthe transforms work right only when fig.add_axes(rect) is used to\ngenerate the axes, not when the axes object is generated first and\nthen fig.add_axes(ax) is called.  I don't understand this. - EF\n\nclass ColorbarAxes(axes.Axes):\n    def __init__(self, parent, **kw):\n        orientation = kw.setdefault('orientation', 'vertical')\n        fraction = kw.pop('fraction', 0.15)\n        shrink = kw.pop('shrink', 1.0)\n        aspect = kw.pop('aspect', 20)\n        self.cbkw = kw\n        pb = transforms.PBox(parent.get_position())\n        if orientation == 'vertical':\n            pb1, pbcb = pb.splitx(1.0-fraction)\n            pbcb.shrink(1.0, shrink).anchor('C')\n            anchor = (0.3, 0.5)\n            panchor = (0.8, 0.5)\n        else:\n            pbcb, pb1 = pb.splity(fraction)\n            pbcb.shrink(shrink, 1.0).anchor('C')\n            aspect = 1.0/aspect\n            anchor = (0.5, 0.2)\n            panchor = (0.5, 0.8)\n        parent.set_position(pb1)\n        parent.set_anchor(panchor)\n        fig = parent.get_figure()\n        axes.Axes.__init__(self, fig, pbcb)\n        fig.add_axes(self)\n        self.set_aspect(aspect, anchor=anchor, adjustable='box')\n\n'''\n\n",
          "file_after": "'''\nColorbar toolkit with two classes and a function:\n\n    ColorbarBase is the base class with full colorbar drawing functionality.\n        It can be used as-is to make a colorbar for a given colormap;\n        a mappable object (e.g., image) is not needed.\n\n    Colorbar is the derived class for use with images or contour plots.\n\n    make_axes is a function for resizing an axes and adding a second axes\n        suitable for a colorbar\n\nThe Figure.colorbar() method uses make_axes and Colorbar; the pylab.colorbar()\nfunction is a thin wrapper over Figure.colorbar().\n\n'''\n\nimport numpy as npy\nimport matplotlib as mpl\nimport matplotlib.colors as colors\nimport matplotlib.cm as cm\nimport matplotlib.ticker as ticker\nimport matplotlib.cbook as cbook\nimport matplotlib.transforms as transforms\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.collections as collections\nimport matplotlib.contour as contour\n\nmake_axes_kw_doc = '''\n        fraction    = 0.15; fraction of original axes to use for colorbar\n        pad         = 0.05 if vertical, 0.15 if horizontal; fraction\n                              of original axes between colorbar and\n                              new image axes\n        shrink      = 1.0; fraction by which to shrink the colorbar\n        aspect      = 20; ratio of long to short dimensions\n\n'''\n\ncolormap_kw_doc = '''\n        extend='neither', 'both', 'min', 'max'\n                If not 'neither', make pointed end(s) for out-of-range\n                values.  These are set for a given colormap using the\n                colormap set_under and set_over methods.\n        spacing='uniform', 'proportional'\n                Uniform spacing gives each discrete color the same space;\n                proportional makes the space proportional to the data interval.\n        ticks=None, list of ticks, Locator object\n                If None, ticks are determined automatically from the input.\n        format=None, format string, Formatter object\n                If none, the ScalarFormatter is used.\n                If a format string is given, e.g. '%.3f', that is used.\n                An alternative Formatter object may be given instead.\n        drawedges=False, True\n                If true, draw lines at color boundaries.\n\n        The following will probably be useful only in the context of\n        indexed colors (that is, when the mappable has norm=NoNorm()),\n        or other unusual circumstances.\n\n        boundaries=None or a sequence\n        values=None or a sequence which must be of length 1 less than the\n                sequence of boundaries.\n                For each region delimited by adjacent entries in\n                boundaries, the color mapped to the corresponding\n                value in values will be used.\n\n'''\n\ncolorbar_doc = '''\nAdd a colorbar to a plot.\n\nFunction signatures for the pyplot interface; all but the first are\nalso method signatures for the Figure.colorbar method:\n\n    colorbar(**kwargs)\n    colorbar(mappable, **kwargs)\n    colorbar(mappable, cax=cax, **kwargs)\n    colorbar(mappable, ax=ax, **kwargs)\n\n    arguments:\n        mappable: the image, ContourSet, etc. to which the colorbar applies;\n                    this argument is mandatory for the Figure.colorbar\n                    method but optional for the pyplot.colorbar function,\n                    which sets the default to the current image.\n\n    keyword arguments:\n        cax: None | axes object into which the colorbar will be drawn\n        ax:  None | parent axes object from which space for a new\n                     colorbar axes will be stolen\n\n\n**kwargs are in two groups:\n    axes properties:\n%s\n    colorbar properties:\n%s\n\nIf mappable is a ContourSet, its extend kwarg is included automatically.\n\nNote that the shrink kwarg provides a simple way to keep\na vertical colorbar, for example, from being taller than\nthe axes of the mappable to which the colorbar is attached;\nbut it is a manual method requiring some trial and error.\nIf the colorbar is too tall (or a horizontal colorbar is\ntoo wide) use a smaller value of shrink.\n\nFor more precise control, you can manually specify the\npositions of the axes objects in which the mappable and\nthe colorbar are drawn.  In this case, do not use any of the\naxes properties kwargs.\n''' % (make_axes_kw_doc, colormap_kw_doc)\n\n\n\nclass ColorbarBase(cm.ScalarMappable):\n    '''\n    Draw a colorbar in an existing axes.\n\n    This is a base class for the Colorbar class, which is\n    the basis for the colorbar method and pylab function.\n\n    It is also useful by itself for showing a colormap.  If\n    the cmap kwarg is given but boundaries and values are left\n    as None, then the colormap will be displayed on a 0-1 scale.\n    To show the under- and over-value colors, specify the norm\n    as colors.Normalize(clip=False).\n    To show the colors versus index instead of on the 0-1 scale,\n    use norm=colors.NoNorm.\n    '''\n    _slice_dict = {'neither': slice(0,1000000),\n                   'both': slice(1,-1),\n                   'min': slice(1,1000000),\n                   'max': slice(0,-1)}\n\n    def __init__(self, ax, cmap=None,\n                           norm=None,\n                           alpha=1.0,\n                           values=None,\n                           boundaries=None,\n                           orientation='vertical',\n                           extend='neither',\n                           spacing='uniform',  # uniform or proportional\n                           ticks=None,\n                           format=None,\n                           drawedges=False,\n                           filled=True,\n                           ):\n        self.ax = ax\n        if cmap is None: cmap = cm.get_cmap()\n        if norm is None: norm = colors.Normalize()\n        self.alpha = alpha\n        cm.ScalarMappable.__init__(self, cmap=cmap, norm=norm)\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = self._slice_dict[extend]\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.solids = None\n        self.lines = None\n        self.set_label('')\n        if cbook.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n        if format is None:\n            if isinstance(self.norm, colors.LogNorm):\n                self.formatter = ticker.LogFormatter()\n            else:\n                self.formatter = ticker.ScalarFormatter()\n        elif cbook.is_string_like(format):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter\n        # The rest is in a method so we can recalculate when clim changes.\n        self.draw_all()\n\n    def draw_all(self):\n        '''\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        '''\n        self._process_values()\n        self._find_range()\n        X, Y = self._mesh()\n        C = self._values[:,npy.newaxis]\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)\n        self._set_label()\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        x, y = self._outline(X, Y)\n        ax.set_xlim(npy.amin(x), npy.amax(x))\n        ax.set_ylim(npy.amin(y), npy.amax(y))\n        ax.update_datalim_numerix(x, y)\n        self.outline = lines.Line2D(x, y, color=mpl.rcParams['axes.edgecolor'],\n                                    linewidth=mpl.rcParams['axes.linewidth'])\n        ax.add_artist(self.outline)\n        c = mpl.rcParams['axes.facecolor']\n        self.patch = patches.Polygon(zip(x,y), edgecolor=c,\n                 facecolor=c,\n                 linewidth=0.01,\n                 zorder=-1)\n        ax.add_artist(self.patch)\n        ticks, ticklabels, offset_string = self._ticker()\n        if self.orientation == 'vertical':\n            ax.set_xticks([])\n            ax.yaxis.set_label_position('right')\n            ax.yaxis.set_ticks_position('right')\n            ax.set_yticks(ticks)\n            ax.set_yticklabels(ticklabels)\n            ax.yaxis.get_major_formatter().set_offset_string(offset_string)\n\n        else:\n            ax.set_yticks([])\n            ax.xaxis.set_label_position('bottom')\n            ax.set_xticks(ticks)\n            ax.set_xticklabels(ticklabels)\n            ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n\n    def set_label(self, label, **kw):\n        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n\n    def _outline(self, X, Y):\n        '''\n        Return x, y arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N-2, N-1, 2*N-1, 2*N-2, N+1, N, 0]\n        x = npy.take(npy.ravel(npy.transpose(X)), ii)\n        y = npy.take(npy.ravel(npy.transpose(Y)), ii)\n        if self.orientation == 'horizontal':\n            return y,x\n        return x,y\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [zip(X[i], Y[i]) for i in range(1, N-1)]\n        else:\n            return [zip(Y[i], X[i]) for i in range(1, N-1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using pcolor; optionally add separators.\n        '''\n        ## Change to pcolormesh if/when it is fixed to handle alpha\n        ## correctly.\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (npy.transpose(Y), npy.transpose(X), npy.transpose(C))\n        kw = {'cmap':self.cmap, 'norm':self.norm,\n                    'shading':'flat', 'alpha':self.alpha}\n        col = self.ax.pcolor(*args, **kw)\n        #self.add_observer(col) # We should observe, not be observed...\n        self.solids = col\n        if self.drawedges:\n            self.dividers = collections.LineCollection(self._edges(X,Y),\n                              colors=(mpl.rcParams['axes.edgecolor'],),\n                              linewidths=(0.5*mpl.rcParams['axes.linewidth'],)\n                              )\n            self.ax.add_collection(self.dividers)\n\n    def add_lines(self, levels, colors, linewidths):\n        '''\n        Draw lines on the colorbar.\n        '''\n        N = len(levels)\n        dummy, y = self._locate(levels)\n        if len(y) <> N:\n            raise ValueError(\"levels are outside colorbar range\")\n        x = npy.array([0.0, 1.0])\n        X, Y = npy.meshgrid(x,y)\n        if self.orientation == 'vertical':\n            xy = [zip(X[i], Y[i]) for i in range(N)]\n        else:\n            xy = [zip(Y[i], X[i]) for i in range(N)]\n        col = collections.LineCollection(xy, linewidths=linewidths)\n        self.lines = col\n        col.set_color(colors)\n        self.ax.add_collection(col)\n\n\n    def _ticker(self):\n        '''\n        Return two sequences: ticks (colorbar data locations)\n        and ticklabels (strings).\n        '''\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv/10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = ticker.LogLocator()\n                else:\n                    locator = ticker.MaxNLocator()\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n        if isinstance(self.norm, colors.NoNorm):\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis()\n        formatter.create_dummy_axis()\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n        b = npy.array(locator())\n        b, ticks = self._locate(b)\n        formatter.set_locs(b)\n        ticklabels = [formatter(t) for t in b]\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string\n\n    def _process_values(self, b=None):\n        '''\n        Set the _boundaries and _values attributes based on\n        the input boundaries and values.  Input boundaries can\n        be self.boundaries or the argument b.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = npy.array(b)\n            if self.values is None:\n                self._values = 0.5*(self._boundaries[:-1]\n                                        + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(npy.int16)\n                return\n            self._values = npy.array(self.values)\n            return\n        if self.values is not None:\n            self._values = npy.array(self.values)\n            if self.boundaries is None:\n                b = npy.zeros(len(self.values)+1, 'd')\n                b[1:-1] = 0.5*(self._values[:-1] - self._values[1:])\n                b[0] = 2.0*b[1] - b[2]\n                b[-1] = 2.0*b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = npy.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N+1) * self.cmap.N - 0.5\n            v = npy.zeros((len(b)-1,), dtype=npy.int16)\n            v[self._inside] = npy.arange(self.cmap.N, dtype=npy.int16)\n            if self.extend in ('both', 'min'):\n                v[0] = -1\n            if self.extend in ('both', 'max'):\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n            b = self.norm.inverse(self._uniform_y(self.cmap.N+1))\n            if self.extend in ('both', 'min'):\n                b[0] = b[0] - 1\n            if self.extend in ('both', 'max'):\n                b[-1] = b[-1] + 1\n        self._process_values(b)\n\n    def _find_range(self):\n        '''\n        Set vmin and vmax attributes to the first and last\n        boundary excluding extended end boundaries.\n        '''\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]\n\n    def _central_N(self):\n        '''number of boundaries *before* extension of ends'''\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb\n\n    def _extended_N(self):\n        '''\n        Based on the colormap and extend variable, return the\n        number of boundaries.\n        '''\n        N = self.cmap.N + 1\n        if self.extend == 'both':\n            N += 2\n        elif self.extend in ('min', 'max'):\n            N += 1\n        return N\n\n    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for N uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = npy.linspace(0, 1, N)\n        else:\n            if self.extend == 'both':\n                y = npy.zeros(N + 2, 'd')\n                y[0] = -0.05\n                y[-1] = 1.05\n            elif self.extend == 'min':\n                y = npy.zeros(N + 1, 'd')\n                y[0] = -0.05\n            else:\n                y = npy.zeros(N + 1, 'd')\n                y[-1] = 1.05\n            y[self._inside] = npy.linspace(0, 1, N)\n        return y\n\n    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        y = self.norm(self._boundaries.copy())\n        if self.extend in ('both', 'min'):\n            y[0] = -0.05\n        if self.extend in ('both', 'max'):\n            y[-1] = 1.05\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = norm(yi)\n        return y\n\n    def _mesh(self):\n        '''\n        Return X,Y, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and\n        transposition for a horizontal colorbar are done outside\n        this function.\n        '''\n        x = npy.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        self._y = y\n        X, Y = npy.meshgrid(x,y)\n        if self.extend in ('min', 'both'):\n            X[0,:] = 0.5\n        if self.extend in ('max', 'both'):\n            X[-1,:] = 0.5\n        return X, Y\n\n    def _locate(self, x):\n        '''\n        Given a possible set of color data values, return the ones\n        within range, together with their corresponding colorbar\n        data coordinates.\n        '''\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._boundaries\n            xn = x\n            xout = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            # We do our own clipping so that we can allow a tiny\n            # bit of slop in the end point ticks to allow for\n            # floating point errors.\n            xn = self.norm(x, clip=False).filled()\n            in_cond = (xn > -0.001) & (xn < 1.001)\n            xn = npy.compress(in_cond, xn)\n            xout = npy.compress(in_cond, x)\n        # The rest is linear interpolation with clipping.\n        y = self._y\n        N = len(b)\n        ii = npy.minimum(npy.searchsorted(b, xn), N-1)\n        i0 = npy.maximum(ii - 1, 0)\n        #db = b[ii] - b[i0]  (does not work with Numeric)\n        db = npy.take(b, ii) - npy.take(b, i0)\n        db = npy.where(i0==ii, 1.0, db)\n        #dy = y[ii] - y[i0]\n        dy = npy.take(y, ii) - npy.take(y, i0)\n        z = npy.take(y, i0) + (xn-npy.take(b,i0))*dy/db\n        return xout, z\n\n    def set_alpha(self, alpha):\n        self.alpha = alpha\n\nclass Colorbar(ColorbarBase):\n    def __init__(self, ax, mappable, **kw):\n        mappable.autoscale_None() # Ensure mappable.norm.vmin, vmax\n                             # are set when colorbar is called,\n                             # even if mappable.draw has not yet\n                             # been called.  This will not change\n                             # vmin, vmax if they are already set.\n        self.mappable = mappable\n        kw['cmap'] = mappable.cmap\n        kw['norm'] = mappable.norm\n        kw['alpha'] = mappable.get_alpha()\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            #kw['ticks'] = CS._levels\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            ColorbarBase.__init__(self, ax, **kw)\n\n\n    def add_lines(self, CS):\n        '''\n        Add the lines from a non-filled ContourSet to the colorbar.\n        '''\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        #print 'tlinewidths:', tlinewidths\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths)\n\n    def notify(self, mappable):\n        '''Manually change any contour line colors.  This is called\n        when the image or contour plot to which this colorbar belongs\n        is changed.\n        '''\n        cm.ScalarMappable.notify(self, mappable)\n        # We are using an ugly brute-force method: clearing and\n        # redrawing the whole thing.  The problem is that if any\n        # properties have been changed by methods other than the\n        # colorbar methods, those changes will be lost.\n        self.ax.cla()\n        self.draw_all()\n        #if self.vmin != self.norm.vmin or self.vmax != self.norm.vmax:\n        #    self.ax.cla()\n        #    self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n            #if self.lines is not None:\n            #    tcolors = [c[0] for c in CS.tcolors]\n            #    self.lines.set_color(tcolors)\n        #Fixme? Recalculate boundaries, ticks if vmin, vmax have changed.\n        #Fixme: Some refactoring may be needed; we should not\n        # be recalculating everything if there was a simple alpha\n        # change.\n\ndef make_axes(parent, **kw):\n    orientation = kw.setdefault('orientation', 'vertical')\n    fraction = kw.pop('fraction', 0.15)\n    shrink = kw.pop('shrink', 1.0)\n    aspect = kw.pop('aspect', 20)\n    #pb = transforms.PBox(parent.get_position())\n    pb = parent.get_position(original=True).frozen()\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        x1 = 1.0-fraction\n        pb1, pbx, pbcb = pb.splitx(x1-pad, x1)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored('C', pbcb)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        pbcb, pbx, pb1 = pb.splity(fraction, fraction+pad)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored('C', pbcb)\n        aspect = 1.0/aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n    parent.set_position(pb1)\n    parent.set_anchor(panchor)\n    fig = parent.get_figure()\n    cax = fig.add_axes(pbcb)\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw\nmake_axes.__doc__ ='''\n    Resize and reposition a parent axes, and return a child\n    axes suitable for a colorbar.\n\n    cax, kw = make_axes(parent, **kw)\n\n    Keyword arguments may include the following (with defaults):\n        orientation = 'vertical'  or 'horizontal'\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary.\n    '''  % make_axes_kw_doc\n\n\n'''\nThe following does not work correctly.  The problem seems to be that\nthe transforms work right only when fig.add_axes(rect) is used to\ngenerate the axes, not when the axes object is generated first and\nthen fig.add_axes(ax) is called.  I don't understand this. - EF\n\nclass ColorbarAxes(axes.Axes):\n    def __init__(self, parent, **kw):\n        orientation = kw.setdefault('orientation', 'vertical')\n        fraction = kw.pop('fraction', 0.15)\n        shrink = kw.pop('shrink', 1.0)\n        aspect = kw.pop('aspect', 20)\n        self.cbkw = kw\n        pb = transforms.PBox(parent.get_position())\n        if orientation == 'vertical':\n            pb1, pbcb = pb.splitx(1.0-fraction)\n            pbcb.shrink(1.0, shrink).anchor('C')\n            anchor = (0.3, 0.5)\n            panchor = (0.8, 0.5)\n        else:\n            pbcb, pb1 = pb.splity(fraction)\n            pbcb.shrink(shrink, 1.0).anchor('C')\n            aspect = 1.0/aspect\n            anchor = (0.5, 0.2)\n            panchor = (0.5, 0.8)\n        parent.set_position(pb1)\n        parent.set_anchor(panchor)\n        fig = parent.get_figure()\n        axes.Axes.__init__(self, fig, pbcb)\n        fig.add_axes(self)\n        self.set_aspect(aspect, anchor=anchor, adjustable='box')\n\n'''\n\n",
          "file_patch": "@@ -70,21 +70,27 @@ colormap_kw_doc = '''\n colorbar_doc = '''\n Add a colorbar to a plot.\n \n-Function signatures:\n+Function signatures for the pyplot interface; all but the first are\n+also method signatures for the Figure.colorbar method:\n \n     colorbar(**kwargs)\n-\n     colorbar(mappable, **kwargs)\n+    colorbar(mappable, cax=cax, **kwargs)\n+    colorbar(mappable, ax=ax, **kwargs)\n+\n+    arguments:\n+        mappable: the image, ContourSet, etc. to which the colorbar applies;\n+                    this argument is mandatory for the Figure.colorbar\n+                    method but optional for the pyplot.colorbar function,\n+                    which sets the default to the current image.\n \n-    colorbar(mappable, cax, **kwargs)\n+    keyword arguments:\n+        cax: None | axes object into which the colorbar will be drawn\n+        ax:  None | parent axes object from which space for a new\n+                     colorbar axes will be stolen\n \n-The optional arguments mappable and cax may be included in the kwargs;\n-they are image, ContourSet, etc. to which the colorbar applies, and\n-the axes object in which the colorbar will be drawn.  Defaults are\n-the current image and a new axes object created next to that image\n-after resizing the image.\n \n-kwargs are in two groups:\n+**kwargs are in two groups:\n     axes properties:\n %s\n     colorbar properties:\n@@ -155,6 +161,7 @@ class ColorbarBase(cm.ScalarMappable):\n         self.filled = filled\n         self.solids = None\n         self.lines = None\n+        self.set_label('')\n         if cbook.iterable(ticks):\n             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n         else:\n@@ -183,6 +190,7 @@ class ColorbarBase(cm.ScalarMappable):\n         self._config_axes(X, Y)\n         if self.filled:\n             self._add_solids(X, Y, C)\n+        self._set_label()\n \n     def _config_axes(self, X, Y):\n         '''\n@@ -220,11 +228,17 @@ class ColorbarBase(cm.ScalarMappable):\n             ax.set_xticklabels(ticklabels)\n             ax.xaxis.get_major_formatter().set_offset_string(offset_string)\n \n-    def set_label(self, label, **kw):\n+    def _set_label(self):\n         if self.orientation == 'vertical':\n-            self.ax.set_ylabel(label, **kw)\n+            self.ax.set_ylabel(self._label, **self._labelkw)\n         else:\n-            self.ax.set_xlabel(label, **kw)\n+            self.ax.set_xlabel(self._label, **self._labelkw)\n+\n+    def set_label(self, label, **kw):\n+        self._label = label\n+        self._labelkw = kw\n+        self._set_label()\n+\n \n     def _outline(self, X, Y):\n         '''\n@@ -556,6 +570,10 @@ class Colorbar(ColorbarBase):\n         is changed.\n         '''\n         cm.ScalarMappable.notify(self, mappable)\n+        # We are using an ugly brute-force method: clearing and\n+        # redrawing the whole thing.  The problem is that if any\n+        # properties have been changed by methods other than the\n+        # colorbar methods, those changes will be lost.\n         self.ax.cla()\n         self.draw_all()\n         #if self.vmin != self.norm.vmin or self.vmax != self.norm.vmax:\n",
          "files_name_in_blame_commit": [
            "colorbar.py",
            "pyplot.py",
            "figure.py"
          ]
        }
      }
    }
  }
}
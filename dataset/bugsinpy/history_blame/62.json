{
  "id": "62",
  "blame_commit": {
    "commit": {
      "commit_id": "4afed00d7a90d07a958adf09c8b5ab81f7b52e67",
      "commit_message": "Fixed hillshading problems with masked elevation arrays",
      "commit_author": "Joe Kington",
      "commit_date": "2014-09-27 10:13:18",
      "commit_parent": "71cb78653e490d01dee0cf41b69344087fb950ce"
    },
    "function": {
      "function_name": "shade_rgb",
      "function_code_before": "def shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n    intensity = intensity[..., np.newaxis]\n    lookup = {'hsv': self.blend_hsv, 'soft': self.blend_soft_light, 'overlay': self.blend_overlay}\n    if blend_mode in lookup:\n        return lookup[blend_mode](rgb, intensity, **kwargs)\n    else:\n        try:\n            return blend_mode(rgb, intensity, **kwargs)\n        except TypeError:\n            msg = '\"blend_mode\" must be callable or one of {}'\n            raise ValueError(msg.format(lookup.keys))",
      "function_code_after": "def shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n    intensity = intensity[..., np.newaxis]\n    lookup = {'hsv': self.blend_hsv, 'soft': self.blend_soft_light, 'overlay': self.blend_overlay}\n    if blend_mode in lookup:\n        blend = lookup[blend_mode](rgb, intensity, **kwargs)\n    else:\n        try:\n            blend = blend_mode(rgb, intensity, **kwargs)\n        except TypeError:\n            msg = '\"blend_mode\" must be callable or one of {}'\n            raise ValueError(msg.format(lookup.keys))\n    if hasattr(intensity, 'mask'):\n        mask = intensity.mask[..., 0]\n        for i in range(3):\n            blend[..., i][mask] = rgb[..., i][mask]\n    return blend",
      "function_before_start_line": 1640,
      "function_before_end_line": 1705,
      "function_after_start_line": 1640,
      "function_after_end_line": 1713,
      "function_before_token_count": 132,
      "function_after_token_count": 181,
      "functions_name_modified_file": [
        "is_color_like",
        "set_bad",
        "is_gray",
        "blend_hsv",
        "autoscale",
        "_init",
        "rgb2hex",
        "rgb_to_hsv",
        "_set_extremes",
        "set_gamma",
        "scaled",
        "_inv_transform",
        "from_list",
        "set_over",
        "hsv_to_rgb",
        "process_value",
        "shade_rgb",
        "_transform_vmin_vmax",
        "shade",
        "to_rgba_array",
        "_transform",
        "hex2color",
        "inverse",
        "makeMappingArray",
        "__init__",
        "__call__",
        "from_levels_and_colors",
        "autoscale_None",
        "blend_overlay",
        "hillshade",
        "blend_soft_light",
        "to_rgba",
        "set_under",
        "to_rgb"
      ],
      "functions_name_all_files": [
        "is_color_like",
        "set_bad",
        "is_gray",
        "blend_hsv",
        "autoscale",
        "_init",
        "rgb2hex",
        "rgb_to_hsv",
        "_set_extremes",
        "set_gamma",
        "scaled",
        "_inv_transform",
        "from_list",
        "set_over",
        "hsv_to_rgb",
        "process_value",
        "shade_rgb",
        "_transform_vmin_vmax",
        "shade",
        "to_rgba_array",
        "_transform",
        "hex2color",
        "inverse",
        "makeMappingArray",
        "__init__",
        "__call__",
        "from_levels_and_colors",
        "autoscale_None",
        "blend_overlay",
        "hillshade",
        "blend_soft_light",
        "to_rgba",
        "set_under",
        "to_rgb"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": []
    },
    "file": {
      "file_name": "colors.py",
      "file_nloc": 1130,
      "file_complexity": 238,
      "file_token_count": 7999,
      "file_before": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with\n    The :meth:`shade_rgb`\n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        #-- Calculate the intensity from the illumination angle\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        # The aspect is defined by the _downhill_ direction, thus the negative\n        aspect = np.arctan2(-dy, -dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        intensity = (np.sin(alt) * np.sin(slope)\n                     + np.cos(alt) * np.cos(slope)\n                     * np.cos(az - aspect))\n\n        #-- Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        #-- Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1, intensity)\n\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='hsv',\n              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            return lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                return blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                msg = '\"blend_mode\" must be callable or one of {}'\n                raise ValueError(msg.format(lookup.keys))\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n\n    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
      "file_after": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with\n    The :meth:`shade_rgb`\n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        #-- Calculate the intensity from the illumination angle\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        # The aspect is defined by the _downhill_ direction, thus the negative\n        aspect = np.arctan2(-dy, -dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        intensity = (np.sin(alt) * np.sin(slope)\n                     + np.cos(alt) * np.cos(slope)\n                     * np.cos(az - aspect))\n\n        #-- Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        #-- Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1, intensity)\n\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='hsv',\n              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                msg = '\"blend_mode\" must be callable or one of {}'\n                raise ValueError(msg.format(lookup.keys))\n\n        # Only apply result where hillshade intensity isn't masked\n        if hasattr(intensity, 'mask'):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n\n    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
      "file_patch": "@@ -1696,14 +1696,22 @@ class LightSource(object):\n                 'overlay': self.blend_overlay,\n                 }\n         if blend_mode in lookup:\n-            return lookup[blend_mode](rgb, intensity, **kwargs)\n+            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n         else:\n             try:\n-                return blend_mode(rgb, intensity, **kwargs)\n+                blend = blend_mode(rgb, intensity, **kwargs)\n             except TypeError:\n                 msg = '\"blend_mode\" must be callable or one of {}'\n                 raise ValueError(msg.format(lookup.keys))\n \n+        # Only apply result where hillshade intensity isn't masked\n+        if hasattr(intensity, 'mask'):\n+            mask = intensity.mask[..., 0]\n+            for i in range(3):\n+                blend[..., i][mask] = rgb[..., i][mask]\n+\n+        return blend\n+\n     def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                   hsv_min_val=None, hsv_min_sat=None):\n         \"\"\"\n",
      "files_name_in_blame_commit": [
        "colors.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 416
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "1640": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1641": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                  vert_exag=1, dx=1, dy=1, **kwargs):",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1642": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        \"\"\"",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1643": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        Take the input RGB array (ny*nx*3) adjust their color values",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1644": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        to given the impression of a shaded relief map with a",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1645": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        specified light source using the elevation (ny*nx).",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1646": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        A new RGB array ((ny*nx*3)) is returned.",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1647": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 0
      },
      "1648": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        Parameters",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1649": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        ----------",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1650": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        rgb : array-like",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1651": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            An MxNx3 RGB array, assumed to be in the range of 0 to 1.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1652": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        elevation : array-like",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1653": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            A 2d array (or equivalent) of the height values used to generate a",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1654": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            shaded map.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1655": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        fraction : number",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1656": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            Increases or decreases the contrast of the hillshade.  Values",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1657": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            greater than one will cause intermediate values to move closer to",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1658": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            full illumination or shadow (and clipping any values that move",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1659": {
        "commit_id": "0db6341ca220878f925df8b0fe230f81954766e9",
        "line_code": "            beyond 0 or 1). Note that this is not visually or mathematically",
        "commit_date": "2014-07-22 22:26:25",
        "valid": 1
      },
      "1660": {
        "commit_id": "0db6341ca220878f925df8b0fe230f81954766e9",
        "line_code": "            the same as vertical exaggeration.",
        "commit_date": "2014-07-22 22:26:25",
        "valid": 1
      },
      "1661": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1662": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            The type of blending used to combine the colormapped data values",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1663": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            with the illumination intensity.  For backwards compatibility, this",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1664": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            defaults to \"hsv\". Note that for most topographic surfaces,",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1665": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            \"overlay\" or \"soft\" appear more visually realistic. If a",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1666": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            user-defined function is supplied, it is expected to combine an",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1667": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1668": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1669": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            Additional kwargs supplied to this function will be passed on to",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1670": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            the *blend_mode* function.",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1671": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        vert_exag : number, optional",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1672": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            The amount to exaggerate the elevation values by when calculating",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1673": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            illumination. This can be used either to correct for differences in",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1674": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            units between the x-y coordinate system and the elevation",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1675": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            coordinate system (e.g. decimal degrees vs meters) or to exaggerate",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1676": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            or de-emphasize topography.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1677": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        dx : number, optional",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1678": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            The x-spacing (columns) of the input *elevation* grid.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1679": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        dy : number, optional",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1680": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            The y-spacing (rows) of the input *elevation* grid.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1681": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        Additional kwargs are passed on to the *blend_mode* function.",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1682": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 0
      },
      "1683": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        Returns",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1684": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        -------",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1685": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "        shaded_rgb : ndarray",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1686": {
        "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
        "line_code": "            An MxNx3 array of floats ranging between 0-1.",
        "commit_date": "2014-07-20 22:31:12",
        "valid": 1
      },
      "1687": {
        "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
        "line_code": "        \"\"\"",
        "commit_date": "2009-08-14 18:11:05",
        "valid": 1
      },
      "1688": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        # Calculate the \"hillshade\" intensity.",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1689": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1690": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        intensity = intensity[..., np.newaxis]",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1691": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 0
      },
      "1692": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        # Blend the hillshade and rgb data using the specified mode",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1693": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        lookup = {",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1694": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                'hsv': self.blend_hsv,",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1695": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                'soft': self.blend_soft_light,",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1696": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                'overlay': self.blend_overlay,",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1697": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                }",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1698": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        if blend_mode in lookup:",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1699": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            return lookup[blend_mode](rgb, intensity, **kwargs)",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1700": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "        else:",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1701": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            try:",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1702": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                return blend_mode(rgb, intensity, **kwargs)",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1703": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "            except TypeError:",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1704": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                msg = '\"blend_mode\" must be callable or one of {}'",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      },
      "1705": {
        "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
        "line_code": "                raise ValueError(msg.format(lookup.keys))",
        "commit_date": "2014-07-20 22:34:16",
        "valid": 1
      }
    },
    "commits": {
      "0db6341ca220878f925df8b0fe230f81954766e9": {
        "commit": {
          "commit_id": "0db6341ca220878f925df8b0fe230f81954766e9",
          "commit_message": "Make the \"fraction\" kwarg behave as it did before recent LightSource enhancements",
          "commit_author": "Joe Kington",
          "commit_date": "2014-07-22 22:26:25",
          "commit_parent": "ed5cd76d231a8279633bde02e6549350c005fa82"
        },
        "function": {
          "function_name": "shade_rgb",
          "function_code_before": "def shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n    intensity = intensity[..., np.newaxis]\n    lookup = {'hsv': self.blend_hsv, 'soft': self.blend_soft_light, 'overlay': self.blend_overlay}\n    if blend_mode in lookup:\n        return lookup[blend_mode](rgb, intensity, **kwargs)\n    else:\n        try:\n            return blend_mode(rgb, intensity, **kwargs)\n        except TypeError:\n            msg = '\"blend_mode\" must be callable or one of {}'\n            raise ValueError(msg.format(lookup.keys))",
          "function_code_after": "def shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n    intensity = intensity[..., np.newaxis]\n    lookup = {'hsv': self.blend_hsv, 'soft': self.blend_soft_light, 'overlay': self.blend_overlay}\n    if blend_mode in lookup:\n        return lookup[blend_mode](rgb, intensity, **kwargs)\n    else:\n        try:\n            return blend_mode(rgb, intensity, **kwargs)\n        except TypeError:\n            msg = '\"blend_mode\" must be callable or one of {}'\n            raise ValueError(msg.format(lookup.keys))",
          "function_before_start_line": 1633,
          "function_before_end_line": 1701,
          "function_after_start_line": 1631,
          "function_after_end_line": 1696,
          "function_before_token_count": 132,
          "function_after_token_count": 132,
          "functions_name_modified_file": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "blend_overlay",
            "hillshade",
            "blend_soft_light",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_all_files": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "blend_overlay",
            "hillshade",
            "blend_soft_light",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_co_evolved_modified_file": [
            "hillshade",
            "shade"
          ],
          "functions_name_co_evolved_all_files": [
            "hillshade",
            "shade"
          ]
        },
        "file": {
          "file_name": "colors.py",
          "file_nloc": 1125,
          "file_complexity": 236,
          "file_token_count": 7945,
          "file_before": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        if fraction != 1.0:\n            intensity = fraction * (intensity - 0.5) + 0.5\n            if np.abs(fraction) > 1:\n                np.clip(intensity, 0, 1, intensity)\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='hsv', \n              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map \n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv', \n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv':self.blend_hsv, \n                'soft':self.blend_soft_light, \n                'overlay':self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            return lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                return blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                msg = '\"blend_mode\" must be callable or one of {}'\n                raise ValueError(msg.format(lookup.keys))\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2 \n\n    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_after": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n        if np.abs(fraction) > 1:\n            np.clip(intensity, imin, imax, intensity)\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        intensity -= imin\n        intensity /= (imax - imin)\n\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='hsv', \n              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map \n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv', \n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv':self.blend_hsv, \n                'soft':self.blend_soft_light, \n                'overlay':self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            return lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                return blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                msg = '\"blend_mode\" must be callable or one of {}'\n                raise ValueError(msg.format(lookup.keys))\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2 \n\n    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_patch": "@@ -1528,12 +1528,8 @@ class LightSource(object):\n             Increases or decreases the contrast of the hillshade.  Values\n             greater than one will cause intermediate values to move closer to\n             full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1).  Values less than one will cause full shadow or\n-            full illumination to move closer to a value of 0.5, thereby\n-            decreasing contrast.  Note that this is not mathematically or\n-            visually the same as increasing/decreasing the vertical\n-            exaggeration.\n-\n+            beyond 0 or 1). Note that this is not visually or mathematically\n+            the same as vertical exaggeration.\n         Returns\n         -------\n         intensity : ndarray\n@@ -1557,12 +1553,16 @@ class LightSource(object):\n                      + np.cos(alt) * np.cos(slope) \n                      * np.cos(az - aspect))\n \n-        intensity -= intensity.min()\n-        intensity /= intensity.ptp()\n-        if fraction != 1.0:\n-            intensity = fraction * (intensity - 0.5) + 0.5\n-            if np.abs(fraction) > 1:\n-                np.clip(intensity, 0, 1, intensity)\n+        # Apply contrast stretch\n+        imin, imax = intensity.min(), intensity.max()\n+        intensity *= fraction\n+        if np.abs(fraction) > 1:\n+            np.clip(intensity, imin, imax, intensity)\n+\n+        # Rescale to 0-1, keeping range before contrast stretch\n+        intensity -= imin\n+        intensity /= (imax - imin)\n+\n         return intensity\n \n     def shade(self, data, cmap, norm=None, blend_mode='hsv', \n@@ -1608,11 +1608,8 @@ class LightSource(object):\n             Increases or decreases the contrast of the hillshade.  Values\n             greater than one will cause intermediate values to move closer to\n             full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1).  Values less than one will cause full shadow or\n-            full illumination to move closer to a value of 0.5, thereby\n-            decreasing contrast.  Note that this is not mathematically or\n-            visually the same as increasing/decreasing the vertical\n-            exaggeration.\n+            beyond 0 or 1). Note that this is not visually or mathematically\n+            the same as vertical exaggeration.\n         Additional kwargs are passed on to the *blend_mode* function. \n         \n         Returns\n@@ -1625,7 +1622,8 @@ class LightSource(object):\n \n         rgb0 = cmap(norm(data))\n         rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n-                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n+                              vert_exag=vert_exag, dx=dx, dy=dy,\n+                              fraction=fraction, **kwargs)\n         # Don't overwrite the alpha channel, if present.\n         rgb0[..., :3] = rgb1[..., :3]\n         return rgb0\n@@ -1649,11 +1647,8 @@ class LightSource(object):\n             Increases or decreases the contrast of the hillshade.  Values\n             greater than one will cause intermediate values to move closer to\n             full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1).  Values less than one will cause full shadow or\n-            full illumination to move closer to a value of 0.5, thereby\n-            decreasing contrast.  Note that this is not mathematically or\n-            visually the same as increasing/decreasing the vertical\n-            exaggeration.\n+            beyond 0 or 1). Note that this is not visually or mathematically\n+            the same as vertical exaggeration.\n         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n             The type of blending used to combine the colormapped data values\n             with the illumination intensity.  For backwards compatibility, this\n",
          "files_name_in_blame_commit": [
            "colors.py"
          ]
        }
      },
      "a1af495e106cda69c160e0d7b6ec02acd3d55537": {
        "commit": {
          "commit_id": "a1af495e106cda69c160e0d7b6ec02acd3d55537",
          "commit_message": "Added new blending modes to LightSource for more realistic rendering",
          "commit_author": "Joe Kington",
          "commit_date": "2014-07-20 22:34:16",
          "commit_parent": "4faa4548c4cf2af3dc7d028379a3146169d7b139"
        },
        "function": {
          "function_name": "shade_rgb",
          "function_code_before": "def shade_rgb(self, rgb, elevation, fraction=1.0, vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to :meth:`blend_hsv`. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, fraction=fraction)\n    return self.blend_hsv(rgb, intensity, **kwargs)",
          "function_code_after": "def shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n    intensity = intensity[..., np.newaxis]\n    lookup = {'hsv': self.blend_hsv, 'soft': self.blend_soft_light, 'overlay': self.blend_overlay}\n    if blend_mode in lookup:\n        return lookup[blend_mode](rgb, intensity, **kwargs)\n    else:\n        try:\n            return blend_mode(rgb, intensity, **kwargs)\n        except TypeError:\n            msg = '\"blend_mode\" must be callable or one of {}'\n            raise ValueError(msg.format(lookup.keys))",
          "function_before_start_line": 1625,
          "function_before_end_line": 1667,
          "function_after_start_line": 1633,
          "function_after_end_line": 1701,
          "function_before_token_count": 54,
          "function_after_token_count": 132,
          "functions_name_modified_file": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "blend_overlay",
            "hillshade",
            "blend_soft_light",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_all_files": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "blend_overlay",
            "hillshade",
            "blend_soft_light",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "blend_overlay",
            "shade",
            "blend_hsv",
            "blend_soft_light"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "blend_overlay",
            "shade",
            "blend_hsv",
            "blend_soft_light"
          ]
        },
        "file": {
          "file_name": "colors.py",
          "file_nloc": 1124,
          "file_complexity": 237,
          "file_token_count": 7948,
          "file_before": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45,\n                 hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1,\n                 hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        if fraction != 1.0:\n            intensity = fraction * (intensity - 0.5) + 0.5\n            if np.abs(fraction) > 1:\n                np.clip(intensity, 0, 1, intensity)\n        return intensity\n\n    def shade(self, data, cmap, norm=None, vert_exag=1, dx=1, dy=1, fraction=1,\n              **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map \n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., vert_exag=1, dx=1, dy=1,\n                  **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to :meth:`blend_hsv`. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        intensity = self.hillshade(elevation, fraction=fraction)\n        return self.blend_hsv(rgb, intensity, **kwargs)\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_after": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        if fraction != 1.0:\n            intensity = fraction * (intensity - 0.5) + 0.5\n            if np.abs(fraction) > 1:\n                np.clip(intensity, 0, 1, intensity)\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='hsv', \n              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map \n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv', \n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces, \n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv':self.blend_hsv, \n                'soft':self.blend_soft_light, \n                'overlay':self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            return lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                return blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                msg = '\"blend_mode\" must be callable or one of {}'\n                raise ValueError(msg.format(lookup.keys))\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2 \n\n    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_patch": "@@ -1457,7 +1457,6 @@ def hsv_to_rgb(hsv):\n \n     return rgb\n \n-\n class LightSource(object):\n     \"\"\"\n     Create a light source coming from the specified azimuth and elevation.\n@@ -1469,9 +1468,8 @@ class LightSource(object):\n     The :meth:`shade_rgb` \n     The :meth:`hillshade` produces an illumination map of a surface.\n     \"\"\"\n-    def __init__(self, azdeg=315, altdeg=45,\n-                 hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1,\n-                 hsv_max_sat=0):\n+    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n+                 hsv_min_sat=1, hsv_max_sat=0):\n         \"\"\"\n         Specify the azimuth (measured clockwise from south) and altitude\n         (measured up from the plane of the surface) of the light source\n@@ -1567,8 +1565,8 @@ class LightSource(object):\n                 np.clip(intensity, 0, 1, intensity)\n         return intensity\n \n-    def shade(self, data, cmap, norm=None, vert_exag=1, dx=1, dy=1, fraction=1,\n-              **kwargs):\n+    def shade(self, data, cmap, norm=None, blend_mode='hsv', \n+              vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n         \"\"\"\n         Combine colormapped data values with an illumination intensity map \n         (a.k.a.  \"hillshade\") of the values.\n@@ -1586,6 +1584,16 @@ class LightSource(object):\n         norm : `~matplotlib.colors.Normalize` instance, optional\n             The normalization used to scale values before colormapping. If\n             None, the input will be linearly scaled between its min and max.\n+        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n+            The type of blending used to combine the colormapped data values\n+            with the illumination intensity.  For backwards compatibility, this\n+            defaults to \"hsv\". Note that for most topographic surfaces, \n+            \"overlay\" or \"soft\" appear more visually realistic. If a\n+            user-defined function is supplied, it is expected to combine an\n+            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n+            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n+            Additional kwargs supplied to this function will be passed on to\n+            the *blend_mode* function.\n         vert_exag : number, optional\n             The amount to exaggerate the elevation values by when calculating\n             illumination. This can be used either to correct for differences in\n@@ -1622,8 +1630,8 @@ class LightSource(object):\n         rgb0[..., :3] = rgb1[..., :3]\n         return rgb0\n \n-    def shade_rgb(self, rgb, elevation, fraction=1., vert_exag=1, dx=1, dy=1,\n-                  **kwargs):\n+    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv', \n+                  vert_exag=1, dx=1, dy=1, **kwargs):\n         \"\"\"\n         Take the input RGB array (ny*nx*3) adjust their color values\n         to given the impression of a shaded relief map with a\n@@ -1646,6 +1654,16 @@ class LightSource(object):\n             decreasing contrast.  Note that this is not mathematically or\n             visually the same as increasing/decreasing the vertical\n             exaggeration.\n+        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n+            The type of blending used to combine the colormapped data values\n+            with the illumination intensity.  For backwards compatibility, this\n+            defaults to \"hsv\". Note that for most topographic surfaces, \n+            \"overlay\" or \"soft\" appear more visually realistic. If a\n+            user-defined function is supplied, it is expected to combine an\n+            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n+            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n+            Additional kwargs supplied to this function will be passed on to\n+            the *blend_mode* function.\n         vert_exag : number, optional\n             The amount to exaggerate the elevation values by when calculating\n             illumination. This can be used either to correct for differences in\n@@ -1656,15 +1674,31 @@ class LightSource(object):\n             The x-spacing (columns) of the input *elevation* grid.\n         dy : number, optional\n             The y-spacing (rows) of the input *elevation* grid.\n-        Additional kwargs are passed on to :meth:`blend_hsv`. \n+        Additional kwargs are passed on to the *blend_mode* function. \n         \n         Returns\n         -------\n         shaded_rgb : ndarray\n             An MxNx3 array of floats ranging between 0-1.\n         \"\"\"\n-        intensity = self.hillshade(elevation, fraction=fraction)\n-        return self.blend_hsv(rgb, intensity, **kwargs)\n+        # Calculate the \"hillshade\" intensity.\n+        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n+        intensity = intensity[..., np.newaxis]\n+\n+        # Blend the hillshade and rgb data using the specified mode\n+        lookup = {\n+                'hsv':self.blend_hsv, \n+                'soft':self.blend_soft_light, \n+                'overlay':self.blend_overlay,\n+                }\n+        if blend_mode in lookup:\n+            return lookup[blend_mode](rgb, intensity, **kwargs)\n+        else:\n+            try:\n+                return blend_mode(rgb, intensity, **kwargs)\n+            except TypeError:\n+                msg = '\"blend_mode\" must be callable or one of {}'\n+                raise ValueError(msg.format(lookup.keys))\n \n     def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                   hsv_min_val=None, hsv_min_sat=None):\n@@ -1716,6 +1750,7 @@ class LightSource(object):\n             hsv_min_val = self.hsv_min_val\n \n         # Expects a 2D intensity array scaled between -1 to 1...\n+        intensity = intensity[..., 0]\n         intensity = 2 * intensity - 1\n \n         # convert to rgb, then rgb to hsv\n@@ -1747,6 +1782,45 @@ class LightSource(object):\n         # convert modified hsv back to rgb.\n         return hsv_to_rgb(hsv)\n \n+    def blend_soft_light(self, rgb, intensity):\n+        \"\"\"\n+        Combines an rgb image with an intensity map using \"soft light\"\n+        blending.  Uses the \"pegtop\" formula.\n+\n+        Parameters\n+        ----------\n+        rgb : ndarray\n+            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n+        intensity : ndarray\n+            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n+\n+        Returns\n+        -------\n+        rgb : ndarray\n+            An MxNx3 RGB array representing the combined images.\n+        \"\"\"\n+        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2 \n+\n+    def blend_overlay(self, rgb, intensity):\n+        \"\"\"\n+        Combines an rgb image with an intensity map using \"overlay\" blending.\n+\n+        Parameters\n+        ----------\n+        rgb : ndarray\n+            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n+        intensity : ndarray\n+            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n+\n+        Returns\n+        -------\n+        rgb : ndarray\n+            An MxNx3 RGB array representing the combined images.\n+        \"\"\"\n+        low = 2 * intensity * rgb\n+        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n+        return np.where(rgb <= 0.5, low, high)\n+\n def from_levels_and_colors(levels, colors, extend='neither'):\n     \"\"\"\n     A helper routine to generate a cmap and a norm instance which\n",
          "files_name_in_blame_commit": [
            "colors.py"
          ]
        }
      },
      "4faa4548c4cf2af3dc7d028379a3146169d7b139": {
        "commit": {
          "commit_id": "4faa4548c4cf2af3dc7d028379a3146169d7b139",
          "commit_message": "Added support for vertical exag and non-uniform spacing to LightSource",
          "commit_author": "Joe Kington",
          "commit_date": "2014-07-20 22:31:12",
          "commit_parent": "ee99cf589efc675cc524d70a15343f46b5293807"
        },
        "function": {
          "function_name": "shade_rgb",
          "function_code_before": "def shade_rgb(self, rgb, elevation, fraction=1.0, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n        \"\"\"\n    intensity = self.hillshade(elevation, fraction=fraction)\n    return self.blend_hsv(rgb, intensity, **kwargs)",
          "function_code_after": "def shade_rgb(self, rgb, elevation, fraction=1.0, vert_exag=1, dx=1, dy=1, **kwargs):\n    \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to :meth:`blend_hsv`. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n    intensity = self.hillshade(elevation, fraction=fraction)\n    return self.blend_hsv(rgb, intensity, **kwargs)",
          "function_before_start_line": 1573,
          "function_before_end_line": 1581,
          "function_after_start_line": 1625,
          "function_after_end_line": 1667,
          "function_before_token_count": 42,
          "function_after_token_count": 54,
          "functions_name_modified_file": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "hillshade",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_all_files": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "blend_hsv",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "set_gamma",
            "scaled",
            "_inv_transform",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "process_value",
            "shade_rgb",
            "_transform_vmin_vmax",
            "shade",
            "to_rgba_array",
            "_transform",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "from_levels_and_colors",
            "autoscale_None",
            "hillshade",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_co_evolved_modified_file": [
            "hillshade",
            "shade"
          ],
          "functions_name_co_evolved_all_files": [
            "hillshade",
            "shade"
          ]
        },
        "file": {
          "file_name": "colors.py",
          "file_nloc": 1105,
          "file_complexity": 233,
          "file_token_count": 7779,
          "file_before": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45,\n                 hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1,\n                 hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        dy, dx = np.gradient(elevation)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        if fraction != 1.0:\n            intensity = fraction * (intensity - 0.5) + 0.5\n            if np.abs(fraction) > 1:\n                np.clip(intensity, 0, 1, intensity)\n        return intensity\n\n    def shade(self, data, cmap, norm=None, **kwargs):\n        \"\"\"\n        Take the input data array, convert to HSV values in the\n        given colormap, then adjust those color values\n        to give the impression of a shaded relief map with a\n        specified light source.\n        RGBA values are returned, which can then be used to\n        plot the shaded image with imshow.\n        \"\"\"\n\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, **kwargs)\n        rgb0[:, :, 0:3] = rgb1\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n        \"\"\"\n        intensity = self.hillshade(elevation, fraction=fraction)\n        return self.blend_hsv(rgb, intensity, **kwargs)\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_after": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap. Colormapping typically involves two steps: a data array is first\nmapped onto the range 0-1 using an instance of :class:`Normalize` or of a\nsubclass; then this number in the 0-1 range is mapped to a color using an\ninstance of a subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all the built-in\ncolormap instances, but is also useful for making custom colormaps, and\n:class:`ListedColormap`, which is used for generating a custom colormap from a\nlist of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single color\nspecifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic built-in colors, you can use a single letter\n\n    - b: blue\n    - g: green\n    - r: red\n    - c: cyan\n    - m: magenta\n    - y: yellow\n    - k: black\n    - w: white\n\nGray shades can be given as a string encoding a float in the 0-1 range, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify the\ncolor using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B* are in\nthe range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and 'chartreuse'\nare supported.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import zip\n\nimport warnings\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\ncnames = {\n    'aliceblue':            '#F0F8FF',\n    'antiquewhite':         '#FAEBD7',\n    'aqua':                 '#00FFFF',\n    'aquamarine':           '#7FFFD4',\n    'azure':                '#F0FFFF',\n    'beige':                '#F5F5DC',\n    'bisque':               '#FFE4C4',\n    'black':                '#000000',\n    'blanchedalmond':       '#FFEBCD',\n    'blue':                 '#0000FF',\n    'blueviolet':           '#8A2BE2',\n    'brown':                '#A52A2A',\n    'burlywood':            '#DEB887',\n    'cadetblue':            '#5F9EA0',\n    'chartreuse':           '#7FFF00',\n    'chocolate':            '#D2691E',\n    'coral':                '#FF7F50',\n    'cornflowerblue':       '#6495ED',\n    'cornsilk':             '#FFF8DC',\n    'crimson':              '#DC143C',\n    'cyan':                 '#00FFFF',\n    'darkblue':             '#00008B',\n    'darkcyan':             '#008B8B',\n    'darkgoldenrod':        '#B8860B',\n    'darkgray':             '#A9A9A9',\n    'darkgreen':            '#006400',\n    'darkkhaki':            '#BDB76B',\n    'darkmagenta':          '#8B008B',\n    'darkolivegreen':       '#556B2F',\n    'darkorange':           '#FF8C00',\n    'darkorchid':           '#9932CC',\n    'darkred':              '#8B0000',\n    'darksage':             '#598556',\n    'darksalmon':           '#E9967A',\n    'darkseagreen':         '#8FBC8F',\n    'darkslateblue':        '#483D8B',\n    'darkslategray':        '#2F4F4F',\n    'darkturquoise':        '#00CED1',\n    'darkviolet':           '#9400D3',\n    'deeppink':             '#FF1493',\n    'deepskyblue':          '#00BFFF',\n    'dimgray':              '#696969',\n    'dodgerblue':           '#1E90FF',\n    'firebrick':            '#B22222',\n    'floralwhite':          '#FFFAF0',\n    'forestgreen':          '#228B22',\n    'fuchsia':              '#FF00FF',\n    'gainsboro':            '#DCDCDC',\n    'ghostwhite':           '#F8F8FF',\n    'gold':                 '#FFD700',\n    'goldenrod':            '#DAA520',\n    'gray':                 '#808080',\n    'green':                '#008000',\n    'greenyellow':          '#ADFF2F',\n    'honeydew':             '#F0FFF0',\n    'hotpink':              '#FF69B4',\n    'indianred':            '#CD5C5C',\n    'indigo':               '#4B0082',\n    'ivory':                '#FFFFF0',\n    'khaki':                '#F0E68C',\n    'lavender':             '#E6E6FA',\n    'lavenderblush':        '#FFF0F5',\n    'lawngreen':            '#7CFC00',\n    'lemonchiffon':         '#FFFACD',\n    'lightblue':            '#ADD8E6',\n    'lightcoral':           '#F08080',\n    'lightcyan':            '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen':           '#90EE90',\n    'lightgray':            '#D3D3D3',\n    'lightpink':            '#FFB6C1',\n    'lightsage':            '#BCECAC',\n    'lightsalmon':          '#FFA07A',\n    'lightseagreen':        '#20B2AA',\n    'lightskyblue':         '#87CEFA',\n    'lightslategray':       '#778899',\n    'lightsteelblue':       '#B0C4DE',\n    'lightyellow':          '#FFFFE0',\n    'lime':                 '#00FF00',\n    'limegreen':            '#32CD32',\n    'linen':                '#FAF0E6',\n    'magenta':              '#FF00FF',\n    'maroon':               '#800000',\n    'mediumaquamarine':     '#66CDAA',\n    'mediumblue':           '#0000CD',\n    'mediumorchid':         '#BA55D3',\n    'mediumpurple':         '#9370DB',\n    'mediumseagreen':       '#3CB371',\n    'mediumslateblue':      '#7B68EE',\n    'mediumspringgreen':    '#00FA9A',\n    'mediumturquoise':      '#48D1CC',\n    'mediumvioletred':      '#C71585',\n    'midnightblue':         '#191970',\n    'mintcream':            '#F5FFFA',\n    'mistyrose':            '#FFE4E1',\n    'moccasin':             '#FFE4B5',\n    'navajowhite':          '#FFDEAD',\n    'navy':                 '#000080',\n    'oldlace':              '#FDF5E6',\n    'olive':                '#808000',\n    'olivedrab':            '#6B8E23',\n    'orange':               '#FFA500',\n    'orangered':            '#FF4500',\n    'orchid':               '#DA70D6',\n    'palegoldenrod':        '#EEE8AA',\n    'palegreen':            '#98FB98',\n    'paleturquoise':        '#AFEEEE',\n    'palevioletred':        '#DB7093',\n    'papayawhip':           '#FFEFD5',\n    'peachpuff':            '#FFDAB9',\n    'peru':                 '#CD853F',\n    'pink':                 '#FFC0CB',\n    'plum':                 '#DDA0DD',\n    'powderblue':           '#B0E0E6',\n    'purple':               '#800080',\n    'red':                  '#FF0000',\n    'rosybrown':            '#BC8F8F',\n    'royalblue':            '#4169E1',\n    'saddlebrown':          '#8B4513',\n    'salmon':               '#FA8072',\n    'sage':                 '#87AE73',\n    'sandybrown':           '#FAA460',\n    'seagreen':             '#2E8B57',\n    'seashell':             '#FFF5EE',\n    'sienna':               '#A0522D',\n    'silver':               '#C0C0C0',\n    'skyblue':              '#87CEEB',\n    'slateblue':            '#6A5ACD',\n    'slategray':            '#708090',\n    'snow':                 '#FFFAFA',\n    'springgreen':          '#00FF7F',\n    'steelblue':            '#4682B4',\n    'tan':                  '#D2B48C',\n    'teal':                 '#008080',\n    'thistle':              '#D8BFD8',\n    'tomato':               '#FF6347',\n    'turquoise':            '#40E0D0',\n    'violet':               '#EE82EE',\n    'wheat':                '#F5DEB3',\n    'white':                '#FFFFFF',\n    'whitesmoke':           '#F5F5F5',\n    'yellow':               '#FFFF00',\n    'yellowgreen':          '#9ACD32'}\n\n\n# add british equivs\nfor k, v in list(six.iteritems(cnames)):\n    if k.find('gray') >= 0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given an rgb or rgba sequence of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([np.round(val * 255) for val in rgb[:3]])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, six.string_types):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16) / 255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\n\nclass ColorConverter(object):\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b': (0.0, 0.0, 1.0),\n        'g': (0.0, 0.5, 0.0),\n        'r': (1.0, 0.0, 0.0),\n        'c': (0.0, 0.75, 0.75),\n        'm': (0.75, 0, 0.75),\n        'y': (0.75, 0.75, 0),\n        'k': (0.0, 0.0, 0.0),\n        'w': (1.0, 1.0, 1.0), }\n\n    cache = {}\n\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a string representation of a float, like '0.4',\n               indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n\n        try:\n            return self.cache[arg]\n        except KeyError:\n            pass\n        except TypeError:  # could be unhashable rgb seq\n            arg = tuple(arg)\n            try:\n                return self.cache[arg]\n            except KeyError:\n                pass\n            except TypeError:\n                raise ValueError(\n                    'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                'gray (string) must be in range 0-1')\n                        color = (fl,)*3\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                        'sequence length is %d; must be 3 or 4' % len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError(\n                        'number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError(\n                    'cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError) as exc:\n            raise ValueError(\n                'to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                if len(arg) == 3:\n                    r, g, b = arg\n                    if any(float(x) < 0 or x > 1 for x in arg):\n                        raise ValueError(\n                            'number in rbg sequence outside 0-1 range')\n                else:\n                    raise ValueError(\n                            'length of rgba sequence should be either 3 or 4')\n            else:\n                r, g, b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r, g, b, alpha\n        except (TypeError, ValueError) as exc:\n            raise ValueError(\n                'to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0, 4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    result = np.asarray(c, np.float)\n                    if alpha is not None:\n                        if alpha > 1 or alpha < 0:\n                            raise ValueError(\"alpha must be in 0-1 range\")\n                        result[:, 3] = alpha\n                    return result\n                    # This alpha operation above is new, and depends\n                    # on higher levels to refrain from setting alpha\n                    # to values other than None unless there is\n                    # intent to override any existing alpha values.\n\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\n\ncolorConverter = ColorConverter()\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n\n    if six.callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=np.float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x) - x):\n        raise ValueError(\n            \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    lut = np.zeros((N,), np.float)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = (((xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])) *\n                 (y0[ind] - y1[ind - 1]) + y1[ind - 1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap(object):\n    \"\"\"\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    \"\"\"\n    def __init__(self, name, N=256):\n        r\"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, othewise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            xma = ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask           # Mask will be used below.\n            xa = xma.filled()             # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            # Treat 1.0 as slightly less than 1.\n            vals = np.array([1, 0], dtype=xa.dtype)\n            almost_one = np.nextafter(*vals)\n            cbook._putmask(xa, xa == 1.0, almost_one)\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            xa *= self.N\n            np.clip(xa, -1, self.N, out=xa)\n\n            # ensure that all 'under' values will still have negative\n            # value after casting to int\n            cbook._putmask(xa, xa < 0.0, -1)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        cbook._putmask(xa, xa > self.N - 1, self._i_over)\n        cbook._putmask(xa, xa < 0, self._i_under)\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                cbook._putmask(xa, mask_bad, self._i_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = min(alpha, 1.0)  # alpha must be between 0 and 1\n            alpha = max(alpha, 0.0)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = np.empty(shape=xa.shape + (4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set color to be used for masked values.\n        \"\"\"\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color='k', alpha=None):\n        \"\"\"Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        \"\"\"\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        \"\"\"Generate the lookup table, self._lut\"\"\"\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.alltrue(self._lut[:, 0] == self._lut[:, 1]) and\n                np.alltrue(self._lut[:, 0] == self._lut[:, 2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        \"\"\"\n        Set a new gamma value and regenerate color map.\n        \"\"\"\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        \"\"\"\n\n        if not cbook.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if cbook.iterable(colors[0]) and len(colors[0]) == 2 and \\\n                not cbook.is_string_like(colors[0]):\n            # List of value, color pairs\n            vals, colors = list(zip(*colors))\n        else:\n            vals = np.linspace(0., 1., len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = colorConverter.to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name='from_list', N=None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors)  # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try:\n                    gray = float(self.colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        rgba = colorConverter.to_rgba_array(self.colors)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3] = rgba\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize(object):\n    \"\"\"\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        if cbook.iterable(value):\n            is_scalar = False\n            result = ma.asarray(value)\n            if result.dtype.kind == 'f':\n                if isinstance(value, np.ndarray):\n                    result = result.copy()\n            elif result.dtype.itemsize > 2:\n                result = result.astype(np.float)\n            else:\n                result = result.astype(np.float32)\n        else:\n            is_scalar = True\n            result = ma.array([value]).astype(np.float)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            vmin = float(vmin)\n            vmax = float(vmax)\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin = float(self.vmin)\n        vmax = float(self.vmax)\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin <= 0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            cbook._putmask(resdat, mask, 1)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        A = ma.masked_less_equal(A, 0, copy=False)\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is not None and self.vmax is not None:\n            return\n        A = ma.masked_less_equal(A, 0, copy=False)\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n\n\nclass SymLogNorm(Normalize):\n    \"\"\"\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    \"\"\"\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                  mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        \"\"\"\n        Inplace transformation.\n        \"\"\"\n        masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        \"\"\"\n        Inverse inplace Transformation.\n        \"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        \"\"\"\n        Calculates vmin and vmax in the transformed system.\n        \"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(np.float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        \"\"\" autoscale only None-valued vmin or vmax \"\"\"\n        if self.vmin is not None and self.vmax is not None:\n            pass\n        if self.vmin is None:\n            self.vmin = ma.min(A)\n        if self.vmax is None:\n            self.vmax = ma.max(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the ``[0, 1]`` interval with a power-law\n    scaling. This will clip any negative data points to 0.\n    \"\"\"\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = ma.getmask(result)\n                val = ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n            result[value < 0] = 0\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return ma.power(value, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n    def autoscale(self, A):\n        \"\"\"\n        Set *vmin*, *vmax* to min, max of *A*.\n        \"\"\"\n        self.vmin = ma.min(A)\n        if self.vmin < 0:\n            self.vmin = 0\n            warnings.warn(\"Power-law scaling on negative values is \"\n                          \"ill-defined, clamping to 0.\")\n\n        self.vmax = ma.max(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None and np.size(A) > 0:\n            self.vmin = ma.min(A)\n            if self.vmin < 0:\n                self.vmin = 0\n                warnings.warn(\"Power-law scaling on negative values is \"\n                              \"ill-defined, clamping to 0.\")\n\n        if self.vmax is None and np.size(A) > 0:\n            self.vmax = ma.max(A)\n\n\nclass BoundaryNorm(Normalize):\n    \"\"\"\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    \"\"\"\n    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax + 1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = float(self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    \"\"\"\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    \"\"\"\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = cbook.deprecated('1.3', alternative='Normalize',\n                             name='normalize',\n                             obj_type='class alias')(Normalize)\nno_norm = cbook.deprecated('1.3', alternative='NoNorm',\n                           name='no_norm',\n                           obj_type='class alias')(NoNorm)\n\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    # make sure it is an ndarray\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=arr.shape))\n\n    in_ndim = arr.ndim\n    if arr.ndim == 1:\n        arr = np.array(arr, ndmin=2)\n\n    # make sure we don't have an int image\n    if arr.dtype.kind in ('iu'):\n        arr = arr.astype(np.float32)\n\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    if in_ndim == 1:\n        out.shape = (3,)\n\n    return out\n\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    all values assumed to be in range [0, 1]\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n        # make sure it is an ndarray\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                            \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    # if we got pased a 1D array, try to treat as\n    # a single color and reshape as needed\n    in_ndim = hsv.ndim\n    if in_ndim == 1:\n        hsv = np.array(hsv, ndmin=2)\n\n    # make sure we don't have an int image\n    if hsv.dtype.kind in ('iu'):\n        hsv = hsv.astype(np.float32)\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(np.int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.empty_like(hsv)\n    rgb[..., 0] = r\n    rgb[..., 1] = g\n    rgb[..., 2] = b\n\n    if in_ndim == 1:\n        rgb.shape = (3, )\n\n    return rgb\n\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce \"shaded\" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with \n    The :meth:`shade_rgb` \n    The :meth:`hillshade` produces an illumination map of a surface.\n    \"\"\"\n    def __init__(self, azdeg=315, altdeg=45,\n                 hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1,\n                 hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*, \n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source. \n        \n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker. \n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n        slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = (np.sin(alt) * np.sin(slope) \n                     + np.cos(alt) * np.cos(slope) \n                     * np.cos(az - aspect))\n\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        if fraction != 1.0:\n            intensity = fraction * (intensity - 0.5) + 0.5\n            if np.abs(fraction) > 1:\n                np.clip(intensity, 0, 1, intensity)\n        return intensity\n\n    def shade(self, data, cmap, norm=None, vert_exag=1, dx=1, dy=1, fraction=1,\n              **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map \n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function. \n        \n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if norm is None:\n            norm = Normalize(vmin=data.min(), vmax=data.max())\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., vert_exag=1, dx=1, dy=1,\n                  **kwargs):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1).  Values less than one will cause full shadow or\n            full illumination to move closer to a value of 0.5, thereby\n            decreasing contrast.  Note that this is not mathematically or\n            visually the same as increasing/decreasing the vertical\n            exaggeration.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to :meth:`blend_hsv`. \n        \n        Returns\n        -------\n        shaded_rgb : ndarray\n            An MxNx3 array of floats ranging between 0-1.\n        \"\"\"\n        intensity = self.hillshade(elevation, fraction=fraction)\n        return self.blend_hsv(rgb, intensity, **kwargs)\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val: number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\ndef from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    \"\"\"\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == 'both':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == 'min':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == 'max':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == 'neither':\n        extra_colors = 0\n    else:\n        raise ValueError('Unexpected value for extend: {0!r}'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError('With extend == {0!r} and n_levels == {1!r} expected'\n                         ' n_colors == {2!r}. Got {3!r}.'\n                         ''.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n",
          "file_patch": "@@ -1516,6 +1516,16 @@ class LightSource(object):\n         elevation : array-like\n             A 2d array (or equivalent) of the height values used to generate an\n             illumination map\n+        vert_exag : number, optional\n+            The amount to exaggerate the elevation values by when calculating\n+            illumination. This can be used either to correct for differences in\n+            units between the x-y coordinate system and the elevation\n+            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n+            or de-emphasize topographic effects.\n+        dx : number, optional\n+            The x-spacing (columns) of the input *elevation* grid.\n+        dy : number, optional\n+            The y-spacing (rows) of the input *elevation* grid.\n         fraction : number, optional\n             Increases or decreases the contrast of the hillshade.  Values\n             greater than one will cause intermediate values to move closer to\n@@ -1537,7 +1547,12 @@ class LightSource(object):\n         az = np.radians(90 - self.azdeg)\n         alt = np.radians(self.altdeg)\n \n-        dy, dx = np.gradient(elevation)\n+        # Because most image and raster GIS data has the first row in the array\n+        # as the \"top\" of the image, dy is implicitly negative.  This is\n+        # consistent to what `imshow` assumes, as well.\n+        dy = -dy\n+\n+        dy, dx = np.gradient(vert_exag * elevation, dy, dx)\n         slope = 0.5 * np.pi - np.arctan(np.hypot(dx, dy))\n         aspect = np.arctan2(dx, dy)\n         intensity = (np.sin(alt) * np.sin(slope) \n@@ -1552,30 +1567,101 @@ class LightSource(object):\n                 np.clip(intensity, 0, 1, intensity)\n         return intensity\n \n-    def shade(self, data, cmap, norm=None, **kwargs):\n-        \"\"\"\n-        Take the input data array, convert to HSV values in the\n-        given colormap, then adjust those color values\n-        to give the impression of a shaded relief map with a\n-        specified light source.\n-        RGBA values are returned, which can then be used to\n-        plot the shaded image with imshow.\n+    def shade(self, data, cmap, norm=None, vert_exag=1, dx=1, dy=1, fraction=1,\n+              **kwargs):\n         \"\"\"\n+        Combine colormapped data values with an illumination intensity map \n+        (a.k.a.  \"hillshade\") of the values.\n \n+        Parameters\n+        ----------\n+        data : array-like\n+            A 2d array (or equivalent) of the height values used to generate a\n+            shaded map.\n+        cmap : `~matplotlib.colors.Colormap` instance\n+            The colormap used to color the *data* array. Note that this must be\n+            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n+            passing in `cmap='gist_earth'`, use\n+            `cmap=plt.get_cmap('gist_earth')` instead.\n+        norm : `~matplotlib.colors.Normalize` instance, optional\n+            The normalization used to scale values before colormapping. If\n+            None, the input will be linearly scaled between its min and max.\n+        vert_exag : number, optional\n+            The amount to exaggerate the elevation values by when calculating\n+            illumination. This can be used either to correct for differences in\n+            units between the x-y coordinate system and the elevation\n+            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n+            or de-emphasize topography.\n+        dx : number, optional\n+            The x-spacing (columns) of the input *elevation* grid.\n+        dy : number, optional\n+            The y-spacing (rows) of the input *elevation* grid.\n+        fraction : number, optional\n+            Increases or decreases the contrast of the hillshade.  Values\n+            greater than one will cause intermediate values to move closer to\n+            full illumination or shadow (and clipping any values that move\n+            beyond 0 or 1).  Values less than one will cause full shadow or\n+            full illumination to move closer to a value of 0.5, thereby\n+            decreasing contrast.  Note that this is not mathematically or\n+            visually the same as increasing/decreasing the vertical\n+            exaggeration.\n+        Additional kwargs are passed on to the *blend_mode* function. \n+        \n+        Returns\n+        -------\n+        rgba : ndarray\n+            An MxNx4 array of floats ranging between 0-1.\n+        \"\"\"\n         if norm is None:\n             norm = Normalize(vmin=data.min(), vmax=data.max())\n \n         rgb0 = cmap(norm(data))\n-        rgb1 = self.shade_rgb(rgb0, elevation=data, **kwargs)\n-        rgb0[:, :, 0:3] = rgb1\n+        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode, \n+                              vert_exag=vert_exag, dx=dx, dy=dy, **kwargs)\n+        # Don't overwrite the alpha channel, if present.\n+        rgb0[..., :3] = rgb1[..., :3]\n         return rgb0\n \n-    def shade_rgb(self, rgb, elevation, fraction=1., **kwargs):\n+    def shade_rgb(self, rgb, elevation, fraction=1., vert_exag=1, dx=1, dy=1,\n+                  **kwargs):\n         \"\"\"\n         Take the input RGB array (ny*nx*3) adjust their color values\n         to given the impression of a shaded relief map with a\n         specified light source using the elevation (ny*nx).\n         A new RGB array ((ny*nx*3)) is returned.\n+\n+        Parameters\n+        ----------\n+        rgb : array-like\n+            An MxNx3 RGB array, assumed to be in the range of 0 to 1.\n+        elevation : array-like\n+            A 2d array (or equivalent) of the height values used to generate a\n+            shaded map.\n+        fraction : number\n+            Increases or decreases the contrast of the hillshade.  Values\n+            greater than one will cause intermediate values to move closer to\n+            full illumination or shadow (and clipping any values that move\n+            beyond 0 or 1).  Values less than one will cause full shadow or\n+            full illumination to move closer to a value of 0.5, thereby\n+            decreasing contrast.  Note that this is not mathematically or\n+            visually the same as increasing/decreasing the vertical\n+            exaggeration.\n+        vert_exag : number, optional\n+            The amount to exaggerate the elevation values by when calculating\n+            illumination. This can be used either to correct for differences in\n+            units between the x-y coordinate system and the elevation\n+            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n+            or de-emphasize topography.\n+        dx : number, optional\n+            The x-spacing (columns) of the input *elevation* grid.\n+        dy : number, optional\n+            The y-spacing (rows) of the input *elevation* grid.\n+        Additional kwargs are passed on to :meth:`blend_hsv`. \n+        \n+        Returns\n+        -------\n+        shaded_rgb : ndarray\n+            An MxNx3 array of floats ranging between 0-1.\n         \"\"\"\n         intensity = self.hillshade(elevation, fraction=fraction)\n         return self.blend_hsv(rgb, intensity, **kwargs)\n",
          "files_name_in_blame_commit": [
            "colors.py"
          ]
        }
      },
      "b5f348da9c3126e618dee700de37066602d378af": {
        "commit": {
          "commit_id": "b5f348da9c3126e618dee700de37066602d378af",
          "commit_message": "add support for image filtering in agg backend\n\nsvn path=/trunk/matplotlib/; revision=7488",
          "commit_author": "Jae-Joon Lee",
          "commit_date": "2009-08-14 18:11:05",
          "commit_parent": "1e6f21eb062d2c6b4723fb4d15310e45be4ca704"
        },
        "function": {
          "function_name": "shade_rgb",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "is_color_like",
            "set_bad",
            "is_gray",
            "autoscale",
            "_init",
            "rgb2hex",
            "rgb_to_hsv",
            "_set_extremes",
            "scaled",
            "from_list",
            "set_over",
            "hsv_to_rgb",
            "shade_rgb",
            "shade",
            "to_rgba_array",
            "hex2color",
            "inverse",
            "makeMappingArray",
            "__init__",
            "__call__",
            "autoscale_None",
            "to_rgba",
            "set_under",
            "to_rgb"
          ],
          "functions_name_all_files": [
            "close_group",
            "flipy",
            "get_ha",
            "resize",
            "get_style",
            "points_to_pixels",
            "print_png",
            "set_picker",
            "set_color",
            "get_visible",
            "_get_layout",
            "update_bbox_position_size",
            "set_fontname",
            "rgb2hex",
            "get_text_width_height_descent",
            "get_linestyle",
            "get_fontproperties",
            "stop_event_loop_default",
            "process_image",
            "shade",
            "kwdoc",
            "get_rotation",
            "_get_position_xy",
            "set_fontproperties",
            "set_gid",
            "_set_gc_clip",
            "set_linestyle",
            "set_font_properties",
            "stop_filter",
            "set_linespacing",
            "filtered_text",
            "save_figure",
            "get_alpha",
            "get_supported_filetypes_grouped",
            "set_dashpad",
            "get_valid_values",
            "draw",
            "prepare_image",
            "stop_rasterizing",
            "release_pan",
            "get_figure",
            "get_rasterized",
            "_iter_collection_raw_paths",
            "strip_math",
            "set_name",
            "_get_setters_and_targets",
            "__call__",
            "set_rasterized",
            "set_stretch",
            "set_zorder",
            "set_bbox",
            "press_zoom",
            "get_fontstretch",
            "switch_backends",
            "get_linewidth",
            "draw_path_collection",
            "get_gid",
            "new_figure_manager",
            "aliased_name_rest",
            "pprint_getters",
            "update_coords",
            "pprint_setters",
            "get_rotation_mode",
            "draw_gouraud_triangle",
            "get_name",
            "update",
            "is_alias",
            "set_foreground",
            "print_emf",
            "update_positions",
            "set_bad",
            "set_x",
            "_draw_bbox",
            "get_agg_filter",
            "convert_xunits",
            "get_default_filetype",
            "get_clip_rectangle",
            "get_width_height",
            "blit",
            "stop_event_loop",
            "set_dashrotation",
            "onRemove",
            "restore_region",
            "set_clip_on",
            "is_color_like",
            "set_fontstretch",
            "draw_tex",
            "clear",
            "show_popup",
            "get_fontfamily",
            "draw_image",
            "set_capstyle",
            "draw_mathtext",
            "draw_quad_mesh",
            "draw_event",
            "__str__",
            "set_variant",
            "hex2color",
            "get_stretch",
            "leave_notify_event",
            "get_dashpad",
            "get_setters",
            "_check_xy",
            "is_gray",
            "get_horizontalalignment",
            "autoscale",
            "rgb_to_hsv",
            "set_style",
            "drop_shadow_patches",
            "from_list",
            "set_position",
            "add_callback",
            "get_fontsize",
            "_update_methods",
            "button_press_event",
            "_process_text_args",
            "get_dashlength",
            "inverse",
            "_iter_collection",
            "set_dashdirection",
            "_get_xy",
            "get_zorder",
            "get_dashdirection",
            "draw_markers",
            "get_label",
            "pick",
            "drag_pan",
            "get_window_extent",
            "get_annotation_clip",
            "press_pan",
            "get_dashrotation",
            "set_rotation_mode",
            "release",
            "set_ha",
            "set_alpha",
            "set_multialignment",
            "have_units",
            "destroy",
            "_init_toolbar",
            "get_rgb",
            "set_snap",
            "set_fontsize",
            "set_text",
            "idle_event",
            "get_verticalalignment",
            "start_event_loop",
            "mpl_connect",
            "get_position",
            "set_joinstyle",
            "hitlist",
            "option_image_nocomposite",
            "set_url",
            "get_transformed_clip_path_and_affine",
            "aliased_name",
            "flush_events",
            "get_bbox_patch",
            "get_snap",
            "enter_notify_event",
            "get_picker",
            "hsv_to_rgb",
            "set_linewidth",
            "release_zoom",
            "dynamic_update",
            "pan",
            "set_hatch",
            "draw_rubberband",
            "start_event_loop_default",
            "makeMappingArray",
            "__init__",
            "get_url",
            "allow_rasterization",
            "contains",
            "set_animated",
            "set_cursor",
            "set_history_buttons",
            "set_visible",
            "set_family",
            "set_ma",
            "get_aliases",
            "open_group",
            "update_from",
            "shade_rgb",
            "get_color",
            "tostring_rgb",
            "draw_path",
            "to_rgba_array",
            "button_release_event",
            "set_annotation_clip",
            "_get_textbox",
            "set_clip_rectangle",
            "get_image_magnification",
            "_update_position_xytext",
            "get_va",
            "properties",
            "restore",
            "_init",
            "pickable",
            "_update_view",
            "set_weight",
            "get_fontweight",
            "get_fontvariant",
            "mouse_move",
            "motion_notify_event",
            "set_rotation",
            "get_animated",
            "pchanged",
            "set_agg_filter",
            "setp",
            "_get_multialignment",
            "set_fontvariant",
            "print_svg",
            "start_filter",
            "get_children",
            "findobj",
            "_update_enter_leave",
            "get_clip_on",
            "set",
            "get_hatch",
            "set_y",
            "get_variant",
            "get_prop_tup",
            "remove_callback",
            "set_figure",
            "remove",
            "home",
            "get_hatch_path",
            "push_current",
            "set_size",
            "get_clip_path",
            "drop_shadow_line",
            "get_axes",
            "set_label",
            "set_axes",
            "get_fontstyle",
            "autoscale_None",
            "mpl_disconnect",
            "light_filter_pie",
            "scroll_event",
            "set_transform",
            "get_antialiased",
            "onHilite",
            "draw_idle",
            "get_transform",
            "get_capstyle",
            "print_ps",
            "press",
            "scaled",
            "forward",
            "tostring_argb",
            "set_horizontalalignment",
            "set_over",
            "copy_from_bbox",
            "back",
            "set_va",
            "set_graylevel",
            "get_dashpush",
            "get_pad",
            "set_dashpush",
            "draw_cursor",
            "is_math_text",
            "start_rasterizing",
            "pprint_setters_rest",
            "resize_event",
            "set_dashlength",
            "get_canvas_width_height",
            "is_transform_set",
            "get_family",
            "set_antialiased",
            "key_release_event",
            "is_figure_set",
            "buffer_rgba",
            "get_joinstyle",
            "pick_event",
            "set_clip_box",
            "copy_properties",
            "set_fontweight",
            "draw_text",
            "set_contains",
            "set_backgroundcolor",
            "get_size",
            "set_under",
            "get_fontname",
            "_get_agg_font",
            "set_window_title",
            "new_gc",
            "get_text",
            "set_message",
            "get_clip_box",
            "zoom",
            "_set_current_renderer",
            "print_svgz",
            "get_dashes",
            "print_figure",
            "key_press_event",
            "to_rgba",
            "to_rgb",
            "convert_yunits",
            "set_fontstyle",
            "_set_extremes",
            "set_lod",
            "set_clip_path",
            "get_supported_filetypes",
            "_get_xy_display",
            "get_renderer",
            "get_font_properties",
            "get_contains",
            "print_eps",
            "get_texmanager",
            "getp",
            "full_screen_toggle",
            "get_weight",
            "set_verticalalignment",
            "print_raw",
            "print_pdf",
            "key_press",
            "set_dashes"
          ],
          "functions_name_co_evolved_modified_file": [
            "shade"
          ],
          "functions_name_co_evolved_all_files": [
            "start_rasterizing",
            "stop_filter",
            "filtered_text",
            "get_agg_filter",
            "drop_shadow_patches",
            "draw",
            "prepare_image",
            "stop_rasterizing",
            "_update_methods",
            "process_image",
            "set_agg_filter",
            "get_rasterized",
            "shade",
            "drop_shadow_line",
            "get_pad",
            "__init__",
            "__call__",
            "start_filter",
            "allow_rasterization",
            "light_filter_pie",
            "draw_markers"
          ]
        },
        "file": {
          "file_name": "colors.py",
          "file_nloc": 733,
          "file_complexity": 148,
          "file_token_count": 5509,
          "file_before": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of\ncolors called a colormap. Colormapping typically involves two steps:\na data array is first mapped onto the range 0-1 using an instance\nof :class:`Normalize` or of a subclass; then this number in the 0-1\nrange is mapped to a color using an instance of a subclass of\n:class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all\nthe built-in colormap instances, but is also useful for making\ncustom colormaps, and :class:`ListedColormap`, which is used for\ngenerating a custom colormap from a list of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single\ncolor specifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic builtin colors, you can use a single letter\n\n    - b  : blue\n    - g  : green\n    - r  : red\n    - c  : cyan\n    - m  : magenta\n    - y  : yellow\n    - k  : black\n    - w  : white\n\nGray shades can be given as a string encoding a float in the 0-1\nrange, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify\nthe color using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B*\nare in the range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and\n'chartreuse' are supported.\n\"\"\"\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\nparts = np.__version__.split('.')\nNP_MAJOR, NP_MINOR = map(int, parts[:2])\n# true if clip supports the out kwarg\nNP_CLIP_OUT = NP_MAJOR>=1 and NP_MINOR>=2\n\ncnames = {\n    'aliceblue'            : '#F0F8FF',\n    'antiquewhite'         : '#FAEBD7',\n    'aqua'                 : '#00FFFF',\n    'aquamarine'           : '#7FFFD4',\n    'azure'                : '#F0FFFF',\n    'beige'                : '#F5F5DC',\n    'bisque'               : '#FFE4C4',\n    'black'                : '#000000',\n    'blanchedalmond'       : '#FFEBCD',\n    'blue'                 : '#0000FF',\n    'blueviolet'           : '#8A2BE2',\n    'brown'                : '#A52A2A',\n    'burlywood'            : '#DEB887',\n    'cadetblue'            : '#5F9EA0',\n    'chartreuse'           : '#7FFF00',\n    'chocolate'            : '#D2691E',\n    'coral'                : '#FF7F50',\n    'cornflowerblue'       : '#6495ED',\n    'cornsilk'             : '#FFF8DC',\n    'crimson'              : '#DC143C',\n    'cyan'                 : '#00FFFF',\n    'darkblue'             : '#00008B',\n    'darkcyan'             : '#008B8B',\n    'darkgoldenrod'        : '#B8860B',\n    'darkgray'             : '#A9A9A9',\n    'darkgreen'            : '#006400',\n    'darkkhaki'            : '#BDB76B',\n    'darkmagenta'          : '#8B008B',\n    'darkolivegreen'       : '#556B2F',\n    'darkorange'           : '#FF8C00',\n    'darkorchid'           : '#9932CC',\n    'darkred'              : '#8B0000',\n    'darksalmon'           : '#E9967A',\n    'darkseagreen'         : '#8FBC8F',\n    'darkslateblue'        : '#483D8B',\n    'darkslategray'        : '#2F4F4F',\n    'darkturquoise'        : '#00CED1',\n    'darkviolet'           : '#9400D3',\n    'deeppink'             : '#FF1493',\n    'deepskyblue'          : '#00BFFF',\n    'dimgray'              : '#696969',\n    'dodgerblue'           : '#1E90FF',\n    'firebrick'            : '#B22222',\n    'floralwhite'          : '#FFFAF0',\n    'forestgreen'          : '#228B22',\n    'fuchsia'              : '#FF00FF',\n    'gainsboro'            : '#DCDCDC',\n    'ghostwhite'           : '#F8F8FF',\n    'gold'                 : '#FFD700',\n    'goldenrod'            : '#DAA520',\n    'gray'                 : '#808080',\n    'green'                : '#008000',\n    'greenyellow'          : '#ADFF2F',\n    'honeydew'             : '#F0FFF0',\n    'hotpink'              : '#FF69B4',\n    'indianred'            : '#CD5C5C',\n    'indigo'               : '#4B0082',\n    'ivory'                : '#FFFFF0',\n    'khaki'                : '#F0E68C',\n    'lavender'             : '#E6E6FA',\n    'lavenderblush'        : '#FFF0F5',\n    'lawngreen'            : '#7CFC00',\n    'lemonchiffon'         : '#FFFACD',\n    'lightblue'            : '#ADD8E6',\n    'lightcoral'           : '#F08080',\n    'lightcyan'            : '#E0FFFF',\n    'lightgoldenrodyellow' : '#FAFAD2',\n    'lightgreen'           : '#90EE90',\n    'lightgrey'            : '#D3D3D3',\n    'lightpink'            : '#FFB6C1',\n    'lightsalmon'          : '#FFA07A',\n    'lightseagreen'        : '#20B2AA',\n    'lightskyblue'         : '#87CEFA',\n    'lightslategray'       : '#778899',\n    'lightsteelblue'       : '#B0C4DE',\n    'lightyellow'          : '#FFFFE0',\n    'lime'                 : '#00FF00',\n    'limegreen'            : '#32CD32',\n    'linen'                : '#FAF0E6',\n    'magenta'              : '#FF00FF',\n    'maroon'               : '#800000',\n    'mediumaquamarine'     : '#66CDAA',\n    'mediumblue'           : '#0000CD',\n    'mediumorchid'         : '#BA55D3',\n    'mediumpurple'         : '#9370DB',\n    'mediumseagreen'       : '#3CB371',\n    'mediumslateblue'      : '#7B68EE',\n    'mediumspringgreen'    : '#00FA9A',\n    'mediumturquoise'      : '#48D1CC',\n    'mediumvioletred'      : '#C71585',\n    'midnightblue'         : '#191970',\n    'mintcream'            : '#F5FFFA',\n    'mistyrose'            : '#FFE4E1',\n    'moccasin'             : '#FFE4B5',\n    'navajowhite'          : '#FFDEAD',\n    'navy'                 : '#000080',\n    'oldlace'              : '#FDF5E6',\n    'olive'                : '#808000',\n    'olivedrab'            : '#6B8E23',\n    'orange'               : '#FFA500',\n    'orangered'            : '#FF4500',\n    'orchid'               : '#DA70D6',\n    'palegoldenrod'        : '#EEE8AA',\n    'palegreen'            : '#98FB98',\n    'palevioletred'        : '#AFEEEE',\n    'papayawhip'           : '#FFEFD5',\n    'peachpuff'            : '#FFDAB9',\n    'peru'                 : '#CD853F',\n    'pink'                 : '#FFC0CB',\n    'plum'                 : '#DDA0DD',\n    'powderblue'           : '#B0E0E6',\n    'purple'               : '#800080',\n    'red'                  : '#FF0000',\n    'rosybrown'            : '#BC8F8F',\n    'royalblue'            : '#4169E1',\n    'saddlebrown'          : '#8B4513',\n    'salmon'               : '#FA8072',\n    'sandybrown'           : '#FAA460',\n    'seagreen'             : '#2E8B57',\n    'seashell'             : '#FFF5EE',\n    'sienna'               : '#A0522D',\n    'silver'               : '#C0C0C0',\n    'skyblue'              : '#87CEEB',\n    'slateblue'            : '#6A5ACD',\n    'slategray'            : '#708090',\n    'snow'                 : '#FFFAFA',\n    'springgreen'          : '#00FF7F',\n    'steelblue'            : '#4682B4',\n    'tan'                  : '#D2B48C',\n    'teal'                 : '#008080',\n    'thistle'              : '#D8BFD8',\n    'tomato'               : '#FF6347',\n    'turquoise'            : '#40E0D0',\n    'violet'               : '#EE82EE',\n    'wheat'                : '#F5DEB3',\n    'white'                : '#FFFFFF',\n    'whitesmoke'           : '#F5F5F5',\n    'yellow'               : '#FFFF00',\n    'yellowgreen'          : '#9ACD32',\n    }\n\n\n# add british equivs\nfor k, v in cnames.items():\n    if k.find('gray')>=0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given a len 3 rgb tuple of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([round(val*255) for val in rgb])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, basestring):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16)/255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\nclass ColorConverter:\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b' : (0.0, 0.0, 1.0),\n        'g' : (0.0, 0.5, 0.0),\n        'r' : (1.0, 0.0, 0.0),\n        'c' : (0.0, 0.75, 0.75),\n        'm' : (0.75, 0, 0.75),\n        'y' : (0.75, 0.75, 0),\n        'k' : (0.0, 0.0, 0.0),\n        'w' : (1.0, 1.0, 1.0),\n        }\n\n    cache = {}\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a float, like '0.4', indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        try: return self.cache[arg]\n        except KeyError: pass\n        except TypeError: # could be unhashable rgb seq\n            arg = tuple(arg)\n            try: return self.cache[arg]\n            except KeyError: pass\n            except TypeError:\n                raise ValueError(\n                      'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                   'gray (string) must be in range 0-1')\n                        color = tuple([fl]*3)\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                           'sequence length is %d; must be 3 or 4'%len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or  (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError('number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError('cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError), exc:\n            raise ValueError('to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if [x for x in arg if (float(x) < 0) or  (x > 1)]:\n                        # This will raise TypeError if x is not a number.\n                        raise ValueError('number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                r,g,b = arg[:3]\n                if [x for x in (r,g,b) if (float(x) < 0) or  (x > 1)]:\n                    raise ValueError('number in rbg sequence outside 0-1 range')\n            else:\n                r,g,b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r,g,b,alpha\n        except (TypeError, ValueError), exc:\n            raise ValueError('to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0,4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    # looks like rgba already, nothing to be done; do\n                    # we want to apply alpha here if\n                    # (c[:,3]==1).all() ?\n                    return np.asarray(c, np.float)\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\ncolorConverter = ColorConverter()\n\ndef makeMappingArray(N, data):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x  = adata[:,0]\n    y0 = adata[:,1]\n    y1 = adata[:,2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n           \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x)-x):\n        raise ValueError(\n           \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N-1)\n    lut = np.zeros((N,), np.float)\n    xind = np.arange(float(N))\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = ( ((xind[1:-1] - x[ind-1]) / (x[ind] - x[ind-1]))\n                  * (y0[ind] - y1[ind-1]) + y1[ind-1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap:\n    \"\"\"Base class for all scalar to rgb mappings\n\n        Important methods:\n\n            * :meth:`set_bad`\n            * :meth:`set_under`\n            * :meth:`set_over`\n    \"\"\"\n    def __init__(self, name, N=256):\n        \"\"\"\n        Public class attributes:\n            :attr:`N` : number of rgb quantization levels\n            :attr:`name` : name of colormap\n\n        \"\"\"\n        self.name = name\n        self.N = N\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0) # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = N\n        self._i_over = N+1\n        self._i_bad = N+2\n        self._isinit = False\n\n\n    def __call__(self, X, alpha=1.0, bytes=False):\n        \"\"\"\n        *X* is either a scalar or an array (of any dimension).\n        If scalar, a tuple of rgba values is returned, otherwise\n        an array with the new shape = oldshape+(4,). If the X-values\n        are integers, then they are used as indices into the array.\n        If they are floating point, then they must be in the\n        interval (0.0, 1.0).\n        Alpha must be a scalar.\n        If bytes is False, the rgba values will be floats on a\n        0-1 scale; if True, they will be uint8, 0-255.\n        \"\"\"\n\n        if not self._isinit: self._init()\n        alpha = min(alpha, 1.0) # alpha must be between 0 and 1\n        alpha = max(alpha, 0.0)\n        self._lut[:-1,-1] = alpha  # Don't assign global alpha to i_bad;\n                                   # it would defeat the purpose of the\n                                   # default behavior, which is to not\n                                   # show anything where data are missing.\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            # force a copy here -- the ma.array and filled functions\n            # do force a cop of the data by default - JDH\n            xma = ma.array(X, copy=True)\n            xa = xma.filled(0)\n            mask_bad = ma.getmask(xma)\n        if xa.dtype.char in np.typecodes['Float']:\n            np.putmask(xa, xa==1.0, 0.9999999) #Treat 1.0 as slightly less than 1.\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            if NP_CLIP_OUT:\n                np.clip(xa * self.N, -1, self.N, out=xa)\n            else:\n                xa = np.clip(xa * self.N, -1, self.N)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        np.putmask(xa, xa>self.N-1, self._i_over)\n        np.putmask(xa, xa<0, self._i_under)\n        if mask_bad is not None and mask_bad.shape == xa.shape:\n            np.putmask(xa, mask_bad, self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut\n        rgba = np.empty(shape=xa.shape+(4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0,:])\n        return rgba\n\n    def set_bad(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for masked values.\n        '''\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def set_under(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        '''\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def set_over(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        '''\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N-1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init():\n        '''Generate the lookup table, self._lut'''\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit: self._init()\n        return (np.alltrue(self._lut[:,0] == self._lut[:,1])\n                    and np.alltrue(self._lut[:,0] == self._lut[:,2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n            :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        self.monochrome = False  # True only if all colors in map are identical;\n                                 # needed for contouring.\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(self.N, self._segmentdata['red'])\n        self._lut[:-3, 1] = makeMappingArray(self.N, self._segmentdata['green'])\n        self._lut[:-3, 2] = makeMappingArray(self.N, self._segmentdata['blue'])\n        self._isinit = True\n        self._set_extremes()\n\n    @staticmethod\n    def from_list(name, colors, N=256):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=1\n        to colors[-1] at val=1.  N is the number of rgb quantization\n        levels.\n        \"\"\"\n\n        ncolors = len(colors)\n        vals = np.linspace(0., 1., ncolors)\n\n        cdict = dict(red=[], green=[], blue=[])\n        for val, color in zip(vals, colors):\n            r,g,b = colorConverter.to_rgb(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n\n        return LinearSegmentedColormap(name, cdict, N)\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name = 'from_list', N = None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 floating point array (*N* rgb values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are identical;\n                                 # needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors) # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try: gray = float(self.colors)\n                except TypeError: pass\n                else:  self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n\n    def _init(self):\n        rgb = np.array([colorConverter.to_rgb(c)\n                    for c in self.colors], np.float)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3, :-1] = rgb\n        self._lut[:-3, -1] = 1\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize:\n    \"\"\"\n    Normalize a given value to the 0-1 range\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        if cbook.iterable(value):\n            vtype = 'array'\n            val = ma.asarray(value).astype(np.float)\n        else:\n            vtype = 'scalar'\n            val = ma.array([value]).astype(np.float)\n\n        self.autoscale_None(val)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin==vmax:\n            return 0.0 * val\n        else:\n            if clip:\n                mask = ma.getmask(val)\n                val = ma.array(np.clip(val.filled(vmax), vmin, vmax),\n                                mask=mask)\n            result = (val-vmin) * (1.0/(vmax-vmin))\n        if vtype == 'scalar':\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n\n    def autoscale(self, A):\n        '''\n        Set *vmin*, *vmax* to min, max of *A*.\n        '''\n        self.vmin = ma.minimum(A)\n        self.vmax = ma.maximum(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None: self.vmin = ma.minimum(A)\n        if self.vmax is None: self.vmax = ma.maximum(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        if cbook.iterable(value):\n            vtype = 'array'\n            val = ma.asarray(value).astype(np.float)\n        else:\n            vtype = 'scalar'\n            val = ma.array([value]).astype(np.float)\n\n        self.autoscale_None(val)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin<=0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin==vmax:\n            return 0.0 * val\n        else:\n            if clip:\n                mask = ma.getmask(val)\n                val = ma.array(np.clip(val.filled(vmax), vmin, vmax),\n                                mask=mask)\n            result = (ma.log(val)-np.log(vmin))/(np.log(vmax)-np.log(vmin))\n        if vtype == 'scalar':\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax/vmin), val)\n        else:\n            return vmin * pow((vmax/vmin), value)\n\nclass BoundaryNorm(Normalize):\n    '''\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    '''\n    def __init__(self, boundaries, ncolors, clip=False):\n        '''\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        '''\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N-1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax+1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx>=b] = i\n        if self._interp:\n            iret = (iret * (float(self.Ncmap-1)/(self.N-2))).astype(np.int16)\n        iret[xx<self.vmin] = -1\n        iret[xx>=self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    '''\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    '''\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = Normalize\nno_norm = NoNorm\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert rgb values in a numpy array to hsv values\n    input and output arrays should have shape (M,N,3)\n    \"\"\"\n    out = np.empty_like(arr)\n    arr_max = arr.max(-1)\n    delta = arr.ptp(-1)\n    s = delta / arr_max\n    s[delta==0] = 0\n    # red is max\n    idx = (arr[:,:,0] == arr_max)\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[:,:,1] == arr_max)\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0] ) / delta[idx]\n    # blue is max\n    idx = (arr[:,:,2] == arr_max)\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1] ) / delta[idx]\n    out[:,:,0] = (out[:,:,0]/6.0) % 1.0\n    out[:,:,1] = s\n    out[:,:,2] = arr_max\n    return out\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    both input and output arrays have shape (M,N,3)\n    \"\"\"\n    h = hsv[:,:,0]; s = hsv[:,:,1]; v = hsv[:,:,2]\n    r = np.empty_like(h); g = np.empty_like(h); b = np.empty_like(h)\n    i = (h*6.0).astype(np.int)\n    f = (h*6.0) - i\n    p = v*(1.0 - s)\n    q = v*(1.0 - s*f)\n    t = v*(1.0 - s*(1.0-f))\n    idx = i%6 == 0\n    r[idx] = v[idx]; g[idx] = t[idx]; b[idx] = p[idx]\n    idx = i == 1\n    r[idx] = q[idx]; g[idx] = v[idx]; b[idx] = p[idx]\n    idx = i == 2\n    r[idx] = p[idx]; g[idx] = v[idx]; b[idx] = t[idx]\n    idx = i == 3\n    r[idx] = p[idx]; g[idx] = q[idx]; b[idx] = v[idx]\n    idx = i == 4\n    r[idx] = t[idx]; g[idx] = p[idx]; b[idx] = v[idx]\n    idx = i == 5\n    r[idx] = v[idx]; g[idx] = p[idx]; b[idx] = q[idx]\n    idx = s == 0\n    r[idx] = v[idx]; g[idx] = v[idx]; b[idx] = v[idx]\n    rgb = np.empty_like(hsv)\n    rgb[:,:,0]=r; rgb[:,:,1]=g; rgb[:,:,2]=b\n    return rgb\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n    The :meth:`shade` is used to produce rgb values for a shaded relief image\n    given a data array.\n    \"\"\"\n    def __init__(self,azdeg=315,altdeg=45,\\\n                 hsv_min_val=0,hsv_max_val=1,hsv_min_sat=1,hsv_max_sat=0):\n       \"\"\"\n       Specify the azimuth (measured clockwise from south) and altitude\n       (measured up from the plane of the surface) of the light source\n       in degrees.\n\n       The color of the resulting image will be darkened\n       by moving the (s,v) values (in hsv colorspace) toward\n       (hsv_min_sat, hsv_min_val) in the shaded regions, or\n       lightened by sliding (s,v) toward\n       (hsv_max_sat hsv_max_val) in regions that are illuminated.\n       The default extremes are chose so that completely shaded points\n       are nearly black (s = 1, v = 0) and completely illuminated points\n       are nearly white (s = 0, v = 1).\n       \"\"\"\n       self.azdeg = azdeg\n       self.altdeg = altdeg\n       self.hsv_min_val = hsv_min_val\n       self.hsv_max_val = hsv_max_val\n       self.hsv_min_sat = hsv_min_sat\n       self.hsv_max_sat = hsv_max_sat\n\n    def shade(self,data,cmap):\n        \"\"\"\n        Take the input data array, convert to HSV values in the\n        given colormap, then adjust those color values\n        to given the impression of a shaded relief map with a\n        specified light source.\n        RGBA values are returned, which can then be used to\n        plot the shaded image with imshow.\n        \"\"\"\n        # imagine an artificial sun placed at infinity in\n        # some azimuth and elevation position illuminating our surface. The parts of\n        # the surface that slope toward the sun should brighten while those sides\n        # facing away should become darker.\n        # convert alt, az to radians\n        az = self.azdeg*np.pi/180.0\n        alt = self.altdeg*np.pi/180.0\n        # gradient in x and y directions\n        dx, dy = np.gradient(data)\n        slope = 0.5*np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = np.sin(alt)*np.sin(slope) + np.cos(alt)*np.cos(slope)*np.cos(-az -\\\n                aspect - 0.5*np.pi)\n        # rescale to interval -1,1\n        # +1 means maximum sun exposure and -1 means complete shade.\n        intensity = (intensity - intensity.min())/(intensity.max() - intensity.min())\n        intensity = 2.*intensity - 1.\n        # convert to rgb, then rgb to hsv\n        rgb = cmap((data-data.min())/(data.max()-data.min()))\n        hsv = rgb_to_hsv(rgb[:,:,0:3])\n        # modify hsv values to simulate illumination.\n        hsv[:,:,1] = np.where(np.logical_and(np.abs(hsv[:,:,1])>1.e-10,intensity>0),\\\n                (1.-intensity)*hsv[:,:,1]+intensity*self.hsv_max_sat, hsv[:,:,1])\n        hsv[:,:,2] = np.where(intensity > 0, (1.-intensity)*hsv[:,:,2] +\\\n                intensity*self.hsv_max_val, hsv[:,:,2])\n        hsv[:,:,1] = np.where(np.logical_and(np.abs(hsv[:,:,1])>1.e-10,intensity<0),\\\n                (1.+intensity)*hsv[:,:,1]-intensity*self.hsv_min_sat, hsv[:,:,1])\n        hsv[:,:,2] = np.where(intensity < 0, (1.+intensity)*hsv[:,:,2] -\\\n                intensity*self.hsv_min_val, hsv[:,:,2])\n        hsv[:,:,1:] = np.where(hsv[:,:,1:]<0.,0,hsv[:,:,1:])\n        hsv[:,:,1:] = np.where(hsv[:,:,1:]>1.,1,hsv[:,:,1:])\n        # convert modified hsv back to rgb.\n        rgb[:,:,0:3] = hsv_to_rgb(hsv)\n        return rgb\n",
          "file_after": "\"\"\"\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of\ncolors called a colormap. Colormapping typically involves two steps:\na data array is first mapped onto the range 0-1 using an instance\nof :class:`Normalize` or of a subclass; then this number in the 0-1\nrange is mapped to a color using an instance of a subclass of\n:class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which is used to generate all\nthe built-in colormap instances, but is also useful for making\ncustom colormaps, and :class:`ListedColormap`, which is used for\ngenerating a custom colormap from a list of color specifications.\n\nThe module also provides a single instance, *colorConverter*, of the\n:class:`ColorConverter` class providing methods for converting single\ncolor specifications or sequences of them to *RGB* or *RGBA*.\n\nCommands which take color arguments can use several formats to specify\nthe colors.  For the basic builtin colors, you can use a single letter\n\n    - b  : blue\n    - g  : green\n    - r  : red\n    - c  : cyan\n    - m  : magenta\n    - y  : yellow\n    - k  : black\n    - w  : white\n\nGray shades can be given as a string encoding a float in the 0-1\nrange, e.g.::\n\n    color = '0.75'\n\nFor a greater range of colors, you have two options.  You can specify\nthe color using an html hex string, as in::\n\n      color = '#eeefff'\n\nor you can pass an *R* , *G* , *B* tuple, where each of *R* , *G* , *B*\nare in the range [0,1].\n\nFinally, legal html names for colors, like 'red', 'burlywood' and\n'chartreuse' are supported.\n\"\"\"\nimport re\nimport numpy as np\nfrom numpy import ma\nimport matplotlib.cbook as cbook\n\nparts = np.__version__.split('.')\nNP_MAJOR, NP_MINOR = map(int, parts[:2])\n# true if clip supports the out kwarg\nNP_CLIP_OUT = NP_MAJOR>=1 and NP_MINOR>=2\n\ncnames = {\n    'aliceblue'            : '#F0F8FF',\n    'antiquewhite'         : '#FAEBD7',\n    'aqua'                 : '#00FFFF',\n    'aquamarine'           : '#7FFFD4',\n    'azure'                : '#F0FFFF',\n    'beige'                : '#F5F5DC',\n    'bisque'               : '#FFE4C4',\n    'black'                : '#000000',\n    'blanchedalmond'       : '#FFEBCD',\n    'blue'                 : '#0000FF',\n    'blueviolet'           : '#8A2BE2',\n    'brown'                : '#A52A2A',\n    'burlywood'            : '#DEB887',\n    'cadetblue'            : '#5F9EA0',\n    'chartreuse'           : '#7FFF00',\n    'chocolate'            : '#D2691E',\n    'coral'                : '#FF7F50',\n    'cornflowerblue'       : '#6495ED',\n    'cornsilk'             : '#FFF8DC',\n    'crimson'              : '#DC143C',\n    'cyan'                 : '#00FFFF',\n    'darkblue'             : '#00008B',\n    'darkcyan'             : '#008B8B',\n    'darkgoldenrod'        : '#B8860B',\n    'darkgray'             : '#A9A9A9',\n    'darkgreen'            : '#006400',\n    'darkkhaki'            : '#BDB76B',\n    'darkmagenta'          : '#8B008B',\n    'darkolivegreen'       : '#556B2F',\n    'darkorange'           : '#FF8C00',\n    'darkorchid'           : '#9932CC',\n    'darkred'              : '#8B0000',\n    'darksalmon'           : '#E9967A',\n    'darkseagreen'         : '#8FBC8F',\n    'darkslateblue'        : '#483D8B',\n    'darkslategray'        : '#2F4F4F',\n    'darkturquoise'        : '#00CED1',\n    'darkviolet'           : '#9400D3',\n    'deeppink'             : '#FF1493',\n    'deepskyblue'          : '#00BFFF',\n    'dimgray'              : '#696969',\n    'dodgerblue'           : '#1E90FF',\n    'firebrick'            : '#B22222',\n    'floralwhite'          : '#FFFAF0',\n    'forestgreen'          : '#228B22',\n    'fuchsia'              : '#FF00FF',\n    'gainsboro'            : '#DCDCDC',\n    'ghostwhite'           : '#F8F8FF',\n    'gold'                 : '#FFD700',\n    'goldenrod'            : '#DAA520',\n    'gray'                 : '#808080',\n    'green'                : '#008000',\n    'greenyellow'          : '#ADFF2F',\n    'honeydew'             : '#F0FFF0',\n    'hotpink'              : '#FF69B4',\n    'indianred'            : '#CD5C5C',\n    'indigo'               : '#4B0082',\n    'ivory'                : '#FFFFF0',\n    'khaki'                : '#F0E68C',\n    'lavender'             : '#E6E6FA',\n    'lavenderblush'        : '#FFF0F5',\n    'lawngreen'            : '#7CFC00',\n    'lemonchiffon'         : '#FFFACD',\n    'lightblue'            : '#ADD8E6',\n    'lightcoral'           : '#F08080',\n    'lightcyan'            : '#E0FFFF',\n    'lightgoldenrodyellow' : '#FAFAD2',\n    'lightgreen'           : '#90EE90',\n    'lightgrey'            : '#D3D3D3',\n    'lightpink'            : '#FFB6C1',\n    'lightsalmon'          : '#FFA07A',\n    'lightseagreen'        : '#20B2AA',\n    'lightskyblue'         : '#87CEFA',\n    'lightslategray'       : '#778899',\n    'lightsteelblue'       : '#B0C4DE',\n    'lightyellow'          : '#FFFFE0',\n    'lime'                 : '#00FF00',\n    'limegreen'            : '#32CD32',\n    'linen'                : '#FAF0E6',\n    'magenta'              : '#FF00FF',\n    'maroon'               : '#800000',\n    'mediumaquamarine'     : '#66CDAA',\n    'mediumblue'           : '#0000CD',\n    'mediumorchid'         : '#BA55D3',\n    'mediumpurple'         : '#9370DB',\n    'mediumseagreen'       : '#3CB371',\n    'mediumslateblue'      : '#7B68EE',\n    'mediumspringgreen'    : '#00FA9A',\n    'mediumturquoise'      : '#48D1CC',\n    'mediumvioletred'      : '#C71585',\n    'midnightblue'         : '#191970',\n    'mintcream'            : '#F5FFFA',\n    'mistyrose'            : '#FFE4E1',\n    'moccasin'             : '#FFE4B5',\n    'navajowhite'          : '#FFDEAD',\n    'navy'                 : '#000080',\n    'oldlace'              : '#FDF5E6',\n    'olive'                : '#808000',\n    'olivedrab'            : '#6B8E23',\n    'orange'               : '#FFA500',\n    'orangered'            : '#FF4500',\n    'orchid'               : '#DA70D6',\n    'palegoldenrod'        : '#EEE8AA',\n    'palegreen'            : '#98FB98',\n    'palevioletred'        : '#AFEEEE',\n    'papayawhip'           : '#FFEFD5',\n    'peachpuff'            : '#FFDAB9',\n    'peru'                 : '#CD853F',\n    'pink'                 : '#FFC0CB',\n    'plum'                 : '#DDA0DD',\n    'powderblue'           : '#B0E0E6',\n    'purple'               : '#800080',\n    'red'                  : '#FF0000',\n    'rosybrown'            : '#BC8F8F',\n    'royalblue'            : '#4169E1',\n    'saddlebrown'          : '#8B4513',\n    'salmon'               : '#FA8072',\n    'sandybrown'           : '#FAA460',\n    'seagreen'             : '#2E8B57',\n    'seashell'             : '#FFF5EE',\n    'sienna'               : '#A0522D',\n    'silver'               : '#C0C0C0',\n    'skyblue'              : '#87CEEB',\n    'slateblue'            : '#6A5ACD',\n    'slategray'            : '#708090',\n    'snow'                 : '#FFFAFA',\n    'springgreen'          : '#00FF7F',\n    'steelblue'            : '#4682B4',\n    'tan'                  : '#D2B48C',\n    'teal'                 : '#008080',\n    'thistle'              : '#D8BFD8',\n    'tomato'               : '#FF6347',\n    'turquoise'            : '#40E0D0',\n    'violet'               : '#EE82EE',\n    'wheat'                : '#F5DEB3',\n    'white'                : '#FFFFFF',\n    'whitesmoke'           : '#F5F5F5',\n    'yellow'               : '#FFFF00',\n    'yellowgreen'          : '#9ACD32',\n    }\n\n\n# add british equivs\nfor k, v in cnames.items():\n    if k.find('gray')>=0:\n        k = k.replace('gray', 'grey')\n        cnames[k] = v\n\ndef is_color_like(c):\n    'Return *True* if *c* can be converted to *RGB*'\n    try:\n        colorConverter.to_rgb(c)\n        return True\n    except ValueError:\n        return False\n\n\ndef rgb2hex(rgb):\n    'Given a len 3 rgb tuple of 0-1 floats, return the hex string'\n    return '#%02x%02x%02x' % tuple([round(val*255) for val in rgb])\n\nhexColorPattern = re.compile(\"\\A#[a-fA-F0-9]{6}\\Z\")\n\ndef hex2color(s):\n    \"\"\"\n    Take a hex string *s* and return the corresponding rgb 3-tuple\n    Example: #efefef -> (0.93725, 0.93725, 0.93725)\n    \"\"\"\n    if not isinstance(s, basestring):\n        raise TypeError('hex2color requires a string argument')\n    if hexColorPattern.match(s) is None:\n        raise ValueError('invalid hex color string \"%s\"' % s)\n    return tuple([int(n, 16)/255.0 for n in (s[1:3], s[3:5], s[5:7])])\n\nclass ColorConverter:\n    \"\"\"\n    Provides methods for converting color specifications to *RGB* or *RGBA*\n\n    Caching is used for more efficient conversion upon repeated calls\n    with the same argument.\n\n    Ordinarily only the single instance instantiated in this module,\n    *colorConverter*, is needed.\n    \"\"\"\n    colors = {\n        'b' : (0.0, 0.0, 1.0),\n        'g' : (0.0, 0.5, 0.0),\n        'r' : (1.0, 0.0, 0.0),\n        'c' : (0.0, 0.75, 0.75),\n        'm' : (0.75, 0, 0.75),\n        'y' : (0.75, 0.75, 0),\n        'k' : (0.0, 0.0, 0.0),\n        'w' : (1.0, 1.0, 1.0),\n        }\n\n    cache = {}\n    def to_rgb(self, arg):\n        \"\"\"\n        Returns an *RGB* tuple of three floats from 0-1.\n\n        *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n        several forms:\n\n            1) a letter from the set 'rgbcmykw'\n            2) a hex color string, like '#00FFFF'\n            3) a standard name, like 'aqua'\n            4) a float, like '0.4', indicating gray on a 0-1 scale\n\n        if *arg* is *RGBA*, the *A* will simply be discarded.\n        \"\"\"\n        try: return self.cache[arg]\n        except KeyError: pass\n        except TypeError: # could be unhashable rgb seq\n            arg = tuple(arg)\n            try: return self.cache[arg]\n            except KeyError: pass\n            except TypeError:\n                raise ValueError(\n                      'to_rgb: arg \"%s\" is unhashable even inside a tuple'\n                                    % (str(arg),))\n\n        try:\n            if cbook.is_string_like(arg):\n                argl = arg.lower()\n                color = self.colors.get(argl, None)\n                if color is None:\n                    str1 = cnames.get(argl, argl)\n                    if str1.startswith('#'):\n                        color = hex2color(str1)\n                    else:\n                        fl = float(argl)\n                        if fl < 0 or fl > 1:\n                            raise ValueError(\n                                   'gray (string) must be in range 0-1')\n                        color = tuple([fl]*3)\n            elif cbook.iterable(arg):\n                if len(arg) > 4 or len(arg) < 3:\n                    raise ValueError(\n                           'sequence length is %d; must be 3 or 4'%len(arg))\n                color = tuple(arg[:3])\n                if [x for x in color if (float(x) < 0) or  (x > 1)]:\n                    # This will raise TypeError if x is not a number.\n                    raise ValueError('number in rbg sequence outside 0-1 range')\n            else:\n                raise ValueError('cannot convert argument to rgb sequence')\n\n            self.cache[arg] = color\n\n        except (KeyError, ValueError, TypeError), exc:\n            raise ValueError('to_rgb: Invalid rgb arg \"%s\"\\n%s' % (str(arg), exc))\n            # Error messages could be improved by handling TypeError\n            # separately; but this should be rare and not too hard\n            # for the user to figure out as-is.\n        return color\n\n    def to_rgba(self, arg, alpha=None):\n        \"\"\"\n        Returns an *RGBA* tuple of four floats from 0-1.\n\n        For acceptable values of *arg*, see :meth:`to_rgb`.\n        In addition, if *arg* is \"none\" (case-insensitive),\n        then (0,0,0,0) will be returned.\n        If *arg* is an *RGBA* sequence and *alpha* is not *None*,\n        *alpha* will replace the original *A*.\n        \"\"\"\n        try:\n            if arg.lower() == 'none':\n                return (0.0, 0.0, 0.0, 0.0)\n        except AttributeError:\n            pass\n\n        try:\n            if not cbook.is_string_like(arg) and cbook.iterable(arg):\n                if len(arg) == 4:\n                    if [x for x in arg if (float(x) < 0) or  (x > 1)]:\n                        # This will raise TypeError if x is not a number.\n                        raise ValueError('number in rbga sequence outside 0-1 range')\n                    if alpha is None:\n                        return tuple(arg)\n                    if alpha < 0.0 or alpha > 1.0:\n                        raise ValueError(\"alpha must be in range 0-1\")\n                    return arg[0], arg[1], arg[2], alpha\n                r,g,b = arg[:3]\n                if [x for x in (r,g,b) if (float(x) < 0) or  (x > 1)]:\n                    raise ValueError('number in rbg sequence outside 0-1 range')\n            else:\n                r,g,b = self.to_rgb(arg)\n            if alpha is None:\n                alpha = 1.0\n            return r,g,b,alpha\n        except (TypeError, ValueError), exc:\n            raise ValueError('to_rgba: Invalid rgba arg \"%s\"\\n%s' % (str(arg), exc))\n\n    def to_rgba_array(self, c, alpha=None):\n        \"\"\"\n        Returns a numpy array of *RGBA* tuples.\n\n        Accepts a single mpl color spec or a sequence of specs.\n\n        Special case to handle \"no color\": if *c* is \"none\" (case-insensitive),\n        then an empty array will be returned.  Same for an empty list.\n        \"\"\"\n        try:\n            nc = len(c)\n        except TypeError:\n            raise ValueError(\n                \"Cannot convert argument type %s to rgba array\" % type(c))\n        try:\n            if nc == 0 or c.lower() == 'none':\n                return np.zeros((0,4), dtype=np.float)\n        except AttributeError:\n            pass\n        try:\n            # Single value? Put it in an array with a single row.\n            return np.array([self.to_rgba(c, alpha)], dtype=np.float)\n        except ValueError:\n            if isinstance(c, np.ndarray):\n                if c.ndim != 2 and c.dtype.kind not in 'SU':\n                    raise ValueError(\"Color array must be two-dimensional\")\n                if (c.ndim == 2 and c.shape[1] == 4 and c.dtype.kind == 'f'):\n                    if (c.ravel() > 1).any() or (c.ravel() < 0).any():\n                        raise ValueError(\n                            \"number in rgba sequence is outside 0-1 range\")\n                    # looks like rgba already, nothing to be done; do\n                    # we want to apply alpha here if\n                    # (c[:,3]==1).all() ?\n                    return np.asarray(c, np.float)\n            # It must be some other sequence of color specs.\n            result = np.zeros((nc, 4), dtype=np.float)\n            for i, cc in enumerate(c):\n                result[i] = self.to_rgba(cc, alpha)\n            return result\n\ncolorConverter = ColorConverter()\n\ndef makeMappingArray(N, data):\n    \"\"\"Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n    try:\n        adata = np.array(data)\n    except:\n        raise TypeError(\"data must be convertable to an array\")\n    shape = adata.shape\n    if len(shape) != 2 and shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x  = adata[:,0]\n    y0 = adata[:,1]\n    y1 = adata[:,2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n           \"data mapping points must start with x=0. and end with x=1\")\n    if np.sometrue(np.sort(x)-x):\n        raise ValueError(\n           \"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    x = x * (N-1)\n    lut = np.zeros((N,), np.float)\n    xind = np.arange(float(N))\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    lut[1:-1] = ( ((xind[1:-1] - x[ind-1]) / (x[ind] - x[ind-1]))\n                  * (y0[ind] - y1[ind-1]) + y1[ind-1])\n    lut[0] = y1[0]\n    lut[-1] = y0[-1]\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    np.clip(lut, 0.0, 1.0)\n    #lut = where(lut > 1., 1., lut)\n    #lut = where(lut < 0., 0., lut)\n    return lut\n\n\nclass Colormap:\n    \"\"\"Base class for all scalar to rgb mappings\n\n        Important methods:\n\n            * :meth:`set_bad`\n            * :meth:`set_under`\n            * :meth:`set_over`\n    \"\"\"\n    def __init__(self, name, N=256):\n        \"\"\"\n        Public class attributes:\n            :attr:`N` : number of rgb quantization levels\n            :attr:`name` : name of colormap\n\n        \"\"\"\n        self.name = name\n        self.N = N\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0) # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = N\n        self._i_over = N+1\n        self._i_bad = N+2\n        self._isinit = False\n\n\n    def __call__(self, X, alpha=1.0, bytes=False):\n        \"\"\"\n        *X* is either a scalar or an array (of any dimension).\n        If scalar, a tuple of rgba values is returned, otherwise\n        an array with the new shape = oldshape+(4,). If the X-values\n        are integers, then they are used as indices into the array.\n        If they are floating point, then they must be in the\n        interval (0.0, 1.0).\n        Alpha must be a scalar.\n        If bytes is False, the rgba values will be floats on a\n        0-1 scale; if True, they will be uint8, 0-255.\n        \"\"\"\n\n        if not self._isinit: self._init()\n        alpha = min(alpha, 1.0) # alpha must be between 0 and 1\n        alpha = max(alpha, 0.0)\n        self._lut[:-1,-1] = alpha  # Don't assign global alpha to i_bad;\n                                   # it would defeat the purpose of the\n                                   # default behavior, which is to not\n                                   # show anything where data are missing.\n        mask_bad = None\n        if not cbook.iterable(X):\n            vtype = 'scalar'\n            xa = np.array([X])\n        else:\n            vtype = 'array'\n            # force a copy here -- the ma.array and filled functions\n            # do force a cop of the data by default - JDH\n            xma = ma.array(X, copy=True)\n            xa = xma.filled(0)\n            mask_bad = ma.getmask(xma)\n        if xa.dtype.char in np.typecodes['Float']:\n            np.putmask(xa, xa==1.0, 0.9999999) #Treat 1.0 as slightly less than 1.\n            # The following clip is fast, and prevents possible\n            # conversion of large positive values to negative integers.\n\n            if NP_CLIP_OUT:\n                np.clip(xa * self.N, -1, self.N, out=xa)\n            else:\n                xa = np.clip(xa * self.N, -1, self.N)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        np.putmask(xa, xa>self.N-1, self._i_over)\n        np.putmask(xa, xa<0, self._i_under)\n        if mask_bad is not None and mask_bad.shape == xa.shape:\n            np.putmask(xa, mask_bad, self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut\n        rgba = np.empty(shape=xa.shape+(4,), dtype=lut.dtype)\n        lut.take(xa, axis=0, mode='clip', out=rgba)\n                    #  twice as fast as lut[xa];\n                    #  using the clip or wrap mode and providing an\n                    #  output array speeds it up a little more.\n        if vtype == 'scalar':\n            rgba = tuple(rgba[0,:])\n        return rgba\n\n    def set_bad(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for masked values.\n        '''\n        self._rgba_bad = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def set_under(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        '''\n        self._rgba_under = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def set_over(self, color = 'k', alpha = 1.0):\n        '''Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        '''\n        self._rgba_over = colorConverter.to_rgba(color, alpha)\n        if self._isinit: self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N-1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init():\n        '''Generate the lookup table, self._lut'''\n        raise NotImplementedError(\"Abstract class only\")\n\n    def is_gray(self):\n        if not self._isinit: self._init()\n        return (np.alltrue(self._lut[:,0] == self._lut[:,1])\n                    and np.alltrue(self._lut[:,0] == self._lut[:,2]))\n\n\nclass LinearSegmentedColormap(Colormap):\n    \"\"\"Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    \"\"\"\n    def __init__(self, name, segmentdata, N=256):\n        \"\"\"Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n            :func:`makeMappingArray`\n               For information about making a mapping array.\n        \"\"\"\n        self.monochrome = False  # True only if all colors in map are identical;\n                                 # needed for contouring.\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), np.float)\n        self._lut[:-3, 0] = makeMappingArray(self.N, self._segmentdata['red'])\n        self._lut[:-3, 1] = makeMappingArray(self.N, self._segmentdata['green'])\n        self._lut[:-3, 2] = makeMappingArray(self.N, self._segmentdata['blue'])\n        self._isinit = True\n        self._set_extremes()\n\n    @staticmethod\n    def from_list(name, colors, N=256):\n        \"\"\"\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=1\n        to colors[-1] at val=1.  N is the number of rgb quantization\n        levels.\n        \"\"\"\n\n        ncolors = len(colors)\n        vals = np.linspace(0., 1., ncolors)\n\n        cdict = dict(red=[], green=[], blue=[])\n        for val, color in zip(vals, colors):\n            r,g,b = colorConverter.to_rgb(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n\n        return LinearSegmentedColormap(name, cdict, N)\n\nclass ListedColormap(Colormap):\n    \"\"\"Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    \"\"\"\n    def __init__(self, colors, name = 'from_list', N = None):\n        \"\"\"\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 floating point array (*N* rgb values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        \"\"\"\n        self.colors = colors\n        self.monochrome = False  # True only if all colors in map are identical;\n                                 # needed for contouring.\n        if N is None:\n            N = len(self.colors)\n        else:\n            if cbook.is_string_like(self.colors):\n                self.colors = [self.colors] * N\n                self.monochrome = True\n            elif cbook.iterable(self.colors):\n                self.colors = list(self.colors) # in case it was a tuple\n                if len(self.colors) == 1:\n                    self.monochrome = True\n                if len(self.colors) < N:\n                    self.colors = list(self.colors) * N\n                del(self.colors[N:])\n            else:\n                try: gray = float(self.colors)\n                except TypeError: pass\n                else:  self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n\n    def _init(self):\n        rgb = np.array([colorConverter.to_rgb(c)\n                    for c in self.colors], np.float)\n        self._lut = np.zeros((self.N + 3, 4), np.float)\n        self._lut[:-3, :-1] = rgb\n        self._lut[:-3, -1] = 1\n        self._isinit = True\n        self._set_extremes()\n\n\nclass Normalize:\n    \"\"\"\n    Normalize a given value to the 0-1 range\n    \"\"\"\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are taken from the input's\n        minimum and maximum value respectively.  If *clip* is *True* and\n        the given value falls outside the range, the returned value\n        will be 0 or 1, whichever is closer. Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = vmin\n        self.vmax = vmax\n        self.clip = clip\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        if cbook.iterable(value):\n            vtype = 'array'\n            val = ma.asarray(value).astype(np.float)\n        else:\n            vtype = 'scalar'\n            val = ma.array([value]).astype(np.float)\n\n        self.autoscale_None(val)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin==vmax:\n            return 0.0 * val\n        else:\n            if clip:\n                mask = ma.getmask(val)\n                val = ma.array(np.clip(val.filled(vmax), vmin, vmax),\n                                mask=mask)\n            result = (val-vmin) * (1.0/(vmax-vmin))\n        if vtype == 'scalar':\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n\n    def autoscale(self, A):\n        '''\n        Set *vmin*, *vmax* to min, max of *A*.\n        '''\n        self.vmin = ma.minimum(A)\n        self.vmax = ma.maximum(A)\n\n    def autoscale_None(self, A):\n        ' autoscale only None-valued vmin or vmax'\n        if self.vmin is None: self.vmin = ma.minimum(A)\n        if self.vmax is None: self.vmax = ma.maximum(A)\n\n    def scaled(self):\n        'return true if vmin and vmax set'\n        return (self.vmin is not None and self.vmax is not None)\n\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale\n    \"\"\"\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        if cbook.iterable(value):\n            vtype = 'array'\n            val = ma.asarray(value).astype(np.float)\n        else:\n            vtype = 'scalar'\n            val = ma.array([value]).astype(np.float)\n\n        self.autoscale_None(val)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin<=0:\n            raise ValueError(\"values must all be positive\")\n        elif vmin==vmax:\n            return 0.0 * val\n        else:\n            if clip:\n                mask = ma.getmask(val)\n                val = ma.array(np.clip(val.filled(vmax), vmin, vmax),\n                                mask=mask)\n            result = (ma.log(val)-np.log(vmin))/(np.log(vmax)-np.log(vmin))\n        if vtype == 'scalar':\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        vmin, vmax = self.vmin, self.vmax\n\n        if cbook.iterable(value):\n            val = ma.asarray(value)\n            return vmin * ma.power((vmax/vmin), val)\n        else:\n            return vmin * pow((vmax/vmin), value)\n\nclass BoundaryNorm(Normalize):\n    '''\n    Generate a colormap index based on discrete intervals.\n\n    Unlike :class:`Normalize` or :class:`LogNorm`,\n    :class:`BoundaryNorm` maps values to integers instead of to the\n    interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via\n    piece-wise linear interpolation, but using integers seems\n    simpler, and reduces the number of conversions back and forth\n    between integer and floating point.\n    '''\n    def __init__(self, boundaries, ncolors, clip=False):\n        '''\n        *boundaries*\n            a monotonically increasing sequence\n        *ncolors*\n            number of colors in the colormap to be used\n\n        If::\n\n            b[i] <= v < b[i+1]\n\n        then v is mapped to color j;\n        as i varies from 0 to len(boundaries)-2,\n        j goes from 0 to ncolors-1.\n\n        Out-of-range values are mapped to -1 if low and ncolors\n        if high; these are converted to valid indices by\n        :meth:`Colormap.__call__` .\n        '''\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N-1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, x, clip=None):\n        if clip is None:\n            clip = self.clip\n        x = ma.asarray(x)\n        mask = ma.getmaskarray(x)\n        xx = x.filled(self.vmax+1)\n        if clip:\n            np.clip(xx, self.vmin, self.vmax)\n        iret = np.zeros(x.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx>=b] = i\n        if self._interp:\n            iret = (iret * (float(self.Ncmap-1)/(self.N-2))).astype(np.int16)\n        iret[xx<self.vmin] = -1\n        iret[xx>=self.vmax] = self.Ncmap\n        ret = ma.array(iret, mask=mask)\n        if ret.shape == () and not mask:\n            ret = int(ret)  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        return ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n    '''\n    Dummy replacement for Normalize, for the case where we\n    want to use indices directly in a\n    :class:`~matplotlib.cm.ScalarMappable` .\n    '''\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n# compatibility with earlier class names that violated convention:\nnormalize = Normalize\nno_norm = NoNorm\n\ndef rgb_to_hsv(arr):\n    \"\"\"\n    convert rgb values in a numpy array to hsv values\n    input and output arrays should have shape (M,N,3)\n    \"\"\"\n    out = np.empty_like(arr)\n    arr_max = arr.max(-1)\n    delta = arr.ptp(-1)\n    s = delta / arr_max\n    s[delta==0] = 0\n    # red is max\n    idx = (arr[:,:,0] == arr_max)\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[:,:,1] == arr_max)\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0] ) / delta[idx]\n    # blue is max\n    idx = (arr[:,:,2] == arr_max)\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1] ) / delta[idx]\n    out[:,:,0] = (out[:,:,0]/6.0) % 1.0\n    out[:,:,1] = s\n    out[:,:,2] = arr_max\n    return out\n\ndef hsv_to_rgb(hsv):\n    \"\"\"\n    convert hsv values in a numpy array to rgb values\n    both input and output arrays have shape (M,N,3)\n    \"\"\"\n    h = hsv[:,:,0]; s = hsv[:,:,1]; v = hsv[:,:,2]\n    r = np.empty_like(h); g = np.empty_like(h); b = np.empty_like(h)\n    i = (h*6.0).astype(np.int)\n    f = (h*6.0) - i\n    p = v*(1.0 - s)\n    q = v*(1.0 - s*f)\n    t = v*(1.0 - s*(1.0-f))\n    idx = i%6 == 0\n    r[idx] = v[idx]; g[idx] = t[idx]; b[idx] = p[idx]\n    idx = i == 1\n    r[idx] = q[idx]; g[idx] = v[idx]; b[idx] = p[idx]\n    idx = i == 2\n    r[idx] = p[idx]; g[idx] = v[idx]; b[idx] = t[idx]\n    idx = i == 3\n    r[idx] = p[idx]; g[idx] = q[idx]; b[idx] = v[idx]\n    idx = i == 4\n    r[idx] = t[idx]; g[idx] = p[idx]; b[idx] = v[idx]\n    idx = i == 5\n    r[idx] = v[idx]; g[idx] = p[idx]; b[idx] = q[idx]\n    idx = s == 0\n    r[idx] = v[idx]; g[idx] = v[idx]; b[idx] = v[idx]\n    rgb = np.empty_like(hsv)\n    rgb[:,:,0]=r; rgb[:,:,1]=g; rgb[:,:,2]=b\n    return rgb\n\nclass LightSource(object):\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n    The :meth:`shade` is used to produce rgb values for a shaded relief image\n    given a data array.\n    \"\"\"\n    def __init__(self,azdeg=315,altdeg=45,\\\n                 hsv_min_val=0,hsv_max_val=1,hsv_min_sat=1,hsv_max_sat=0):\n       \"\"\"\n       Specify the azimuth (measured clockwise from south) and altitude\n       (measured up from the plane of the surface) of the light source\n       in degrees.\n\n       The color of the resulting image will be darkened\n       by moving the (s,v) values (in hsv colorspace) toward\n       (hsv_min_sat, hsv_min_val) in the shaded regions, or\n       lightened by sliding (s,v) toward\n       (hsv_max_sat hsv_max_val) in regions that are illuminated.\n       The default extremes are chose so that completely shaded points\n       are nearly black (s = 1, v = 0) and completely illuminated points\n       are nearly white (s = 0, v = 1).\n       \"\"\"\n       self.azdeg = azdeg\n       self.altdeg = altdeg\n       self.hsv_min_val = hsv_min_val\n       self.hsv_max_val = hsv_max_val\n       self.hsv_min_sat = hsv_min_sat\n       self.hsv_max_sat = hsv_max_sat\n\n    def shade(self,data,cmap):\n        \"\"\"\n        Take the input data array, convert to HSV values in the\n        given colormap, then adjust those color values\n        to given the impression of a shaded relief map with a\n        specified light source.\n        RGBA values are returned, which can then be used to\n        plot the shaded image with imshow.\n        \"\"\"\n\n        rgb0 = cmap((data-data.min())/(data.max()-data.min()))\n        rgb1 = self.shade_rgb(rgb0, elevation=data)\n        rgb0[:,:,0:3] = rgb1\n        return rgb0\n\n    def shade_rgb(self,rgb, elevation, fraction=1.):\n        \"\"\"\n        Take the input RGB array (ny*nx*3) adjust their color values\n        to given the impression of a shaded relief map with a\n        specified light source using the elevation (ny*nx).\n        A new RGB array ((ny*nx*3)) is returned.\n        \"\"\"\n        # imagine an artificial sun placed at infinity in\n        # some azimuth and elevation position illuminating our surface. The parts of\n        # the surface that slope toward the sun should brighten while those sides\n        # facing away should become darker.\n        # convert alt, az to radians\n        az = self.azdeg*np.pi/180.0\n        alt = self.altdeg*np.pi/180.0\n        # gradient in x and y directions\n        dx, dy = np.gradient(elevation)\n        slope = 0.5*np.pi - np.arctan(np.hypot(dx, dy))\n        aspect = np.arctan2(dx, dy)\n        intensity = np.sin(alt)*np.sin(slope) + np.cos(alt)*np.cos(slope)*np.cos(-az -\\\n                aspect - 0.5*np.pi)\n        # rescale to interval -1,1\n        # +1 means maximum sun exposure and -1 means complete shade.\n        intensity = (intensity - intensity.min())/(intensity.max() - intensity.min())\n        intensity = (2.*intensity - 1.)*fraction\n        # convert to rgb, then rgb to hsv\n        #rgb = cmap((data-data.min())/(data.max()-data.min()))\n        hsv = rgb_to_hsv(rgb[:,:,0:3])\n        # modify hsv values to simulate illumination.\n        hsv[:,:,1] = np.where(np.logical_and(np.abs(hsv[:,:,1])>1.e-10,intensity>0),\\\n                (1.-intensity)*hsv[:,:,1]+intensity*self.hsv_max_sat, hsv[:,:,1])\n        hsv[:,:,2] = np.where(intensity > 0, (1.-intensity)*hsv[:,:,2] +\\\n                intensity*self.hsv_max_val, hsv[:,:,2])\n        hsv[:,:,1] = np.where(np.logical_and(np.abs(hsv[:,:,1])>1.e-10,intensity<0),\\\n                (1.+intensity)*hsv[:,:,1]-intensity*self.hsv_min_sat, hsv[:,:,1])\n        hsv[:,:,2] = np.where(intensity < 0, (1.+intensity)*hsv[:,:,2] -\\\n                intensity*self.hsv_min_val, hsv[:,:,2])\n        hsv[:,:,1:] = np.where(hsv[:,:,1:]<0.,0,hsv[:,:,1:])\n        hsv[:,:,1:] = np.where(hsv[:,:,1:]>1.,1,hsv[:,:,1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n",
          "file_patch": "@@ -1021,6 +1021,19 @@ class LightSource(object):\n         RGBA values are returned, which can then be used to\n         plot the shaded image with imshow.\n         \"\"\"\n+\n+        rgb0 = cmap((data-data.min())/(data.max()-data.min()))\n+        rgb1 = self.shade_rgb(rgb0, elevation=data)\n+        rgb0[:,:,0:3] = rgb1\n+        return rgb0\n+\n+    def shade_rgb(self,rgb, elevation, fraction=1.):\n+        \"\"\"\n+        Take the input RGB array (ny*nx*3) adjust their color values\n+        to given the impression of a shaded relief map with a\n+        specified light source using the elevation (ny*nx).\n+        A new RGB array ((ny*nx*3)) is returned.\n+        \"\"\"\n         # imagine an artificial sun placed at infinity in\n         # some azimuth and elevation position illuminating our surface. The parts of\n         # the surface that slope toward the sun should brighten while those sides\n@@ -1029,7 +1042,7 @@ class LightSource(object):\n         az = self.azdeg*np.pi/180.0\n         alt = self.altdeg*np.pi/180.0\n         # gradient in x and y directions\n-        dx, dy = np.gradient(data)\n+        dx, dy = np.gradient(elevation)\n         slope = 0.5*np.pi - np.arctan(np.hypot(dx, dy))\n         aspect = np.arctan2(dx, dy)\n         intensity = np.sin(alt)*np.sin(slope) + np.cos(alt)*np.cos(slope)*np.cos(-az -\\\n@@ -1037,9 +1050,9 @@ class LightSource(object):\n         # rescale to interval -1,1\n         # +1 means maximum sun exposure and -1 means complete shade.\n         intensity = (intensity - intensity.min())/(intensity.max() - intensity.min())\n-        intensity = 2.*intensity - 1.\n+        intensity = (2.*intensity - 1.)*fraction\n         # convert to rgb, then rgb to hsv\n-        rgb = cmap((data-data.min())/(data.max()-data.min()))\n+        #rgb = cmap((data-data.min())/(data.max()-data.min()))\n         hsv = rgb_to_hsv(rgb[:,:,0:3])\n         # modify hsv values to simulate illumination.\n         hsv[:,:,1] = np.where(np.logical_and(np.abs(hsv[:,:,1])>1.e-10,intensity>0),\\\n@@ -1053,5 +1066,4 @@ class LightSource(object):\n         hsv[:,:,1:] = np.where(hsv[:,:,1:]<0.,0,hsv[:,:,1:])\n         hsv[:,:,1:] = np.where(hsv[:,:,1:]>1.,1,hsv[:,:,1:])\n         # convert modified hsv back to rgb.\n-        rgb[:,:,0:3] = hsv_to_rgb(hsv)\n-        return rgb\n+        return hsv_to_rgb(hsv)\n",
          "files_name_in_blame_commit": [
            "demo_agg_filter.py",
            "backend_bases.py",
            "artist.py",
            "text.py",
            "colors.py",
            "backend_agg.py",
            "backend_mixed.py"
          ]
        }
      }
    }
  }
}
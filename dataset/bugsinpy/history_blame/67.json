{
  "id": "67",
  "blame_commit": {
    "commit": {
      "commit_id": "e18f20497b4253e21174d4114b22559db3f612ec",
      "commit_message": "minor tidy",
      "commit_author": "Casper da Costa-Luis",
      "commit_date": "2017-05-04 23:59:19",
      "commit_parent": "a379e330d013cf5f7cec8e9460d1d5e03b543444"
    },
    "function": {
      "function_name": "__len__",
      "function_code_before": "def __len__(self):\n    return (self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable)) if self.iterable is not None else self.total",
      "function_code_after": "def __len__(self):\n    return self.total if self.iterable is None else self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable) if hasattr(self.iterable, '__len__') else self.total",
      "function_before_start_line": 754,
      "function_before_end_line": 757,
      "function_after_start_line": 754,
      "function_after_end_line": 758,
      "function_before_token_count": 44,
      "function_after_token_count": 56,
      "functions_name_modified_file": [
        "trange",
        "clear",
        "_decr_instances",
        "set_postfix",
        "status_printer",
        "set_description",
        "refresh",
        "format_sizeof",
        "write",
        "_get_free_pos",
        "__enter__",
        "__hash__",
        "report",
        "__iter__",
        "run",
        "__le__",
        "__ge__",
        "close",
        "__new__",
        "__lt__",
        "exit",
        "__gt__",
        "moveto",
        "__eq__",
        "__repr__",
        "__init__",
        "pandas",
        "__del__",
        "update",
        "__len__",
        "__ne__",
        "unpause",
        "format_interval",
        "format_meter",
        "__exit__"
      ],
      "functions_name_all_files": [
        "trange",
        "clear",
        "_decr_instances",
        "set_postfix",
        "status_printer",
        "set_description",
        "refresh",
        "format_sizeof",
        "write",
        "_get_free_pos",
        "__enter__",
        "__hash__",
        "report",
        "__iter__",
        "run",
        "__le__",
        "__ge__",
        "close",
        "__new__",
        "__lt__",
        "exit",
        "__gt__",
        "moveto",
        "__eq__",
        "__repr__",
        "__init__",
        "pandas",
        "__del__",
        "update",
        "__len__",
        "__ne__",
        "unpause",
        "format_interval",
        "format_meter",
        "__exit__"
      ],
      "functions_name_co_evolved_modified_file": [
        "update",
        "__repr__"
      ],
      "functions_name_co_evolved_all_files": [
        "update",
        "__repr__"
      ]
    },
    "file": {
      "file_name": "_tqdm.py",
      "file_nloc": 618,
      "file_complexity": 206,
      "file_token_count": 4113,
      "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\nfrom __future__ import absolute_import\n# integer division / : float, // : int\nfrom __future__ import division\n# compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet, _basestring, _OrderedDict\n# native libraries\nimport sys\nfrom numbers import Number\nfrom threading import Thread\nfrom time import time\nfrom time import sleep\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange',\n           'TqdmTypeError', 'TqdmKeyError', 'TqdmDeprecationWarning']\n\n\nclass TqdmTypeError(TypeError):\n    pass\n\n\nclass TqdmKeyError(KeyError):\n    pass\n\n\nclass TqdmDeprecationWarning(Exception):\n    # not suppressed if raised\n    def __init__(self, msg, fp_write=None, *a, **k):\n        if fp_write is not None:\n            fp_write(\"\\nTqdmDeprecationWarning: \" + str(msg).rstrip() + '\\n')\n        else:\n            super(TqdmDeprecationWarning, self).__init__(msg, *a, **k)\n\n\nclass TMonitor(Thread):\n    \"\"\"\n    Monitoring thread for tqdm bars.\n    Monitors if tqdm bars are taking too much time to display\n    and readjusts miniters automatically if necessary.\n\n    Parameters\n    ----------\n    tqdm_cls  : class\n        tqdm class to use (can be core tqdm or a submodule).\n    sleep_interval  : fload\n        Time to sleep between monitoring checks.\n    \"\"\"\n\n    # internal vars for unit testing\n    _time = None\n    _sleep = None\n\n    def __init__(self, tqdm_cls, sleep_interval):\n        # setcheckinterval is deprecated\n        getattr(sys, 'setswitchinterval',\n                getattr(sys, 'setcheckinterval'))(100)\n        Thread.__init__(self)\n        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)\n        self.was_killed = False\n        self.woken = 0  # last time woken up, to sync with monitor\n        self.tqdm_cls = tqdm_cls\n        self.sleep_interval = sleep_interval\n        if TMonitor._time is not None:\n            self._time = TMonitor._time\n        else:\n            self._time = time\n        if TMonitor._sleep is not None:\n            self._sleep = TMonitor._sleep\n        else:\n            self._sleep = sleep\n        self.start()\n\n    def exit(self):\n        self.was_killed = True\n        # self.join()  # DO NOT, blocking event, slows down tqdm at closing\n        return self.report()\n\n    def run(self):\n        cur_t = self._time()\n        while True:\n            # After processing and before sleeping, notify that we woke\n            # Need to be done just before sleeping\n            self.woken = cur_t\n            # Sleep some time...\n            self._sleep(self.sleep_interval)\n            # Quit if killed\n            # if self.exit_event.is_set():  # TODO: should work but does not...\n            if self.was_killed:\n                return\n            # Then monitor!\n            cur_t = self._time()\n            # Check for each tqdm instance if one is waiting too long to print\n            # NB: copy avoids size change during iteration RuntimeError\n            for instance in self.tqdm_cls._instances.copy():\n                # Only if mininterval > 1 (else iterations are just slow)\n                # and last refresh was longer than maxinterval in this instance\n                if instance.miniters > 1 and \\\n                  (cur_t - instance.last_print_t) >= instance.maxinterval:\n                    # We force bypassing miniters on next iteration\n                    # dynamic_miniters should adjust mininterval automatically\n                    instance.miniters = 1\n                    # Refresh now! (works only for manual tqdm)\n                    instance.refresh()\n\n    def report(self):\n        # return self.is_alive()  # TODO: does not work...\n        return not self.was_killed\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    monitor_interval = 10  # set to 0 to disable the thread\n    monitor = None\n\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None, postfix=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        postfix  : str, optional\n            Same as prefix but will be placed at the end as additional stats.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt,\n                    ', '+postfix if postfix else '')\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                               if unit_scale else\n                                               '{0:5.2f}'.format(rate))\n                                               if rate else '?') + unit + '/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            'postfix': ', '+postfix if postfix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar = l_bar_user.format(**bar_args)\n                    r_bar = r_bar_user.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt,\n                ', '+postfix if postfix else '')\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Create the monitoring thread\n        if cls.monitor_interval and (cls.monitor is None or\n                                     not cls.monitor.report()):\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n            # Kill monitor if no instances are left\n            if not cls._instances and cls.monitor:\n                cls.monitor.exit()\n                try:\n                    del cls.monitor\n                except AttributeError:\n                    pass\n                cls.monitor = None\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        fp = file\n\n        # Clear all bars\n        inst_cleared = []\n        for inst in getattr(cls, '_instances', []):\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == fp or all(f in (sys.stdout, sys.stderr)\n                                    for f in (fp, inst.fp)):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        fp.write(s)\n        fp.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            # Avoid race conditions by checking that the instance started\n            if hasattr(inst, 'start_t'):  # pragma: nocover\n                inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    @classmethod\n    def pandas(tclass, *targs, **tkwargs):\n        \"\"\"\n        Registers the given `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.DataFrameGroupBy\n            | groupby.SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be create every time `progress_apply` is called,\n        and each instance will automatically close() upon completion.\n\n        Parameters\n        ----------\n        targs, tkwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm, tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        https://stackoverflow.com/questions/18603270/\n        progress-indicator-during-pandas-operations-python\n        \"\"\"\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        from pandas.core.groupby import DataFrameGroupBy\n        from pandas.core.groupby import SeriesGroupBy\n        from pandas.core.groupby import GroupBy\n        from pandas.core.groupby import PanelGroupBy\n        from pandas import Panel\n\n        deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                *args, *kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n                # Precompute total iterations\n                total = getattr(df, 'ngroups', None)\n                if total is None:  # not grouped\n                    total = len(df) if isinstance(df, Series) \\\n                        else df.size // len(df)\n                else:\n                    total += 1  # pandas calls update once too many\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = tclass(*targs, total=total, **tkwargs)\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    t.update()\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in *args and **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                result = getattr(df, df_function)(wrapper, *args, **kwargs)\n\n                # Close bar and return pandas calculation result\n                t.close()\n                return result\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n\n        Panel.progress_apply = inner_generator()\n        PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 postfix=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress display update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress display update interval, in seconds [default: 10].\n            Automatically adjusts `miniters` to correspond to `mininterval`\n            after long display update lag. Only works if `dynamic_miniters`\n            or monitor thread is enabled.\n        miniters  : int, optional\n            Minimum progress display update interval, in iterations.\n            If 0 and `dynamic_miniters`, will automatically adjust to equal\n            `mininterval` (more CPU efficient, good for tight loops).\n            If > 0, will skip display of specified number of iterations.\n            Tweak this and `mininterval` to get very efficient loops.\n            If your progress is erratic with both fast and slow iterations\n            (network, skipping items, etc) you should set miniters=1.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool or None, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False]. If set to None, disable on non-TTY.\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        postfix  : dict, optional\n            Specify additional stats to display at the end of the bar.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (TqdmDeprecationWarning(\"\"\"\\\n`nested` is deprecated and automated. Use position instead for manual control.\n\"\"\", fp_write=getattr(file, 'write', sys.stderr.write))\n                if \"nested\" in kwargs else\n                TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            self.set_postfix(**postfix)\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format,\n                    self.postfix))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __len__(self):\n        return (self.iterable.shape[0] if hasattr(self.iterable, 'shape')\n                else len(self.iterable)) if self.iterable is not None \\\n            else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 self._time() - self.start_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format,\n                                 self.postfix)\n\n    def __lt__(self, other):\n        return self.pos < other.pos\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return self.pos == other.pos\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= self.miniters:\n                    miniters = self.miniters  # watch monitoring thread changes\n                    delta_t = _time() - last_print_t\n                    if delta_t >= mininterval:\n                        cur_t = _time()\n                        delta_it = n - last_print_n\n                        elapsed = cur_t - start_t  # optimised if in inner loop\n                        # EMA (not just overall average)\n                        if smoothing and delta_t and delta_it:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format,\n                            self.postfix))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the max iteration rate seen so far between 2 prints\n                        if dynamic_miniters:\n                            if maxinterval and delta_t >= maxinterval:\n                                # Adjust miniters to time interval by rule of 3\n                                if mininterval:\n                                    # Set miniters to correspond to mininterval\n                                    miniters = delta_it * mininterval / delta_t\n                                else:\n                                    # Set miniters to correspond to maxinterval\n                                    miniters = delta_it * maxinterval / delta_t\n                            elif smoothing:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * \\\n                                              (mininterval / delta_t\n                                               if mininterval and delta_t\n                                               else 1) + \\\n                                              (1 - smoothing) * miniters\n                            else:\n                                # Maximum nb of iterations between 2 prints\n                                miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n                        self.miniters = miniters\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.miniters = miniters\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        if self.n - self.last_print_n >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            delta_t = self._time() - self.last_print_t\n            if delta_t >= self.mininterval:\n                cur_t = self._time()\n                delta_it = self.n - self.last_print_n  # should be n?\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t and delta_it:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format, self.postfix))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far between two prints.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t >= self.maxinterval:\n                        if self.mininterval:\n                            self.miniters = delta_it * self.mininterval \\\n                                        / delta_t\n                        else:\n                            self.miniters = delta_it * self.maxinterval \\\n                                        / delta_t\n                    elif self.smoothing:\n                        self.miniters = self.smoothing * delta_it * \\\n                                        (self.mininterval / delta_t\n                                         if self.mininterval and delta_t\n                                         else 1) + \\\n                                        (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format, self.postfix))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def set_postfix(self, ordered_dict=None, **kwargs):\n        \"\"\"\n        Set/modify postfix (additional stats)\n        with automatic formatting based on datatype.\n        \"\"\"\n        # Sort in alphabetical order to be more deterministic\n        postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n        for key in sorted(kwargs.keys()):\n            postfix[key] = kwargs[key]\n        # Preprocess stats according to datatype\n        for key in postfix.keys():\n            # Number: limit the length of the string\n            if isinstance(postfix[key], Number):\n                postfix[key] = '{0:2.3g}'.format(postfix[key])\n            # Else for any other type, try to get the string conversion\n            elif not isinstance(postfix[key], _basestring):\n                postfix[key] = str(postfix[key])\n            # Else if it's a string, don't need to preprocess anything\n        # Stitch together to get the final postfix\n        self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                                 for key in postfix.keys())\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if self.disable:\n            return\n\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        if self.disable:\n            return\n\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
      "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\nfrom __future__ import absolute_import\n# integer division / : float, // : int\nfrom __future__ import division\n# compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet, _basestring, _OrderedDict\n# native libraries\nimport sys\nfrom numbers import Number\nfrom threading import Thread\nfrom time import time\nfrom time import sleep\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange',\n           'TqdmTypeError', 'TqdmKeyError', 'TqdmDeprecationWarning']\n\n\nclass TqdmTypeError(TypeError):\n    pass\n\n\nclass TqdmKeyError(KeyError):\n    pass\n\n\nclass TqdmDeprecationWarning(Exception):\n    # not suppressed if raised\n    def __init__(self, msg, fp_write=None, *a, **k):\n        if fp_write is not None:\n            fp_write(\"\\nTqdmDeprecationWarning: \" + str(msg).rstrip() + '\\n')\n        else:\n            super(TqdmDeprecationWarning, self).__init__(msg, *a, **k)\n\n\nclass TMonitor(Thread):\n    \"\"\"\n    Monitoring thread for tqdm bars.\n    Monitors if tqdm bars are taking too much time to display\n    and readjusts miniters automatically if necessary.\n\n    Parameters\n    ----------\n    tqdm_cls  : class\n        tqdm class to use (can be core tqdm or a submodule).\n    sleep_interval  : fload\n        Time to sleep between monitoring checks.\n    \"\"\"\n\n    # internal vars for unit testing\n    _time = None\n    _sleep = None\n\n    def __init__(self, tqdm_cls, sleep_interval):\n        # setcheckinterval is deprecated\n        getattr(sys, 'setswitchinterval',\n                getattr(sys, 'setcheckinterval'))(100)\n        Thread.__init__(self)\n        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)\n        self.was_killed = False\n        self.woken = 0  # last time woken up, to sync with monitor\n        self.tqdm_cls = tqdm_cls\n        self.sleep_interval = sleep_interval\n        if TMonitor._time is not None:\n            self._time = TMonitor._time\n        else:\n            self._time = time\n        if TMonitor._sleep is not None:\n            self._sleep = TMonitor._sleep\n        else:\n            self._sleep = sleep\n        self.start()\n\n    def exit(self):\n        self.was_killed = True\n        # self.join()  # DO NOT, blocking event, slows down tqdm at closing\n        return self.report()\n\n    def run(self):\n        cur_t = self._time()\n        while True:\n            # After processing and before sleeping, notify that we woke\n            # Need to be done just before sleeping\n            self.woken = cur_t\n            # Sleep some time...\n            self._sleep(self.sleep_interval)\n            # Quit if killed\n            # if self.exit_event.is_set():  # TODO: should work but does not...\n            if self.was_killed:\n                return\n            # Then monitor!\n            cur_t = self._time()\n            # Check for each tqdm instance if one is waiting too long to print\n            # NB: copy avoids size change during iteration RuntimeError\n            for instance in self.tqdm_cls._instances.copy():\n                # Only if mininterval > 1 (else iterations are just slow)\n                # and last refresh was longer than maxinterval in this instance\n                if instance.miniters > 1 and \\\n                  (cur_t - instance.last_print_t) >= instance.maxinterval:\n                    # We force bypassing miniters on next iteration\n                    # dynamic_miniters should adjust mininterval automatically\n                    instance.miniters = 1\n                    # Refresh now! (works only for manual tqdm)\n                    instance.refresh()\n\n    def report(self):\n        # return self.is_alive()  # TODO: does not work...\n        return not self.was_killed\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    monitor_interval = 10  # set to 0 to disable the thread\n    monitor = None\n\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None, postfix=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        postfix  : str, optional\n            Same as prefix but will be placed at the end as additional stats.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt,\n                    ', '+postfix if postfix else '')\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                               if unit_scale else\n                                               '{0:5.2f}'.format(rate))\n                                               if rate else '?') + unit + '/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            'postfix': ', '+postfix if postfix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar = l_bar_user.format(**bar_args)\n                    r_bar = r_bar_user.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt,\n                ', '+postfix if postfix else '')\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Create the monitoring thread\n        if cls.monitor_interval and (cls.monitor is None or\n                                     not cls.monitor.report()):\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n            # Kill monitor if no instances are left\n            if not cls._instances and cls.monitor:\n                cls.monitor.exit()\n                try:\n                    del cls.monitor\n                except AttributeError:\n                    pass\n                cls.monitor = None\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        fp = file\n\n        # Clear all bars\n        inst_cleared = []\n        for inst in getattr(cls, '_instances', []):\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == fp or all(f in (sys.stdout, sys.stderr)\n                                    for f in (fp, inst.fp)):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        fp.write(s)\n        fp.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            # Avoid race conditions by checking that the instance started\n            if hasattr(inst, 'start_t'):  # pragma: nocover\n                inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    @classmethod\n    def pandas(tclass, *targs, **tkwargs):\n        \"\"\"\n        Registers the given `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.DataFrameGroupBy\n            | groupby.SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be create every time `progress_apply` is called,\n        and each instance will automatically close() upon completion.\n\n        Parameters\n        ----------\n        targs, tkwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm, tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        https://stackoverflow.com/questions/18603270/\n        progress-indicator-during-pandas-operations-python\n        \"\"\"\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        from pandas.core.groupby import DataFrameGroupBy\n        from pandas.core.groupby import SeriesGroupBy\n        from pandas.core.groupby import GroupBy\n        from pandas.core.groupby import PanelGroupBy\n        from pandas import Panel\n\n        deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                *args, *kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n                # Precompute total iterations\n                total = getattr(df, 'ngroups', None)\n                if total is None:  # not grouped\n                    total = len(df) if isinstance(df, Series) \\\n                        else df.size // len(df)\n                else:\n                    total += 1  # pandas calls update once too many\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = tclass(*targs, total=total, **tkwargs)\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    t.update()\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in *args and **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                result = getattr(df, df_function)(wrapper, *args, **kwargs)\n\n                # Close bar and return pandas calculation result\n                t.close()\n                return result\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n\n        Panel.progress_apply = inner_generator()\n        PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 postfix=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress display update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress display update interval, in seconds [default: 10].\n            Automatically adjusts `miniters` to correspond to `mininterval`\n            after long display update lag. Only works if `dynamic_miniters`\n            or monitor thread is enabled.\n        miniters  : int, optional\n            Minimum progress display update interval, in iterations.\n            If 0 and `dynamic_miniters`, will automatically adjust to equal\n            `mininterval` (more CPU efficient, good for tight loops).\n            If > 0, will skip display of specified number of iterations.\n            Tweak this and `mininterval` to get very efficient loops.\n            If your progress is erratic with both fast and slow iterations\n            (network, skipping items, etc) you should set miniters=1.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool or None, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False]. If set to None, disable on non-TTY.\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        postfix  : dict, optional\n            Specify additional stats to display at the end of the bar.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (TqdmDeprecationWarning(\"\"\"\\\n`nested` is deprecated and automated. Use position instead for manual control.\n\"\"\", fp_write=getattr(file, 'write', sys.stderr.write))\n                if \"nested\" in kwargs else\n                TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            self.set_postfix(**postfix)\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format,\n                    self.postfix))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __len__(self):\n        return self.total if self.iterable is None else \\\n                (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n                 else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n                 else self.total)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 self._time() - self.start_t,\n                                 self.dynamic_ncols(self.fp)\n                                 if self.dynamic_ncols else self.ncols,\n                                 self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format,\n                                 self.postfix)\n\n    def __lt__(self, other):\n        return self.pos < other.pos\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return self.pos == other.pos\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= self.miniters:\n                    miniters = self.miniters  # watch monitoring thread changes\n                    delta_t = _time() - last_print_t\n                    if delta_t >= mininterval:\n                        cur_t = _time()\n                        delta_it = n - last_print_n\n                        elapsed = cur_t - start_t  # optimised if in inner loop\n                        # EMA (not just overall average)\n                        if smoothing and delta_t and delta_it:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format,\n                            self.postfix))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the max iteration rate seen so far between 2 prints\n                        if dynamic_miniters:\n                            if maxinterval and delta_t >= maxinterval:\n                                # Adjust miniters to time interval by rule of 3\n                                if mininterval:\n                                    # Set miniters to correspond to mininterval\n                                    miniters = delta_it * mininterval / delta_t\n                                else:\n                                    # Set miniters to correspond to maxinterval\n                                    miniters = delta_it * maxinterval / delta_t\n                            elif smoothing:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * \\\n                                              (mininterval / delta_t\n                                               if mininterval and delta_t\n                                               else 1) + \\\n                                              (1 - smoothing) * miniters\n                            else:\n                                # Maximum nb of iterations between 2 prints\n                                miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n                        self.miniters = miniters\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.miniters = miniters\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        if self.n - self.last_print_n >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            delta_t = self._time() - self.last_print_t\n            if delta_t >= self.mininterval:\n                cur_t = self._time()\n                delta_it = self.n - self.last_print_n  # should be n?\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t and delta_it:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.__repr__())\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far between two prints.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t >= self.maxinterval:\n                        if self.mininterval:\n                            self.miniters = delta_it * self.mininterval \\\n                                        / delta_t\n                        else:\n                            self.miniters = delta_it * self.maxinterval \\\n                                        / delta_t\n                    elif self.smoothing:\n                        self.miniters = self.smoothing * delta_it * \\\n                                        (self.mininterval / delta_t\n                                         if self.mininterval and delta_t\n                                         else 1) + \\\n                                        (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format, self.postfix))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def set_postfix(self, ordered_dict=None, **kwargs):\n        \"\"\"\n        Set/modify postfix (additional stats)\n        with automatic formatting based on datatype.\n        \"\"\"\n        # Sort in alphabetical order to be more deterministic\n        postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n        for key in sorted(kwargs.keys()):\n            postfix[key] = kwargs[key]\n        # Preprocess stats according to datatype\n        for key in postfix.keys():\n            # Number: limit the length of the string\n            if isinstance(postfix[key], Number):\n                postfix[key] = '{0:2.3g}'.format(postfix[key])\n            # Else for any other type, try to get the string conversion\n            elif not isinstance(postfix[key], _basestring):\n                postfix[key] = str(postfix[key])\n            # Else if it's a string, don't need to preprocess anything\n        # Stitch together to get the final postfix\n        self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                                 for key in postfix.keys())\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if self.disable:\n            return\n\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        if self.disable:\n            return\n\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
      "file_patch": "@@ -752,9 +752,10 @@ class tqdm(object):\n         self.start_t = self.last_print_t\n \n     def __len__(self):\n-        return (self.iterable.shape[0] if hasattr(self.iterable, 'shape')\n-                else len(self.iterable)) if self.iterable is not None \\\n-            else self.total\n+        return self.total if self.iterable is None else \\\n+                (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n+                 else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n+                 else self.total)\n \n     def __enter__(self):\n         return self\n@@ -769,7 +770,9 @@ class tqdm(object):\n     def __repr__(self):\n         return self.format_meter(self.n, self.total,\n                                  self._time() - self.start_t,\n-                                 self.ncols, self.desc, self.ascii, self.unit,\n+                                 self.dynamic_ncols(self.fp)\n+                                 if self.dynamic_ncols else self.ncols,\n+                                 self.desc, self.ascii, self.unit,\n                                  self.unit_scale, 1 / self.avg_time\n                                  if self.avg_time else None, self.bar_format,\n                                  self.postfix)\n@@ -953,13 +956,7 @@ Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n                     self.moveto(self.pos)\n \n                 # Print bar's update\n-                self.sp(self.format_meter(\n-                    self.n, self.total, elapsed,\n-                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n-                     else self.ncols),\n-                    self.desc, self.ascii, self.unit, self.unit_scale,\n-                    1 / self.avg_time if self.avg_time else None,\n-                    self.bar_format, self.postfix))\n+                self.sp(self.__repr__())\n \n                 if self.pos:\n                     self.moveto(-self.pos)\n",
      "files_name_in_blame_commit": [
        "_tqdm.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 258
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "754": {
        "commit_id": "a5130ec42153ad4fcf96664c6ec7b20950aef3c6",
        "line_code": "    def __len__(self):",
        "commit_date": "2015-11-11 10:05:34",
        "valid": 1
      },
      "755": {
        "commit_id": "bb53160c84ff99c6511c1c55bd33650e3c6d1af2",
        "line_code": "        return (self.iterable.shape[0] if hasattr(self.iterable, 'shape')",
        "commit_date": "2016-06-26 11:44:17",
        "valid": 1
      },
      "756": {
        "commit_id": "57edc22ab40cc51c66545484a7a4e431e21c4b35",
        "line_code": "                else len(self.iterable)) if self.iterable is not None \\",
        "commit_date": "2016-06-26 08:48:16",
        "valid": 1
      },
      "757": {
        "commit_id": "57edc22ab40cc51c66545484a7a4e431e21c4b35",
        "line_code": "            else self.total",
        "commit_date": "2016-06-26 08:48:16",
        "valid": 1
      }
    },
    "commits": {
      "57edc22ab40cc51c66545484a7a4e431e21c4b35": {
        "commit": {
          "commit_id": "57edc22ab40cc51c66545484a7a4e431e21c4b35",
          "commit_message": "numpy len support, addressing #185",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-06-26 08:48:16",
          "commit_parent": "9f8801f218694d27fab6cf335f5149835020d867"
        },
        "function": {
          "function_name": "__len__",
          "function_code_before": "def __len__(self):\n    return len(self.iterable) if self.iterable else self.total",
          "function_code_after": "def __len__(self):\n    return (self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable)) if self.iterable is not None else self.total",
          "function_before_start_line": 510,
          "function_before_end_line": 511,
          "function_after_start_line": 510,
          "function_after_end_line": 513,
          "function_before_token_count": 20,
          "function_after_token_count": 45,
          "functions_name_modified_file": [
            "trange",
            "clear",
            "_decr_instances",
            "status_printer",
            "set_description",
            "refresh",
            "format_sizeof",
            "write",
            "_get_free_pos",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__new__",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "seek",
            "test_disable",
            "clear",
            "test_iterate_over_csv_rows",
            "_decr_instances",
            "pretest",
            "test_ascii",
            "test_repr",
            "status_printer",
            "time",
            "set_description",
            "refresh",
            "test_bar_format",
            "read",
            "closing",
            "format_sizeof",
            "test_len",
            "cpu_timify",
            "test_set_description",
            "write",
            "test_si_format",
            "tell",
            "test_close",
            "get_bar",
            "test_clear",
            "test_deprecated_gui",
            "_get_free_pos",
            "test_min_interval",
            "__enter__",
            "__hash__",
            "__iter__",
            "posttest",
            "__le__",
            "test_trange",
            "test_update",
            "test_deprecated_nested",
            "test_min_iters",
            "__ge__",
            "test_cmp",
            "close",
            "test_refresh",
            "sleep",
            "test_all_defaults",
            "__new__",
            "test_dynamic_min_iters",
            "test_write",
            "squash_ctrlchars",
            "__lt__",
            "test_leave_option",
            "test_format_meter",
            "__gt__",
            "moveto",
            "__eq__",
            "test_position",
            "__repr__",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "__del__",
            "test_smoothing",
            "getvalue",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval",
            "test_unpause"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_len"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 457,
          "file_complexity": 157,
          "file_token_count": 3067,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                               if unit_scale else\n                                               '{0:5.2f}'.format(rate))\n                                               if rate else '?') + unit + '/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar = l_bar_user.format(**bar_args)\n                    r_bar = r_bar_user.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        fp = file\n\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == fp or all(f in (sys.stdout, sys.stderr)\n                                    for f in (fp, inst.fp)):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        fp.write(s)\n        fp.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                               if unit_scale else\n                                               '{0:5.2f}'.format(rate))\n                                               if rate else '?') + unit + '/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar = l_bar_user.format(**bar_args)\n                    r_bar = r_bar_user.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        fp = file\n\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == fp or all(f in (sys.stdout, sys.stderr)\n                                    for f in (fp, inst.fp)):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        fp.write(s)\n        fp.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return (self.iterable.shape[0] if hasattr(self.iterable, 'shape') \\\n                else len(self.iterable)) if self.iterable is not None \\\n            else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -508,7 +508,9 @@ class tqdm(object):\n         self.start_t = self.last_print_t = self._time()\n \n     def __len__(self):\n-        return len(self.iterable) if self.iterable else self.total\n+        return (self.iterable.shape[0] if hasattr(self.iterable, 'shape') \\\n+                else len(self.iterable)) if self.iterable is not None \\\n+            else self.total\n \n     def __enter__(self):\n         return self\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "a5130ec42153ad4fcf96664c6ec7b20950aef3c6": {
        "commit": {
          "commit_id": "a5130ec42153ad4fcf96664c6ec7b20950aef3c6",
          "commit_message": "fully abstracted gui",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-11-11 10:05:34",
          "commit_parent": "6fd1182bec6bd05934e9bd471e58c373d49f1d68"
        },
        "function": {
          "function_name": "__len__",
          "function_code_before": "def __len__(self):\n    return len(self.iterable) if self.iterable else self.total",
          "function_code_after": "def __len__(self):\n    return len(self.iterable) if self.iterable else self.total",
          "function_before_start_line": 396,
          "function_before_end_line": 397,
          "function_after_start_line": 336,
          "function_after_end_line": 337,
          "function_before_token_count": 20,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__init__",
            "update",
            "StatusPrinter",
            "__iter__",
            "format_meter"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "update",
            "StatusPrinter",
            "__iter__",
            "format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 442,
          "file_complexity": 116,
          "file_token_count": 3096,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total-n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n                 smoothing=0.05):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.05].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:  # pragma: no cover\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if gui:  # pragma: no cover\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                                    loc='center right')\n                    # progressbar\n                    self.hspan = plt.axhspan(0, 0.001,\n                                             xmin=0, xmax=0, color='g')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                    ax.legend(('cur', 'est'), loc='lower left')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            if gui:  # pragma: no cover\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:  # pragma: no cover\n                            # Inline due to multiple calls\n                            total = self.total\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # overall rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ymax = 1.1 * y\n                                ax.set_ylim(ymin, ymax)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                                try:\n                                    poly_lims = self.hspan.get_xy()\n                                except AttributeError:\n                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                             xmax=0, color='g')\n                                    poly_lims = self.hspan.get_xy()\n                                poly_lims[0, 1] = ymin\n                                poly_lims[1, 1] = ymax\n                                poly_lims[2] = [n / total, ymax]\n                                poly_lims[3] = [poly_lims[2, 0], ymin]\n                                if len(poly_lims) > 4:\n                                    poly_lims[4, 1] = ymin\n                                self.hspan.set_xy(poly_lims)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                self.desc, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            # EMA (not just overall average)\n                            if smoothing and delta_t:\n                                avg_rate = delta_it / delta_t \\\n                                    if avg_rate is None \\\n                                    else smoothing * delta_it / delta_t + \\\n                                    (1 - smoothing) * avg_rate\n\n                            sp(format_meter(\n                                n, self.total, elapsed,\n                                (dynamic_ncols(self.fp) if dynamic_ncols\n                                 else ncols),\n                                self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:  # pragma: no cover\n                    # Inline due to multiple calls\n                    total = self.total\n                    ax = self.ax\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                          xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [self.n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.desc, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    # EMA (not just overall average)\n                    if self.smoothing and delta_t:\n                        self.avg_rate = delta_it / delta_t \\\n                            if self.avg_rate is None \\\n                            else self.smoothing * delta_it / delta_t + \\\n                            (1 - self.smoothing) * self.avg_rate\n\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale,\n                        self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.gui:  # pragma: no cover\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    # stats for overall rate (no weighted average)\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n                self.fp.write('\\n')\n            else:\n                self.sp('')\n                self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'tqdm_gui', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' ' * max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n                 smoothing=0.05):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.05].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            self.fp.write('\\n')\n        else:\n            self.sp('')\n            self.fp.write('\\r')\n\n\nclass tqdm_gui(tqdm):  # pragma: no cover\n    def __init__(self, *args, **kwargs):\n\n        # try:  # pragma: no cover\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        from collections import deque\n        # except ImportError:  # gui not available\n        #   kwargs['gui'] = False\n        # else:\n        kwargs['gui'] = True\n\n        super(tqdm_gui, self).__init__(*args, **kwargs)\n\n        # Initialize the GUI display\n        if self.disable or not kwargs['gui']:\n            return\n\n        self.fp.write('Warning: GUI is experimental/alpha\\n')\n        self.mpl = mpl\n        self.plt = plt\n        self.sp = None\n\n        # Remember if external environment uses toolbars\n        self.toolbar = self.mpl.rcParams['toolbar']\n        self.mpl.rcParams['toolbar'] = 'None'\n\n        self.mininterval = max(self.mininterval, 0.5)\n        self.fig, ax = plt.subplots(figsize=(9, 2.2))\n        # self.fig.subplots_adjust(bottom=0.2)\n        if self.total:\n            self.xdata = []\n            self.ydata = []\n            self.zdata = []\n        else:\n            self.xdata = deque([])\n            self.ydata = deque([])\n            self.zdata = deque([])\n        self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n        self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n        ax.set_ylim(0, 0.001)\n        if self.total:\n            ax.set_xlim(0, 100)\n            ax.set_xlabel('percent')\n            self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                            loc='center right')\n            # progressbar\n            self.hspan = plt.axhspan(0, 0.001,\n                                     xmin=0, xmax=0, color='g')\n        else:\n            # ax.set_xlim(-60, 0)\n            ax.set_xlim(0, 60)\n            ax.invert_xaxis()\n            ax.set_xlabel('seconds')\n            ax.legend(('cur', 'est'), loc='lower left')\n        ax.grid()\n        # ax.set_xlabel('seconds')\n        ax.set_ylabel((self.unit if self.unit else 'it') + '/s')\n        if self.unit_scale:\n            plt.ticklabel_format(style='sci', axis='y',\n                                 scilimits=(0, 0))\n            ax.yaxis.get_offset_text().set_x(-0.15)\n\n        # Remember if external environment is interactive\n        self.wasion = plt.isinteractive()\n        plt.ion()\n        self.ax = ax\n\n    def __iter__(self):\n        # TODO: somehow allow the following:\n        # if not self.gui:\n        #   return super(tqdm_gui, self).__iter__()\n        iterable = self.iterable\n        if self.disable:\n            for obj in iterable:\n                yield obj\n            return\n\n        # ncols = self.ncols\n        mininterval = self.mininterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        unit = self.unit\n        unit_scale = self.unit_scale\n        ascii = self.ascii\n        start_t = self.start_t\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        # dynamic_ncols = self.dynamic_ncols\n        # smoothing = self.smoothing\n        # avg_rate = self.avg_rate\n\n        plt = self.plt\n        ax = self.ax\n        xdata = self.xdata\n        ydata = self.ydata\n        zdata = self.zdata\n        line1 = self.line1\n        line2 = self.line2\n\n        for obj in iterable:\n            yield obj\n            # Update and print the progressbar.\n            # Note: does not call self.update(1) for speed optimisation.\n            n += 1\n            delta_it = n - last_print_n\n            # check the counter first (avoid calls to time())\n            if delta_it >= miniters:\n                cur_t = time()\n                delta_t = cur_t - last_print_t\n                if delta_t >= mininterval:  # pragma: no cover\n                    elapsed = cur_t - start_t\n                    # Inline due to multiple calls\n                    total = self.total\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # overall rate\n                    z = n / elapsed\n                    # update line data\n                    xdata.append(n * 100.0 / total if total else cur_t)\n                    ydata.append(y)\n                    zdata.append(z)\n\n                    # Discard old values\n                    # xmin, xmax = ax.get_xlim()\n                    # if (not total) and elapsed > xmin * 1.1:\n                    if (not total) and elapsed > 66:\n                        xdata.popleft()\n                        ydata.popleft()\n                        zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        line1.set_data(xdata, ydata)\n                        line2.set_data(xdata, zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                     xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in xdata]\n                        line1.set_data(t_ago, ydata)\n                        line2.set_data(t_ago, zdata)\n\n                    ax.set_title(format_meter(\n                        n, total, elapsed, 0,\n                        self.desc, ascii, unit, unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    plt.pause(1e-9)\n\n                    # If no `miniters` was specified, adjust automatically\n                    # to the maximum iteration rate seen so far.\n                    if dynamic_miniters:\n                        miniters = max(miniters, delta_it)\n\n                    # Store old values for next call\n                    last_print_n = n\n                    last_print_t = cur_t\n\n        # Closing the progress bar.\n        # Update some internal variables for close().\n        self.last_print_n = last_print_n\n        self.n = n\n        self.close()\n\n    def update(self, n=1):\n        # if not self.gui:\n        #   return super(tqdm_gui, self).close()\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # Inline due to multiple calls\n                total = self.total\n                ax = self.ax\n\n                # instantaneous rate\n                y = delta_it / delta_t\n                # smoothed rate\n                z = self.n / elapsed\n                # update line data\n                self.xdata.append(self.n * 100.0 / total\n                                  if total else cur_t)\n                self.ydata.append(y)\n                self.zdata.append(z)\n\n                # Discard old values\n                if (not total) and elapsed > 66:\n                    self.xdata.popleft()\n                    self.ydata.popleft()\n                    self.zdata.popleft()\n\n                ymin, ymax = ax.get_ylim()\n                if y > ymax or z > ymax:\n                    ymax = 1.1 * y\n                    ax.set_ylim(ymin, ymax)\n                    ax.figure.canvas.draw()\n\n                if total:\n                    self.line1.set_data(self.xdata, self.ydata)\n                    self.line2.set_data(self.xdata, self.zdata)\n                    try:\n                        poly_lims = self.hspan.get_xy()\n                    except AttributeError:\n                        self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                      xmax=0, color='g')\n                        poly_lims = self.hspan.get_xy()\n                    poly_lims[0, 1] = ymin\n                    poly_lims[1, 1] = ymax\n                    poly_lims[2] = [self.n / total, ymax]\n                    poly_lims[3] = [poly_lims[2, 0], ymin]\n                    if len(poly_lims) > 4:\n                        poly_lims[4, 1] = ymin\n                    self.hspan.set_xy(poly_lims)\n                else:\n                    t_ago = [cur_t - i for i in self.xdata]\n                    self.line1.set_data(t_ago, self.ydata)\n                    self.line2.set_data(t_ago, self.zdata)\n\n                ax.set_title(format_meter(\n                    self.n, total, elapsed, 0,\n                    self.desc, self.ascii, self.unit, self.unit_scale),\n                    fontname=\"DejaVu Sans Mono\",\n                    fontsize=11)\n                self.plt.pause(1e-9)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        # if not self.gui:\n        #   return super(tqdm_gui, self).close()\n        if self.disable:\n            return\n\n        # Restore toolbars\n        self.mpl.rcParams['toolbar'] = self.toolbar\n        # Return to non-interactive mode\n        if not self.wasion:\n            self.plt.ioff()\n        if not self.leave:\n            self.plt.close(self.fig)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -18,7 +18,7 @@ from time import time\n \n __author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                               \"casperdcl\", \"lrq3000\"]}\n-__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n+__all__ = ['tqdm', 'tqdm_gui', 'trange', 'format_interval', 'format_meter']\n \n \n def format_sizeof(num, suffix=''):\n@@ -135,7 +135,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         frac = n / total\n         percentage = frac * 100\n \n-        remaining_str = format_interval((total-n) / rate) if rate else '?'\n+        remaining_str = format_interval((total - n) / rate) if rate else '?'\n \n         # format the stats displayed to the left and right sides of the bar\n         l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n@@ -154,14 +154,14 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n             bar_length, frac_bar_length = divmod(\n                 int(frac * N_BARS * 10), 10)\n \n-            bar = '#'*bar_length\n+            bar = '#' * bar_length\n             frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                 else ' '\n \n         else:\n             bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n-            bar = _unich(0x2588)*bar_length\n+            bar = _unich(0x2588) * bar_length\n             frac_bar = _unich(0x2590 - frac_bar_length) \\\n                 if frac_bar_length else ' '\n \n@@ -195,7 +195,7 @@ def StatusPrinter(file):\n \n     def print_status(s):\n         len_s = len(s)\n-        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n+        fp.write('\\r' + s + ' ' * max(last_printed_len[0] - len_s, 0))\n         fp.flush()\n         last_printed_len[0] = len_s\n     return print_status\n@@ -298,23 +298,12 @@ class tqdm(object):\n         if ascii is None:\n             ascii = not _supports_unicode(file)\n \n-        if gui:  # pragma: no cover\n-            try:\n-                import matplotlib as mpl\n-                import matplotlib.pyplot as plt\n-                from collections import deque\n-            except ImportError:\n-                gui = False\n-            else:\n-                self.mpl = mpl\n-                self.plt = plt\n-\n         if smoothing is None:\n             smoothing = 0\n \n         # Store the arguments\n         self.iterable = iterable\n-        self.desc = desc+': ' if desc else ''\n+        self.desc = desc + ': ' if desc else ''\n         self.total = total\n         self.leave = leave\n         self.fp = file\n@@ -331,56 +320,7 @@ class tqdm(object):\n         self.smoothing = smoothing\n         self.avg_rate = None\n \n-        if gui:  # pragma: no cover\n-            # Initialize the GUI display\n-            if not disable:\n-                file.write('Warning: GUI is experimental/alpha\\n')\n-\n-                # Remember if external environment uses toolbars\n-                self.toolbar = self.mpl.rcParams['toolbar']\n-                self.mpl.rcParams['toolbar'] = 'None'\n-\n-                self.mininterval = max(mininterval, 0.5)\n-                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n-                # self.fig.subplots_adjust(bottom=0.2)\n-                if total:\n-                    self.xdata = []\n-                    self.ydata = []\n-                    self.zdata = []\n-                else:\n-                    self.xdata = deque([])\n-                    self.ydata = deque([])\n-                    self.zdata = deque([])\n-                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n-                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n-                ax.set_ylim(0, 0.001)\n-                if total:\n-                    ax.set_xlim(0, 100)\n-                    ax.set_xlabel('percent')\n-                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n-                                    loc='center right')\n-                    # progressbar\n-                    self.hspan = plt.axhspan(0, 0.001,\n-                                             xmin=0, xmax=0, color='g')\n-                else:\n-                    # ax.set_xlim(-60, 0)\n-                    ax.set_xlim(0, 60)\n-                    ax.invert_xaxis()\n-                    ax.set_xlabel('seconds')\n-                    ax.legend(('cur', 'est'), loc='lower left')\n-                ax.grid()\n-                # ax.set_xlabel('seconds')\n-                ax.set_ylabel((unit if unit else 'it') + '/s')\n-                if unit_scale:\n-                    plt.ticklabel_format(style='sci', axis='y',\n-                                         scilimits=(0, 0))\n-                    ax.yaxis.get_offset_text().set_x(-0.15)\n-\n-                # Remember if external environment is interactive\n-                self.wasion = plt.isinteractive()\n-                plt.ion()\n-                self.ax = ax\n-        else:\n+        if not gui:\n             # Initialize the screen printer\n             self.sp = StatusPrinter(self.fp)\n             if not disable:\n@@ -419,20 +359,11 @@ class tqdm(object):\n             last_print_t = self.last_print_t\n             last_print_n = self.last_print_n\n             n = self.n\n-            gui = self.gui\n             dynamic_ncols = self.dynamic_ncols\n             smoothing = self.smoothing\n             avg_rate = self.avg_rate\n-            if gui:  # pragma: no cover\n-                plt = self.plt\n-                ax = self.ax\n-                xdata = self.xdata\n-                ydata = self.ydata\n-                zdata = self.zdata\n-                line1 = self.line1\n-                line2 = self.line2\n-            else:\n-                sp = self.sp\n+\n+            sp = self.sp\n \n             for obj in iterable:\n                 yield obj\n@@ -446,72 +377,18 @@ class tqdm(object):\n                     delta_t = cur_t - last_print_t\n                     if delta_t >= mininterval:\n                         elapsed = cur_t - start_t\n-                        if gui:  # pragma: no cover\n-                            # Inline due to multiple calls\n-                            total = self.total\n-                            # instantaneous rate\n-                            y = delta_it / delta_t\n-                            # overall rate\n-                            z = n / elapsed\n-                            # update line data\n-                            xdata.append(n * 100.0 / total if total else cur_t)\n-                            ydata.append(y)\n-                            zdata.append(z)\n-\n-                            # Discard old values\n-                            # xmin, xmax = ax.get_xlim()\n-                            # if (not total) and elapsed > xmin * 1.1:\n-                            if (not total) and elapsed > 66:\n-                                xdata.popleft()\n-                                ydata.popleft()\n-                                zdata.popleft()\n-\n-                            ymin, ymax = ax.get_ylim()\n-                            if y > ymax or z > ymax:\n-                                ymax = 1.1 * y\n-                                ax.set_ylim(ymin, ymax)\n-                                ax.figure.canvas.draw()\n-\n-                            if total:\n-                                line1.set_data(xdata, ydata)\n-                                line2.set_data(xdata, zdata)\n-                                try:\n-                                    poly_lims = self.hspan.get_xy()\n-                                except AttributeError:\n-                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n-                                                             xmax=0, color='g')\n-                                    poly_lims = self.hspan.get_xy()\n-                                poly_lims[0, 1] = ymin\n-                                poly_lims[1, 1] = ymax\n-                                poly_lims[2] = [n / total, ymax]\n-                                poly_lims[3] = [poly_lims[2, 0], ymin]\n-                                if len(poly_lims) > 4:\n-                                    poly_lims[4, 1] = ymin\n-                                self.hspan.set_xy(poly_lims)\n-                            else:\n-                                t_ago = [cur_t - i for i in xdata]\n-                                line1.set_data(t_ago, ydata)\n-                                line2.set_data(t_ago, zdata)\n-\n-                            ax.set_title(format_meter(\n-                                n, total, elapsed, 0,\n-                                self.desc, ascii, unit, unit_scale),\n-                                fontname=\"DejaVu Sans Mono\",\n-                                fontsize=11)\n-                            plt.pause(1e-9)\n-                        else:\n-                            # EMA (not just overall average)\n-                            if smoothing and delta_t:\n-                                avg_rate = delta_it / delta_t \\\n-                                    if avg_rate is None \\\n-                                    else smoothing * delta_it / delta_t + \\\n-                                    (1 - smoothing) * avg_rate\n-\n-                            sp(format_meter(\n-                                n, self.total, elapsed,\n-                                (dynamic_ncols(self.fp) if dynamic_ncols\n-                                 else ncols),\n-                                self.desc, ascii, unit, unit_scale, avg_rate))\n+                        # EMA (not just overall average)\n+                        if smoothing and delta_t:\n+                            avg_rate = delta_it / delta_t \\\n+                                if avg_rate is None \\\n+                                else smoothing * delta_it / delta_t + \\\n+                                (1 - smoothing) * avg_rate\n+\n+                        sp(format_meter(\n+                            n, self.total, elapsed,\n+                            (dynamic_ncols(self.fp) if dynamic_ncols\n+                             else ncols),\n+                            self.desc, ascii, unit, unit_scale, avg_rate))\n \n                         # If no `miniters` was specified, adjust automatically\n                         # to the maximum iteration rate seen so far.\n@@ -562,26 +439,185 @@ class tqdm(object):\n             delta_t = cur_t - self.last_print_t\n             if delta_t >= self.mininterval:\n                 elapsed = cur_t - self.start_t\n-                if self.gui:  # pragma: no cover\n+                # EMA (not just overall average)\n+                if self.smoothing and delta_t:\n+                    self.avg_rate = delta_it / delta_t \\\n+                        if self.avg_rate is None \\\n+                        else self.smoothing * delta_it / delta_t + \\\n+                        (1 - self.smoothing) * self.avg_rate\n+\n+                self.sp(format_meter(\n+                    self.n, self.total, elapsed,\n+                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n+                     else self.ncols),\n+                    self.desc, self.ascii, self.unit, self.unit_scale,\n+                    self.avg_rate))\n+\n+                # If no `miniters` was specified, adjust automatically to the\n+                # maximum iteration rate seen so far.\n+                # e.g.: After running `tqdm.update(5)`, subsequent\n+                # calls to `tqdm.update()` will only cause an update after\n+                # at least 5 more iterations.\n+                if self.dynamic_miniters:\n+                    self.miniters = max(self.miniters, delta_it)\n+\n+                # Store old values for next call\n+                self.last_print_n = self.n\n+                self.last_print_t = cur_t\n+\n+    def close(self):\n+        \"\"\"\n+        Cleanup and (if leave=False) close the progressbar.\n+        \"\"\"\n+        if self.disable:\n+            return\n+\n+        if self.leave:\n+            if self.last_print_n < self.n:\n+                cur_t = time()\n+                # stats for overall rate (no weighted average)\n+                self.sp(format_meter(\n+                    self.n, self.total, cur_t - self.start_t,\n+                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n+                     else self.ncols),\n+                    self.desc, self.ascii, self.unit, self.unit_scale))\n+            self.fp.write('\\n')\n+        else:\n+            self.sp('')\n+            self.fp.write('\\r')\n+\n+\n+class tqdm_gui(tqdm):  # pragma: no cover\n+    def __init__(self, *args, **kwargs):\n+\n+        # try:  # pragma: no cover\n+        import matplotlib as mpl\n+        import matplotlib.pyplot as plt\n+        from collections import deque\n+        # except ImportError:  # gui not available\n+        #   kwargs['gui'] = False\n+        # else:\n+        kwargs['gui'] = True\n+\n+        super(tqdm_gui, self).__init__(*args, **kwargs)\n+\n+        # Initialize the GUI display\n+        if self.disable or not kwargs['gui']:\n+            return\n+\n+        self.fp.write('Warning: GUI is experimental/alpha\\n')\n+        self.mpl = mpl\n+        self.plt = plt\n+        self.sp = None\n+\n+        # Remember if external environment uses toolbars\n+        self.toolbar = self.mpl.rcParams['toolbar']\n+        self.mpl.rcParams['toolbar'] = 'None'\n+\n+        self.mininterval = max(self.mininterval, 0.5)\n+        self.fig, ax = plt.subplots(figsize=(9, 2.2))\n+        # self.fig.subplots_adjust(bottom=0.2)\n+        if self.total:\n+            self.xdata = []\n+            self.ydata = []\n+            self.zdata = []\n+        else:\n+            self.xdata = deque([])\n+            self.ydata = deque([])\n+            self.zdata = deque([])\n+        self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n+        self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n+        ax.set_ylim(0, 0.001)\n+        if self.total:\n+            ax.set_xlim(0, 100)\n+            ax.set_xlabel('percent')\n+            self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n+                            loc='center right')\n+            # progressbar\n+            self.hspan = plt.axhspan(0, 0.001,\n+                                     xmin=0, xmax=0, color='g')\n+        else:\n+            # ax.set_xlim(-60, 0)\n+            ax.set_xlim(0, 60)\n+            ax.invert_xaxis()\n+            ax.set_xlabel('seconds')\n+            ax.legend(('cur', 'est'), loc='lower left')\n+        ax.grid()\n+        # ax.set_xlabel('seconds')\n+        ax.set_ylabel((self.unit if self.unit else 'it') + '/s')\n+        if self.unit_scale:\n+            plt.ticklabel_format(style='sci', axis='y',\n+                                 scilimits=(0, 0))\n+            ax.yaxis.get_offset_text().set_x(-0.15)\n+\n+        # Remember if external environment is interactive\n+        self.wasion = plt.isinteractive()\n+        plt.ion()\n+        self.ax = ax\n+\n+    def __iter__(self):\n+        # TODO: somehow allow the following:\n+        # if not self.gui:\n+        #   return super(tqdm_gui, self).__iter__()\n+        iterable = self.iterable\n+        if self.disable:\n+            for obj in iterable:\n+                yield obj\n+            return\n+\n+        # ncols = self.ncols\n+        mininterval = self.mininterval\n+        miniters = self.miniters\n+        dynamic_miniters = self.dynamic_miniters\n+        unit = self.unit\n+        unit_scale = self.unit_scale\n+        ascii = self.ascii\n+        start_t = self.start_t\n+        last_print_t = self.last_print_t\n+        last_print_n = self.last_print_n\n+        n = self.n\n+        # dynamic_ncols = self.dynamic_ncols\n+        # smoothing = self.smoothing\n+        # avg_rate = self.avg_rate\n+\n+        plt = self.plt\n+        ax = self.ax\n+        xdata = self.xdata\n+        ydata = self.ydata\n+        zdata = self.zdata\n+        line1 = self.line1\n+        line2 = self.line2\n+\n+        for obj in iterable:\n+            yield obj\n+            # Update and print the progressbar.\n+            # Note: does not call self.update(1) for speed optimisation.\n+            n += 1\n+            delta_it = n - last_print_n\n+            # check the counter first (avoid calls to time())\n+            if delta_it >= miniters:\n+                cur_t = time()\n+                delta_t = cur_t - last_print_t\n+                if delta_t >= mininterval:  # pragma: no cover\n+                    elapsed = cur_t - start_t\n                     # Inline due to multiple calls\n                     total = self.total\n-                    ax = self.ax\n-\n                     # instantaneous rate\n                     y = delta_it / delta_t\n-                    # smoothed rate\n-                    z = self.n / elapsed\n+                    # overall rate\n+                    z = n / elapsed\n                     # update line data\n-                    self.xdata.append(self.n * 100.0 / total\n-                                      if total else cur_t)\n-                    self.ydata.append(y)\n-                    self.zdata.append(z)\n+                    xdata.append(n * 100.0 / total if total else cur_t)\n+                    ydata.append(y)\n+                    zdata.append(z)\n \n                     # Discard old values\n+                    # xmin, xmax = ax.get_xlim()\n+                    # if (not total) and elapsed > xmin * 1.1:\n                     if (not total) and elapsed > 66:\n-                        self.xdata.popleft()\n-                        self.ydata.popleft()\n-                        self.zdata.popleft()\n+                        xdata.popleft()\n+                        ydata.popleft()\n+                        zdata.popleft()\n \n                     ymin, ymax = ax.get_ylim()\n                     if y > ymax or z > ymax:\n@@ -590,52 +626,121 @@ class tqdm(object):\n                         ax.figure.canvas.draw()\n \n                     if total:\n-                        self.line1.set_data(self.xdata, self.ydata)\n-                        self.line2.set_data(self.xdata, self.zdata)\n+                        line1.set_data(xdata, ydata)\n+                        line2.set_data(xdata, zdata)\n                         try:\n                             poly_lims = self.hspan.get_xy()\n                         except AttributeError:\n-                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n-                                                          xmax=0, color='g')\n+                            self.hspan = plt.axhspan(0, 0.001, xmin=0,\n+                                                     xmax=0, color='g')\n                             poly_lims = self.hspan.get_xy()\n                         poly_lims[0, 1] = ymin\n                         poly_lims[1, 1] = ymax\n-                        poly_lims[2] = [self.n / total, ymax]\n+                        poly_lims[2] = [n / total, ymax]\n                         poly_lims[3] = [poly_lims[2, 0], ymin]\n                         if len(poly_lims) > 4:\n                             poly_lims[4, 1] = ymin\n                         self.hspan.set_xy(poly_lims)\n                     else:\n-                        t_ago = [cur_t - i for i in self.xdata]\n-                        self.line1.set_data(t_ago, self.ydata)\n-                        self.line2.set_data(t_ago, self.zdata)\n+                        t_ago = [cur_t - i for i in xdata]\n+                        line1.set_data(t_ago, ydata)\n+                        line2.set_data(t_ago, zdata)\n \n                     ax.set_title(format_meter(\n-                        self.n, total, elapsed, 0,\n-                        self.desc, self.ascii, self.unit, self.unit_scale),\n+                        n, total, elapsed, 0,\n+                        self.desc, ascii, unit, unit_scale),\n                         fontname=\"DejaVu Sans Mono\",\n                         fontsize=11)\n-                    self.plt.pause(1e-9)\n+                    plt.pause(1e-9)\n+\n+                    # If no `miniters` was specified, adjust automatically\n+                    # to the maximum iteration rate seen so far.\n+                    if dynamic_miniters:\n+                        miniters = max(miniters, delta_it)\n+\n+                    # Store old values for next call\n+                    last_print_n = n\n+                    last_print_t = cur_t\n+\n+        # Closing the progress bar.\n+        # Update some internal variables for close().\n+        self.last_print_n = last_print_n\n+        self.n = n\n+        self.close()\n+\n+    def update(self, n=1):\n+        # if not self.gui:\n+        #   return super(tqdm_gui, self).close()\n+        if self.disable:\n+            return\n+\n+        if n < 1:\n+            n = 1\n+        self.n += n\n+\n+        delta_it = self.n - self.last_print_n  # should be n?\n+        if delta_it >= self.miniters:\n+            # We check the counter first, to reduce the overhead of time()\n+            cur_t = time()\n+            delta_t = cur_t - self.last_print_t\n+            if delta_t >= self.mininterval:\n+                elapsed = cur_t - self.start_t\n+                # Inline due to multiple calls\n+                total = self.total\n+                ax = self.ax\n+\n+                # instantaneous rate\n+                y = delta_it / delta_t\n+                # smoothed rate\n+                z = self.n / elapsed\n+                # update line data\n+                self.xdata.append(self.n * 100.0 / total\n+                                  if total else cur_t)\n+                self.ydata.append(y)\n+                self.zdata.append(z)\n+\n+                # Discard old values\n+                if (not total) and elapsed > 66:\n+                    self.xdata.popleft()\n+                    self.ydata.popleft()\n+                    self.zdata.popleft()\n+\n+                ymin, ymax = ax.get_ylim()\n+                if y > ymax or z > ymax:\n+                    ymax = 1.1 * y\n+                    ax.set_ylim(ymin, ymax)\n+                    ax.figure.canvas.draw()\n+\n+                if total:\n+                    self.line1.set_data(self.xdata, self.ydata)\n+                    self.line2.set_data(self.xdata, self.zdata)\n+                    try:\n+                        poly_lims = self.hspan.get_xy()\n+                    except AttributeError:\n+                        self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n+                                                      xmax=0, color='g')\n+                        poly_lims = self.hspan.get_xy()\n+                    poly_lims[0, 1] = ymin\n+                    poly_lims[1, 1] = ymax\n+                    poly_lims[2] = [self.n / total, ymax]\n+                    poly_lims[3] = [poly_lims[2, 0], ymin]\n+                    if len(poly_lims) > 4:\n+                        poly_lims[4, 1] = ymin\n+                    self.hspan.set_xy(poly_lims)\n                 else:\n-                    # EMA (not just overall average)\n-                    if self.smoothing and delta_t:\n-                        self.avg_rate = delta_it / delta_t \\\n-                            if self.avg_rate is None \\\n-                            else self.smoothing * delta_it / delta_t + \\\n-                            (1 - self.smoothing) * self.avg_rate\n-\n-                    self.sp(format_meter(\n-                        self.n, self.total, elapsed,\n-                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n-                         else self.ncols),\n-                        self.desc, self.ascii, self.unit, self.unit_scale,\n-                        self.avg_rate))\n+                    t_ago = [cur_t - i for i in self.xdata]\n+                    self.line1.set_data(t_ago, self.ydata)\n+                    self.line2.set_data(t_ago, self.zdata)\n+\n+                ax.set_title(format_meter(\n+                    self.n, total, elapsed, 0,\n+                    self.desc, self.ascii, self.unit, self.unit_scale),\n+                    fontname=\"DejaVu Sans Mono\",\n+                    fontsize=11)\n+                self.plt.pause(1e-9)\n \n                 # If no `miniters` was specified, adjust automatically to the\n                 # maximum iteration rate seen so far.\n-                # e.g.: After running `tqdm.update(5)`, subsequent\n-                # calls to `tqdm.update()` will only cause an update after\n-                # at least 5 more iterations.\n                 if self.dynamic_miniters:\n                     self.miniters = max(self.miniters, delta_it)\n \n@@ -644,34 +749,18 @@ class tqdm(object):\n                 self.last_print_t = cur_t\n \n     def close(self):\n-        \"\"\"\n-        Cleanup and (if leave=False) close the progressbar.\n-        \"\"\"\n+        # if not self.gui:\n+        #   return super(tqdm_gui, self).close()\n         if self.disable:\n             return\n \n-        if self.gui:  # pragma: no cover\n-            # Restore toolbars\n-            self.mpl.rcParams['toolbar'] = self.toolbar\n-            # Return to non-interactive mode\n-            if not self.wasion:\n-                self.plt.ioff()\n-            if not self.leave:\n-                self.plt.close(self.fig)\n-        else:\n-            if self.leave:\n-                if self.last_print_n < self.n:\n-                    cur_t = time()\n-                    # stats for overall rate (no weighted average)\n-                    self.sp(format_meter(\n-                        self.n, self.total, cur_t-self.start_t,\n-                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n-                         else self.ncols),\n-                        self.desc, self.ascii, self.unit, self.unit_scale))\n-                self.fp.write('\\n')\n-            else:\n-                self.sp('')\n-                self.fp.write('\\r')\n+        # Restore toolbars\n+        self.mpl.rcParams['toolbar'] = self.toolbar\n+        # Return to non-interactive mode\n+        if not self.wasion:\n+            self.plt.ioff()\n+        if not self.leave:\n+            self.plt.close(self.fig)\n \n \n def trange(*args, **kwargs):\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "_tqdm.py"
          ]
        }
      }
    }
  }
}
{
  "id": "61",
  "blame_commit": {
    "commit": {
      "commit_id": "80bd2b3134b4f01da4e279d040a224326b3577e5",
      "commit_message": "Normalize string quotes (#75)\n\n* Normalize string quotes\r\n\r\nConvert single-quoted strings to double-quoted. Convert triple single-quoted strings to triple double-quoted. Do not touch any strings where conversion would increase the number of backslashes.\r\n\r\nFixes #51.\r\n\r\n* reformat Black itself",
      "commit_author": "Zsolt Dollenstein",
      "commit_date": "2018-03-31 11:21:25",
      "commit_parent": "4dfec562ed3332212cb938d6d4da9671b503ac93"
    },
    "function": {
      "function_name": "dump_to_file",
      "function_code_before": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n    with tempfile.NamedTemporaryFile(mode='w', prefix='blk_', suffix='.log', delete=False) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name",
      "function_code_after": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n    with tempfile.NamedTemporaryFile(mode='w', prefix='blk_', suffix='.log', delete=False) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name",
      "function_before_start_line": 1973,
      "function_before_end_line": 1983,
      "function_after_start_line": 2012,
      "function_after_end_line": 2022,
      "function_before_token_count": 58,
      "function_after_token_count": 58,
      "functions_name_modified_file": [
        "format_str",
        "mark",
        "is_def",
        "visit_default",
        "visit_INDENT",
        "is_delimiter",
        "cancel",
        "diff",
        "is_import",
        "right_hand_split",
        "comments_after",
        "append",
        "format_file_contents",
        "trim_prefix",
        "delimiter_split",
        "visit_SEMI",
        "is_comment",
        "visit_decorators",
        "visit_async_stmt",
        "any_open_brackets",
        "is_python36",
        "format_file_in_place",
        "__attrs_post_init__",
        "schedule_formatting",
        "visit_simple_stmt",
        "shutdown",
        "maybe_increment_for_loop_variable",
        "main",
        "append_comment",
        "visit_stmt",
        "failed",
        "is_decorator",
        "maybe_decrement_after_for_loop_variable",
        "visit",
        "lib2to3_unparse",
        "standalone_comment_split",
        "contains_standalone_comments",
        "visit_DEDENT",
        "gen_python_files_in_dir",
        "preceding_leaf",
        "visit_ENDMARKER",
        "is_yield",
        "leaf_from_consumed",
        "show",
        "whitespace",
        "_maybe_empty_lines",
        "format_stdin_to_stdout",
        "__bool__",
        "dont_increase_indentation",
        "__str__",
        "split_line",
        "make_comment",
        "assert_equivalent",
        "max_delimiter_priority",
        "done",
        "__init__",
        "remove_trailing_comma",
        "maybe_empty_lines",
        "generate_comments",
        "assert_stable",
        "bracket_split_succeeded_or_raise",
        "lib2to3_parse",
        "append_safe",
        "normalize_prefix",
        "is_class",
        "is_flow_control",
        "normalize_string_quotes",
        "return_code",
        "left_hand_split",
        "line",
        "maybe_remove_trailing_comma",
        "dump_to_file",
        "visit_unformatted"
      ],
      "functions_name_all_files": [
        "spaces_types",
        "test_setup",
        "comments_after",
        "delimiter_split",
        "get_long_description",
        "g",
        "read_data",
        "test_comments",
        "append_comment",
        "visit_stmt",
        "test_cantfit",
        "test_import_spacing",
        "visit_DEDENT",
        "coroutine",
        "test_fails_invalid_post_data",
        "failed",
        "is_yield",
        "leaf_from_consumed",
        "show",
        "__init__",
        "spaces2",
        "is_flow_control",
        "return_code",
        "dump_to_stderr",
        "maybe_remove_trailing_comma",
        "dump_to_file",
        "func",
        "test_self",
        "is_def",
        "cancel",
        "diff",
        "right_hand_split",
        "is_comment",
        "test",
        "maybe_increment_for_loop_variable",
        "main",
        "maybe_decrement_after_for_loop_variable",
        "test_composition",
        "visit",
        "lib2to3_unparse",
        "standalone_comment_split",
        "test_python2",
        "__bool__",
        "__str__",
        "split_line",
        "bracket_split_succeeded_or_raise",
        "test_function",
        "normalize_string_quotes",
        "spaces",
        "visit_INDENT",
        "visit_default",
        "get_version",
        "is_import",
        "func_no_args",
        "test_comments3",
        "append",
        "test_expression",
        "format_file_contents",
        "visit_SEMI",
        "assertFormatEqual",
        "visit_decorators",
        "test_debug_visitor",
        "test_piping",
        "visit_async_stmt",
        "test_black",
        "any_open_brackets",
        "function",
        "is_python36",
        "inline_comments_in_brackets_ruin_everything",
        "visit_simple_stmt",
        "shutdown",
        "foo",
        "is_decorator",
        "test_report",
        "preceding_leaf",
        "visit_ENDMARKER",
        "_maybe_empty_lines",
        "format_stdin_to_stdout",
        "dont_increase_indentation",
        "assert_equivalent",
        "max_delimiter_priority",
        "maybe_empty_lines",
        "assert_stable",
        "f",
        "normalize_prefix",
        "test_is_python36",
        "format_str",
        "mark",
        "test_fmtonoff",
        "test_fstring",
        "is_delimiter",
        "gen",
        "trim_prefix",
        "format_file_in_place",
        "__attrs_post_init__",
        "schedule_formatting",
        "test_comments4",
        "contains_standalone_comments",
        "function_signature_stress_test",
        "gen_python_files_in_dir",
        "test_string_quotes",
        "whitespace",
        "make_comment",
        "test_comments2",
        "done",
        "generate_comments",
        "remove_trailing_comma",
        "long_lines",
        "lib2to3_parse",
        "append_safe",
        "is_class",
        "example",
        "wat",
        "left_hand_split",
        "line",
        "test_empty_lines",
        "visit_unformatted"
      ],
      "functions_name_co_evolved_modified_file": [
        "mark",
        "is_def",
        "visit_default",
        "diff",
        "is_import",
        "format_file_contents",
        "delimiter_split",
        "is_python36",
        "__attrs_post_init__",
        "schedule_formatting",
        "maybe_increment_for_loop_variable",
        "main",
        "append_comment",
        "maybe_decrement_after_for_loop_variable",
        "visit",
        "failed",
        "is_yield",
        "whitespace",
        "_maybe_empty_lines",
        "assert_equivalent",
        "__str__",
        "split_line",
        "make_comment",
        "done",
        "generate_comments",
        "assert_stable",
        "lib2to3_parse",
        "normalize_prefix",
        "normalize_string_quotes",
        "is_class"
      ],
      "functions_name_co_evolved_all_files": [
        "func",
        "mark",
        "is_def",
        "visit_default",
        "test_fstring",
        "spaces_types",
        "test_self",
        "get_version",
        "diff",
        "is_import",
        "func_no_args",
        "test_fmtonoff",
        "test_setup",
        "test_comments3",
        "test_expression",
        "format_file_contents",
        "delimiter_split",
        "get_long_description",
        "assertFormatEqual",
        "test_debug_visitor",
        "test_piping",
        "test_black",
        "g",
        "is_python36",
        "inline_comments_in_brackets_ruin_everything",
        "__attrs_post_init__",
        "schedule_formatting",
        "read_data",
        "test",
        "maybe_increment_for_loop_variable",
        "test_comments",
        "main",
        "append_comment",
        "foo",
        "test_comments4",
        "maybe_decrement_after_for_loop_variable",
        "test_cantfit",
        "test_composition",
        "visit",
        "test_python2",
        "test_import_spacing",
        "function_signature_stress_test",
        "test_report",
        "coroutine",
        "failed",
        "is_yield",
        "test_string_quotes",
        "whitespace",
        "_maybe_empty_lines",
        "assert_equivalent",
        "__str__",
        "split_line",
        "make_comment",
        "test_comments2",
        "done",
        "generate_comments",
        "assert_stable",
        "test_function",
        "lib2to3_parse",
        "f",
        "normalize_prefix",
        "normalize_string_quotes",
        "is_class",
        "test_is_python36",
        "dump_to_stderr",
        "wat",
        "spaces",
        "test_empty_lines"
      ]
    },
    "file": {
      "file_name": "black.py",
      "file_nloc": 1692,
      "file_complexity": 514,
      "file_token_count": 9178,
      "file_before": "#!/usr/bin/env python3\n\nimport asyncio\nfrom asyncio.base_events import BaseEventLoop\nfrom concurrent.futures import Executor, ProcessPoolExecutor\nfrom functools import partial, wraps\nimport keyword\nimport logging\nimport os\nfrom pathlib import Path\nimport tokenize\nimport signal\nimport sys\nfrom typing import (\n    Callable,\n    Dict,\n    Generic,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\n\nfrom attr import dataclass, Factory\nimport click\n\n# lib2to3 fork\nfrom blib2to3.pytree import Node, Leaf, type_repr\nfrom blib2to3 import pygram, pytree\nfrom blib2to3.pgen2 import driver, token\nfrom blib2to3.pgen2.parse import ParseError\n\n__version__ = \"18.3a4\"\nDEFAULT_LINE_LENGTH = 88\n# types\nsyms = pygram.python_symbols\nFileContent = str\nEncoding = str\nDepth = int\nNodeType = int\nLeafID = int\nPriority = int\nIndex = int\nLN = Union[Leaf, Node]\nSplitFunc = Callable[['Line', bool], Iterator['Line']]\nout = partial(click.secho, bold=True, err=True)\nerr = partial(click.secho, fg='red', err=True)\n\n\nclass NothingChanged(UserWarning):\n    \"\"\"Raised by :func:`format_file` when reformatted code is the same as source.\"\"\"\n\n\nclass CannotSplit(Exception):\n    \"\"\"A readable split that fits the allotted line length is impossible.\n\n    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and\n    :func:`delimiter_split`.\n    \"\"\"\n\n\nclass FormatError(Exception):\n    \"\"\"Base exception for `# fmt: on` and `# fmt: off` handling.\n\n    It holds the number of bytes of the prefix consumed before the format\n    control comment appeared.\n    \"\"\"\n\n    def __init__(self, consumed: int) -> None:\n        super().__init__(consumed)\n        self.consumed = consumed\n\n    def trim_prefix(self, leaf: Leaf) -> None:\n        leaf.prefix = leaf.prefix[self.consumed:]\n\n    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:\n        \"\"\"Returns a new Leaf from the consumed part of the prefix.\"\"\"\n        unformatted_prefix = leaf.prefix[:self.consumed]\n        return Leaf(token.NEWLINE, unformatted_prefix)\n\n\nclass FormatOn(FormatError):\n    \"\"\"Found a comment like `# fmt: on` in the file.\"\"\"\n\n\nclass FormatOff(FormatError):\n    \"\"\"Found a comment like `# fmt: off` in the file.\"\"\"\n\n\n@click.command()\n@click.option(\n    '-l',\n    '--line-length',\n    type=int,\n    default=DEFAULT_LINE_LENGTH,\n    help='How many character per line to allow.',\n    show_default=True,\n)\n@click.option(\n    '--check',\n    is_flag=True,\n    help=(\n        \"Don't write back the files, just return the status.  Return code 0 \"\n        \"means nothing would change.  Return code 1 means some files would be \"\n        \"reformatted.  Return code 123 means there was an internal error.\"\n    ),\n)\n@click.option(\n    '--fast/--safe',\n    is_flag=True,\n    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n)\n@click.version_option(version=__version__)\n@click.argument(\n    'src',\n    nargs=-1,\n    type=click.Path(\n        exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True\n    ),\n)\n@click.pass_context\ndef main(\n    ctx: click.Context, line_length: int, check: bool, fast: bool, src: List[str]\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        elif s == '-':\n            sources.append(Path('-'))\n        else:\n            err(f'invalid path: {s}')\n    if len(sources) == 0:\n        ctx.exit(0)\n    elif len(sources) == 1:\n        p = sources[0]\n        report = Report(check=check)\n        try:\n            if not p.is_file() and str(p) == '-':\n                changed = format_stdin_to_stdout(\n                    line_length=line_length, fast=fast, write_back=not check\n                )\n            else:\n                changed = format_file_in_place(\n                    p, line_length=line_length, fast=fast, write_back=not check\n                )\n            report.done(p, changed)\n        except Exception as exc:\n            report.failed(p, str(exc))\n        ctx.exit(report.return_code)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        return_code = 1\n        try:\n            return_code = loop.run_until_complete(\n                schedule_formatting(\n                    sources, line_length, not check, fast, loop, executor\n                )\n            )\n        finally:\n            shutdown(loop)\n            ctx.exit(return_code)\n\n\nasync def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    write_back: bool,\n    fast: bool,\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> int:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    tasks = {\n        src: loop.run_in_executor(\n            executor, format_file_in_place, src, line_length, fast, write_back\n        )\n        for src in sources\n    }\n    _task_values = list(tasks.values())\n    loop.add_signal_handler(signal.SIGINT, cancel, _task_values)\n    loop.add_signal_handler(signal.SIGTERM, cancel, _task_values)\n    await asyncio.wait(tasks.values())\n    cancelled = []\n    report = Report(check=not write_back)\n    for src, task in tasks.items():\n        if not task.done():\n            report.failed(src, 'timed out, cancelling')\n            task.cancel()\n            cancelled.append(task)\n        elif task.cancelled():\n            cancelled.append(task)\n        elif task.exception():\n            report.failed(src, str(task.exception()))\n        else:\n            report.done(src, task.result())\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    else:\n        out('All done! \u2728 \ud83c\udf70 \u2728')\n    click.echo(str(report))\n    return report.return_code\n\n\ndef format_file_in_place(\n    src: Path, line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(contents)\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    contents = sys.stdin.read()\n    try:\n        contents = format_file_contents(contents, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back:\n            sys.stdout.write(contents)\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `line_length` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == '':\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents\n\n\ndef format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `line_length` determines how many characters per line are allowed.\n    \"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    py36 = is_python36(src_node)\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        for line in split_line(current_line, line_length=line_length, py36=py36):\n            dst_contents += str(line)\n    return dst_contents\n\n\nGRAMMARS = [\n    pygram.python_grammar_no_print_statement_no_exec_statement,\n    pygram.python_grammar_no_print_statement,\n    pygram.python_grammar_no_exec_statement,\n    pygram.python_grammar,\n]\n\n\ndef lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    if src_txt[-1] != '\\n':\n        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n        src_txt += nl\n    for grammar in GRAMMARS:\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result\n\n\ndef lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code\n\n\nT = TypeVar('T')\n\n\nclass Visitor(Generic[T]):\n    \"\"\"Basic lib2to3 visitor that yields things of type `T` on `visit()`.\"\"\"\n\n    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n\n@dataclass\nclass DebugVisitor(Visitor[T]):\n    tree_depth: int = 0\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = ' ' * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f'{indent}{_type}', fg='yellow')\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f'{indent}/{_type}', fg='yellow', bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f'{indent}{_type}', fg='blue', nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n            out(f' {node.value!r}', fg='blue', bold=False)\n\n    @classmethod\n    def show(cls, code: str) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))\n\n\nKEYWORDS = set(keyword.kwlist)\nWHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\nFLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\nSTATEMENT = {\n    syms.if_stmt,\n    syms.while_stmt,\n    syms.for_stmt,\n    syms.try_stmt,\n    syms.except_clause,\n    syms.with_stmt,\n    syms.funcdef,\n    syms.classdef,\n}\nSTANDALONE_COMMENT = 153\nLOGIC_OPERATORS = {'and', 'or'}\nCOMPARATORS = {\n    token.LESS,\n    token.GREATER,\n    token.EQEQUAL,\n    token.NOTEQUAL,\n    token.LESSEQUAL,\n    token.GREATEREQUAL,\n}\nMATH_OPERATORS = {\n    token.PLUS,\n    token.MINUS,\n    token.STAR,\n    token.SLASH,\n    token.VBAR,\n    token.AMPER,\n    token.PERCENT,\n    token.CIRCUMFLEX,\n    token.TILDE,\n    token.LEFTSHIFT,\n    token.RIGHTSHIFT,\n    token.DOUBLESTAR,\n    token.DOUBLESLASH,\n}\nCOMPREHENSION_PRIORITY = 20\nCOMMA_PRIORITY = 10\nLOGIC_PRIORITY = 5\nSTRING_PRIORITY = 4\nCOMPARATOR_PRIORITY = 3\nMATH_PRIORITY = 1\n\n\n@dataclass\nclass BracketTracker:\n    \"\"\"Keeps track of brackets on a line.\"\"\"\n\n    depth: int = 0\n    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n    delimiters: Dict[LeafID, Priority] = Factory(dict)\n    previous: Optional[Leaf] = None\n\n    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_delimiter(leaf)\n            if delim:\n                self.delimiters[id(leaf)] = delim\n            elif self.previous is not None:\n                if leaf.type == token.STRING and self.previous.type == token.STRING:\n                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'for'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'if'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value in LOGIC_OPERATORS\n                    and leaf.parent\n                ):\n                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n\n    def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)\n\n    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_delimiter()` returns.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)\n\n\n@dataclass\nclass Line:\n    \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n\n    depth: int = 0\n    leaves: List[Leaf] = Factory(list)\n    comments: List[Tuple[Index, Leaf]] = Factory(list)\n    bracket_tracker: BracketTracker = Factory(BracketTracker)\n    inside_brackets: bool = False\n    has_for: bool = False\n    _for_loop_variable: bool = False\n\n    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.value.strip()\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.maybe_decrement_after_for_loop_variable(leaf)\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n            self.maybe_increment_for_loop_variable(leaf)\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Like :func:`append()` but disallow invalid standalone comment structure.\n\n        Raises ValueError when any `leaf` is appended after a standalone comment\n        or when a standalone comment is not the first leaf on the line.\n        \"\"\"\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n\n        self.append(leaf, preformatted=preformatted)\n\n    @property\n    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT\n\n    @property\n    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT\n\n    @property\n    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])\n\n    @property\n    def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'class'\n        )\n\n    @property\n    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == 'def')\n            or (\n                first_leaf.type == token.ASYNC\n                and second_leaf is not None\n                and second_leaf.type == token.NAME\n                and second_leaf.value == 'def'\n            )\n        )\n\n    @property\n    def is_flow_control(self) -> bool:\n        \"\"\"Is this line a flow control statement?\n\n        Those are `return`, `raise`, `break`, and `continue`.\n        \"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value in FLOW_CONTROL\n        )\n\n    @property\n    def is_yield(self) -> bool:\n        \"\"\"Is this line a yield statement?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'yield'\n        )\n\n    @property\n    def contains_standalone_comments(self) -> bool:\n        \"\"\"If so, needs to be split before emitting.\"\"\"\n        for leaf in self.leaves:\n            if leaf.type == STANDALONE_COMMENT:\n                return True\n\n        return False\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (\n            self.leaves\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RBRACE:\n            self.remove_trailing_comma()\n            return True\n\n        if closing.type == token.RSQB:\n            comma = self.leaves[-1]\n            if comma.parent and comma.parent.type == syms.listmaker:\n                self.remove_trailing_comma()\n                return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1\n        commas = 0\n        opening = closing.opening_bracket\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n                if leaf.parent and leaf.parent.type == syms.arglist:\n                    commas += 1\n                    break\n\n        if commas > 1:\n            self.remove_trailing_comma()\n            return True\n\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == 'for':\n            self.has_for = True\n            self.bracket_tracker.depth += 1\n            self._for_loop_variable = True\n            return True\n\n        return False\n\n    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':\n            self.bracket_tracker.depth -= 1\n            self._for_loop_variable = False\n            return True\n\n        return False\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline or standalone comment to the line.\"\"\"\n        if (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            comment.prefix = ''\n            return False\n\n        if comment.type != token.COMMENT:\n            return False\n\n        after = len(self.leaves) - 1\n        if after == -1:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = ''\n            return False\n\n        else:\n            self.comments.append((after, comment))\n            return True\n\n    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:\n        \"\"\"Generate comments that should appear directly after `leaf`.\"\"\"\n        for _leaf_index, _leaf in enumerate(self.leaves):\n            if leaf is _leaf:\n                break\n\n        else:\n            return\n\n        for index, comment_after in self.comments:\n            if _leaf_index == index:\n                yield comment_after\n\n    def remove_trailing_comma(self) -> None:\n        \"\"\"Remove the trailing comma and moves the comments attached to it.\"\"\"\n        comma_index = len(self.leaves) - 1\n        for i in range(len(self.comments)):\n            comment_index, comment = self.comments[i]\n            if comment_index == comma_index:\n                self.comments[i] = (comma_index - 1, comment)\n        self.leaves.pop()\n\n    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return '\\n'\n\n        indent = '    ' * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f'{first.prefix}{indent}{first.value}'\n        for leaf in leaves:\n            res += str(leaf)\n        for _, comment in self.comments:\n            res += str(comment)\n        return res + '\\n'\n\n    def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)\n\n\nclass UnformattedLines(Line):\n    \"\"\"Just like :class:`Line` but stores lines which aren't reformatted.\"\"\"\n\n    def append(self, leaf: Leaf, preformatted: bool = True) -> None:\n        \"\"\"Just add a new `leaf` to the end of the lines.\n\n        The `preformatted` argument is ignored.\n\n        Keeps track of indentation `depth`, which is useful when the user\n        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.\n        \"\"\"\n        try:\n            list(generate_comments(leaf))\n        except FormatOn as f_on:\n            self.leaves.append(f_on.leaf_from_consumed(leaf))\n            raise\n\n        self.leaves.append(leaf)\n        if leaf.type == token.INDENT:\n            self.depth += 1\n        elif leaf.type == token.DEDENT:\n            self.depth -= 1\n\n    def __str__(self) -> str:\n        \"\"\"Render unformatted lines from leaves which were added with `append()`.\n\n        `depth` is not used for indentation in this case.\n        \"\"\"\n        if not self:\n            return '\\n'\n\n        res = ''\n        for leaf in self.leaves:\n            res += str(leaf)\n        return res\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Not implemented in this class. Raises `NotImplementedError`.\"\"\"\n        raise NotImplementedError(\"Unformatted lines don't store comments separately.\")\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n\n@dataclass\nclass EmptyLineTracker:\n    \"\"\"Provides a stateful method that returns the number of potential extra\n    empty lines needed before and after the currently processed line.\n\n    Note: this tracker works on lines that haven't been split yet.  It assumes\n    the prefix of the first leaf consists of optional newlines.  Those newlines\n    are consumed by `maybe_empty_lines()` and included in the computation.\n    \"\"\"\n    previous_line: Optional[Line] = None\n    previous_after: int = 0\n    previous_defs: List[int] = Factory(list)\n\n    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level), as well as providing an extra empty line\n        after flow control keywords to make them more prominent.\n        \"\"\"\n        if isinstance(current_line, UnformattedLines):\n            return 0, 0\n\n        before, after = self._maybe_empty_lines(current_line)\n        before -= self.previous_after\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after\n\n    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count('\\n')\n            before = min(before, max_allowed)\n            first_leaf.prefix = ''\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = 1 if depth else 2\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_yield\n            and (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0\n\n\n@dataclass\nclass LineGenerator(Visitor[Line]):\n    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n\n    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n    in ways that will no longer stringify to valid Python code on the tree.\n    \"\"\"\n    current_line: Line = Factory(Line)\n\n    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            if self.current_line.__class__ == type:\n                self.current_line.depth += indent\n            else:\n                self.current_line = type(depth=self.current_line.depth + indent)\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = type(depth=complete_line.depth + indent)\n        yield complete_line\n\n    def visit(self, node: LN) -> Iterator[Line]:\n        \"\"\"Main method to visit `node` and its children.\n\n        Yields :class:`Line` objects.\n        \"\"\"\n        if isinstance(self.current_line, UnformattedLines):\n            # File contained `# fmt: off`\n            yield from self.visit_unformatted(node)\n\n        else:\n            yield from super().visit(node)\n\n    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            try:\n                for comment in generate_comments(node):\n                    if any_open_brackets:\n                        # any comment within brackets is subject to splitting\n                        self.current_line.append(comment)\n                    elif comment.type == token.COMMENT:\n                        # regular trailing comment\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n                    else:\n                        # regular standalone comment\n                        yield from self.line()\n\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n            except FormatOff as f_off:\n                f_off.trim_prefix(node)\n                yield from self.line(type=UnformattedLines)\n                yield from self.visit(node)\n\n            except FormatOn as f_on:\n                # This only happens here if somebody says \"fmt: on\" multiple\n                # times in a row.\n                f_on.trim_prefix(node)\n                yield from self.visit_default(node)\n\n            else:\n                normalize_prefix(node, inside_brackets=any_open_brackets)\n                if node.type not in WHITESPACE:\n                    self.current_line.append(node)\n        yield from super().visit_default(node)\n\n    def visit_INDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)\n\n    def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n        yield from self.line(-1)\n\n    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, and `class`.\n\n        The relevant Python language `keywords` for a given statement will be NAME\n        leaves within it. This methods puts those on a separate line.\n        \"\"\"\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)\n\n    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)\n\n    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)\n\n    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)\n\n    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()\n\n    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()\n\n    def visit_unformatted(self, node: LN) -> Iterator[Line]:\n        \"\"\"Used when file contained a `# fmt: off`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n        else:\n            try:\n                self.current_line.append(node)\n            except FormatOn as f_on:\n                f_on.trim_prefix(node)\n                yield from self.line()\n                yield from self.visit(node)\n\n    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n        self.visit_except_clause = partial(v, keywords={'except'})\n        self.visit_funcdef = partial(v, keywords={'def'})\n        self.visit_with_stmt = partial(v, keywords={'with'})\n        self.visit_classdef = partial(v, keywords={'class'})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators\n\n\nBRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\nOPENING_BRACKETS = set(BRACKET.keys())\nCLOSING_BRACKETS = set(BRACKET.values())\nBRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\nALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}\n\n\ndef whitespace(leaf: Leaf) -> str:  # noqa C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = ''\n    SPACE = ' '\n    DOUBLESPACE = '  '\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            return SPACE if prevp.type == token.COMMA else NO\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist, syms.argument, syms.parameters, syms.varargslist\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type == token.DOUBLESTAR:\n            if prevp.parent and prevp.parent.type in {\n                syms.arglist,\n                syms.argument,\n                syms.dictsetmaker,\n                syms.parameters,\n                syms.typedargslist,\n                syms.varargslist,\n            }:\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type in {syms.factor, syms.star_expr}\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == 'print'  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if t == token.RPAR:\n            return NO\n\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if t == token.RPAR:\n            return NO\n\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        else:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif (\n        p.type == syms.listmaker\n        or p.type == syms.testlist_gexp\n        or p.type == syms.subscriptlist\n    ):\n        # list interior, including unpacking\n        if not prev:\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict and set interior, including unpacking\n        if not prev:\n            return NO\n\n        if prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript, syms.sliceop\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == 'import':\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE\n\n\ndef preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None\n\n\ndef is_delimiter(leaf: Leaf) -> int:\n    \"\"\"Return the priority of the `leaf` delimiter. Return 0 if not delimiter.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    return 0\n\n\ndef generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    p = leaf.prefix\n    if not p:\n        return\n\n    if '#' not in p:\n        return\n\n    consumed = 0\n    nlines = 0\n    for index, line in enumerate(p.split('\\n')):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith('#'):\n            continue\n\n        if index == 0 and leaf.type != token.ENDMARKER:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        yield Leaf(comment_type, comment, prefix='\\n' * nlines)\n\n        if comment in {'# fmt: on', '# yapf: enable'}:\n            raise FormatOn(consumed)\n\n        if comment in {'# fmt: off', '# yapf: disable'}:\n            raise FormatOff(consumed)\n\n        nlines = 0\n\n\ndef make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n    the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return '#'\n\n    if content[0] == '#':\n        content = content[1:]\n    if content and content[0] not in ' !:#':\n        content = ' ' + content\n    return '#' + content\n\n\ndef split_line(\n    line: Line, line_length: int, inner: bool = False, py36: bool = False\n) -> Iterator[Line]:\n    \"\"\"Split a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n\n    If `py36` is True, splitting may generate syntax that is only compatible\n    with Python 3.6 and later.\n    \"\"\"\n    if isinstance(line, UnformattedLines) or line.is_comment:\n        yield line\n        return\n\n    line_str = str(line).strip('\\n')\n    if (\n        len(line_str) <= line_length\n        and '\\n' not in line_str  # multiline strings\n        and not line.contains_standalone_comments\n    ):\n        yield line\n        return\n\n    split_funcs: List[SplitFunc]\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line, py36):\n                if str(l).strip('\\n') == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(\n                    split_line(l, line_length=line_length, inner=True, py36=py36)\n                )\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line\n\n\ndef left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS:\n                opening_bracket = leaf.opening_bracket\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n\ndef dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:\n    \"\"\"Normalize prefix of the first leaf in every line returned by `split_func`.\n\n    This is a decorator over relevant split functions.\n    \"\"\"\n\n    @wraps(split_func)\n    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:\n        for l in split_func(line, py36):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l\n\n    return split_wrapper\n\n\n@dont_increase_indentation\ndef delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    If `py36` is True, the split will add trailing commas also in function\n    signatures that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_delimiter_priority(\n            exclude={id(last_leaf)}\n        )\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if (\n            leaf.bracket_depth == lowest_depth\n            and leaf.type == token.STAR\n            or leaf.type == token.DOUBLESTAR\n        ):\n            trailing_comma_safe = trailing_comma_safe and py36\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and trailing_comma_safe\n        ):\n            current_line.append(Leaf(token.COMMA, ','))\n        yield current_line\n\n\n@dont_increase_indentation\ndef standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split standalone comments from the rest of the line.\"\"\"\n    for leaf in line.leaves:\n        if leaf.type == STANDALONE_COMMENT:\n            if leaf.bracket_depth == 0:\n                break\n\n    else:\n        raise CannotSplit(\"Line does not have any standalone comments\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n    if current_line:\n        yield current_line\n\n\ndef is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == 'import' and p and p.type == syms.import_name)\n            or (v == 'from' and p and p.type == syms.import_from)\n        )\n    )\n\n\ndef normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split('#')\n        if '\\\\' not in spl[0]:\n            nl_count = spl[-1].count('\\n')\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = '\\n' * nl_count\n            return\n\n    leaf.prefix = ''\n\n\ndef is_python36(node: Node) -> bool:\n    \"\"\"Return True if the current file is using Python 3.6+ features.\n\n    Currently looking for:\n    - f-strings; and\n    - trailing commas after * or ** in function signatures.\n    \"\"\"\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", 'rf', 'fr', 'RF', 'FR'}:\n                return True\n\n        elif (\n            n.type == syms.typedargslist\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            for ch in n.children:\n                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:\n                    return True\n\n    return False\n\n\nPYTHON_EXTENSIONS = {'.py'}\nBLACKLISTED_DIRECTORIES = {\n    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n}\n\n\ndef gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n    and have one of the PYTHON_EXTENSIONS.\n    \"\"\"\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child\n\n\n@dataclass\nclass Report:\n    \"\"\"Provides a reformatting counter. Can be rendered with `str(report)`.\"\"\"\n    check: bool = False\n    change_count: int = 0\n    same_count: int = 0\n    failure_count: int = 0\n\n    def done(self, src: Path, changed: bool) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed:\n            reformatted = 'would reformat' if self.check else 'reformatted'\n            out(f'{reformatted} {src}')\n            self.change_count += 1\n        else:\n            out(f'{src} already well formatted, good job.', bold=False)\n            self.same_count += 1\n\n    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f'error: cannot format {src}: {message}')\n        self.failure_count += 1\n\n    @property\n    def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special returncodes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0\n\n    def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = 's' if self.change_count > 1 else ''\n            report.append(\n                click.style(f'{self.change_count} file{s} {reformatted}', bold=True)\n            )\n        if self.same_count:\n            s = 's' if self.same_count > 1 else ''\n            report.append(f'{self.same_count} file{s} {unchanged}')\n        if self.failure_count:\n            s = 's' if self.failure_count > 1 else ''\n            report.append(\n                click.style(f'{self.failure_count} file{s} {failed}', fg='red')\n            )\n        return ', '.join(report) + '.'\n\n\ndef assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = '\\n'.join(_v(src_ast))\n    dst_ast_str = '\\n'.join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, 'source', 'first pass'),\n            diff(dst, newdst, 'first pass', 'second pass'),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode='w', prefix='blk_', suffix='.log', delete=False\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + '\\n' for line in a.split('\\n')]\n    b_lines = [line + '\\n' for line in b.split('\\n')]\n    return ''.join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\ndef cancel(tasks: List[asyncio.Task]) -> None:\n    \"\"\"asyncio signal handler that cancels all `tasks` and reports to stderr.\"\"\"\n    err(\"Aborted!\")\n    for task in tasks:\n        task.cancel()\n\n\ndef shutdown(loop: BaseEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n        # `concurrent.futures.Future` objects cannot be cancelled once they\n        # are already running. There might be some when the `shutdown()` happened.\n        # Silence their logger's spew about the event loop being closed.\n        cf_logger = logging.getLogger(\"concurrent.futures\")\n        cf_logger.setLevel(logging.CRITICAL)\n        loop.close()\n\n\nif __name__ == '__main__':\n    main()\n",
      "file_after": "#!/usr/bin/env python3\n\nimport asyncio\nfrom asyncio.base_events import BaseEventLoop\nfrom concurrent.futures import Executor, ProcessPoolExecutor\nfrom functools import partial, wraps\nimport keyword\nimport logging\nimport os\nfrom pathlib import Path\nimport tokenize\nimport signal\nimport sys\nfrom typing import (\n    Callable,\n    Dict,\n    Generic,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\n\nfrom attr import dataclass, Factory\nimport click\n\n# lib2to3 fork\nfrom blib2to3.pytree import Node, Leaf, type_repr\nfrom blib2to3 import pygram, pytree\nfrom blib2to3.pgen2 import driver, token\nfrom blib2to3.pgen2.parse import ParseError\n\n__version__ = \"18.3a4\"\nDEFAULT_LINE_LENGTH = 88\n# types\nsyms = pygram.python_symbols\nFileContent = str\nEncoding = str\nDepth = int\nNodeType = int\nLeafID = int\nPriority = int\nIndex = int\nLN = Union[Leaf, Node]\nSplitFunc = Callable[[\"Line\", bool], Iterator[\"Line\"]]\nout = partial(click.secho, bold=True, err=True)\nerr = partial(click.secho, fg=\"red\", err=True)\n\n\nclass NothingChanged(UserWarning):\n    \"\"\"Raised by :func:`format_file` when reformatted code is the same as source.\"\"\"\n\n\nclass CannotSplit(Exception):\n    \"\"\"A readable split that fits the allotted line length is impossible.\n\n    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and\n    :func:`delimiter_split`.\n    \"\"\"\n\n\nclass FormatError(Exception):\n    \"\"\"Base exception for `# fmt: on` and `# fmt: off` handling.\n\n    It holds the number of bytes of the prefix consumed before the format\n    control comment appeared.\n    \"\"\"\n\n    def __init__(self, consumed: int) -> None:\n        super().__init__(consumed)\n        self.consumed = consumed\n\n    def trim_prefix(self, leaf: Leaf) -> None:\n        leaf.prefix = leaf.prefix[self.consumed:]\n\n    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:\n        \"\"\"Returns a new Leaf from the consumed part of the prefix.\"\"\"\n        unformatted_prefix = leaf.prefix[:self.consumed]\n        return Leaf(token.NEWLINE, unformatted_prefix)\n\n\nclass FormatOn(FormatError):\n    \"\"\"Found a comment like `# fmt: on` in the file.\"\"\"\n\n\nclass FormatOff(FormatError):\n    \"\"\"Found a comment like `# fmt: off` in the file.\"\"\"\n\n\n@click.command()\n@click.option(\n    \"-l\",\n    \"--line-length\",\n    type=int,\n    default=DEFAULT_LINE_LENGTH,\n    help=\"How many character per line to allow.\",\n    show_default=True,\n)\n@click.option(\n    \"--check\",\n    is_flag=True,\n    help=(\n        \"Don't write back the files, just return the status.  Return code 0 \"\n        \"means nothing would change.  Return code 1 means some files would be \"\n        \"reformatted.  Return code 123 means there was an internal error.\"\n    ),\n)\n@click.option(\n    \"--fast/--safe\",\n    is_flag=True,\n    help=\"If --fast given, skip temporary sanity checks. [default: --safe]\",\n)\n@click.version_option(version=__version__)\n@click.argument(\n    \"src\",\n    nargs=-1,\n    type=click.Path(\n        exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True\n    ),\n)\n@click.pass_context\ndef main(\n    ctx: click.Context, line_length: int, check: bool, fast: bool, src: List[str]\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        elif s == \"-\":\n            sources.append(Path(\"-\"))\n        else:\n            err(f\"invalid path: {s}\")\n    if len(sources) == 0:\n        ctx.exit(0)\n    elif len(sources) == 1:\n        p = sources[0]\n        report = Report(check=check)\n        try:\n            if not p.is_file() and str(p) == \"-\":\n                changed = format_stdin_to_stdout(\n                    line_length=line_length, fast=fast, write_back=not check\n                )\n            else:\n                changed = format_file_in_place(\n                    p, line_length=line_length, fast=fast, write_back=not check\n                )\n            report.done(p, changed)\n        except Exception as exc:\n            report.failed(p, str(exc))\n        ctx.exit(report.return_code)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        return_code = 1\n        try:\n            return_code = loop.run_until_complete(\n                schedule_formatting(\n                    sources, line_length, not check, fast, loop, executor\n                )\n            )\n        finally:\n            shutdown(loop)\n            ctx.exit(return_code)\n\n\nasync def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    write_back: bool,\n    fast: bool,\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> int:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    tasks = {\n        src: loop.run_in_executor(\n            executor, format_file_in_place, src, line_length, fast, write_back\n        )\n        for src in sources\n    }\n    _task_values = list(tasks.values())\n    loop.add_signal_handler(signal.SIGINT, cancel, _task_values)\n    loop.add_signal_handler(signal.SIGTERM, cancel, _task_values)\n    await asyncio.wait(tasks.values())\n    cancelled = []\n    report = Report(check=not write_back)\n    for src, task in tasks.items():\n        if not task.done():\n            report.failed(src, \"timed out, cancelling\")\n            task.cancel()\n            cancelled.append(task)\n        elif task.cancelled():\n            cancelled.append(task)\n        elif task.exception():\n            report.failed(src, str(task.exception()))\n        else:\n            report.done(src, task.result())\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    else:\n        out(\"All done! \u2728 \ud83c\udf70 \u2728\")\n    click.echo(str(report))\n    return report.return_code\n\n\ndef format_file_in_place(\n    src: Path, line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(contents)\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    contents = sys.stdin.read()\n    try:\n        contents = format_file_contents(contents, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back:\n            sys.stdout.write(contents)\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `line_length` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == \"\":\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents\n\n\ndef format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `line_length` determines how many characters per line are allowed.\n    \"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    py36 = is_python36(src_node)\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        for line in split_line(current_line, line_length=line_length, py36=py36):\n            dst_contents += str(line)\n    return dst_contents\n\n\nGRAMMARS = [\n    pygram.python_grammar_no_print_statement_no_exec_statement,\n    pygram.python_grammar_no_print_statement,\n    pygram.python_grammar_no_exec_statement,\n    pygram.python_grammar,\n]\n\n\ndef lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    if src_txt[-1] != \"\\n\":\n        nl = \"\\r\\n\" if \"\\r\\n\" in src_txt[:1024] else \"\\n\"\n        src_txt += nl\n    for grammar in GRAMMARS:\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result\n\n\ndef lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code\n\n\nT = TypeVar(\"T\")\n\n\nclass Visitor(Generic[T]):\n    \"\"\"Basic lib2to3 visitor that yields things of type `T` on `visit()`.\"\"\"\n\n    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f\"visit_{name}\", self.visit_default)(node)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n\n@dataclass\nclass DebugVisitor(Visitor[T]):\n    tree_depth: int = 0\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = \" \" * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f\"{indent}{_type}\", fg=\"yellow\")\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f\"{indent}/{_type}\", fg=\"yellow\", bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f\"{indent}{_type}\", fg=\"blue\", nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f\" {node.prefix!r}\", fg=\"green\", bold=False, nl=False)\n            out(f\" {node.value!r}\", fg=\"blue\", bold=False)\n\n    @classmethod\n    def show(cls, code: str) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))\n\n\nKEYWORDS = set(keyword.kwlist)\nWHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\nFLOW_CONTROL = {\"return\", \"raise\", \"break\", \"continue\"}\nSTATEMENT = {\n    syms.if_stmt,\n    syms.while_stmt,\n    syms.for_stmt,\n    syms.try_stmt,\n    syms.except_clause,\n    syms.with_stmt,\n    syms.funcdef,\n    syms.classdef,\n}\nSTANDALONE_COMMENT = 153\nLOGIC_OPERATORS = {\"and\", \"or\"}\nCOMPARATORS = {\n    token.LESS,\n    token.GREATER,\n    token.EQEQUAL,\n    token.NOTEQUAL,\n    token.LESSEQUAL,\n    token.GREATEREQUAL,\n}\nMATH_OPERATORS = {\n    token.PLUS,\n    token.MINUS,\n    token.STAR,\n    token.SLASH,\n    token.VBAR,\n    token.AMPER,\n    token.PERCENT,\n    token.CIRCUMFLEX,\n    token.TILDE,\n    token.LEFTSHIFT,\n    token.RIGHTSHIFT,\n    token.DOUBLESTAR,\n    token.DOUBLESLASH,\n}\nCOMPREHENSION_PRIORITY = 20\nCOMMA_PRIORITY = 10\nLOGIC_PRIORITY = 5\nSTRING_PRIORITY = 4\nCOMPARATOR_PRIORITY = 3\nMATH_PRIORITY = 1\n\n\n@dataclass\nclass BracketTracker:\n    \"\"\"Keeps track of brackets on a line.\"\"\"\n\n    depth: int = 0\n    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n    delimiters: Dict[LeafID, Priority] = Factory(dict)\n    previous: Optional[Leaf] = None\n\n    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_delimiter(leaf)\n            if delim:\n                self.delimiters[id(leaf)] = delim\n            elif self.previous is not None:\n                if leaf.type == token.STRING and self.previous.type == token.STRING:\n                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == \"for\"\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == \"if\"\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value in LOGIC_OPERATORS\n                    and leaf.parent\n                ):\n                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n\n    def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)\n\n    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_delimiter()` returns.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)\n\n\n@dataclass\nclass Line:\n    \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n\n    depth: int = 0\n    leaves: List[Leaf] = Factory(list)\n    comments: List[Tuple[Index, Leaf]] = Factory(list)\n    bracket_tracker: BracketTracker = Factory(BracketTracker)\n    inside_brackets: bool = False\n    has_for: bool = False\n    _for_loop_variable: bool = False\n\n    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.value.strip()\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.maybe_decrement_after_for_loop_variable(leaf)\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n            self.maybe_increment_for_loop_variable(leaf)\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Like :func:`append()` but disallow invalid standalone comment structure.\n\n        Raises ValueError when any `leaf` is appended after a standalone comment\n        or when a standalone comment is not the first leaf on the line.\n        \"\"\"\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n\n        self.append(leaf, preformatted=preformatted)\n\n    @property\n    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT\n\n    @property\n    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT\n\n    @property\n    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])\n\n    @property\n    def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"class\"\n        )\n\n    @property\n    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == \"def\")\n            or (\n                first_leaf.type == token.ASYNC\n                and second_leaf is not None\n                and second_leaf.type == token.NAME\n                and second_leaf.value == \"def\"\n            )\n        )\n\n    @property\n    def is_flow_control(self) -> bool:\n        \"\"\"Is this line a flow control statement?\n\n        Those are `return`, `raise`, `break`, and `continue`.\n        \"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value in FLOW_CONTROL\n        )\n\n    @property\n    def is_yield(self) -> bool:\n        \"\"\"Is this line a yield statement?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"yield\"\n        )\n\n    @property\n    def contains_standalone_comments(self) -> bool:\n        \"\"\"If so, needs to be split before emitting.\"\"\"\n        for leaf in self.leaves:\n            if leaf.type == STANDALONE_COMMENT:\n                return True\n\n        return False\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (\n            self.leaves\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RBRACE:\n            self.remove_trailing_comma()\n            return True\n\n        if closing.type == token.RSQB:\n            comma = self.leaves[-1]\n            if comma.parent and comma.parent.type == syms.listmaker:\n                self.remove_trailing_comma()\n                return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1\n        commas = 0\n        opening = closing.opening_bracket\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n                if leaf.parent and leaf.parent.type == syms.arglist:\n                    commas += 1\n                    break\n\n        if commas > 1:\n            self.remove_trailing_comma()\n            return True\n\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"for\":\n            self.has_for = True\n            self.bracket_tracker.depth += 1\n            self._for_loop_variable = True\n            return True\n\n        return False\n\n    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == \"in\":\n            self.bracket_tracker.depth -= 1\n            self._for_loop_variable = False\n            return True\n\n        return False\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline or standalone comment to the line.\"\"\"\n        if (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            comment.prefix = \"\"\n            return False\n\n        if comment.type != token.COMMENT:\n            return False\n\n        after = len(self.leaves) - 1\n        if after == -1:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = \"\"\n            return False\n\n        else:\n            self.comments.append((after, comment))\n            return True\n\n    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:\n        \"\"\"Generate comments that should appear directly after `leaf`.\"\"\"\n        for _leaf_index, _leaf in enumerate(self.leaves):\n            if leaf is _leaf:\n                break\n\n        else:\n            return\n\n        for index, comment_after in self.comments:\n            if _leaf_index == index:\n                yield comment_after\n\n    def remove_trailing_comma(self) -> None:\n        \"\"\"Remove the trailing comma and moves the comments attached to it.\"\"\"\n        comma_index = len(self.leaves) - 1\n        for i in range(len(self.comments)):\n            comment_index, comment = self.comments[i]\n            if comment_index == comma_index:\n                self.comments[i] = (comma_index - 1, comment)\n        self.leaves.pop()\n\n    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return \"\\n\"\n\n        indent = \"    \" * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f\"{first.prefix}{indent}{first.value}\"\n        for leaf in leaves:\n            res += str(leaf)\n        for _, comment in self.comments:\n            res += str(comment)\n        return res + \"\\n\"\n\n    def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)\n\n\nclass UnformattedLines(Line):\n    \"\"\"Just like :class:`Line` but stores lines which aren't reformatted.\"\"\"\n\n    def append(self, leaf: Leaf, preformatted: bool = True) -> None:\n        \"\"\"Just add a new `leaf` to the end of the lines.\n\n        The `preformatted` argument is ignored.\n\n        Keeps track of indentation `depth`, which is useful when the user\n        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.\n        \"\"\"\n        try:\n            list(generate_comments(leaf))\n        except FormatOn as f_on:\n            self.leaves.append(f_on.leaf_from_consumed(leaf))\n            raise\n\n        self.leaves.append(leaf)\n        if leaf.type == token.INDENT:\n            self.depth += 1\n        elif leaf.type == token.DEDENT:\n            self.depth -= 1\n\n    def __str__(self) -> str:\n        \"\"\"Render unformatted lines from leaves which were added with `append()`.\n\n        `depth` is not used for indentation in this case.\n        \"\"\"\n        if not self:\n            return \"\\n\"\n\n        res = \"\"\n        for leaf in self.leaves:\n            res += str(leaf)\n        return res\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Not implemented in this class. Raises `NotImplementedError`.\"\"\"\n        raise NotImplementedError(\"Unformatted lines don't store comments separately.\")\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n\n@dataclass\nclass EmptyLineTracker:\n    \"\"\"Provides a stateful method that returns the number of potential extra\n    empty lines needed before and after the currently processed line.\n\n    Note: this tracker works on lines that haven't been split yet.  It assumes\n    the prefix of the first leaf consists of optional newlines.  Those newlines\n    are consumed by `maybe_empty_lines()` and included in the computation.\n    \"\"\"\n    previous_line: Optional[Line] = None\n    previous_after: int = 0\n    previous_defs: List[int] = Factory(list)\n\n    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level), as well as providing an extra empty line\n        after flow control keywords to make them more prominent.\n        \"\"\"\n        if isinstance(current_line, UnformattedLines):\n            return 0, 0\n\n        before, after = self._maybe_empty_lines(current_line)\n        before -= self.previous_after\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after\n\n    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = 1 if depth else 2\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_yield\n            and (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0\n\n\n@dataclass\nclass LineGenerator(Visitor[Line]):\n    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n\n    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n    in ways that will no longer stringify to valid Python code on the tree.\n    \"\"\"\n    current_line: Line = Factory(Line)\n\n    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            if self.current_line.__class__ == type:\n                self.current_line.depth += indent\n            else:\n                self.current_line = type(depth=self.current_line.depth + indent)\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = type(depth=complete_line.depth + indent)\n        yield complete_line\n\n    def visit(self, node: LN) -> Iterator[Line]:\n        \"\"\"Main method to visit `node` and its children.\n\n        Yields :class:`Line` objects.\n        \"\"\"\n        if isinstance(self.current_line, UnformattedLines):\n            # File contained `# fmt: off`\n            yield from self.visit_unformatted(node)\n\n        else:\n            yield from super().visit(node)\n\n    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            try:\n                for comment in generate_comments(node):\n                    if any_open_brackets:\n                        # any comment within brackets is subject to splitting\n                        self.current_line.append(comment)\n                    elif comment.type == token.COMMENT:\n                        # regular trailing comment\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n                    else:\n                        # regular standalone comment\n                        yield from self.line()\n\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n            except FormatOff as f_off:\n                f_off.trim_prefix(node)\n                yield from self.line(type=UnformattedLines)\n                yield from self.visit(node)\n\n            except FormatOn as f_on:\n                # This only happens here if somebody says \"fmt: on\" multiple\n                # times in a row.\n                f_on.trim_prefix(node)\n                yield from self.visit_default(node)\n\n            else:\n                normalize_prefix(node, inside_brackets=any_open_brackets)\n                if node.type == token.STRING:\n                    normalize_string_quotes(node)\n                if node.type not in WHITESPACE:\n                    self.current_line.append(node)\n        yield from super().visit_default(node)\n\n    def visit_INDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)\n\n    def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n        yield from self.line(-1)\n\n    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, and `class`.\n\n        The relevant Python language `keywords` for a given statement will be NAME\n        leaves within it. This methods puts those on a separate line.\n        \"\"\"\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)\n\n    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)\n\n    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)\n\n    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)\n\n    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()\n\n    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()\n\n    def visit_unformatted(self, node: LN) -> Iterator[Line]:\n        \"\"\"Used when file contained a `# fmt: off`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n        else:\n            try:\n                self.current_line.append(node)\n            except FormatOn as f_on:\n                f_on.trim_prefix(node)\n                yield from self.line()\n                yield from self.visit(node)\n\n    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        self.visit_if_stmt = partial(v, keywords={\"if\", \"else\", \"elif\"})\n        self.visit_while_stmt = partial(v, keywords={\"while\", \"else\"})\n        self.visit_for_stmt = partial(v, keywords={\"for\", \"else\"})\n        self.visit_try_stmt = partial(v, keywords={\"try\", \"except\", \"else\", \"finally\"})\n        self.visit_except_clause = partial(v, keywords={\"except\"})\n        self.visit_funcdef = partial(v, keywords={\"def\"})\n        self.visit_with_stmt = partial(v, keywords={\"with\"})\n        self.visit_classdef = partial(v, keywords={\"class\"})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators\n\n\nBRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\nOPENING_BRACKETS = set(BRACKET.keys())\nCLOSING_BRACKETS = set(BRACKET.values())\nBRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\nALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}\n\n\ndef whitespace(leaf: Leaf) -> str:  # noqa C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = \"\"\n    SPACE = \" \"\n    DOUBLESPACE = \"  \"\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            return SPACE if prevp.type == token.COMMA else NO\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist, syms.argument, syms.parameters, syms.varargslist\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type == token.DOUBLESTAR:\n            if prevp.parent and prevp.parent.type in {\n                syms.arglist,\n                syms.argument,\n                syms.dictsetmaker,\n                syms.parameters,\n                syms.typedargslist,\n                syms.varargslist,\n            }:\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type in {syms.factor, syms.star_expr}\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == \"print\"  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if t == token.RPAR:\n            return NO\n\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if t == token.RPAR:\n            return NO\n\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        else:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif (\n        p.type == syms.listmaker\n        or p.type == syms.testlist_gexp\n        or p.type == syms.subscriptlist\n    ):\n        # list interior, including unpacking\n        if not prev:\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict and set interior, including unpacking\n        if not prev:\n            return NO\n\n        if prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript, syms.sliceop\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == \"import\":\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE\n\n\ndef preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None\n\n\ndef is_delimiter(leaf: Leaf) -> int:\n    \"\"\"Return the priority of the `leaf` delimiter. Return 0 if not delimiter.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    return 0\n\n\ndef generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    p = leaf.prefix\n    if not p:\n        return\n\n    if \"#\" not in p:\n        return\n\n    consumed = 0\n    nlines = 0\n    for index, line in enumerate(p.split(\"\\n\")):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith(\"#\"):\n            continue\n\n        if index == 0 and leaf.type != token.ENDMARKER:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        yield Leaf(comment_type, comment, prefix=\"\\n\" * nlines)\n\n        if comment in {\"# fmt: on\", \"# yapf: enable\"}:\n            raise FormatOn(consumed)\n\n        if comment in {\"# fmt: off\", \"# yapf: disable\"}:\n            raise FormatOff(consumed)\n\n        nlines = 0\n\n\ndef make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n    the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if content and content[0] not in \" !:#\":\n        content = \" \" + content\n    return \"#\" + content\n\n\ndef split_line(\n    line: Line, line_length: int, inner: bool = False, py36: bool = False\n) -> Iterator[Line]:\n    \"\"\"Split a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n\n    If `py36` is True, splitting may generate syntax that is only compatible\n    with Python 3.6 and later.\n    \"\"\"\n    if isinstance(line, UnformattedLines) or line.is_comment:\n        yield line\n        return\n\n    line_str = str(line).strip(\"\\n\")\n    if (\n        len(line_str) <= line_length\n        and \"\\n\" not in line_str  # multiline strings\n        and not line.contains_standalone_comments\n    ):\n        yield line\n        return\n\n    split_funcs: List[SplitFunc]\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line, py36):\n                if str(l).strip(\"\\n\") == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(\n                    split_line(l, line_length=line_length, inner=True, py36=py36)\n                )\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line\n\n\ndef left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS:\n                opening_bracket = leaf.opening_bracket\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n\ndef dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:\n    \"\"\"Normalize prefix of the first leaf in every line returned by `split_func`.\n\n    This is a decorator over relevant split functions.\n    \"\"\"\n\n    @wraps(split_func)\n    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:\n        for l in split_func(line, py36):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l\n\n    return split_wrapper\n\n\n@dont_increase_indentation\ndef delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    If `py36` is True, the split will add trailing commas also in function\n    signatures that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_delimiter_priority(\n            exclude={id(last_leaf)}\n        )\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if (\n            leaf.bracket_depth == lowest_depth\n            and leaf.type == token.STAR\n            or leaf.type == token.DOUBLESTAR\n        ):\n            trailing_comma_safe = trailing_comma_safe and py36\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and trailing_comma_safe\n        ):\n            current_line.append(Leaf(token.COMMA, \",\"))\n        yield current_line\n\n\n@dont_increase_indentation\ndef standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split standalone comments from the rest of the line.\"\"\"\n    for leaf in line.leaves:\n        if leaf.type == STANDALONE_COMMENT:\n            if leaf.bracket_depth == 0:\n                break\n\n    else:\n        raise CannotSplit(\"Line does not have any standalone comments\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n    if current_line:\n        yield current_line\n\n\ndef is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == \"import\" and p and p.type == syms.import_name)\n            or (v == \"from\" and p and p.type == syms.import_from)\n        )\n    )\n\n\ndef normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split(\"#\")\n        if \"\\\\\" not in spl[0]:\n            nl_count = spl[-1].count(\"\\n\")\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = \"\\n\" * nl_count\n            return\n\n    leaf.prefix = \"\"\n\n\ndef normalize_string_quotes(leaf: Leaf) -> None:\n    value = leaf.value.lstrip(\"furbFURB\")\n    if value[:3] == '\"\"\"':\n        return\n\n    elif value[:3] == \"'''\":\n        orig_quote = \"'''\"\n        new_quote = '\"\"\"'\n    elif value[0] == '\"':\n        orig_quote = '\"'\n        new_quote = \"'\"\n    else:\n        orig_quote = \"'\"\n        new_quote = '\"'\n    first_quote_pos = leaf.value.find(orig_quote)\n    if first_quote_pos == -1:\n        return  # There's an internal error\n\n    body = leaf.value[first_quote_pos + len(orig_quote):-len(orig_quote)]\n    new_body = body.replace(f\"\\\\{orig_quote}\", orig_quote).replace(\n        new_quote, f\"\\\\{new_quote}\"\n    )\n    if new_quote == '\"\"\"' and new_body[-1] == '\"':\n        # edge case:\n        new_body = new_body[:-1] + '\\\\\"'\n    orig_escape_count = body.count(\"\\\\\")\n    new_escape_count = new_body.count(\"\\\\\")\n    if new_escape_count > orig_escape_count:\n        return  # Do not introduce more escaping\n\n    if new_escape_count == orig_escape_count and orig_quote == '\"':\n        return  # Prefer double quotes\n\n    prefix = leaf.value[:first_quote_pos]\n    leaf.value = f\"{prefix}{new_quote}{new_body}{new_quote}\"\n\n\ndef is_python36(node: Node) -> bool:\n    \"\"\"Return True if the current file is using Python 3.6+ features.\n\n    Currently looking for:\n    - f-strings; and\n    - trailing commas after * or ** in function signatures.\n    \"\"\"\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                return True\n\n        elif (\n            n.type == syms.typedargslist\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            for ch in n.children:\n                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:\n                    return True\n\n    return False\n\n\nPYTHON_EXTENSIONS = {\".py\"}\nBLACKLISTED_DIRECTORIES = {\n    \"build\", \"buck-out\", \"dist\", \"_build\", \".git\", \".hg\", \".mypy_cache\", \".tox\", \".venv\"\n}\n\n\ndef gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n    and have one of the PYTHON_EXTENSIONS.\n    \"\"\"\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child\n\n\n@dataclass\nclass Report:\n    \"\"\"Provides a reformatting counter. Can be rendered with `str(report)`.\"\"\"\n    check: bool = False\n    change_count: int = 0\n    same_count: int = 0\n    failure_count: int = 0\n\n    def done(self, src: Path, changed: bool) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed:\n            reformatted = \"would reformat\" if self.check else \"reformatted\"\n            out(f\"{reformatted} {src}\")\n            self.change_count += 1\n        else:\n            out(f\"{src} already well formatted, good job.\", bold=False)\n            self.same_count += 1\n\n    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f\"error: cannot format {src}: {message}\")\n        self.failure_count += 1\n\n    @property\n    def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special returncodes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0\n\n    def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = \"s\" if self.change_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.change_count} file{s} {reformatted}\", bold=True)\n            )\n        if self.same_count:\n            s = \"s\" if self.same_count > 1 else \"\"\n            report.append(f\"{self.same_count} file{s} {unchanged}\")\n        if self.failure_count:\n            s = \"s\" if self.failure_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.failure_count} file{s} {failed}\", fg=\"red\")\n            )\n        return \", \".join(report) + \".\"\n\n\ndef assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_v(src_ast))\n    dst_ast_str = \"\\n\".join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            f.write(\"\\n\")\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.split(\"\\n\")]\n    b_lines = [line + \"\\n\" for line in b.split(\"\\n\")]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\ndef cancel(tasks: List[asyncio.Task]) -> None:\n    \"\"\"asyncio signal handler that cancels all `tasks` and reports to stderr.\"\"\"\n    err(\"Aborted!\")\n    for task in tasks:\n        task.cancel()\n\n\ndef shutdown(loop: BaseEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n        # `concurrent.futures.Future` objects cannot be cancelled once they\n        # are already running. There might be some when the `shutdown()` happened.\n        # Silence their logger's spew about the event loop being closed.\n        cf_logger = logging.getLogger(\"concurrent.futures\")\n        cf_logger.setLevel(logging.CRITICAL)\n        loop.close()\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "file_patch": "@@ -47,9 +47,9 @@ LeafID = int\n Priority = int\n Index = int\n LN = Union[Leaf, Node]\n-SplitFunc = Callable[['Line', bool], Iterator['Line']]\n+SplitFunc = Callable[[\"Line\", bool], Iterator[\"Line\"]]\n out = partial(click.secho, bold=True, err=True)\n-err = partial(click.secho, fg='red', err=True)\n+err = partial(click.secho, fg=\"red\", err=True)\n \n \n class NothingChanged(UserWarning):\n@@ -94,15 +94,15 @@ class FormatOff(FormatError):\n \n @click.command()\n @click.option(\n-    '-l',\n-    '--line-length',\n+    \"-l\",\n+    \"--line-length\",\n     type=int,\n     default=DEFAULT_LINE_LENGTH,\n-    help='How many character per line to allow.',\n+    help=\"How many character per line to allow.\",\n     show_default=True,\n )\n @click.option(\n-    '--check',\n+    \"--check\",\n     is_flag=True,\n     help=(\n         \"Don't write back the files, just return the status.  Return code 0 \"\n@@ -111,13 +111,13 @@ class FormatOff(FormatError):\n     ),\n )\n @click.option(\n-    '--fast/--safe',\n+    \"--fast/--safe\",\n     is_flag=True,\n-    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n+    help=\"If --fast given, skip temporary sanity checks. [default: --safe]\",\n )\n @click.version_option(version=__version__)\n @click.argument(\n-    'src',\n+    \"src\",\n     nargs=-1,\n     type=click.Path(\n         exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True\n@@ -136,17 +136,17 @@ def main(\n         elif p.is_file():\n             # if a file was explicitly given, we don't care about its extension\n             sources.append(p)\n-        elif s == '-':\n-            sources.append(Path('-'))\n+        elif s == \"-\":\n+            sources.append(Path(\"-\"))\n         else:\n-            err(f'invalid path: {s}')\n+            err(f\"invalid path: {s}\")\n     if len(sources) == 0:\n         ctx.exit(0)\n     elif len(sources) == 1:\n         p = sources[0]\n         report = Report(check=check)\n         try:\n-            if not p.is_file() and str(p) == '-':\n+            if not p.is_file() and str(p) == \"-\":\n                 changed = format_stdin_to_stdout(\n                     line_length=line_length, fast=fast, write_back=not check\n                 )\n@@ -202,7 +202,7 @@ async def schedule_formatting(\n     report = Report(check=not write_back)\n     for src, task in tasks.items():\n         if not task.done():\n-            report.failed(src, 'timed out, cancelling')\n+            report.failed(src, \"timed out, cancelling\")\n             task.cancel()\n             cancelled.append(task)\n         elif task.cancelled():\n@@ -214,7 +214,7 @@ async def schedule_formatting(\n     if cancelled:\n         await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n     else:\n-        out('All done! \u2728 \ud83c\udf70 \u2728')\n+        out(\"All done! \u2728 \ud83c\udf70 \u2728\")\n     click.echo(str(report))\n     return report.return_code\n \n@@ -272,7 +272,7 @@ def format_file_contents(\n     valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n     `line_length` is passed to :func:`format_str`.\n     \"\"\"\n-    if src_contents.strip() == '':\n+    if src_contents.strip() == \"\":\n         raise NothingChanged\n \n     dst_contents = format_str(src_contents, line_length=line_length)\n@@ -319,8 +319,8 @@ GRAMMARS = [\n def lib2to3_parse(src_txt: str) -> Node:\n     \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n     grammar = pygram.python_grammar_no_print_statement\n-    if src_txt[-1] != '\\n':\n-        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n+    if src_txt[-1] != \"\\n\":\n+        nl = \"\\r\\n\" if \"\\r\\n\" in src_txt[:1024] else \"\\n\"\n         src_txt += nl\n     for grammar in GRAMMARS:\n         drv = driver.Driver(grammar, pytree.convert)\n@@ -350,7 +350,7 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-T = TypeVar('T')\n+T = TypeVar(\"T\")\n \n \n class Visitor(Generic[T]):\n@@ -370,7 +370,7 @@ class Visitor(Generic[T]):\n             name = token.tok_name[node.type]\n         else:\n             name = type_repr(node.type)\n-        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n+        yield from getattr(self, f\"visit_{name}\", self.visit_default)(node)\n \n     def visit_default(self, node: LN) -> Iterator[T]:\n         \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n@@ -384,24 +384,24 @@ class DebugVisitor(Visitor[T]):\n     tree_depth: int = 0\n \n     def visit_default(self, node: LN) -> Iterator[T]:\n-        indent = ' ' * (2 * self.tree_depth)\n+        indent = \" \" * (2 * self.tree_depth)\n         if isinstance(node, Node):\n             _type = type_repr(node.type)\n-            out(f'{indent}{_type}', fg='yellow')\n+            out(f\"{indent}{_type}\", fg=\"yellow\")\n             self.tree_depth += 1\n             for child in node.children:\n                 yield from self.visit(child)\n \n             self.tree_depth -= 1\n-            out(f'{indent}/{_type}', fg='yellow', bold=False)\n+            out(f\"{indent}/{_type}\", fg=\"yellow\", bold=False)\n         else:\n             _type = token.tok_name.get(node.type, str(node.type))\n-            out(f'{indent}{_type}', fg='blue', nl=False)\n+            out(f\"{indent}{_type}\", fg=\"blue\", nl=False)\n             if node.prefix:\n                 # We don't have to handle prefixes for `Node` objects since\n                 # that delegates to the first child anyway.\n-                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n-            out(f' {node.value!r}', fg='blue', bold=False)\n+                out(f\" {node.prefix!r}\", fg=\"green\", bold=False, nl=False)\n+            out(f\" {node.value!r}\", fg=\"blue\", bold=False)\n \n     @classmethod\n     def show(cls, code: str) -> None:\n@@ -415,7 +415,7 @@ class DebugVisitor(Visitor[T]):\n \n KEYWORDS = set(keyword.kwlist)\n WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\n-FLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\n+FLOW_CONTROL = {\"return\", \"raise\", \"break\", \"continue\"}\n STATEMENT = {\n     syms.if_stmt,\n     syms.while_stmt,\n@@ -427,7 +427,7 @@ STATEMENT = {\n     syms.classdef,\n }\n STANDALONE_COMMENT = 153\n-LOGIC_OPERATORS = {'and', 'or'}\n+LOGIC_OPERATORS = {\"and\", \"or\"}\n COMPARATORS = {\n     token.LESS,\n     token.GREATER,\n@@ -500,14 +500,14 @@ class BracketTracker:\n                     self.delimiters[id(self.previous)] = STRING_PRIORITY\n                 elif (\n                     leaf.type == token.NAME\n-                    and leaf.value == 'for'\n+                    and leaf.value == \"for\"\n                     and leaf.parent\n                     and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                 ):\n                     self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                 elif (\n                     leaf.type == token.NAME\n-                    and leaf.value == 'if'\n+                    and leaf.value == \"if\"\n                     and leaf.parent\n                     and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                 ):\n@@ -612,7 +612,7 @@ class Line:\n         return (\n             bool(self)\n             and self.leaves[0].type == token.NAME\n-            and self.leaves[0].value == 'class'\n+            and self.leaves[0].value == \"class\"\n         )\n \n     @property\n@@ -628,12 +628,12 @@ class Line:\n         except IndexError:\n             second_leaf = None\n         return (\n-            (first_leaf.type == token.NAME and first_leaf.value == 'def')\n+            (first_leaf.type == token.NAME and first_leaf.value == \"def\")\n             or (\n                 first_leaf.type == token.ASYNC\n                 and second_leaf is not None\n                 and second_leaf.type == token.NAME\n-                and second_leaf.value == 'def'\n+                and second_leaf.value == \"def\"\n             )\n         )\n \n@@ -655,7 +655,7 @@ class Line:\n         return (\n             bool(self)\n             and self.leaves[0].type == token.NAME\n-            and self.leaves[0].value == 'yield'\n+            and self.leaves[0].value == \"yield\"\n         )\n \n     @property\n@@ -722,7 +722,7 @@ class Line:\n         To avoid splitting on the comma in this situation, increase the depth of\n         tokens between `for` and `in`.\n         \"\"\"\n-        if leaf.type == token.NAME and leaf.value == 'for':\n+        if leaf.type == token.NAME and leaf.value == \"for\":\n             self.has_for = True\n             self.bracket_tracker.depth += 1\n             self._for_loop_variable = True\n@@ -732,7 +732,7 @@ class Line:\n \n     def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n         \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n-        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':\n+        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == \"in\":\n             self.bracket_tracker.depth -= 1\n             self._for_loop_variable = False\n             return True\n@@ -745,7 +745,7 @@ class Line:\n             comment.type == STANDALONE_COMMENT\n             and self.bracket_tracker.any_open_brackets()\n         ):\n-            comment.prefix = ''\n+            comment.prefix = \"\"\n             return False\n \n         if comment.type != token.COMMENT:\n@@ -754,7 +754,7 @@ class Line:\n         after = len(self.leaves) - 1\n         if after == -1:\n             comment.type = STANDALONE_COMMENT\n-            comment.prefix = ''\n+            comment.prefix = \"\"\n             return False\n \n         else:\n@@ -786,17 +786,17 @@ class Line:\n     def __str__(self) -> str:\n         \"\"\"Render the line.\"\"\"\n         if not self:\n-            return '\\n'\n+            return \"\\n\"\n \n-        indent = '    ' * self.depth\n+        indent = \"    \" * self.depth\n         leaves = iter(self.leaves)\n         first = next(leaves)\n-        res = f'{first.prefix}{indent}{first.value}'\n+        res = f\"{first.prefix}{indent}{first.value}\"\n         for leaf in leaves:\n             res += str(leaf)\n         for _, comment in self.comments:\n             res += str(comment)\n-        return res + '\\n'\n+        return res + \"\\n\"\n \n     def __bool__(self) -> bool:\n         \"\"\"Return True if the line has leaves or comments.\"\"\"\n@@ -832,9 +832,9 @@ class UnformattedLines(Line):\n         `depth` is not used for indentation in this case.\n         \"\"\"\n         if not self:\n-            return '\\n'\n+            return \"\\n\"\n \n-        res = ''\n+        res = \"\"\n         for leaf in self.leaves:\n             res += str(leaf)\n         return res\n@@ -888,9 +888,9 @@ class EmptyLineTracker:\n         if current_line.leaves:\n             # Consume the first leaf's extra newlines.\n             first_leaf = current_line.leaves[0]\n-            before = first_leaf.prefix.count('\\n')\n+            before = first_leaf.prefix.count(\"\\n\")\n             before = min(before, max_allowed)\n-            first_leaf.prefix = ''\n+            first_leaf.prefix = \"\"\n         else:\n             before = 0\n         depth = current_line.depth\n@@ -1009,6 +1009,8 @@ class LineGenerator(Visitor[Line]):\n \n             else:\n                 normalize_prefix(node, inside_brackets=any_open_brackets)\n+                if node.type == token.STRING:\n+                    normalize_string_quotes(node)\n                 if node.type not in WHITESPACE:\n                     self.current_line.append(node)\n         yield from super().visit_default(node)\n@@ -1098,14 +1100,14 @@ class LineGenerator(Visitor[Line]):\n     def __attrs_post_init__(self) -> None:\n         \"\"\"You are in a twisty little maze of passages.\"\"\"\n         v = self.visit_stmt\n-        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n-        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n-        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n-        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n-        self.visit_except_clause = partial(v, keywords={'except'})\n-        self.visit_funcdef = partial(v, keywords={'def'})\n-        self.visit_with_stmt = partial(v, keywords={'with'})\n-        self.visit_classdef = partial(v, keywords={'class'})\n+        self.visit_if_stmt = partial(v, keywords={\"if\", \"else\", \"elif\"})\n+        self.visit_while_stmt = partial(v, keywords={\"while\", \"else\"})\n+        self.visit_for_stmt = partial(v, keywords={\"for\", \"else\"})\n+        self.visit_try_stmt = partial(v, keywords={\"try\", \"except\", \"else\", \"finally\"})\n+        self.visit_except_clause = partial(v, keywords={\"except\"})\n+        self.visit_funcdef = partial(v, keywords={\"def\"})\n+        self.visit_with_stmt = partial(v, keywords={\"with\"})\n+        self.visit_classdef = partial(v, keywords={\"class\"})\n         self.visit_async_funcdef = self.visit_async_stmt\n         self.visit_decorated = self.visit_decorators\n \n@@ -1119,9 +1121,9 @@ ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}\n \n def whitespace(leaf: Leaf) -> str:  # noqa C901\n     \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n-    NO = ''\n-    SPACE = ' '\n-    DOUBLESPACE = '  '\n+    NO = \"\"\n+    SPACE = \" \"\n+    DOUBLESPACE = \"  \"\n     t = leaf.type\n     p = leaf.parent\n     v = leaf.value\n@@ -1185,7 +1187,7 @@ def whitespace(leaf: Leaf) -> str:  # noqa C901\n             and prevp.parent.type == syms.shift_expr\n             and prevp.prev_sibling\n             and prevp.prev_sibling.type == token.NAME\n-            and prevp.prev_sibling.value == 'print'  # type: ignore\n+            and prevp.prev_sibling.value == \"print\"  # type: ignore\n         ):\n             # Python 2 print chevron\n             return NO\n@@ -1342,7 +1344,7 @@ def whitespace(leaf: Leaf) -> str:  # noqa C901\n                 return NO\n \n         elif t == token.NAME:\n-            if v == 'import':\n+            if v == \"import\":\n                 return SPACE\n \n             if prev and prev.type == token.DOT:\n@@ -1416,17 +1418,17 @@ def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n     if not p:\n         return\n \n-    if '#' not in p:\n+    if \"#\" not in p:\n         return\n \n     consumed = 0\n     nlines = 0\n-    for index, line in enumerate(p.split('\\n')):\n+    for index, line in enumerate(p.split(\"\\n\")):\n         consumed += len(line) + 1  # adding the length of the split '\\n'\n         line = line.lstrip()\n         if not line:\n             nlines += 1\n-        if not line.startswith('#'):\n+        if not line.startswith(\"#\"):\n             continue\n \n         if index == 0 and leaf.type != token.ENDMARKER:\n@@ -1434,12 +1436,12 @@ def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n         else:\n             comment_type = STANDALONE_COMMENT\n         comment = make_comment(line)\n-        yield Leaf(comment_type, comment, prefix='\\n' * nlines)\n+        yield Leaf(comment_type, comment, prefix=\"\\n\" * nlines)\n \n-        if comment in {'# fmt: on', '# yapf: enable'}:\n+        if comment in {\"# fmt: on\", \"# yapf: enable\"}:\n             raise FormatOn(consumed)\n \n-        if comment in {'# fmt: off', '# yapf: disable'}:\n+        if comment in {\"# fmt: off\", \"# yapf: disable\"}:\n             raise FormatOff(consumed)\n \n         nlines = 0\n@@ -1455,13 +1457,13 @@ def make_comment(content: str) -> str:\n     \"\"\"\n     content = content.rstrip()\n     if not content:\n-        return '#'\n+        return \"#\"\n \n-    if content[0] == '#':\n+    if content[0] == \"#\":\n         content = content[1:]\n-    if content and content[0] not in ' !:#':\n-        content = ' ' + content\n-    return '#' + content\n+    if content and content[0] not in \" !:#\":\n+        content = \" \" + content\n+    return \"#\" + content\n \n \n def split_line(\n@@ -1481,10 +1483,10 @@ def split_line(\n         yield line\n         return\n \n-    line_str = str(line).strip('\\n')\n+    line_str = str(line).strip(\"\\n\")\n     if (\n         len(line_str) <= line_length\n-        and '\\n' not in line_str  # multiline strings\n+        and \"\\n\" not in line_str  # multiline strings\n         and not line.contains_standalone_comments\n     ):\n         yield line\n@@ -1504,7 +1506,7 @@ def split_line(\n         result: List[Line] = []\n         try:\n             for l in split_func(line, py36):\n-                if str(l).strip('\\n') == line_str:\n+                if str(l).strip(\"\\n\") == line_str:\n                     raise CannotSplit(\"Split function returned an unchanged result\")\n \n                 result.extend(\n@@ -1703,7 +1705,7 @@ def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n             and current_line.leaves[-1].type != token.COMMA\n             and trailing_comma_safe\n         ):\n-            current_line.append(Leaf(token.COMMA, ','))\n+            current_line.append(Leaf(token.COMMA, \",\"))\n         yield current_line\n \n \n@@ -1749,8 +1751,8 @@ def is_import(leaf: Leaf) -> bool:\n     return bool(\n         t == token.NAME\n         and (\n-            (v == 'import' and p and p.type == syms.import_name)\n-            or (v == 'from' and p and p.type == syms.import_from)\n+            (v == \"import\" and p and p.type == syms.import_name)\n+            or (v == \"from\" and p and p.type == syms.import_from)\n         )\n     )\n \n@@ -1762,15 +1764,52 @@ def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n     Note: don't use backslashes for formatting or you'll lose your voting rights.\n     \"\"\"\n     if not inside_brackets:\n-        spl = leaf.prefix.split('#')\n-        if '\\\\' not in spl[0]:\n-            nl_count = spl[-1].count('\\n')\n+        spl = leaf.prefix.split(\"#\")\n+        if \"\\\\\" not in spl[0]:\n+            nl_count = spl[-1].count(\"\\n\")\n             if len(spl) > 1:\n                 nl_count -= 1\n-            leaf.prefix = '\\n' * nl_count\n+            leaf.prefix = \"\\n\" * nl_count\n             return\n \n-    leaf.prefix = ''\n+    leaf.prefix = \"\"\n+\n+\n+def normalize_string_quotes(leaf: Leaf) -> None:\n+    value = leaf.value.lstrip(\"furbFURB\")\n+    if value[:3] == '\"\"\"':\n+        return\n+\n+    elif value[:3] == \"'''\":\n+        orig_quote = \"'''\"\n+        new_quote = '\"\"\"'\n+    elif value[0] == '\"':\n+        orig_quote = '\"'\n+        new_quote = \"'\"\n+    else:\n+        orig_quote = \"'\"\n+        new_quote = '\"'\n+    first_quote_pos = leaf.value.find(orig_quote)\n+    if first_quote_pos == -1:\n+        return  # There's an internal error\n+\n+    body = leaf.value[first_quote_pos + len(orig_quote):-len(orig_quote)]\n+    new_body = body.replace(f\"\\\\{orig_quote}\", orig_quote).replace(\n+        new_quote, f\"\\\\{new_quote}\"\n+    )\n+    if new_quote == '\"\"\"' and new_body[-1] == '\"':\n+        # edge case:\n+        new_body = new_body[:-1] + '\\\\\"'\n+    orig_escape_count = body.count(\"\\\\\")\n+    new_escape_count = new_body.count(\"\\\\\")\n+    if new_escape_count > orig_escape_count:\n+        return  # Do not introduce more escaping\n+\n+    if new_escape_count == orig_escape_count and orig_quote == '\"':\n+        return  # Prefer double quotes\n+\n+    prefix = leaf.value[:first_quote_pos]\n+    leaf.value = f\"{prefix}{new_quote}{new_body}{new_quote}\"\n \n \n def is_python36(node: Node) -> bool:\n@@ -1783,7 +1822,7 @@ def is_python36(node: Node) -> bool:\n     for n in node.pre_order():\n         if n.type == token.STRING:\n             value_head = n.value[:2]  # type: ignore\n-            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", 'rf', 'fr', 'RF', 'FR'}:\n+            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 return True\n \n         elif (\n@@ -1798,9 +1837,9 @@ def is_python36(node: Node) -> bool:\n     return False\n \n \n-PYTHON_EXTENSIONS = {'.py'}\n+PYTHON_EXTENSIONS = {\".py\"}\n BLACKLISTED_DIRECTORIES = {\n-    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n+    \"build\", \"buck-out\", \"dist\", \"_build\", \".git\", \".hg\", \".mypy_cache\", \".tox\", \".venv\"\n }\n \n \n@@ -1830,16 +1869,16 @@ class Report:\n     def done(self, src: Path, changed: bool) -> None:\n         \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n         if changed:\n-            reformatted = 'would reformat' if self.check else 'reformatted'\n-            out(f'{reformatted} {src}')\n+            reformatted = \"would reformat\" if self.check else \"reformatted\"\n+            out(f\"{reformatted} {src}\")\n             self.change_count += 1\n         else:\n-            out(f'{src} already well formatted, good job.', bold=False)\n+            out(f\"{src} already well formatted, good job.\", bold=False)\n             self.same_count += 1\n \n     def failed(self, src: Path, message: str) -> None:\n         \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n-        err(f'error: cannot format {src}: {message}')\n+        err(f\"error: cannot format {src}: {message}\")\n         self.failure_count += 1\n \n     @property\n@@ -1876,19 +1915,19 @@ class Report:\n             failed = \"failed to reformat\"\n         report = []\n         if self.change_count:\n-            s = 's' if self.change_count > 1 else ''\n+            s = \"s\" if self.change_count > 1 else \"\"\n             report.append(\n-                click.style(f'{self.change_count} file{s} {reformatted}', bold=True)\n+                click.style(f\"{self.change_count} file{s} {reformatted}\", bold=True)\n             )\n         if self.same_count:\n-            s = 's' if self.same_count > 1 else ''\n-            report.append(f'{self.same_count} file{s} {unchanged}')\n+            s = \"s\" if self.same_count > 1 else \"\"\n+            report.append(f\"{self.same_count} file{s} {unchanged}\")\n         if self.failure_count:\n-            s = 's' if self.failure_count > 1 else ''\n+            s = \"s\" if self.failure_count > 1 else \"\"\n             report.append(\n-                click.style(f'{self.failure_count} file{s} {failed}', fg='red')\n+                click.style(f\"{self.failure_count} file{s} {failed}\", fg=\"red\")\n             )\n-        return ', '.join(report) + '.'\n+        return \", \".join(report) + \".\"\n \n \n def assert_equivalent(src: str, dst: str) -> None:\n@@ -1935,17 +1974,17 @@ def assert_equivalent(src: str, dst: str) -> None:\n     try:\n         dst_ast = ast.parse(dst)\n     except Exception as exc:\n-        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n+        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n         raise AssertionError(\n             f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n             f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n             f\"This invalid output might be helpful: {log}\"\n         ) from None\n \n-    src_ast_str = '\\n'.join(_v(src_ast))\n-    dst_ast_str = '\\n'.join(_v(dst_ast))\n+    src_ast_str = \"\\n\".join(_v(src_ast))\n+    dst_ast_str = \"\\n\".join(_v(dst_ast))\n     if src_ast_str != dst_ast_str:\n-        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n+        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n         raise AssertionError(\n             f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n             f\"the source.  \"\n@@ -1959,8 +1998,8 @@ def assert_stable(src: str, dst: str, line_length: int) -> None:\n     newdst = format_str(dst, line_length=line_length)\n     if dst != newdst:\n         log = dump_to_file(\n-            diff(src, dst, 'source', 'first pass'),\n-            diff(dst, newdst, 'first pass', 'second pass'),\n+            diff(src, dst, \"source\", \"first pass\"),\n+            diff(dst, newdst, \"first pass\", \"second pass\"),\n         )\n         raise AssertionError(\n             f\"INTERNAL ERROR: Black produced different code on the second pass \"\n@@ -1975,11 +2014,11 @@ def dump_to_file(*output: str) -> str:\n     import tempfile\n \n     with tempfile.NamedTemporaryFile(\n-        mode='w', prefix='blk_', suffix='.log', delete=False\n+        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False\n     ) as f:\n         for lines in output:\n             f.write(lines)\n-            f.write('\\n')\n+            f.write(\"\\n\")\n     return f.name\n \n \n@@ -1987,9 +2026,9 @@ def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n     \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n     import difflib\n \n-    a_lines = [line + '\\n' for line in a.split('\\n')]\n-    b_lines = [line + '\\n' for line in b.split('\\n')]\n-    return ''.join(\n+    a_lines = [line + \"\\n\" for line in a.split(\"\\n\")]\n+    b_lines = [line + \"\\n\" for line in b.split(\"\\n\")]\n+    return \"\".join(\n         difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n     )\n \n@@ -2023,5 +2062,5 @@ def shutdown(loop: BaseEventLoop) -> None:\n         loop.close()\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     main()\n",
      "files_name_in_blame_commit": [
        "composition.py",
        "fstring.py",
        "string_quotes.py",
        "comments3.py",
        "comments2.py",
        "setup.py",
        "function.py",
        "test_black.py",
        "comments4.py",
        "black.py",
        "empty_lines.py",
        "comments.py",
        "fmtonoff.py",
        "expression.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 66
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "1973": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "def dump_to_file(*output: str) -> str:",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1974": {
        "commit_id": "44a235173119eb63b27a648b931940f13c04f424",
        "line_code": "    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"",
        "commit_date": "2018-03-28 19:31:53",
        "valid": 1
      },
      "1975": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "    import tempfile",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1976": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 0
      },
      "1977": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "    with tempfile.NamedTemporaryFile(",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1978": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "        mode='w', prefix='blk_', suffix='.log', delete=False",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1979": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "    ) as f:",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1980": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "        for lines in output:",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1981": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "            f.write(lines)",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1982": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "            f.write('\\n')",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      },
      "1983": {
        "commit_id": "e74117f172e29e8a980e2c9de929ad50d376915",
        "line_code": "    return f.name",
        "commit_date": "2018-03-14 12:55:32",
        "valid": 1
      }
    },
    "commits": {
      "44a235173119eb63b27a648b931940f13c04f424": {
        "commit": {
          "commit_id": "44a235173119eb63b27a648b931940f13c04f424",
          "commit_message": "Use imperative language in all docstrings",
          "commit_author": "\u0141ukasz Langa",
          "commit_date": "2018-03-28 19:31:53",
          "commit_parent": "b901d75deb497aa56a1d7651a3386af8a495afc9"
        },
        "function": {
          "function_name": "dump_to_file",
          "function_code_before": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n    import tempfile\n    with tempfile.NamedTemporaryFile(mode='w', prefix='blk_', suffix='.log', delete=False) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name",
          "function_code_after": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n    with tempfile.NamedTemporaryFile(mode='w', prefix='blk_', suffix='.log', delete=False) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name",
          "function_before_start_line": 1878,
          "function_before_end_line": 1888,
          "function_after_start_line": 1876,
          "function_after_end_line": 1886,
          "function_before_token_count": 58,
          "function_after_token_count": 58,
          "functions_name_modified_file": [
            "format_str",
            "mark",
            "is_def",
            "visit_default",
            "visit_INDENT",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "append",
            "format_file_contents",
            "trim_prefix",
            "left_hand_split",
            "visit_SEMI",
            "delimiter_split",
            "is_comment",
            "visit_decorators",
            "visit_async_stmt",
            "any_open_brackets",
            "is_python36",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "visit_simple_stmt",
            "maybe_increment_for_loop_variable",
            "main",
            "append_comment",
            "visit_stmt",
            "is_decorator",
            "maybe_decrement_after_for_loop_variable",
            "visit",
            "lib2to3_unparse",
            "visit_DEDENT",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "is_yield",
            "leaf_from_consumed",
            "show",
            "whitespace",
            "_maybe_empty_lines",
            "format_stdin_to_stdout",
            "__bool__",
            "failed",
            "__str__",
            "split_line",
            "make_comment",
            "assert_equivalent",
            "max_delimiter_priority",
            "done",
            "__init__",
            "maybe_empty_lines",
            "generate_comments",
            "assert_stable",
            "bracket_split_succeeded_or_raise",
            "lib2to3_parse",
            "normalize_prefix",
            "is_class",
            "is_flow_control",
            "return_code",
            "maybe_adapt_standalone_comment",
            "line",
            "maybe_remove_trailing_comma",
            "dump_to_file",
            "visit_unformatted"
          ],
          "functions_name_all_files": [
            "format_str",
            "mark",
            "is_def",
            "visit_default",
            "visit_INDENT",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "append",
            "format_file_contents",
            "trim_prefix",
            "left_hand_split",
            "visit_SEMI",
            "delimiter_split",
            "is_comment",
            "visit_decorators",
            "visit_async_stmt",
            "any_open_brackets",
            "is_python36",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "visit_simple_stmt",
            "maybe_increment_for_loop_variable",
            "main",
            "append_comment",
            "visit_stmt",
            "is_decorator",
            "maybe_decrement_after_for_loop_variable",
            "visit",
            "lib2to3_unparse",
            "visit_DEDENT",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "is_yield",
            "leaf_from_consumed",
            "show",
            "whitespace",
            "_maybe_empty_lines",
            "format_stdin_to_stdout",
            "__bool__",
            "failed",
            "__str__",
            "split_line",
            "make_comment",
            "assert_equivalent",
            "max_delimiter_priority",
            "done",
            "__init__",
            "maybe_empty_lines",
            "generate_comments",
            "assert_stable",
            "bracket_split_succeeded_or_raise",
            "lib2to3_parse",
            "normalize_prefix",
            "is_class",
            "is_flow_control",
            "return_code",
            "maybe_adapt_standalone_comment",
            "line",
            "maybe_remove_trailing_comma",
            "dump_to_file",
            "visit_unformatted"
          ],
          "functions_name_co_evolved_modified_file": [
            "format_str",
            "visit_INDENT",
            "mark",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "format_file_contents",
            "delimiter_split",
            "visit_SEMI",
            "visit_decorators",
            "visit_async_stmt",
            "any_open_brackets",
            "is_python36",
            "visit_simple_stmt",
            "maybe_increment_for_loop_variable",
            "append_comment",
            "visit_stmt",
            "visit",
            "visit_DEDENT",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "is_yield",
            "show",
            "__bool__",
            "assert_equivalent",
            "__str__",
            "split_line",
            "make_comment",
            "max_delimiter_priority",
            "generate_comments",
            "maybe_empty_lines",
            "assert_stable",
            "normalize_prefix",
            "is_flow_control",
            "is_class",
            "return_code",
            "left_hand_split"
          ],
          "functions_name_co_evolved_all_files": [
            "format_str",
            "visit_INDENT",
            "mark",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "format_file_contents",
            "delimiter_split",
            "visit_SEMI",
            "visit_decorators",
            "visit_async_stmt",
            "any_open_brackets",
            "is_python36",
            "visit_simple_stmt",
            "maybe_increment_for_loop_variable",
            "append_comment",
            "visit_stmt",
            "visit",
            "visit_DEDENT",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "is_yield",
            "show",
            "__bool__",
            "assert_equivalent",
            "__str__",
            "split_line",
            "make_comment",
            "max_delimiter_priority",
            "generate_comments",
            "maybe_empty_lines",
            "assert_stable",
            "normalize_prefix",
            "is_flow_control",
            "is_class",
            "return_code",
            "left_hand_split"
          ]
        },
        "file": {
          "file_name": "black.py",
          "file_nloc": 1564,
          "file_complexity": 470,
          "file_token_count": 8444,
          "file_before": "#!/usr/bin/env python3\n\nimport asyncio\nfrom asyncio.base_events import BaseEventLoop\nfrom concurrent.futures import Executor, ProcessPoolExecutor\nfrom functools import partial\nimport keyword\nimport os\nfrom pathlib import Path\nimport tokenize\nimport sys\nfrom typing import (\n    Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, Type, TypeVar, Union\n)\n\nfrom attr import dataclass, Factory\nimport click\n\n# lib2to3 fork\nfrom blib2to3.pytree import Node, Leaf, type_repr\nfrom blib2to3 import pygram, pytree\nfrom blib2to3.pgen2 import driver, token\nfrom blib2to3.pgen2.parse import ParseError\n\n__version__ = \"18.3a4\"\nDEFAULT_LINE_LENGTH = 88\n# types\nsyms = pygram.python_symbols\nFileContent = str\nEncoding = str\nDepth = int\nNodeType = int\nLeafID = int\nPriority = int\nLN = Union[Leaf, Node]\nout = partial(click.secho, bold=True, err=True)\nerr = partial(click.secho, fg='red', err=True)\n\n\nclass NothingChanged(UserWarning):\n    \"\"\"Raised by `format_file()` when the reformatted code is the same as source.\"\"\"\n\n\nclass CannotSplit(Exception):\n    \"\"\"A readable split that fits the allotted line length is impossible.\n\n    Raised by `left_hand_split()`, `right_hand_split()`, and `delimiter_split()`.\n    \"\"\"\n\n\nclass FormatError(Exception):\n    \"\"\"Base exception for `# fmt: on` and `# fmt: off` handling.\n\n    It holds the number of bytes of the prefix consumed before the format\n    control comment appeared.\n    \"\"\"\n\n    def __init__(self, consumed: int) -> None:\n        super().__init__(consumed)\n        self.consumed = consumed\n\n    def trim_prefix(self, leaf: Leaf) -> None:\n        leaf.prefix = leaf.prefix[self.consumed:]\n\n    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:\n        \"\"\"Returns a new Leaf from the consumed part of the prefix.\"\"\"\n        unformatted_prefix = leaf.prefix[:self.consumed]\n        return Leaf(token.NEWLINE, unformatted_prefix)\n\n\nclass FormatOn(FormatError):\n    \"\"\"Found a comment like `# fmt: on` in the file.\"\"\"\n\n\nclass FormatOff(FormatError):\n    \"\"\"Found a comment like `# fmt: off` in the file.\"\"\"\n\n\n@click.command()\n@click.option(\n    '-l',\n    '--line-length',\n    type=int,\n    default=DEFAULT_LINE_LENGTH,\n    help='How many character per line to allow.',\n    show_default=True,\n)\n@click.option(\n    '--check',\n    is_flag=True,\n    help=(\n        \"Don't write back the files, just return the status.  Return code 0 \"\n        \"means nothing would change.  Return code 1 means some files would be \"\n        \"reformatted.  Return code 123 means there was an internal error.\"\n    ),\n)\n@click.option(\n    '--fast/--safe',\n    is_flag=True,\n    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n)\n@click.version_option(version=__version__)\n@click.argument(\n    'src',\n    nargs=-1,\n    type=click.Path(\n        exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True\n    ),\n)\n@click.pass_context\ndef main(\n    ctx: click.Context, line_length: int, check: bool, fast: bool, src: List[str]\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        elif s == '-':\n            sources.append(Path('-'))\n        else:\n            err(f'invalid path: {s}')\n    if len(sources) == 0:\n        ctx.exit(0)\n    elif len(sources) == 1:\n        p = sources[0]\n        report = Report(check=check)\n        try:\n            if not p.is_file() and str(p) == '-':\n                changed = format_stdin_to_stdout(\n                    line_length=line_length, fast=fast, write_back=not check\n                )\n            else:\n                changed = format_file_in_place(\n                    p, line_length=line_length, fast=fast, write_back=not check\n                )\n            report.done(p, changed)\n        except Exception as exc:\n            report.failed(p, str(exc))\n        ctx.exit(report.return_code)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        return_code = 1\n        try:\n            return_code = loop.run_until_complete(\n                schedule_formatting(\n                    sources, line_length, not check, fast, loop, executor\n                )\n            )\n        finally:\n            loop.close()\n            ctx.exit(return_code)\n\n\nasync def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    write_back: bool,\n    fast: bool,\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> int:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    tasks = {\n        src: loop.run_in_executor(\n            executor, format_file_in_place, src, line_length, fast, write_back\n        )\n        for src in sources\n    }\n    await asyncio.wait(tasks.values())\n    cancelled = []\n    report = Report()\n    for src, task in tasks.items():\n        if not task.done():\n            report.failed(src, 'timed out, cancelling')\n            task.cancel()\n            cancelled.append(task)\n        elif task.exception():\n            report.failed(src, str(task.exception()))\n        else:\n            report.done(src, task.result())\n    if cancelled:\n        await asyncio.wait(cancelled, timeout=2)\n    out('All done! \u2728 \ud83c\udf70 \u2728')\n    click.echo(str(report))\n    return report.return_code\n\n\ndef format_file_in_place(\n    src: Path, line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(contents)\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    contents = sys.stdin.read()\n    try:\n        contents = format_file_contents(contents, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back:\n            sys.stdout.write(contents)\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n    \"\"\"Reformats a file and returns its contents and encoding.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `line_length` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == '':\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents\n\n\ndef format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformats a string and returns new contents.\n\n    `line_length` determines how many characters per line are allowed.\n    \"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    py36 = is_python36(src_node)\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        for line in split_line(current_line, line_length=line_length, py36=py36):\n            dst_contents += str(line)\n    return dst_contents\n\n\nGRAMMARS = [\n    pygram.python_grammar_no_print_statement_no_exec_statement,\n    pygram.python_grammar_no_print_statement,\n    pygram.python_grammar_no_exec_statement,\n    pygram.python_grammar,\n]\n\n\ndef lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    if src_txt[-1] != '\\n':\n        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n        src_txt += nl\n    for grammar in GRAMMARS:\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result\n\n\ndef lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code\n\n\nT = TypeVar('T')\n\n\nclass Visitor(Generic[T]):\n    \"\"\"Basic lib2to3 visitor that yields things of type `T` on `visit()`.\"\"\"\n\n    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n\n@dataclass\nclass DebugVisitor(Visitor[T]):\n    tree_depth: int = 0\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = ' ' * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f'{indent}{_type}', fg='yellow')\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f'{indent}/{_type}', fg='yellow', bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f'{indent}{_type}', fg='blue', nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n            out(f' {node.value!r}', fg='blue', bold=False)\n\n    @classmethod\n    def show(cls, code: str) -> None:\n        \"\"\"Pretty-prints a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))\n\n\nKEYWORDS = set(keyword.kwlist)\nWHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\nFLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\nSTATEMENT = {\n    syms.if_stmt,\n    syms.while_stmt,\n    syms.for_stmt,\n    syms.try_stmt,\n    syms.except_clause,\n    syms.with_stmt,\n    syms.funcdef,\n    syms.classdef,\n}\nSTANDALONE_COMMENT = 153\nLOGIC_OPERATORS = {'and', 'or'}\nCOMPARATORS = {\n    token.LESS,\n    token.GREATER,\n    token.EQEQUAL,\n    token.NOTEQUAL,\n    token.LESSEQUAL,\n    token.GREATEREQUAL,\n}\nMATH_OPERATORS = {\n    token.PLUS,\n    token.MINUS,\n    token.STAR,\n    token.SLASH,\n    token.VBAR,\n    token.AMPER,\n    token.PERCENT,\n    token.CIRCUMFLEX,\n    token.TILDE,\n    token.LEFTSHIFT,\n    token.RIGHTSHIFT,\n    token.DOUBLESTAR,\n    token.DOUBLESLASH,\n}\nCOMPREHENSION_PRIORITY = 20\nCOMMA_PRIORITY = 10\nLOGIC_PRIORITY = 5\nSTRING_PRIORITY = 4\nCOMPARATOR_PRIORITY = 3\nMATH_PRIORITY = 1\n\n\n@dataclass\nclass BracketTracker:\n    \"\"\"Keeps track of brackets on a line.\"\"\"\n\n    depth: int = 0\n    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n    delimiters: Dict[LeafID, Priority] = Factory(dict)\n    previous: Optional[Leaf] = None\n\n    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Marks `leaf` with bracket-related metadata. Keeps track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_delimiter(leaf)\n            if delim:\n                self.delimiters[id(leaf)] = delim\n            elif self.previous is not None:\n                if leaf.type == token.STRING and self.previous.type == token.STRING:\n                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'for'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'if'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value in LOGIC_OPERATORS\n                    and leaf.parent\n                ):\n                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n\n    def any_open_brackets(self) -> bool:\n        \"\"\"Returns True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)\n\n    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Returns the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_delimiter()` returns.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)\n\n\n@dataclass\nclass Line:\n    \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n\n    depth: int = 0\n    leaves: List[Leaf] = Factory(list)\n    comments: Dict[LeafID, Leaf] = Factory(dict)\n    bracket_tracker: BracketTracker = Factory(BracketTracker)\n    inside_brackets: bool = False\n    has_for: bool = False\n    _for_loop_variable: bool = False\n\n    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.value.strip()\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.maybe_decrement_after_for_loop_variable(leaf)\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n            self.maybe_increment_for_loop_variable(leaf)\n            if self.maybe_adapt_standalone_comment(leaf):\n                return\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)\n\n    @property\n    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return bool(self) and self.leaves[0].type == STANDALONE_COMMENT\n\n    @property\n    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT\n\n    @property\n    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])\n\n    @property\n    def is_class(self) -> bool:\n        \"\"\"Is this a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'class'\n        )\n\n    @property\n    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == 'def')\n            or (\n                first_leaf.type == token.ASYNC\n                and second_leaf is not None\n                and second_leaf.type == token.NAME\n                and second_leaf.value == 'def'\n            )\n        )\n\n    @property\n    def is_flow_control(self) -> bool:\n        \"\"\"Is this a flow control statement?\n\n        Those are `return`, `raise`, `break`, and `continue`.\n        \"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value in FLOW_CONTROL\n        )\n\n    @property\n    def is_yield(self) -> bool:\n        \"\"\"Is this a yield statement?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'yield'\n        )\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (\n            self.leaves\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RBRACE:\n            self.leaves.pop()\n            return True\n\n        if closing.type == token.RSQB:\n            comma = self.leaves[-1]\n            if comma.parent and comma.parent.type == syms.listmaker:\n                self.leaves.pop()\n                return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1\n        commas = 0\n        opening = closing.opening_bracket\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n                if leaf.parent and leaf.parent.type == syms.arglist:\n                    commas += 1\n                    break\n\n        if commas > 1:\n            self.leaves.pop()\n            return True\n\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, we will increase\n        the depth of tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == 'for':\n            self.has_for = True\n            self.bracket_tracker.depth += 1\n            self._for_loop_variable = True\n            return True\n\n        return False\n\n    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':\n            self.bracket_tracker.depth -= 1\n            self._for_loop_variable = False\n            return True\n\n        return False\n\n    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n        \"\"\"Hack a standalone comment to act as a trailing comment for line splitting.\n\n        If this line has brackets and a standalone `comment`, we need to adapt\n        it to be able to still reformat the line.\n\n        This is not perfect, the line to which the standalone comment gets\n        appended will appear \"too long\" when splitting.\n        \"\"\"\n        if not (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            return False\n\n        comment.type = token.COMMENT\n        comment.prefix = '\\n' + '    ' * (self.depth + 1)\n        return self.append_comment(comment)\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline comment to the line.\"\"\"\n        if comment.type != token.COMMENT:\n            return False\n\n        try:\n            after = id(self.last_non_delimiter())\n        except LookupError:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = ''\n            return False\n\n        else:\n            if after in self.comments:\n                self.comments[after].value += str(comment)\n            else:\n                self.comments[after] = comment\n            return True\n\n    def last_non_delimiter(self) -> Leaf:\n        \"\"\"Returns the last non-delimiter on the line. Raises LookupError otherwise.\"\"\"\n        for i in range(len(self.leaves)):\n            last = self.leaves[-i - 1]\n            if not is_delimiter(last):\n                return last\n\n        raise LookupError(\"No non-delimiters found\")\n\n    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return '\\n'\n\n        indent = '    ' * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f'{first.prefix}{indent}{first.value}'\n        for leaf in leaves:\n            res += str(leaf)\n        for comment in self.comments.values():\n            res += str(comment)\n        return res + '\\n'\n\n    def __bool__(self) -> bool:\n        \"\"\"Returns True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)\n\n\nclass UnformattedLines(Line):\n    \"\"\"Just like :class:`Line` but stores lines which aren't reformatted.\"\"\"\n\n    def append(self, leaf: Leaf, preformatted: bool = True) -> None:\n        \"\"\"Just add a new `leaf` to the end of the lines.\n\n        The `preformatted` argument is ignored.\n\n        Keeps track of indentation `depth`, which is useful when the user\n        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.\n        \"\"\"\n        try:\n            list(generate_comments(leaf))\n        except FormatOn as f_on:\n            self.leaves.append(f_on.leaf_from_consumed(leaf))\n            raise\n\n        self.leaves.append(leaf)\n        if leaf.type == token.INDENT:\n            self.depth += 1\n        elif leaf.type == token.DEDENT:\n            self.depth -= 1\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Not implemented in this class.\"\"\"\n        raise NotImplementedError(\"Unformatted lines don't store comments separately.\")\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def __str__(self) -> str:\n        \"\"\"Renders unformatted lines from leaves which were added with `append()`.\n\n        `depth` is not used for indentation in this case.\n        \"\"\"\n        if not self:\n            return '\\n'\n\n        res = ''\n        for leaf in self.leaves:\n            res += str(leaf)\n        return res\n\n\n@dataclass\nclass EmptyLineTracker:\n    \"\"\"Provides a stateful method that returns the number of potential extra\n    empty lines needed before and after the currently processed line.\n\n    Note: this tracker works on lines that haven't been split yet.  It assumes\n    the prefix of the first leaf consists of optional newlines.  Those newlines\n    are consumed by `maybe_empty_lines()` and included in the computation.\n    \"\"\"\n    previous_line: Optional[Line] = None\n    previous_after: int = 0\n    previous_defs: List[int] = Factory(list)\n\n    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Returns the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty lines\n        (two on module-level), as well as providing an extra empty line after flow\n        control keywords to make them more prominent.\n        \"\"\"\n        if isinstance(current_line, UnformattedLines):\n            return 0, 0\n\n        before, after = self._maybe_empty_lines(current_line)\n        before -= self.previous_after\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after\n\n    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count('\\n')\n            before = min(before, max_allowed)\n            first_leaf.prefix = ''\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = 1 if depth else 2\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_yield\n            and (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0\n\n\n@dataclass\nclass LineGenerator(Visitor[Line]):\n    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n\n    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n    in ways that will no longer stringify to valid Python code on the tree.\n    \"\"\"\n    current_line: Line = Factory(Line)\n\n    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            if self.current_line.__class__ == type:\n                self.current_line.depth += indent\n            else:\n                self.current_line = type(depth=self.current_line.depth + indent)\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = type(depth=complete_line.depth + indent)\n        yield complete_line\n\n    def visit(self, node: LN) -> Iterator[Line]:\n        \"\"\"Main method to start the visit process. Yields :class:`Line` objects.\"\"\"\n        if isinstance(self.current_line, UnformattedLines):\n            # File contained `# fmt: off`\n            yield from self.visit_unformatted(node)\n\n        else:\n            yield from super().visit(node)\n\n    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            try:\n                for comment in generate_comments(node):\n                    if any_open_brackets:\n                        # any comment within brackets is subject to splitting\n                        self.current_line.append(comment)\n                    elif comment.type == token.COMMENT:\n                        # regular trailing comment\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n                    else:\n                        # regular standalone comment\n                        yield from self.line()\n\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n            except FormatOff as f_off:\n                f_off.trim_prefix(node)\n                yield from self.line(type=UnformattedLines)\n                yield from self.visit(node)\n\n            except FormatOn as f_on:\n                # This only happens here if somebody says \"fmt: on\" multiple\n                # times in a row.\n                f_on.trim_prefix(node)\n                yield from self.visit_default(node)\n\n            else:\n                normalize_prefix(node, inside_brackets=any_open_brackets)\n                if node.type not in WHITESPACE:\n                    self.current_line.append(node)\n        yield from super().visit_default(node)\n\n    def visit_INDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Increases indentation level, maybe yields a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)\n\n    def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Decreases indentation level, maybe yields a line.\"\"\"\n        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n        yield from self.line(-1)\n\n    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n        \"\"\"Visits a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, and `class`.\n\n        The relevant Python language `keywords` for a given statement will be NAME\n        leaves within it. This methods puts those on a separate line.\n        \"\"\"\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)\n\n    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visits a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)\n\n    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visits `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)\n\n    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visits decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)\n\n    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Semicolons are always removed.\n\n        Statements between them are put on separate lines.\n        \"\"\"\n        yield from self.line()\n\n    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file.\n\n        Process outstanding comments and end with a newline.\n        \"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()\n\n    def visit_unformatted(self, node: LN) -> Iterator[Line]:\n        \"\"\"Used when file contained a `# fmt: off`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n        else:\n            try:\n                self.current_line.append(node)\n            except FormatOn as f_on:\n                f_on.trim_prefix(node)\n                yield from self.line()\n                yield from self.visit(node)\n\n    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n        self.visit_except_clause = partial(v, keywords={'except'})\n        self.visit_funcdef = partial(v, keywords={'def'})\n        self.visit_with_stmt = partial(v, keywords={'with'})\n        self.visit_classdef = partial(v, keywords={'class'})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators\n\n\nBRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\nOPENING_BRACKETS = set(BRACKET.keys())\nCLOSING_BRACKETS = set(BRACKET.values())\nBRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\nALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}\n\n\ndef whitespace(leaf: Leaf) -> str:  # noqa C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = ''\n    SPACE = ' '\n    DOUBLESPACE = '  '\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            return SPACE if prevp.type == token.COMMA else NO\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist, syms.argument, syms.parameters, syms.varargslist\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type == token.DOUBLESTAR:\n            if prevp.parent and prevp.parent.type in {\n                syms.arglist,\n                syms.argument,\n                syms.dictsetmaker,\n                syms.parameters,\n                syms.typedargslist,\n                syms.varargslist,\n            }:\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type in {syms.factor, syms.star_expr}\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == 'print'  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if t == token.RPAR:\n            return NO\n\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if t == token.RPAR:\n            return NO\n\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        else:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif (\n        p.type == syms.listmaker\n        or p.type == syms.testlist_gexp\n        or p.type == syms.subscriptlist\n    ):\n        # list interior, including unpacking\n        if not prev:\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict and set interior, including unpacking\n        if not prev:\n            return NO\n\n        if prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript, syms.sliceop\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == 'import':\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE\n\n\ndef preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Returns the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None\n\n\ndef is_delimiter(leaf: Leaf) -> int:\n    \"\"\"Returns the priority of the `leaf` delimiter. Returns 0 if not delimiter.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    return 0\n\n\ndef generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Cleans the prefix of the `leaf` and generates comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    p = leaf.prefix\n    if not p:\n        return\n\n    if '#' not in p:\n        return\n\n    consumed = 0\n    nlines = 0\n    for index, line in enumerate(p.split('\\n')):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith('#'):\n            continue\n\n        if index == 0 and leaf.type != token.ENDMARKER:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        yield Leaf(comment_type, comment, prefix='\\n' * nlines)\n\n        if comment in {'# fmt: on', '# yapf: enable'}:\n            raise FormatOn(consumed)\n\n        if comment in {'# fmt: off', '# yapf: disable'}:\n            raise FormatOff(consumed)\n\n        nlines = 0\n\n\ndef make_comment(content: str) -> str:\n    \"\"\"Returns a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n    the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return '#'\n\n    if content[0] == '#':\n        content = content[1:]\n    if content and content[0] not in ' !:#':\n        content = ' ' + content\n    return '#' + content\n\n\ndef split_line(\n    line: Line, line_length: int, inner: bool = False, py36: bool = False\n) -> Iterator[Line]:\n    \"\"\"Splits a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n\n    If `py36` is True, splitting may generate syntax that is only compatible\n    with Python 3.6 and later.\n    \"\"\"\n    if isinstance(line, UnformattedLines):\n        yield line\n        return\n\n    line_str = str(line).strip('\\n')\n    if len(line_str) <= line_length and '\\n' not in line_str:\n        yield line\n        return\n\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split]\n        if '\\n' not in line_str:\n            # Only attempt RHS if we don't have multiline strings or comments\n            # on this line.\n            split_funcs.append(right_hand_split)\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line, py36=py36):\n                if str(l).strip('\\n') == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(\n                    split_line(l, line_length=line_length, inner=True, py36=py36)\n                )\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line\n\n\ndef left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Splits line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Splits line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS:\n                opening_bracket = leaf.opening_bracket\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n\ndef delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Splits according to delimiters of the highest priority.\n\n    This kind of split doesn't increase indentation.\n    If `py36` is True, the split will add trailing commas also in function\n    signatures that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_delimiter_priority(\n            exclude={id(last_leaf)}\n        )\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n    for leaf in line.leaves:\n        current_line.append(leaf, preformatted=True)\n        comment_after = line.comments.get(id(leaf))\n        if comment_after:\n            current_line.append(comment_after, preformatted=True)\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if (\n            leaf.bracket_depth == lowest_depth\n            and leaf.type == token.STAR\n            or leaf.type == token.DOUBLESTAR\n        ):\n            trailing_comma_safe = trailing_comma_safe and py36\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            normalize_prefix(current_line.leaves[0], inside_brackets=True)\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and trailing_comma_safe\n        ):\n            current_line.append(Leaf(token.COMMA, ','))\n        normalize_prefix(current_line.leaves[0], inside_brackets=True)\n        yield current_line\n\n\ndef is_import(leaf: Leaf) -> bool:\n    \"\"\"Returns True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == 'import' and p and p.type == syms.import_name)\n            or (v == 'from' and p and p.type == syms.import_from)\n        )\n    )\n\n\ndef normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leaves existing extra newlines if not `inside_brackets`.\n\n    Removes everything else.  Note: don't use backslashes for formatting or\n    you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split('#')\n        if '\\\\' not in spl[0]:\n            nl_count = spl[-1].count('\\n')\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = '\\n' * nl_count\n            return\n\n    leaf.prefix = ''\n\n\ndef is_python36(node: Node) -> bool:\n    \"\"\"Returns True if the current file is using Python 3.6+ features.\n\n    Currently looking for:\n    - f-strings; and\n    - trailing commas after * or ** in function signatures.\n    \"\"\"\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", 'rf', 'fr', 'RF', 'FR'}:\n                return True\n\n        elif (\n            n.type == syms.typedargslist\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            for ch in n.children:\n                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:\n                    return True\n\n    return False\n\n\nPYTHON_EXTENSIONS = {'.py'}\nBLACKLISTED_DIRECTORIES = {\n    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n}\n\n\ndef gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    \"\"\"Generates all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n    and have one of the PYTHON_EXTENSIONS.\n    \"\"\"\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child\n\n\n@dataclass\nclass Report:\n    \"\"\"Provides a reformatting counter. Can be rendered with `str(report)`.\"\"\"\n    check: bool = False\n    change_count: int = 0\n    same_count: int = 0\n    failure_count: int = 0\n\n    def done(self, src: Path, changed: bool) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed:\n            reformatted = 'would reformat' if self.check else 'reformatted'\n            out(f'{reformatted} {src}')\n            self.change_count += 1\n        else:\n            out(f'{src} already well formatted, good job.', bold=False)\n            self.same_count += 1\n\n    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f'error: cannot format {src}: {message}')\n        self.failure_count += 1\n\n    @property\n    def return_code(self) -> int:\n        \"\"\"Which return code should the app use considering the current state.\"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special returncodes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0\n\n    def __str__(self) -> str:\n        \"\"\"A color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = 's' if self.change_count > 1 else ''\n            report.append(\n                click.style(f'{self.change_count} file{s} {reformatted}', bold=True)\n            )\n        if self.same_count:\n            s = 's' if self.same_count > 1 else ''\n            report.append(f'{self.same_count} file{s} {unchanged}')\n        if self.failure_count:\n            s = 's' if self.failure_count > 1 else ''\n            report.append(\n                click.style(f'{self.failure_count} file{s} {failed}', fg='red')\n            )\n        return ', '.join(report) + '.'\n\n\ndef assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raises AssertionError if `src` and `dst` aren't equivalent.\n\n    This is a temporary sanity check until Black becomes stable.\n    \"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = '\\n'.join(_v(src_ast))\n    dst_ast_str = '\\n'.join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raises AssertionError if `dst` reformats differently the second time.\n\n    This is a temporary sanity check until Black becomes stable.\n    \"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, 'source', 'first pass'),\n            diff(dst, newdst, 'first pass', 'second pass'),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode='w', prefix='blk_', suffix='.log', delete=False\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Returns a udiff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + '\\n' for line in a.split('\\n')]\n    b_lines = [line + '\\n' for line in b.split('\\n')]\n    return ''.join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_after": "#!/usr/bin/env python3\n\nimport asyncio\nfrom asyncio.base_events import BaseEventLoop\nfrom concurrent.futures import Executor, ProcessPoolExecutor\nfrom functools import partial\nimport keyword\nimport os\nfrom pathlib import Path\nimport tokenize\nimport sys\nfrom typing import (\n    Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, Type, TypeVar, Union\n)\n\nfrom attr import dataclass, Factory\nimport click\n\n# lib2to3 fork\nfrom blib2to3.pytree import Node, Leaf, type_repr\nfrom blib2to3 import pygram, pytree\nfrom blib2to3.pgen2 import driver, token\nfrom blib2to3.pgen2.parse import ParseError\n\n__version__ = \"18.3a4\"\nDEFAULT_LINE_LENGTH = 88\n# types\nsyms = pygram.python_symbols\nFileContent = str\nEncoding = str\nDepth = int\nNodeType = int\nLeafID = int\nPriority = int\nLN = Union[Leaf, Node]\nout = partial(click.secho, bold=True, err=True)\nerr = partial(click.secho, fg='red', err=True)\n\n\nclass NothingChanged(UserWarning):\n    \"\"\"Raised by :func:`format_file` when reformatted code is the same as source.\"\"\"\n\n\nclass CannotSplit(Exception):\n    \"\"\"A readable split that fits the allotted line length is impossible.\n\n    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and\n    :func:`delimiter_split`.\n    \"\"\"\n\n\nclass FormatError(Exception):\n    \"\"\"Base exception for `# fmt: on` and `# fmt: off` handling.\n\n    It holds the number of bytes of the prefix consumed before the format\n    control comment appeared.\n    \"\"\"\n\n    def __init__(self, consumed: int) -> None:\n        super().__init__(consumed)\n        self.consumed = consumed\n\n    def trim_prefix(self, leaf: Leaf) -> None:\n        leaf.prefix = leaf.prefix[self.consumed:]\n\n    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:\n        \"\"\"Returns a new Leaf from the consumed part of the prefix.\"\"\"\n        unformatted_prefix = leaf.prefix[:self.consumed]\n        return Leaf(token.NEWLINE, unformatted_prefix)\n\n\nclass FormatOn(FormatError):\n    \"\"\"Found a comment like `# fmt: on` in the file.\"\"\"\n\n\nclass FormatOff(FormatError):\n    \"\"\"Found a comment like `# fmt: off` in the file.\"\"\"\n\n\n@click.command()\n@click.option(\n    '-l',\n    '--line-length',\n    type=int,\n    default=DEFAULT_LINE_LENGTH,\n    help='How many character per line to allow.',\n    show_default=True,\n)\n@click.option(\n    '--check',\n    is_flag=True,\n    help=(\n        \"Don't write back the files, just return the status.  Return code 0 \"\n        \"means nothing would change.  Return code 1 means some files would be \"\n        \"reformatted.  Return code 123 means there was an internal error.\"\n    ),\n)\n@click.option(\n    '--fast/--safe',\n    is_flag=True,\n    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n)\n@click.version_option(version=__version__)\n@click.argument(\n    'src',\n    nargs=-1,\n    type=click.Path(\n        exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True\n    ),\n)\n@click.pass_context\ndef main(\n    ctx: click.Context, line_length: int, check: bool, fast: bool, src: List[str]\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        elif s == '-':\n            sources.append(Path('-'))\n        else:\n            err(f'invalid path: {s}')\n    if len(sources) == 0:\n        ctx.exit(0)\n    elif len(sources) == 1:\n        p = sources[0]\n        report = Report(check=check)\n        try:\n            if not p.is_file() and str(p) == '-':\n                changed = format_stdin_to_stdout(\n                    line_length=line_length, fast=fast, write_back=not check\n                )\n            else:\n                changed = format_file_in_place(\n                    p, line_length=line_length, fast=fast, write_back=not check\n                )\n            report.done(p, changed)\n        except Exception as exc:\n            report.failed(p, str(exc))\n        ctx.exit(report.return_code)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        return_code = 1\n        try:\n            return_code = loop.run_until_complete(\n                schedule_formatting(\n                    sources, line_length, not check, fast, loop, executor\n                )\n            )\n        finally:\n            loop.close()\n            ctx.exit(return_code)\n\n\nasync def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    write_back: bool,\n    fast: bool,\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> int:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    tasks = {\n        src: loop.run_in_executor(\n            executor, format_file_in_place, src, line_length, fast, write_back\n        )\n        for src in sources\n    }\n    await asyncio.wait(tasks.values())\n    cancelled = []\n    report = Report()\n    for src, task in tasks.items():\n        if not task.done():\n            report.failed(src, 'timed out, cancelling')\n            task.cancel()\n            cancelled.append(task)\n        elif task.exception():\n            report.failed(src, str(task.exception()))\n        else:\n            report.done(src, task.result())\n    if cancelled:\n        await asyncio.wait(cancelled, timeout=2)\n    out('All done! \u2728 \ud83c\udf70 \u2728')\n    click.echo(str(report))\n    return report.return_code\n\n\ndef format_file_in_place(\n    src: Path, line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(contents)\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: bool = False\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    contents = sys.stdin.read()\n    try:\n        contents = format_file_contents(contents, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back:\n            sys.stdout.write(contents)\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `line_length` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == '':\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents\n\n\ndef format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `line_length` determines how many characters per line are allowed.\n    \"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    py36 = is_python36(src_node)\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        for line in split_line(current_line, line_length=line_length, py36=py36):\n            dst_contents += str(line)\n    return dst_contents\n\n\nGRAMMARS = [\n    pygram.python_grammar_no_print_statement_no_exec_statement,\n    pygram.python_grammar_no_print_statement,\n    pygram.python_grammar_no_exec_statement,\n    pygram.python_grammar,\n]\n\n\ndef lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    if src_txt[-1] != '\\n':\n        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n        src_txt += nl\n    for grammar in GRAMMARS:\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result\n\n\ndef lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code\n\n\nT = TypeVar('T')\n\n\nclass Visitor(Generic[T]):\n    \"\"\"Basic lib2to3 visitor that yields things of type `T` on `visit()`.\"\"\"\n\n    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n\n@dataclass\nclass DebugVisitor(Visitor[T]):\n    tree_depth: int = 0\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = ' ' * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f'{indent}{_type}', fg='yellow')\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f'{indent}/{_type}', fg='yellow', bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f'{indent}{_type}', fg='blue', nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n            out(f' {node.value!r}', fg='blue', bold=False)\n\n    @classmethod\n    def show(cls, code: str) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))\n\n\nKEYWORDS = set(keyword.kwlist)\nWHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\nFLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\nSTATEMENT = {\n    syms.if_stmt,\n    syms.while_stmt,\n    syms.for_stmt,\n    syms.try_stmt,\n    syms.except_clause,\n    syms.with_stmt,\n    syms.funcdef,\n    syms.classdef,\n}\nSTANDALONE_COMMENT = 153\nLOGIC_OPERATORS = {'and', 'or'}\nCOMPARATORS = {\n    token.LESS,\n    token.GREATER,\n    token.EQEQUAL,\n    token.NOTEQUAL,\n    token.LESSEQUAL,\n    token.GREATEREQUAL,\n}\nMATH_OPERATORS = {\n    token.PLUS,\n    token.MINUS,\n    token.STAR,\n    token.SLASH,\n    token.VBAR,\n    token.AMPER,\n    token.PERCENT,\n    token.CIRCUMFLEX,\n    token.TILDE,\n    token.LEFTSHIFT,\n    token.RIGHTSHIFT,\n    token.DOUBLESTAR,\n    token.DOUBLESLASH,\n}\nCOMPREHENSION_PRIORITY = 20\nCOMMA_PRIORITY = 10\nLOGIC_PRIORITY = 5\nSTRING_PRIORITY = 4\nCOMPARATOR_PRIORITY = 3\nMATH_PRIORITY = 1\n\n\n@dataclass\nclass BracketTracker:\n    \"\"\"Keeps track of brackets on a line.\"\"\"\n\n    depth: int = 0\n    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n    delimiters: Dict[LeafID, Priority] = Factory(dict)\n    previous: Optional[Leaf] = None\n\n    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_delimiter(leaf)\n            if delim:\n                self.delimiters[id(leaf)] = delim\n            elif self.previous is not None:\n                if leaf.type == token.STRING and self.previous.type == token.STRING:\n                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'for'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value == 'if'\n                    and leaf.parent\n                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME\n                    and leaf.value in LOGIC_OPERATORS\n                    and leaf.parent\n                ):\n                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n\n    def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)\n\n    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_delimiter()` returns.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)\n\n\n@dataclass\nclass Line:\n    \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n\n    depth: int = 0\n    leaves: List[Leaf] = Factory(list)\n    comments: Dict[LeafID, Leaf] = Factory(dict)\n    bracket_tracker: BracketTracker = Factory(BracketTracker)\n    inside_brackets: bool = False\n    has_for: bool = False\n    _for_loop_variable: bool = False\n\n    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.value.strip()\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.maybe_decrement_after_for_loop_variable(leaf)\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n            self.maybe_increment_for_loop_variable(leaf)\n            if self.maybe_adapt_standalone_comment(leaf):\n                return\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)\n\n    @property\n    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return bool(self) and self.leaves[0].type == STANDALONE_COMMENT\n\n    @property\n    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT\n\n    @property\n    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])\n\n    @property\n    def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'class'\n        )\n\n    @property\n    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == 'def')\n            or (\n                first_leaf.type == token.ASYNC\n                and second_leaf is not None\n                and second_leaf.type == token.NAME\n                and second_leaf.value == 'def'\n            )\n        )\n\n    @property\n    def is_flow_control(self) -> bool:\n        \"\"\"Is this line a flow control statement?\n\n        Those are `return`, `raise`, `break`, and `continue`.\n        \"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value in FLOW_CONTROL\n        )\n\n    @property\n    def is_yield(self) -> bool:\n        \"\"\"Is this line a yield statement?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == 'yield'\n        )\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (\n            self.leaves\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RBRACE:\n            self.leaves.pop()\n            return True\n\n        if closing.type == token.RSQB:\n            comma = self.leaves[-1]\n            if comma.parent and comma.parent.type == syms.listmaker:\n                self.leaves.pop()\n                return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1\n        commas = 0\n        opening = closing.opening_bracket\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n                if leaf.parent and leaf.parent.type == syms.arglist:\n                    commas += 1\n                    break\n\n        if commas > 1:\n            self.leaves.pop()\n            return True\n\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == 'for':\n            self.has_for = True\n            self.bracket_tracker.depth += 1\n            self._for_loop_variable = True\n            return True\n\n        return False\n\n    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':\n            self.bracket_tracker.depth -= 1\n            self._for_loop_variable = False\n            return True\n\n        return False\n\n    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n        \"\"\"Hack a standalone comment to act as a trailing comment for line splitting.\n\n        If this line has brackets and a standalone `comment`, we need to adapt\n        it to be able to still reformat the line.\n\n        This is not perfect, the line to which the standalone comment gets\n        appended will appear \"too long\" when splitting.\n        \"\"\"\n        if not (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            return False\n\n        comment.type = token.COMMENT\n        comment.prefix = '\\n' + '    ' * (self.depth + 1)\n        return self.append_comment(comment)\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline comment to the line.\"\"\"\n        if comment.type != token.COMMENT:\n            return False\n\n        try:\n            after = id(self.last_non_delimiter())\n        except LookupError:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = ''\n            return False\n\n        else:\n            if after in self.comments:\n                self.comments[after].value += str(comment)\n            else:\n                self.comments[after] = comment\n            return True\n\n    def last_non_delimiter(self) -> Leaf:\n        \"\"\"Return the last non-delimiter on the line. Raise LookupError otherwise.\"\"\"\n        for i in range(len(self.leaves)):\n            last = self.leaves[-i - 1]\n            if not is_delimiter(last):\n                return last\n\n        raise LookupError(\"No non-delimiters found\")\n\n    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return '\\n'\n\n        indent = '    ' * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f'{first.prefix}{indent}{first.value}'\n        for leaf in leaves:\n            res += str(leaf)\n        for comment in self.comments.values():\n            res += str(comment)\n        return res + '\\n'\n\n    def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)\n\n\nclass UnformattedLines(Line):\n    \"\"\"Just like :class:`Line` but stores lines which aren't reformatted.\"\"\"\n\n    def append(self, leaf: Leaf, preformatted: bool = True) -> None:\n        \"\"\"Just add a new `leaf` to the end of the lines.\n\n        The `preformatted` argument is ignored.\n\n        Keeps track of indentation `depth`, which is useful when the user\n        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.\n        \"\"\"\n        try:\n            list(generate_comments(leaf))\n        except FormatOn as f_on:\n            self.leaves.append(f_on.leaf_from_consumed(leaf))\n            raise\n\n        self.leaves.append(leaf)\n        if leaf.type == token.INDENT:\n            self.depth += 1\n        elif leaf.type == token.DEDENT:\n            self.depth -= 1\n\n    def __str__(self) -> str:\n        \"\"\"Render unformatted lines from leaves which were added with `append()`.\n\n        `depth` is not used for indentation in this case.\n        \"\"\"\n        if not self:\n            return '\\n'\n\n        res = ''\n        for leaf in self.leaves:\n            res += str(leaf)\n        return res\n\n    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Not implemented in this class. Raises `NotImplementedError`.\"\"\"\n        raise NotImplementedError(\"Unformatted lines don't store comments separately.\")\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n        \"\"\"Does nothing and returns False.\"\"\"\n        return False\n\n\n@dataclass\nclass EmptyLineTracker:\n    \"\"\"Provides a stateful method that returns the number of potential extra\n    empty lines needed before and after the currently processed line.\n\n    Note: this tracker works on lines that haven't been split yet.  It assumes\n    the prefix of the first leaf consists of optional newlines.  Those newlines\n    are consumed by `maybe_empty_lines()` and included in the computation.\n    \"\"\"\n    previous_line: Optional[Line] = None\n    previous_after: int = 0\n    previous_defs: List[int] = Factory(list)\n\n    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level), as well as providing an extra empty line\n        after flow control keywords to make them more prominent.\n        \"\"\"\n        if isinstance(current_line, UnformattedLines):\n            return 0, 0\n\n        before, after = self._maybe_empty_lines(current_line)\n        before -= self.previous_after\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after\n\n    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count('\\n')\n            before = min(before, max_allowed)\n            first_leaf.prefix = ''\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = 1 if depth else 2\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_yield\n            and (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0\n\n\n@dataclass\nclass LineGenerator(Visitor[Line]):\n    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n\n    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n    in ways that will no longer stringify to valid Python code on the tree.\n    \"\"\"\n    current_line: Line = Factory(Line)\n\n    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            if self.current_line.__class__ == type:\n                self.current_line.depth += indent\n            else:\n                self.current_line = type(depth=self.current_line.depth + indent)\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = type(depth=complete_line.depth + indent)\n        yield complete_line\n\n    def visit(self, node: LN) -> Iterator[Line]:\n        \"\"\"Main method to visit `node` and its children.\n\n        Yields :class:`Line` objects.\n        \"\"\"\n        if isinstance(self.current_line, UnformattedLines):\n            # File contained `# fmt: off`\n            yield from self.visit_unformatted(node)\n\n        else:\n            yield from super().visit(node)\n\n    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            try:\n                for comment in generate_comments(node):\n                    if any_open_brackets:\n                        # any comment within brackets is subject to splitting\n                        self.current_line.append(comment)\n                    elif comment.type == token.COMMENT:\n                        # regular trailing comment\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n                    else:\n                        # regular standalone comment\n                        yield from self.line()\n\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n            except FormatOff as f_off:\n                f_off.trim_prefix(node)\n                yield from self.line(type=UnformattedLines)\n                yield from self.visit(node)\n\n            except FormatOn as f_on:\n                # This only happens here if somebody says \"fmt: on\" multiple\n                # times in a row.\n                f_on.trim_prefix(node)\n                yield from self.visit_default(node)\n\n            else:\n                normalize_prefix(node, inside_brackets=any_open_brackets)\n                if node.type not in WHITESPACE:\n                    self.current_line.append(node)\n        yield from super().visit_default(node)\n\n    def visit_INDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)\n\n    def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n        yield from self.line(-1)\n\n    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, and `class`.\n\n        The relevant Python language `keywords` for a given statement will be NAME\n        leaves within it. This methods puts those on a separate line.\n        \"\"\"\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)\n\n    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)\n\n    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)\n\n    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)\n\n    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()\n\n    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()\n\n    def visit_unformatted(self, node: LN) -> Iterator[Line]:\n        \"\"\"Used when file contained a `# fmt: off`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n        else:\n            try:\n                self.current_line.append(node)\n            except FormatOn as f_on:\n                f_on.trim_prefix(node)\n                yield from self.line()\n                yield from self.visit(node)\n\n    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n        self.visit_except_clause = partial(v, keywords={'except'})\n        self.visit_funcdef = partial(v, keywords={'def'})\n        self.visit_with_stmt = partial(v, keywords={'with'})\n        self.visit_classdef = partial(v, keywords={'class'})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators\n\n\nBRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\nOPENING_BRACKETS = set(BRACKET.keys())\nCLOSING_BRACKETS = set(BRACKET.values())\nBRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\nALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}\n\n\ndef whitespace(leaf: Leaf) -> str:  # noqa C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = ''\n    SPACE = ' '\n    DOUBLESPACE = '  '\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            return SPACE if prevp.type == token.COMMA else NO\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist, syms.argument, syms.parameters, syms.varargslist\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type == token.DOUBLESTAR:\n            if prevp.parent and prevp.parent.type in {\n                syms.arglist,\n                syms.argument,\n                syms.dictsetmaker,\n                syms.parameters,\n                syms.typedargslist,\n                syms.varargslist,\n            }:\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type in {syms.factor, syms.star_expr}\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == 'print'  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if t == token.RPAR:\n            return NO\n\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if t == token.RPAR:\n            return NO\n\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        else:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif (\n        p.type == syms.listmaker\n        or p.type == syms.testlist_gexp\n        or p.type == syms.subscriptlist\n    ):\n        # list interior, including unpacking\n        if not prev:\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict and set interior, including unpacking\n        if not prev:\n            return NO\n\n        if prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript, syms.sliceop\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == 'import':\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE\n\n\ndef preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None\n\n\ndef is_delimiter(leaf: Leaf) -> int:\n    \"\"\"Return the priority of the `leaf` delimiter. Return 0 if not delimiter.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    return 0\n\n\ndef generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    p = leaf.prefix\n    if not p:\n        return\n\n    if '#' not in p:\n        return\n\n    consumed = 0\n    nlines = 0\n    for index, line in enumerate(p.split('\\n')):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith('#'):\n            continue\n\n        if index == 0 and leaf.type != token.ENDMARKER:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        yield Leaf(comment_type, comment, prefix='\\n' * nlines)\n\n        if comment in {'# fmt: on', '# yapf: enable'}:\n            raise FormatOn(consumed)\n\n        if comment in {'# fmt: off', '# yapf: disable'}:\n            raise FormatOff(consumed)\n\n        nlines = 0\n\n\ndef make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n    the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return '#'\n\n    if content[0] == '#':\n        content = content[1:]\n    if content and content[0] not in ' !:#':\n        content = ' ' + content\n    return '#' + content\n\n\ndef split_line(\n    line: Line, line_length: int, inner: bool = False, py36: bool = False\n) -> Iterator[Line]:\n    \"\"\"Split a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n\n    If `py36` is True, splitting may generate syntax that is only compatible\n    with Python 3.6 and later.\n    \"\"\"\n    if isinstance(line, UnformattedLines):\n        yield line\n        return\n\n    line_str = str(line).strip('\\n')\n    if len(line_str) <= line_length and '\\n' not in line_str:\n        yield line\n        return\n\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split]\n        if '\\n' not in line_str:\n            # Only attempt RHS if we don't have multiline strings or comments\n            # on this line.\n            split_funcs.append(right_hand_split)\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line, py36=py36):\n                if str(l).strip('\\n') == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(\n                    split_line(l, line_length=line_length, inner=True, py36=py36)\n                )\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line\n\n\ndef left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS:\n                opening_bracket = leaf.opening_bracket\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n\ndef delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    This kind of split doesn't increase indentation.\n    If `py36` is True, the split will add trailing commas also in function\n    signatures that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_delimiter_priority(\n            exclude={id(last_leaf)}\n        )\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n    for leaf in line.leaves:\n        current_line.append(leaf, preformatted=True)\n        comment_after = line.comments.get(id(leaf))\n        if comment_after:\n            current_line.append(comment_after, preformatted=True)\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if (\n            leaf.bracket_depth == lowest_depth\n            and leaf.type == token.STAR\n            or leaf.type == token.DOUBLESTAR\n        ):\n            trailing_comma_safe = trailing_comma_safe and py36\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            normalize_prefix(current_line.leaves[0], inside_brackets=True)\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and trailing_comma_safe\n        ):\n            current_line.append(Leaf(token.COMMA, ','))\n        normalize_prefix(current_line.leaves[0], inside_brackets=True)\n        yield current_line\n\n\ndef is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == 'import' and p and p.type == syms.import_name)\n            or (v == 'from' and p and p.type == syms.import_from)\n        )\n    )\n\n\ndef normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split('#')\n        if '\\\\' not in spl[0]:\n            nl_count = spl[-1].count('\\n')\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = '\\n' * nl_count\n            return\n\n    leaf.prefix = ''\n\n\ndef is_python36(node: Node) -> bool:\n    \"\"\"Return True if the current file is using Python 3.6+ features.\n\n    Currently looking for:\n    - f-strings; and\n    - trailing commas after * or ** in function signatures.\n    \"\"\"\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", 'rf', 'fr', 'RF', 'FR'}:\n                return True\n\n        elif (\n            n.type == syms.typedargslist\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            for ch in n.children:\n                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:\n                    return True\n\n    return False\n\n\nPYTHON_EXTENSIONS = {'.py'}\nBLACKLISTED_DIRECTORIES = {\n    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n}\n\n\ndef gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n    and have one of the PYTHON_EXTENSIONS.\n    \"\"\"\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child\n\n\n@dataclass\nclass Report:\n    \"\"\"Provides a reformatting counter. Can be rendered with `str(report)`.\"\"\"\n    check: bool = False\n    change_count: int = 0\n    same_count: int = 0\n    failure_count: int = 0\n\n    def done(self, src: Path, changed: bool) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed:\n            reformatted = 'would reformat' if self.check else 'reformatted'\n            out(f'{reformatted} {src}')\n            self.change_count += 1\n        else:\n            out(f'{src} already well formatted, good job.', bold=False)\n            self.same_count += 1\n\n    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f'error: cannot format {src}: {message}')\n        self.failure_count += 1\n\n    @property\n    def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special returncodes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0\n\n    def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = 's' if self.change_count > 1 else ''\n            report.append(\n                click.style(f'{self.change_count} file{s} {reformatted}', bold=True)\n            )\n        if self.same_count:\n            s = 's' if self.same_count > 1 else ''\n            report.append(f'{self.same_count} file{s} {unchanged}')\n        if self.failure_count:\n            s = 's' if self.failure_count > 1 else ''\n            report.append(\n                click.style(f'{self.failure_count} file{s} {failed}', fg='red')\n            )\n        return ', '.join(report) + '.'\n\n\ndef assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = '\\n'.join(_v(src_ast))\n    dst_ast_str = '\\n'.join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, 'source', 'first pass'),\n            diff(dst, newdst, 'first pass', 'second pass'),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode='w', prefix='blk_', suffix='.log', delete=False\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + '\\n' for line in a.split('\\n')]\n    b_lines = [line + '\\n' for line in b.split('\\n')]\n    return ''.join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_patch": "@@ -38,13 +38,14 @@ err = partial(click.secho, fg='red', err=True)\n \n \n class NothingChanged(UserWarning):\n-    \"\"\"Raised by `format_file()` when the reformatted code is the same as source.\"\"\"\n+    \"\"\"Raised by :func:`format_file` when reformatted code is the same as source.\"\"\"\n \n \n class CannotSplit(Exception):\n     \"\"\"A readable split that fits the allotted line length is impossible.\n \n-    Raised by `left_hand_split()`, `right_hand_split()`, and `delimiter_split()`.\n+    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and\n+    :func:`delimiter_split`.\n     \"\"\"\n \n \n@@ -244,7 +245,7 @@ def format_stdin_to_stdout(\n def format_file_contents(\n     src_contents: str, line_length: int, fast: bool\n ) -> FileContent:\n-    \"\"\"Reformats a file and returns its contents and encoding.\n+    \"\"\"Reformat contents a file and return new contents.\n \n     If `fast` is False, additionally confirm that the reformatted code is\n     valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n@@ -264,7 +265,7 @@ def format_file_contents(\n \n \n def format_str(src_contents: str, line_length: int) -> FileContent:\n-    \"\"\"Reformats a string and returns new contents.\n+    \"\"\"Reformat a string and return new contents.\n \n     `line_length` determines how many characters per line are allowed.\n     \"\"\"\n@@ -383,7 +384,7 @@ class DebugVisitor(Visitor[T]):\n \n     @classmethod\n     def show(cls, code: str) -> None:\n-        \"\"\"Pretty-prints a given string of `code`.\n+        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n \n         Convenience method for debugging.\n         \"\"\"\n@@ -447,7 +448,7 @@ class BracketTracker:\n     previous: Optional[Leaf] = None\n \n     def mark(self, leaf: Leaf) -> None:\n-        \"\"\"Marks `leaf` with bracket-related metadata. Keeps track of delimiters.\n+        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n \n         All leaves receive an int `bracket_depth` field that stores how deep\n         within brackets a given leaf is. 0 means there are no enclosing brackets\n@@ -502,11 +503,11 @@ class BracketTracker:\n         self.previous = leaf\n \n     def any_open_brackets(self) -> bool:\n-        \"\"\"Returns True if there is an yet unmatched open bracket on the line.\"\"\"\n+        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n         return bool(self.bracket_match)\n \n     def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n-        \"\"\"Returns the highest priority of a delimiter found on the line.\n+        \"\"\"Return the highest priority of a delimiter found on the line.\n \n         Values are consistent with what `is_delimiter()` returns.\n         \"\"\"\n@@ -571,7 +572,7 @@ class Line:\n \n     @property\n     def is_class(self) -> bool:\n-        \"\"\"Is this a class definition?\"\"\"\n+        \"\"\"Is this line a class definition?\"\"\"\n         return (\n             bool(self)\n             and self.leaves[0].type == token.NAME\n@@ -602,7 +603,7 @@ class Line:\n \n     @property\n     def is_flow_control(self) -> bool:\n-        \"\"\"Is this a flow control statement?\n+        \"\"\"Is this line a flow control statement?\n \n         Those are `return`, `raise`, `break`, and `continue`.\n         \"\"\"\n@@ -614,7 +615,7 @@ class Line:\n \n     @property\n     def is_yield(self) -> bool:\n-        \"\"\"Is this a yield statement?\"\"\"\n+        \"\"\"Is this line a yield statement?\"\"\"\n         return (\n             bool(self)\n             and self.leaves[0].type == token.NAME\n@@ -673,8 +674,8 @@ class Line:\n     def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n         \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n \n-        To avoid splitting on the comma in this situation, we will increase\n-        the depth of tokens between `for` and `in`.\n+        To avoid splitting on the comma in this situation, increase the depth of\n+        tokens between `for` and `in`.\n         \"\"\"\n         if leaf.type == token.NAME and leaf.value == 'for':\n             self.has_for = True\n@@ -732,7 +733,7 @@ class Line:\n             return True\n \n     def last_non_delimiter(self) -> Leaf:\n-        \"\"\"Returns the last non-delimiter on the line. Raises LookupError otherwise.\"\"\"\n+        \"\"\"Return the last non-delimiter on the line. Raise LookupError otherwise.\"\"\"\n         for i in range(len(self.leaves)):\n             last = self.leaves[-i - 1]\n             if not is_delimiter(last):\n@@ -756,7 +757,7 @@ class Line:\n         return res + '\\n'\n \n     def __bool__(self) -> bool:\n-        \"\"\"Returns True if the line has leaves or comments.\"\"\"\n+        \"\"\"Return True if the line has leaves or comments.\"\"\"\n         return bool(self.leaves or self.comments)\n \n \n@@ -783,8 +784,21 @@ class UnformattedLines(Line):\n         elif leaf.type == token.DEDENT:\n             self.depth -= 1\n \n+    def __str__(self) -> str:\n+        \"\"\"Render unformatted lines from leaves which were added with `append()`.\n+\n+        `depth` is not used for indentation in this case.\n+        \"\"\"\n+        if not self:\n+            return '\\n'\n+\n+        res = ''\n+        for leaf in self.leaves:\n+            res += str(leaf)\n+        return res\n+\n     def append_comment(self, comment: Leaf) -> bool:\n-        \"\"\"Not implemented in this class.\"\"\"\n+        \"\"\"Not implemented in this class. Raises `NotImplementedError`.\"\"\"\n         raise NotImplementedError(\"Unformatted lines don't store comments separately.\")\n \n     def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n@@ -799,19 +813,6 @@ class UnformattedLines(Line):\n         \"\"\"Does nothing and returns False.\"\"\"\n         return False\n \n-    def __str__(self) -> str:\n-        \"\"\"Renders unformatted lines from leaves which were added with `append()`.\n-\n-        `depth` is not used for indentation in this case.\n-        \"\"\"\n-        if not self:\n-            return '\\n'\n-\n-        res = ''\n-        for leaf in self.leaves:\n-            res += str(leaf)\n-        return res\n-\n \n @dataclass\n class EmptyLineTracker:\n@@ -827,11 +828,11 @@ class EmptyLineTracker:\n     previous_defs: List[int] = Factory(list)\n \n     def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n-        \"\"\"Returns the number of extra empty lines before and after the `current_line`.\n+        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n \n-        This is for separating `def`, `async def` and `class` with extra empty lines\n-        (two on module-level), as well as providing an extra empty line after flow\n-        control keywords to make them more prominent.\n+        This is for separating `def`, `async def` and `class` with extra empty\n+        lines (two on module-level), as well as providing an extra empty line\n+        after flow control keywords to make them more prominent.\n         \"\"\"\n         if isinstance(current_line, UnformattedLines):\n             return 0, 0\n@@ -925,7 +926,10 @@ class LineGenerator(Visitor[Line]):\n         yield complete_line\n \n     def visit(self, node: LN) -> Iterator[Line]:\n-        \"\"\"Main method to start the visit process. Yields :class:`Line` objects.\"\"\"\n+        \"\"\"Main method to visit `node` and its children.\n+\n+        Yields :class:`Line` objects.\n+        \"\"\"\n         if isinstance(self.current_line, UnformattedLines):\n             # File contained `# fmt: off`\n             yield from self.visit_unformatted(node)\n@@ -972,18 +976,18 @@ class LineGenerator(Visitor[Line]):\n         yield from super().visit_default(node)\n \n     def visit_INDENT(self, node: Node) -> Iterator[Line]:\n-        \"\"\"Increases indentation level, maybe yields a line.\"\"\"\n+        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n         # In blib2to3 INDENT never holds comments.\n         yield from self.line(+1)\n         yield from self.visit_default(node)\n \n     def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n-        \"\"\"Decreases indentation level, maybe yields a line.\"\"\"\n+        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n         # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n         yield from self.line(-1)\n \n     def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n-        \"\"\"Visits a statement.\n+        \"\"\"Visit a statement.\n \n         This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n         `def`, `with`, and `class`.\n@@ -998,7 +1002,7 @@ class LineGenerator(Visitor[Line]):\n             yield from self.visit(child)\n \n     def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n-        \"\"\"Visits a statement without nested statements.\"\"\"\n+        \"\"\"Visit a statement without nested statements.\"\"\"\n         is_suite_like = node.parent and node.parent.type in STATEMENT\n         if is_suite_like:\n             yield from self.line(+1)\n@@ -1010,7 +1014,7 @@ class LineGenerator(Visitor[Line]):\n             yield from self.visit_default(node)\n \n     def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n-        \"\"\"Visits `async def`, `async for`, `async with`.\"\"\"\n+        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n         yield from self.line()\n \n         children = iter(node.children)\n@@ -1025,23 +1029,17 @@ class LineGenerator(Visitor[Line]):\n             yield from self.visit(child)\n \n     def visit_decorators(self, node: Node) -> Iterator[Line]:\n-        \"\"\"Visits decorators.\"\"\"\n+        \"\"\"Visit decorators.\"\"\"\n         for child in node.children:\n             yield from self.line()\n             yield from self.visit(child)\n \n     def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n-        \"\"\"Semicolons are always removed.\n-\n-        Statements between them are put on separate lines.\n-        \"\"\"\n+        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n         yield from self.line()\n \n     def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n-        \"\"\"End of file.\n-\n-        Process outstanding comments and end with a newline.\n-        \"\"\"\n+        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n         yield from self.visit_default(leaf)\n         yield from self.line()\n \n@@ -1319,7 +1317,7 @@ def whitespace(leaf: Leaf) -> str:  # noqa C901\n \n \n def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n-    \"\"\"Returns the first leaf that precedes `node`, if any.\"\"\"\n+    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n     while node:\n         res = node.prev_sibling\n         if res:\n@@ -1337,7 +1335,7 @@ def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n \n \n def is_delimiter(leaf: Leaf) -> int:\n-    \"\"\"Returns the priority of the `leaf` delimiter. Returns 0 if not delimiter.\n+    \"\"\"Return the priority of the `leaf` delimiter. Return 0 if not delimiter.\n \n     Higher numbers are higher priority.\n     \"\"\"\n@@ -1358,7 +1356,7 @@ def is_delimiter(leaf: Leaf) -> int:\n \n \n def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n-    \"\"\"Cleans the prefix of the `leaf` and generates comments from it, if any.\n+    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n \n     Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n     in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n@@ -1410,7 +1408,7 @@ def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n \n \n def make_comment(content: str) -> str:\n-    \"\"\"Returns a consistently formatted comment from the given `content` string.\n+    \"\"\"Return a consistently formatted comment from the given `content` string.\n \n     All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n     the hash sign and the content.\n@@ -1431,7 +1429,7 @@ def make_comment(content: str) -> str:\n def split_line(\n     line: Line, line_length: int, inner: bool = False, py36: bool = False\n ) -> Iterator[Line]:\n-    \"\"\"Splits a `line` into potentially many lines.\n+    \"\"\"Split a `line` into potentially many lines.\n \n     They should fit in the allotted `line_length` but might not be able to.\n     `inner` signifies that there were a pair of brackets somewhere around the\n@@ -1485,7 +1483,7 @@ def split_line(\n \n \n def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n-    \"\"\"Splits line into many lines, starting with the first matching bracket pair.\n+    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n \n     Note: this usually looks weird, only use this for function definitions.\n     Prefer RHS otherwise.\n@@ -1529,7 +1527,7 @@ def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n \n \n def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n-    \"\"\"Splits line into many lines, starting with the last matching bracket pair.\"\"\"\n+    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n     head = Line(depth=line.depth)\n     body = Line(depth=line.depth + 1, inside_brackets=True)\n     tail = Line(depth=line.depth)\n@@ -1595,7 +1593,7 @@ def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None\n \n \n def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n-    \"\"\"Splits according to delimiters of the highest priority.\n+    \"\"\"Split according to delimiters of the highest priority.\n \n     This kind of split doesn't increase indentation.\n     If `py36` is True, the split will add trailing commas also in function\n@@ -1647,7 +1645,7 @@ def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n \n \n def is_import(leaf: Leaf) -> bool:\n-    \"\"\"Returns True if the given leaf starts an import statement.\"\"\"\n+    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n     p = leaf.parent\n     t = leaf.type\n     v = leaf.value\n@@ -1661,10 +1659,10 @@ def is_import(leaf: Leaf) -> bool:\n \n \n def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n-    \"\"\"Leaves existing extra newlines if not `inside_brackets`.\n+    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n+    else.\n \n-    Removes everything else.  Note: don't use backslashes for formatting or\n-    you'll lose your voting rights.\n+    Note: don't use backslashes for formatting or you'll lose your voting rights.\n     \"\"\"\n     if not inside_brackets:\n         spl = leaf.prefix.split('#')\n@@ -1679,7 +1677,7 @@ def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n \n \n def is_python36(node: Node) -> bool:\n-    \"\"\"Returns True if the current file is using Python 3.6+ features.\n+    \"\"\"Return True if the current file is using Python 3.6+ features.\n \n     Currently looking for:\n     - f-strings; and\n@@ -1710,7 +1708,7 @@ BLACKLISTED_DIRECTORIES = {\n \n \n def gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n-    \"\"\"Generates all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n+    \"\"\"Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n     and have one of the PYTHON_EXTENSIONS.\n     \"\"\"\n     for child in path.iterdir():\n@@ -1749,7 +1747,13 @@ class Report:\n \n     @property\n     def return_code(self) -> int:\n-        \"\"\"Which return code should the app use considering the current state.\"\"\"\n+        \"\"\"Return the exit code that the app should use.\n+\n+        This considers the current state of changed files and failures:\n+        - if there were any failures, return 123;\n+        - if any files were changed and --check is being used, return 1;\n+        - otherwise return 0.\n+        \"\"\"\n         # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n         # 126 we have special returncodes reserved by the shell.\n         if self.failure_count:\n@@ -1761,7 +1765,7 @@ class Report:\n         return 0\n \n     def __str__(self) -> str:\n-        \"\"\"A color report of the current state.\n+        \"\"\"Render a color report of the current state.\n \n         Use `click.unstyle` to remove colors.\n         \"\"\"\n@@ -1791,10 +1795,7 @@ class Report:\n \n \n def assert_equivalent(src: str, dst: str) -> None:\n-    \"\"\"Raises AssertionError if `src` and `dst` aren't equivalent.\n-\n-    This is a temporary sanity check until Black becomes stable.\n-    \"\"\"\n+    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n \n     import ast\n     import traceback\n@@ -1857,10 +1858,7 @@ def assert_equivalent(src: str, dst: str) -> None:\n \n \n def assert_stable(src: str, dst: str, line_length: int) -> None:\n-    \"\"\"Raises AssertionError if `dst` reformats differently the second time.\n-\n-    This is a temporary sanity check until Black becomes stable.\n-    \"\"\"\n+    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n     newdst = format_str(dst, line_length=line_length)\n     if dst != newdst:\n         log = dump_to_file(\n@@ -1876,7 +1874,7 @@ def assert_stable(src: str, dst: str, line_length: int) -> None:\n \n \n def dump_to_file(*output: str) -> str:\n-    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n+    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n     import tempfile\n \n     with tempfile.NamedTemporaryFile(\n@@ -1889,7 +1887,7 @@ def dump_to_file(*output: str) -> str:\n \n \n def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n-    \"\"\"Returns a udiff string between strings `a` and `b`.\"\"\"\n+    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n     import difflib\n \n     a_lines = [line + '\\n' for line in a.split('\\n')]\n",
          "files_name_in_blame_commit": [
            "black.py"
          ]
        }
      },
      "e74117f172e29e8a980e2c9de929ad50d376915": {
        "commit": {
          "commit_id": "e74117f172e29e8a980e2c9de929ad50d3769150",
          "commit_message": "Initial commit",
          "commit_author": "\u0141ukasz Langa",
          "commit_date": "2018-03-14 12:55:32",
          "commit_parent": ""
        },
        "function": {
          "function_name": "dump_to_file",
          "function_code_before": "",
          "function_code_after": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n    import tempfile\n    with tempfile.NamedTemporaryFile(mode='w', prefix='blk_', suffix='.log', delete=False) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 1453,
          "function_after_end_line": 1463,
          "function_before_token_count": 0,
          "function_after_token_count": 58,
          "functions_name_modified_file": [
            "format_str",
            "mark",
            "is_def",
            "visit_default",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "append",
            "left_hand_split",
            "delimiter_split",
            "visit_SEMI",
            "is_comment",
            "visit_decorators",
            "format_file",
            "visit_suite",
            "visit_async_stmt",
            "any_open_brackets",
            "max_priority",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "visit_simple_stmt",
            "main",
            "append_comment",
            "visit_stmt",
            "is_decorator",
            "visit",
            "lib2to3_unparse",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "is_yield",
            "failed",
            "whitespace",
            "_maybe_empty_lines",
            "__bool__",
            "assert_equivalent",
            "__str__",
            "split_line",
            "done",
            "generate_comments",
            "maybe_empty_lines",
            "assert_stable",
            "lib2to3_parse",
            "normalize_prefix",
            "is_class",
            "is_flow_control",
            "return_code",
            "maybe_adapt_standalone_comment",
            "line",
            "maybe_remove_trailing_comma",
            "dump_to_file"
          ],
          "functions_name_all_files": [
            "untokenize",
            "convert",
            "generate_grammar",
            "test_setup",
            "delimiter_split",
            "get_long_description",
            "load",
            "format_file",
            "expect",
            "max_priority",
            "read_data",
            "test_comments",
            "append_comment",
            "visit_stmt",
            "parse_string",
            "test_cantfit",
            "test_import_spacing",
            "match_seq",
            "__new__",
            "raise_error",
            "coroutine",
            "failed",
            "is_yield",
            "ISEOF",
            "pop",
            "post_order",
            "__init__",
            "append_child",
            "setup",
            "is_flow_control",
            "return_code",
            "dump_to_stderr",
            "gettoken",
            "maybe_adapt_standalone_comment",
            "load_grammar",
            "maybe_remove_trailing_comma",
            "dump_to_file",
            "detect_encoding",
            "test_self",
            "is_def",
            "diff",
            "match",
            "right_hand_split",
            "parse_graminit_c",
            "push",
            "parse_atom",
            "is_comment",
            "finish_off",
            "shift",
            "optimize",
            "visit_suite",
            "insert_child",
            "generate_tokens",
            "test",
            "main",
            "report",
            "run",
            "test_composition",
            "visit",
            "lib2to3_unparse",
            "_eq",
            "make_label",
            "calcfirst",
            "add_whitespace",
            "__bool__",
            "__str__",
            "split_line",
            "_submatch",
            "dump_nfa",
            "test_function",
            "classify",
            "get_lineno",
            "simplify_dfa",
            "type_repr",
            "_recursive_matches",
            "visit_default",
            "load_packaged_grammar",
            "get_version",
            "is_import",
            "func_no_args",
            "append",
            "test_expression",
            "visit_SEMI",
            "assertFormatEqual",
            "visit_decorators",
            "visit_async_stmt",
            "test_black",
            "any_open_brackets",
            "parse_stream",
            "function",
            "next_sibling",
            "inline_comments_in_brackets_ruin_everything",
            "make_dfa",
            "visit_simple_stmt",
            "make_first",
            "parse_item",
            "tokenize",
            "is_decorator",
            "get_suffix",
            "escape",
            "_bare_name_matches",
            "loads",
            "test_report",
            "last_non_delimiter",
            "preceding_leaf",
            "_make_deterministic",
            "__unicode__",
            "visit_ENDMARKER",
            "_maybe_empty_lines",
            "assert_equivalent",
            "parse_file",
            "parse_tokens",
            "_get_normal_name",
            "__eq__",
            "dump",
            "unifystate",
            "depth",
            "__repr__",
            "maybe_empty_lines",
            "generate_matches",
            "printtoken",
            "assert_stable",
            "addarc",
            "f",
            "copy",
            "normalize_prefix",
            "evalString",
            "ISTERMINAL",
            "prev_sibling",
            "format_str",
            "mark",
            "is_delimiter",
            "parse_stream_raw",
            "gen",
            "pre_order",
            "make_grammar",
            "leaves",
            "parse_alt",
            "_generate_pickle_name",
            "remove",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "compat",
            "addfirstsets",
            "_iterative_matches",
            "addtoken",
            "dump_dfa",
            "parse_graminit_h",
            "function_signature_stress_test",
            "tokenize_loop",
            "gen_python_files_in_dir",
            "parse_rhs",
            "_newer",
            "clone",
            "whitespace",
            "replace",
            "test_comments2",
            "done",
            "changed",
            "generate_comments",
            "prefix",
            "parse",
            "long_lines",
            "set_child",
            "lib2to3_parse",
            "is_class",
            "wat",
            "left_hand_split",
            "line",
            "maybe",
            "ISNONTERMINAL"
          ],
          "functions_name_co_evolved_modified_file": [
            "format_str",
            "mark",
            "is_def",
            "visit_default",
            "is_delimiter",
            "diff",
            "is_import",
            "right_hand_split",
            "append",
            "left_hand_split",
            "delimiter_split",
            "visit_SEMI",
            "is_comment",
            "visit_decorators",
            "format_file",
            "visit_suite",
            "visit_async_stmt",
            "any_open_brackets",
            "max_priority",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "visit_simple_stmt",
            "main",
            "append_comment",
            "visit_stmt",
            "is_decorator",
            "visit",
            "lib2to3_unparse",
            "last_non_delimiter",
            "gen_python_files_in_dir",
            "preceding_leaf",
            "visit_ENDMARKER",
            "failed",
            "is_yield",
            "whitespace",
            "_maybe_empty_lines",
            "__bool__",
            "assert_equivalent",
            "__str__",
            "split_line",
            "done",
            "generate_comments",
            "maybe_empty_lines",
            "assert_stable",
            "lib2to3_parse",
            "normalize_prefix",
            "is_flow_control",
            "is_class",
            "return_code",
            "maybe_adapt_standalone_comment",
            "line",
            "maybe_remove_trailing_comma"
          ],
          "functions_name_co_evolved_all_files": [
            "untokenize",
            "convert",
            "generate_grammar",
            "test_setup",
            "delimiter_split",
            "get_long_description",
            "load",
            "format_file",
            "expect",
            "max_priority",
            "read_data",
            "test_comments",
            "append_comment",
            "visit_stmt",
            "parse_string",
            "test_cantfit",
            "test_import_spacing",
            "match_seq",
            "__new__",
            "raise_error",
            "coroutine",
            "failed",
            "is_yield",
            "ISEOF",
            "pop",
            "post_order",
            "__init__",
            "append_child",
            "setup",
            "is_flow_control",
            "return_code",
            "dump_to_stderr",
            "gettoken",
            "maybe_adapt_standalone_comment",
            "load_grammar",
            "maybe_remove_trailing_comma",
            "detect_encoding",
            "test_self",
            "is_def",
            "diff",
            "match",
            "right_hand_split",
            "parse_graminit_c",
            "push",
            "parse_atom",
            "is_comment",
            "finish_off",
            "shift",
            "optimize",
            "visit_suite",
            "insert_child",
            "generate_tokens",
            "test",
            "main",
            "report",
            "run",
            "test_composition",
            "visit",
            "lib2to3_unparse",
            "_eq",
            "make_label",
            "calcfirst",
            "add_whitespace",
            "__bool__",
            "__str__",
            "split_line",
            "_submatch",
            "dump_nfa",
            "test_function",
            "classify",
            "get_lineno",
            "simplify_dfa",
            "type_repr",
            "_recursive_matches",
            "visit_default",
            "load_packaged_grammar",
            "get_version",
            "is_import",
            "func_no_args",
            "append",
            "test_expression",
            "visit_SEMI",
            "assertFormatEqual",
            "visit_decorators",
            "visit_async_stmt",
            "test_black",
            "any_open_brackets",
            "parse_stream",
            "function",
            "next_sibling",
            "inline_comments_in_brackets_ruin_everything",
            "make_dfa",
            "visit_simple_stmt",
            "make_first",
            "parse_item",
            "tokenize",
            "is_decorator",
            "get_suffix",
            "escape",
            "_bare_name_matches",
            "loads",
            "test_report",
            "last_non_delimiter",
            "preceding_leaf",
            "_make_deterministic",
            "__unicode__",
            "visit_ENDMARKER",
            "_maybe_empty_lines",
            "assert_equivalent",
            "parse_file",
            "parse_tokens",
            "_get_normal_name",
            "__eq__",
            "dump",
            "unifystate",
            "depth",
            "__repr__",
            "maybe_empty_lines",
            "generate_matches",
            "printtoken",
            "assert_stable",
            "addarc",
            "f",
            "copy",
            "normalize_prefix",
            "evalString",
            "ISTERMINAL",
            "prev_sibling",
            "format_str",
            "mark",
            "is_delimiter",
            "parse_stream_raw",
            "gen",
            "pre_order",
            "make_grammar",
            "leaves",
            "parse_alt",
            "_generate_pickle_name",
            "remove",
            "format_file_in_place",
            "__attrs_post_init__",
            "schedule_formatting",
            "compat",
            "addfirstsets",
            "_iterative_matches",
            "addtoken",
            "dump_dfa",
            "parse_graminit_h",
            "function_signature_stress_test",
            "tokenize_loop",
            "gen_python_files_in_dir",
            "parse_rhs",
            "_newer",
            "clone",
            "whitespace",
            "replace",
            "test_comments2",
            "done",
            "changed",
            "generate_comments",
            "prefix",
            "parse",
            "long_lines",
            "set_child",
            "lib2to3_parse",
            "is_class",
            "wat",
            "left_hand_split",
            "line",
            "maybe",
            "ISNONTERMINAL"
          ]
        },
        "file": {
          "file_name": "black.py",
          "file_nloc": 1198,
          "file_complexity": 392,
          "file_token_count": 7233,
          "file_before": null,
          "file_after": "#!/usr/bin/env python3\nimport asyncio\nfrom asyncio.base_events import BaseEventLoop\nfrom concurrent.futures import Executor, ProcessPoolExecutor\nfrom functools import partial\nimport keyword\nimport os\nfrom pathlib import Path\nimport tokenize\nfrom typing import (\n    Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, TypeVar, Union\n)\n\nfrom attr import attrib, dataclass, Factory\nimport click\n\n# lib2to3 fork\nfrom blib2to3.pytree import Node, Leaf, type_repr\nfrom blib2to3 import pygram, pytree\nfrom blib2to3.pgen2 import driver, token\nfrom blib2to3.pgen2.parse import ParseError\n\n__version__ = \"18.3a0\"\nDEFAULT_LINE_LENGTH = 88\n# types\nsyms = pygram.python_symbols\nFileContent = str\nEncoding = str\nDepth = int\nNodeType = int\nLeafID = int\nPriority = int\nLN = Union[Leaf, Node]\nout = partial(click.secho, bold=True, err=True)\nerr = partial(click.secho, fg='red', err=True)\n\n\nclass NothingChanged(UserWarning):\n    \"\"\"Raised by `format_file` when the reformatted code is the same as source.\"\"\"\n\n\nclass CannotSplit(Exception):\n    \"\"\"A readable split that fits the allotted line length is impossible.\n\n    Raised by `left_hand_split()` and `right_hand_split()`.\n    \"\"\"\n\n\n@click.command()\n@click.option(\n    '-l',\n    '--line-length',\n    type=int,\n    default=DEFAULT_LINE_LENGTH,\n    help='How many character per line to allow.',\n    show_default=True,\n)\n@click.option(\n    '--fast/--safe',\n    is_flag=True,\n    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n)\n@click.version_option(version=__version__)\n@click.argument(\n    'src',\n    nargs=-1,\n    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True),\n)\n@click.pass_context\ndef main(ctx: click.Context, line_length: int, fast: bool, src: List[str]) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        else:\n            err(f'invalid path: {s}')\n    if len(sources) == 0:\n        ctx.exit(0)\n    elif len(sources) == 1:\n        p = sources[0]\n        report = Report()\n        try:\n            changed = format_file_in_place(p, line_length=line_length, fast=fast)\n            report.done(p, changed)\n        except Exception as exc:\n            report.failed(p, str(exc))\n        ctx.exit(report.return_code)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        return_code = 1\n        try:\n            return_code = loop.run_until_complete(\n                schedule_formatting(sources, line_length, fast, loop, executor)\n            )\n        finally:\n            loop.close()\n            ctx.exit(return_code)\n\n\nasync def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    fast: bool,\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> int:\n    tasks = {\n        src: loop.run_in_executor(\n            executor, format_file_in_place, src, line_length, fast\n        )\n        for src in sources\n    }\n    await asyncio.wait(tasks.values())\n    cancelled = []\n    report = Report()\n    for src, task in tasks.items():\n        if not task.done():\n            report.failed(src, 'timed out, cancelling')\n            task.cancel()\n            cancelled.append(task)\n        elif task.exception():\n            report.failed(src, str(task.exception()))\n        else:\n            report.done(src, task.result())\n    if cancelled:\n        await asyncio.wait(cancelled, timeout=2)\n    out('All done! \u2728 \ud83c\udf70 \u2728')\n    click.echo(str(report))\n    return report.return_code\n\n\ndef format_file_in_place(src: Path, line_length: int, fast: bool) -> bool:\n    \"\"\"Format the file and rewrite if changed. Return True if changed.\"\"\"\n    try:\n        contents, encoding = format_file(src, line_length=line_length, fast=fast)\n    except NothingChanged:\n        return False\n\n    with open(src, \"w\", encoding=encoding) as f:\n        f.write(contents)\n    return True\n\n\ndef format_file(\n    src: Path, line_length: int, fast: bool\n) -> Tuple[FileContent, Encoding]:\n    \"\"\"Reformats a file and returns its contents and encoding.\"\"\"\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    if src_contents.strip() == '':\n        raise NothingChanged(src)\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged(src)\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents, src_buffer.encoding\n\n\ndef format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformats a string and returns new contents.\"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    comments: List[Line] = []\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        if not current_line.is_comment:\n            for comment in comments:\n                dst_contents += str(comment)\n            comments = []\n            for line in split_line(current_line, line_length=line_length):\n                dst_contents += str(line)\n        else:\n            comments.append(current_line)\n    for comment in comments:\n        dst_contents += str(comment)\n    return dst_contents\n\n\ndef lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    drv = driver.Driver(grammar, pytree.convert)\n    if src_txt[-1] != '\\n':\n        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n        src_txt += nl\n    try:\n        result = drv.parse_string(src_txt, True)\n    except ParseError as pe:\n        lineno, column = pe.context[1]\n        lines = src_txt.splitlines()\n        try:\n            faulty_line = lines[lineno - 1]\n        except IndexError:\n            faulty_line = \"<line number missing in source>\"\n        raise ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\") from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result\n\n\ndef lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code\n\n\nT = TypeVar('T')\n\n\nclass Visitor(Generic[T]):\n    \"\"\"Basic lib2to3 visitor that yields things on visiting.\"\"\"\n\n    def visit(self, node: LN) -> Iterator[T]:\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n\n@dataclass\nclass DebugVisitor(Visitor[T]):\n    tree_depth: int = attrib(default=0)\n\n    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = ' ' * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f'{indent}{_type}', fg='yellow')\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f'{indent}/{_type}', fg='yellow', bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f'{indent}{_type}', fg='blue', nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n            out(f' {node.value!r}', fg='blue', bold=False)\n\n\nKEYWORDS = set(keyword.kwlist)\nWHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\nFLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\nSTATEMENT = {\n    syms.if_stmt,\n    syms.while_stmt,\n    syms.for_stmt,\n    syms.try_stmt,\n    syms.except_clause,\n    syms.with_stmt,\n    syms.funcdef,\n    syms.classdef,\n}\nSTANDALONE_COMMENT = 153\nLOGIC_OPERATORS = {'and', 'or'}\nCOMPARATORS = {\n    token.LESS,\n    token.GREATER,\n    token.EQEQUAL,\n    token.NOTEQUAL,\n    token.LESSEQUAL,\n    token.GREATEREQUAL,\n}\nMATH_OPERATORS = {\n    token.PLUS,\n    token.MINUS,\n    token.STAR,\n    token.SLASH,\n    token.VBAR,\n    token.AMPER,\n    token.PERCENT,\n    token.CIRCUMFLEX,\n    token.LEFTSHIFT,\n    token.RIGHTSHIFT,\n    token.DOUBLESTAR,\n    token.DOUBLESLASH,\n}\nCOMPREHENSION_PRIORITY = 20\nCOMMA_PRIORITY = 10\nLOGIC_PRIORITY = 5\nSTRING_PRIORITY = 4\nCOMPARATOR_PRIORITY = 3\nMATH_PRIORITY = 1\n\n\n@dataclass\nclass BracketTracker:\n    depth: int = attrib(default=0)\n    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = attrib(default=Factory(dict))\n    delimiters: Dict[LeafID, Priority] = attrib(default=Factory(dict))\n    previous: Optional[Leaf] = attrib(default=None)\n\n    def mark(self, leaf: Leaf) -> None:\n        if leaf.type == token.COMMENT:\n            return\n\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket  # type: ignore\n        leaf.bracket_depth = self.depth  # type: ignore\n        if self.depth == 0:\n            delim = is_delimiter(leaf)\n            if delim:\n                self.delimiters[id(leaf)] = delim\n            elif self.previous is not None:\n                if leaf.type == token.STRING and self.previous.type == token.STRING:\n                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n                elif (\n                    leaf.type == token.NAME and\n                    leaf.value == 'for' and\n                    leaf.parent and\n                    leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n                elif (\n                    leaf.type == token.NAME and\n                    leaf.value == 'if' and\n                    leaf.parent and\n                    leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n                ):\n                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n\n    def any_open_brackets(self) -> bool:\n        \"\"\"Returns True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)\n\n    def max_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Returns the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_delimiter()` returns.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)\n\n\n@dataclass\nclass Line:\n    depth: int = attrib(default=0)\n    leaves: List[Leaf] = attrib(default=Factory(list))\n    comments: Dict[LeafID, Leaf] = attrib(default=Factory(dict))\n    bracket_tracker: BracketTracker = attrib(default=Factory(BracketTracker))\n    inside_brackets: bool = attrib(default=False)\n\n    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        has_value = leaf.value.strip()\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n            if self.maybe_adapt_standalone_comment(leaf):\n                return\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)\n\n    @property\n    def is_comment(self) -> bool:\n        return bool(self) and self.leaves[0].type == STANDALONE_COMMENT\n\n    @property\n    def is_decorator(self) -> bool:\n        return bool(self) and self.leaves[0].type == token.AT\n\n    @property\n    def is_import(self) -> bool:\n        return bool(self) and is_import(self.leaves[0])\n\n    @property\n    def is_class(self) -> bool:\n        return (\n            bool(self) and\n            self.leaves[0].type == token.NAME and\n            self.leaves[0].value == 'class'\n        )\n\n    @property\n    def is_def(self) -> bool:\n        \"\"\"Also returns True for async defs.\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == 'def') or\n            (\n                first_leaf.type == token.NAME and\n                first_leaf.value == 'async' and\n                second_leaf is not None and\n                second_leaf.type == token.NAME and\n                second_leaf.value == 'def'\n            )\n        )\n\n    @property\n    def is_flow_control(self) -> bool:\n        return (\n            bool(self) and\n            self.leaves[0].type == token.NAME and\n            self.leaves[0].value in FLOW_CONTROL\n        )\n\n    @property\n    def is_yield(self) -> bool:\n        return (\n            bool(self) and\n            self.leaves[0].type == token.NAME and\n            self.leaves[0].value == 'yield'\n        )\n\n    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        if not (\n            self.leaves and\n            self.leaves[-1].type == token.COMMA and\n            closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RSQB or closing.type == token.RBRACE:\n            self.leaves.pop()\n            return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1  # type: ignore\n        commas = 0\n        opening = closing.opening_bracket  # type: ignore\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth  # type: ignore\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n        if commas > 1:\n            self.leaves.pop()\n            return True\n\n        return False\n\n    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n        \"\"\"Hack a standalone comment to act as a trailing comment for line splitting.\n\n        If this line has brackets and a standalone `comment`, we need to adapt\n        it to be able to still reformat the line.\n\n        This is not perfect, the line to which the standalone comment gets\n        appended will appear \"too long\" when splitting.\n        \"\"\"\n        if not (\n            comment.type == STANDALONE_COMMENT and\n            self.bracket_tracker.any_open_brackets()\n        ):\n            return False\n\n        comment.type = token.COMMENT\n        comment.prefix = '\\n' + '    ' * (self.depth + 1)\n        return self.append_comment(comment)\n\n    def append_comment(self, comment: Leaf) -> bool:\n        if comment.type != token.COMMENT:\n            return False\n\n        try:\n            after = id(self.last_non_delimiter())\n        except LookupError:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = ''\n            return False\n\n        else:\n            if after in self.comments:\n                self.comments[after].value += str(comment)\n            else:\n                self.comments[after] = comment\n            return True\n\n    def last_non_delimiter(self) -> Leaf:\n        for i in range(len(self.leaves)):\n            last = self.leaves[-i - 1]\n            if not is_delimiter(last):\n                return last\n\n        raise LookupError(\"No non-delimiters found\")\n\n    def __str__(self) -> str:\n        if not self:\n            return '\\n'\n\n        indent = '    ' * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f'{first.prefix}{indent}{first.value}'\n        for leaf in leaves:\n            res += str(leaf)\n        for comment in self.comments.values():\n            res += str(comment)\n        return res + '\\n'\n\n    def __bool__(self) -> bool:\n        return bool(self.leaves or self.comments)\n\n\n@dataclass\nclass EmptyLineTracker:\n    \"\"\"Provides a stateful method that returns the number of potential extra\n    empty lines needed before and after the currently processed line.\n\n    Note: this tracker works on lines that haven't been split yet.\n    \"\"\"\n    previous_line: Optional[Line] = attrib(default=None)\n    previous_after: int = attrib(default=0)\n    previous_defs: List[int] = attrib(default=Factory(list))\n\n    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Returns the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty lines\n        (two on module-level), as well as providing an extra empty line after flow\n        control keywords to make them more prominent.\n        \"\"\"\n        before, after = self._maybe_empty_lines(current_line)\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after\n\n    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = (1 if depth else 2) - self.previous_after\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            newlines -= self.previous_after\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line and\n            self.previous_line.is_import and\n            not current_line.is_import and\n            depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line and\n            self.previous_line.is_yield and\n            (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0\n\n\n@dataclass\nclass LineGenerator(Visitor[Line]):\n    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n\n    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n    in ways that will no longer stringify to valid Python code on the tree.\n    \"\"\"\n    current_line: Line = attrib(default=Factory(Line))\n    standalone_comments: List[Leaf] = attrib(default=Factory(list))\n\n    def line(self, indent: int = 0) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            self.current_line.depth += indent\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = Line(depth=complete_line.depth + indent)\n        yield complete_line\n\n    def visit_default(self, node: LN) -> Iterator[Line]:\n        if isinstance(node, Leaf):\n            for comment in generate_comments(node):\n                if self.current_line.bracket_tracker.any_open_brackets():\n                    # any comment within brackets is subject to splitting\n                    self.current_line.append(comment)\n                elif comment.type == token.COMMENT:\n                    # regular trailing comment\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n                else:\n                    # regular standalone comment, to be processed later (see\n                    # docstring in `generate_comments()`\n                    self.standalone_comments.append(comment)\n            normalize_prefix(node)\n            if node.type not in WHITESPACE:\n                for comment in self.standalone_comments:\n                    yield from self.line()\n\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n                self.standalone_comments = []\n                self.current_line.append(node)\n        yield from super().visit_default(node)\n\n    def visit_suite(self, node: Node) -> Iterator[Line]:\n        \"\"\"Body of a statement after a colon.\"\"\"\n        children = iter(node.children)\n        # Process newline before indenting.  It might contain an inline\n        # comment that should go right after the colon.\n        newline = next(children)\n        yield from self.visit(newline)\n        yield from self.line(+1)\n\n        for child in children:\n            yield from self.visit(child)\n\n        yield from self.line(-1)\n\n    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        The relevant Python language keywords for this statement are NAME leaves\n        within it.\n        \"\"\"\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)\n\n    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"A statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)\n\n    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.NAME and child.value == 'async':  # type: ignore\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)\n\n    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)\n\n    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        yield from self.line()\n\n    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        yield from self.visit_default(leaf)\n        yield from self.line()\n\n    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n        self.visit_except_clause = partial(v, keywords={'except'})\n        self.visit_funcdef = partial(v, keywords={'def'})\n        self.visit_with_stmt = partial(v, keywords={'with'})\n        self.visit_classdef = partial(v, keywords={'class'})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators\n\n\nBRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\nOPENING_BRACKETS = set(BRACKET.keys())\nCLOSING_BRACKETS = set(BRACKET.values())\nBRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\n\n\ndef whitespace(leaf: Leaf) -> str:\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = ''\n    SPACE = ' '\n    DOUBLESPACE = '  '\n    t = leaf.type\n    p = leaf.parent\n    if t == token.COLON:\n        return NO\n\n    if t == token.COMMA:\n        return NO\n\n    if t == token.RPAR:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    if t == STANDALONE_COMMENT:\n        return NO\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if t == token.RPAR:\n            return NO\n\n        prev = leaf.prev_sibling\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    if p.type == syms.varargslist:\n        # lambdas\n        if t == token.RPAR:\n            return NO\n\n        prev = leaf.prev_sibling\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        prev = leaf.prev_sibling\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        prev = leaf.prev_sibling\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        prev = leaf.prev_sibling\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        prev = leaf.prev_sibling\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        prev = leaf.prev_sibling\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        prev = leaf.prev_sibling\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if t == token.COLON:\n            return NO\n\n        prev = leaf.prev_sibling\n        if not prev or prev.type == token.COLON:\n            return NO\n\n    elif p.type in {\n        syms.test,\n        syms.not_test,\n        syms.xor_expr,\n        syms.or_test,\n        syms.and_test,\n        syms.arith_expr,\n        syms.shift_expr,\n        syms.yield_expr,\n        syms.term,\n        syms.power,\n        syms.comparison,\n    }:\n        # various arithmetic and logic expressions\n        prev = leaf.prev_sibling\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            if prevp.type == token.EQUAL:\n                if prevp.parent and prevp.parent.type in {\n                    syms.varargslist, syms.parameters, syms.arglist, syms.argument\n                }:\n                    return NO\n\n        return SPACE\n\n    elif p.type == syms.atom:\n        if t in CLOSING_BRACKETS:\n            return NO\n\n        prev = leaf.prev_sibling\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp:\n                return NO\n\n            if prevp.type in OPENING_BRACKETS:\n                return NO\n\n            if prevp.type == token.EQUAL:\n                if prevp.parent and prevp.parent.type in {\n                    syms.varargslist, syms.parameters, syms.arglist, syms.argument\n                }:\n                    return NO\n\n            if prevp.type == token.DOUBLESTAR:\n                if prevp.parent and prevp.parent.type in {\n                    syms.varargslist, syms.parameters, syms.arglist, syms.dictsetmaker\n                }:\n                    return NO\n\n        elif prev.type in OPENING_BRACKETS:\n            return NO\n\n        elif t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif (\n        p.type == syms.listmaker or\n        p.type == syms.testlist_gexp or\n        p.type == syms.subscriptlist\n    ):\n        # list interior, including unpacking\n        prev = leaf.prev_sibling\n        if not prev:\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict and set interior, including unpacking\n        prev = leaf.prev_sibling\n        if not prev:\n            return NO\n\n        if prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type == syms.factor or p.type == syms.star_expr:\n        # unary ops\n        prev = leaf.prev_sibling\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript, syms.sliceop\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from and t == token.NAME:\n        prev = leaf.prev_sibling\n        if prev and prev.type == token.DOT:\n            return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE\n\n\ndef preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Returns the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None\n\n\ndef is_delimiter(leaf: Leaf) -> int:\n    \"\"\"Returns the priority of the `leaf` delimiter. Returns 0 if not delimiter.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    if leaf.type == token.NAME and leaf.value in LOGIC_OPERATORS:\n        return LOGIC_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS and\n        leaf.parent and\n        leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    return 0\n\n\ndef generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Cleans the prefix of the `leaf` and generates comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    if not leaf.prefix:\n        return\n\n    if '#' not in leaf.prefix:\n        return\n\n    before_comment, content = leaf.prefix.split('#', 1)\n    content = content.rstrip()\n    if content and (content[0] not in {' ', '!', '#'}):\n        content = ' ' + content\n    is_standalone_comment = (\n        '\\n' in before_comment or '\\n' in content or leaf.type == token.DEDENT\n    )\n    if not is_standalone_comment:\n        # simple trailing comment\n        yield Leaf(token.COMMENT, value='#' + content)\n        return\n\n    for line in ('#' + content).split('\\n'):\n        line = line.lstrip()\n        if not line.startswith('#'):\n            continue\n\n        yield Leaf(STANDALONE_COMMENT, line)\n\n\ndef split_line(line: Line, line_length: int, inner: bool = False) -> Iterator[Line]:\n    \"\"\"Splits a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n    \"\"\"\n    line_str = str(line).strip('\\n')\n    if len(line_str) <= line_length and '\\n' not in line_str:\n        yield line\n        return\n\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split]\n        if '\\n' not in line_str:\n            # Only attempt RHS if we don't have multiline strings or comments\n            # on this line.\n            split_funcs.append(right_hand_split)\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line):\n                if str(l).strip('\\n') == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(split_line(l, line_length=line_length, inner=True))\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line\n\n\ndef left_hand_split(line: Line) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves and\n            leaf.type in CLOSING_BRACKETS and\n            leaf.opening_bracket is matching_bracket  # type: ignore\n        ):\n            current_leaves = tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0])\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    # Check if the split succeeded.\n    tail_len = len(str(tail))\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef right_hand_split(line: Line) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS:\n                opening_bracket = leaf.opening_bracket  # type: ignore\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0])\n    # Build the new lines.\n    for result, leaves in (\n        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n    ):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            comment_after = line.comments.get(id(leaf))\n            if comment_after:\n                result.append(comment_after, preformatted=True)\n    # Check if the split succeeded.\n    tail_len = len(str(tail).strip('\\n'))\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )\n\n    for result in (head, body, tail):\n        if result:\n            yield result\n\n\ndef delimiter_split(line: Line) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    This kind of split doesn't increase indentation.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_priority(exclude={id(last_leaf)})\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    for leaf in line.leaves:\n        current_line.append(leaf, preformatted=True)\n        comment_after = line.comments.get(id(leaf))\n        if comment_after:\n            current_line.append(comment_after, preformatted=True)\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            normalize_prefix(current_line.leaves[0])\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            delimiter_priority == COMMA_PRIORITY and\n            current_line.leaves[-1].type != token.COMMA\n        ):\n            current_line.append(Leaf(token.COMMA, ','))\n        normalize_prefix(current_line.leaves[0])\n        yield current_line\n\n\ndef is_import(leaf: Leaf) -> bool:\n    \"\"\"Returns True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME and\n        (\n            (v == 'import' and p and p.type == syms.import_name) or\n            (v == 'from' and p and p.type == syms.import_from)\n        )\n    )\n\n\ndef normalize_prefix(leaf: Leaf) -> None:\n    \"\"\"Leave existing extra newlines for imports.  Remove everything else.\"\"\"\n    if is_import(leaf):\n        spl = leaf.prefix.split('#', 1)\n        nl_count = spl[0].count('\\n')\n        if len(spl) > 1:\n            # Skip one newline since it was for a standalone comment.\n            nl_count -= 1\n        leaf.prefix = '\\n' * nl_count\n        return\n\n    leaf.prefix = ''\n\n\nPYTHON_EXTENSIONS = {'.py'}\nBLACKLISTED_DIRECTORIES = {\n    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n}\n\n\ndef gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child\n\n\n@dataclass\nclass Report:\n    \"\"\"Provides a reformatting counter.\"\"\"\n    change_count: int = attrib(default=0)\n    same_count: int = attrib(default=0)\n    failure_count: int = attrib(default=0)\n\n    def done(self, src: Path, changed: bool) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed:\n            out(f'reformatted {src}')\n            self.change_count += 1\n        else:\n            out(f'{src} already well formatted, good job.', bold=False)\n            self.same_count += 1\n\n    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f'error: cannot format {src}: {message}')\n        self.failure_count += 1\n\n    @property\n    def return_code(self) -> int:\n        \"\"\"Which return code should the app use considering the current state.\"\"\"\n        return 1 if self.failure_count else 0\n\n    def __str__(self) -> str:\n        \"\"\"A color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        report = []\n        if self.change_count:\n            s = 's' if self.change_count > 1 else ''\n            report.append(\n                click.style(f'{self.change_count} file{s} reformatted', bold=True)\n            )\n        if self.same_count:\n            s = 's' if self.same_count > 1 else ''\n            report.append(f'{self.same_count} file{s} left unchanged')\n        if self.failure_count:\n            s = 's' if self.failure_count > 1 else ''\n            report.append(\n                click.style(\n                    f'{self.failure_count} file{s} failed to reformat', fg='red'\n                )\n            )\n        return ', '.join(report) + '.'\n\n\ndef assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raises AssertionError if `src` and `dst` aren't equivalent.\n\n    This is a temporary sanity check until Black becomes stable.\n    \"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        raise AssertionError(f\"cannot parse source: {exc}\") from None\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\",\n        ) from None\n\n    src_ast_str = '\\n'.join(_v(src_ast))\n    dst_ast_str = '\\n'.join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\",\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raises AssertionError if `dst` reformats differently the second time.\n\n    This is a temporary sanity check until Black becomes stable.\n    \"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, 'source', 'first pass'),\n            diff(dst, newdst, 'first pass', 'second pass'),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\",\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode='w', prefix='blk_', suffix='.log', delete=False\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            f.write('\\n')\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Returns a udiff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + '\\n' for line in a.split('\\n')]\n    b_lines = [line + '\\n' for line in b.split('\\n')]\n    return ''.join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_patch": "@@ -0,0 +1,1478 @@\n+#!/usr/bin/env python3\n+import asyncio\n+from asyncio.base_events import BaseEventLoop\n+from concurrent.futures import Executor, ProcessPoolExecutor\n+from functools import partial\n+import keyword\n+import os\n+from pathlib import Path\n+import tokenize\n+from typing import (\n+    Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, TypeVar, Union\n+)\n+\n+from attr import attrib, dataclass, Factory\n+import click\n+\n+# lib2to3 fork\n+from blib2to3.pytree import Node, Leaf, type_repr\n+from blib2to3 import pygram, pytree\n+from blib2to3.pgen2 import driver, token\n+from blib2to3.pgen2.parse import ParseError\n+\n+__version__ = \"18.3a0\"\n+DEFAULT_LINE_LENGTH = 88\n+# types\n+syms = pygram.python_symbols\n+FileContent = str\n+Encoding = str\n+Depth = int\n+NodeType = int\n+LeafID = int\n+Priority = int\n+LN = Union[Leaf, Node]\n+out = partial(click.secho, bold=True, err=True)\n+err = partial(click.secho, fg='red', err=True)\n+\n+\n+class NothingChanged(UserWarning):\n+    \"\"\"Raised by `format_file` when the reformatted code is the same as source.\"\"\"\n+\n+\n+class CannotSplit(Exception):\n+    \"\"\"A readable split that fits the allotted line length is impossible.\n+\n+    Raised by `left_hand_split()` and `right_hand_split()`.\n+    \"\"\"\n+\n+\n+@click.command()\n+@click.option(\n+    '-l',\n+    '--line-length',\n+    type=int,\n+    default=DEFAULT_LINE_LENGTH,\n+    help='How many character per line to allow.',\n+    show_default=True,\n+)\n+@click.option(\n+    '--fast/--safe',\n+    is_flag=True,\n+    help='If --fast given, skip temporary sanity checks. [default: --safe]',\n+)\n+@click.version_option(version=__version__)\n+@click.argument(\n+    'src',\n+    nargs=-1,\n+    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True),\n+)\n+@click.pass_context\n+def main(ctx: click.Context, line_length: int, fast: bool, src: List[str]) -> None:\n+    \"\"\"The uncompromising code formatter.\"\"\"\n+    sources: List[Path] = []\n+    for s in src:\n+        p = Path(s)\n+        if p.is_dir():\n+            sources.extend(gen_python_files_in_dir(p))\n+        elif p.is_file():\n+            # if a file was explicitly given, we don't care about its extension\n+            sources.append(p)\n+        else:\n+            err(f'invalid path: {s}')\n+    if len(sources) == 0:\n+        ctx.exit(0)\n+    elif len(sources) == 1:\n+        p = sources[0]\n+        report = Report()\n+        try:\n+            changed = format_file_in_place(p, line_length=line_length, fast=fast)\n+            report.done(p, changed)\n+        except Exception as exc:\n+            report.failed(p, str(exc))\n+        ctx.exit(report.return_code)\n+    else:\n+        loop = asyncio.get_event_loop()\n+        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n+        return_code = 1\n+        try:\n+            return_code = loop.run_until_complete(\n+                schedule_formatting(sources, line_length, fast, loop, executor)\n+            )\n+        finally:\n+            loop.close()\n+            ctx.exit(return_code)\n+\n+\n+async def schedule_formatting(\n+    sources: List[Path],\n+    line_length: int,\n+    fast: bool,\n+    loop: BaseEventLoop,\n+    executor: Executor,\n+) -> int:\n+    tasks = {\n+        src: loop.run_in_executor(\n+            executor, format_file_in_place, src, line_length, fast\n+        )\n+        for src in sources\n+    }\n+    await asyncio.wait(tasks.values())\n+    cancelled = []\n+    report = Report()\n+    for src, task in tasks.items():\n+        if not task.done():\n+            report.failed(src, 'timed out, cancelling')\n+            task.cancel()\n+            cancelled.append(task)\n+        elif task.exception():\n+            report.failed(src, str(task.exception()))\n+        else:\n+            report.done(src, task.result())\n+    if cancelled:\n+        await asyncio.wait(cancelled, timeout=2)\n+    out('All done! \u2728 \ud83c\udf70 \u2728')\n+    click.echo(str(report))\n+    return report.return_code\n+\n+\n+def format_file_in_place(src: Path, line_length: int, fast: bool) -> bool:\n+    \"\"\"Format the file and rewrite if changed. Return True if changed.\"\"\"\n+    try:\n+        contents, encoding = format_file(src, line_length=line_length, fast=fast)\n+    except NothingChanged:\n+        return False\n+\n+    with open(src, \"w\", encoding=encoding) as f:\n+        f.write(contents)\n+    return True\n+\n+\n+def format_file(\n+    src: Path, line_length: int, fast: bool\n+) -> Tuple[FileContent, Encoding]:\n+    \"\"\"Reformats a file and returns its contents and encoding.\"\"\"\n+    with tokenize.open(src) as src_buffer:\n+        src_contents = src_buffer.read()\n+    if src_contents.strip() == '':\n+        raise NothingChanged(src)\n+\n+    dst_contents = format_str(src_contents, line_length=line_length)\n+    if src_contents == dst_contents:\n+        raise NothingChanged(src)\n+\n+    if not fast:\n+        assert_equivalent(src_contents, dst_contents)\n+        assert_stable(src_contents, dst_contents, line_length=line_length)\n+    return dst_contents, src_buffer.encoding\n+\n+\n+def format_str(src_contents: str, line_length: int) -> FileContent:\n+    \"\"\"Reformats a string and returns new contents.\"\"\"\n+    src_node = lib2to3_parse(src_contents)\n+    dst_contents = \"\"\n+    comments: List[Line] = []\n+    lines = LineGenerator()\n+    elt = EmptyLineTracker()\n+    empty_line = Line()\n+    after = 0\n+    for current_line in lines.visit(src_node):\n+        for _ in range(after):\n+            dst_contents += str(empty_line)\n+        before, after = elt.maybe_empty_lines(current_line)\n+        for _ in range(before):\n+            dst_contents += str(empty_line)\n+        if not current_line.is_comment:\n+            for comment in comments:\n+                dst_contents += str(comment)\n+            comments = []\n+            for line in split_line(current_line, line_length=line_length):\n+                dst_contents += str(line)\n+        else:\n+            comments.append(current_line)\n+    for comment in comments:\n+        dst_contents += str(comment)\n+    return dst_contents\n+\n+\n+def lib2to3_parse(src_txt: str) -> Node:\n+    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n+    grammar = pygram.python_grammar_no_print_statement\n+    drv = driver.Driver(grammar, pytree.convert)\n+    if src_txt[-1] != '\\n':\n+        nl = '\\r\\n' if '\\r\\n' in src_txt[:1024] else '\\n'\n+        src_txt += nl\n+    try:\n+        result = drv.parse_string(src_txt, True)\n+    except ParseError as pe:\n+        lineno, column = pe.context[1]\n+        lines = src_txt.splitlines()\n+        try:\n+            faulty_line = lines[lineno - 1]\n+        except IndexError:\n+            faulty_line = \"<line number missing in source>\"\n+        raise ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\") from None\n+\n+    if isinstance(result, Leaf):\n+        result = Node(syms.file_input, [result])\n+    return result\n+\n+\n+def lib2to3_unparse(node: Node) -> str:\n+    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n+    code = str(node)\n+    return code\n+\n+\n+T = TypeVar('T')\n+\n+\n+class Visitor(Generic[T]):\n+    \"\"\"Basic lib2to3 visitor that yields things on visiting.\"\"\"\n+\n+    def visit(self, node: LN) -> Iterator[T]:\n+        if node.type < 256:\n+            name = token.tok_name[node.type]\n+        else:\n+            name = type_repr(node.type)\n+        yield from getattr(self, f'visit_{name}', self.visit_default)(node)\n+\n+    def visit_default(self, node: LN) -> Iterator[T]:\n+        if isinstance(node, Node):\n+            for child in node.children:\n+                yield from self.visit(child)\n+\n+\n+@dataclass\n+class DebugVisitor(Visitor[T]):\n+    tree_depth: int = attrib(default=0)\n+\n+    def visit_default(self, node: LN) -> Iterator[T]:\n+        indent = ' ' * (2 * self.tree_depth)\n+        if isinstance(node, Node):\n+            _type = type_repr(node.type)\n+            out(f'{indent}{_type}', fg='yellow')\n+            self.tree_depth += 1\n+            for child in node.children:\n+                yield from self.visit(child)\n+\n+            self.tree_depth -= 1\n+            out(f'{indent}/{_type}', fg='yellow', bold=False)\n+        else:\n+            _type = token.tok_name.get(node.type, str(node.type))\n+            out(f'{indent}{_type}', fg='blue', nl=False)\n+            if node.prefix:\n+                # We don't have to handle prefixes for `Node` objects since\n+                # that delegates to the first child anyway.\n+                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)\n+            out(f' {node.value!r}', fg='blue', bold=False)\n+\n+\n+KEYWORDS = set(keyword.kwlist)\n+WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}\n+FLOW_CONTROL = {'return', 'raise', 'break', 'continue'}\n+STATEMENT = {\n+    syms.if_stmt,\n+    syms.while_stmt,\n+    syms.for_stmt,\n+    syms.try_stmt,\n+    syms.except_clause,\n+    syms.with_stmt,\n+    syms.funcdef,\n+    syms.classdef,\n+}\n+STANDALONE_COMMENT = 153\n+LOGIC_OPERATORS = {'and', 'or'}\n+COMPARATORS = {\n+    token.LESS,\n+    token.GREATER,\n+    token.EQEQUAL,\n+    token.NOTEQUAL,\n+    token.LESSEQUAL,\n+    token.GREATEREQUAL,\n+}\n+MATH_OPERATORS = {\n+    token.PLUS,\n+    token.MINUS,\n+    token.STAR,\n+    token.SLASH,\n+    token.VBAR,\n+    token.AMPER,\n+    token.PERCENT,\n+    token.CIRCUMFLEX,\n+    token.LEFTSHIFT,\n+    token.RIGHTSHIFT,\n+    token.DOUBLESTAR,\n+    token.DOUBLESLASH,\n+}\n+COMPREHENSION_PRIORITY = 20\n+COMMA_PRIORITY = 10\n+LOGIC_PRIORITY = 5\n+STRING_PRIORITY = 4\n+COMPARATOR_PRIORITY = 3\n+MATH_PRIORITY = 1\n+\n+\n+@dataclass\n+class BracketTracker:\n+    depth: int = attrib(default=0)\n+    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = attrib(default=Factory(dict))\n+    delimiters: Dict[LeafID, Priority] = attrib(default=Factory(dict))\n+    previous: Optional[Leaf] = attrib(default=None)\n+\n+    def mark(self, leaf: Leaf) -> None:\n+        if leaf.type == token.COMMENT:\n+            return\n+\n+        if leaf.type in CLOSING_BRACKETS:\n+            self.depth -= 1\n+            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n+            leaf.opening_bracket = opening_bracket  # type: ignore\n+        leaf.bracket_depth = self.depth  # type: ignore\n+        if self.depth == 0:\n+            delim = is_delimiter(leaf)\n+            if delim:\n+                self.delimiters[id(leaf)] = delim\n+            elif self.previous is not None:\n+                if leaf.type == token.STRING and self.previous.type == token.STRING:\n+                    self.delimiters[id(self.previous)] = STRING_PRIORITY\n+                elif (\n+                    leaf.type == token.NAME and\n+                    leaf.value == 'for' and\n+                    leaf.parent and\n+                    leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n+                ):\n+                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n+                elif (\n+                    leaf.type == token.NAME and\n+                    leaf.value == 'if' and\n+                    leaf.parent and\n+                    leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n+                ):\n+                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY\n+        if leaf.type in OPENING_BRACKETS:\n+            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n+            self.depth += 1\n+        self.previous = leaf\n+\n+    def any_open_brackets(self) -> bool:\n+        \"\"\"Returns True if there is an yet unmatched open bracket on the line.\"\"\"\n+        return bool(self.bracket_match)\n+\n+    def max_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n+        \"\"\"Returns the highest priority of a delimiter found on the line.\n+\n+        Values are consistent with what `is_delimiter()` returns.\n+        \"\"\"\n+        return max(v for k, v in self.delimiters.items() if k not in exclude)\n+\n+\n+@dataclass\n+class Line:\n+    depth: int = attrib(default=0)\n+    leaves: List[Leaf] = attrib(default=Factory(list))\n+    comments: Dict[LeafID, Leaf] = attrib(default=Factory(dict))\n+    bracket_tracker: BracketTracker = attrib(default=Factory(BracketTracker))\n+    inside_brackets: bool = attrib(default=False)\n+\n+    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n+        has_value = leaf.value.strip()\n+        if not has_value:\n+            return\n+\n+        if self.leaves and not preformatted:\n+            # Note: at this point leaf.prefix should be empty except for\n+            # imports, for which we only preserve newlines.\n+            leaf.prefix += whitespace(leaf)\n+        if self.inside_brackets or not preformatted:\n+            self.bracket_tracker.mark(leaf)\n+            self.maybe_remove_trailing_comma(leaf)\n+            if self.maybe_adapt_standalone_comment(leaf):\n+                return\n+\n+        if not self.append_comment(leaf):\n+            self.leaves.append(leaf)\n+\n+    @property\n+    def is_comment(self) -> bool:\n+        return bool(self) and self.leaves[0].type == STANDALONE_COMMENT\n+\n+    @property\n+    def is_decorator(self) -> bool:\n+        return bool(self) and self.leaves[0].type == token.AT\n+\n+    @property\n+    def is_import(self) -> bool:\n+        return bool(self) and is_import(self.leaves[0])\n+\n+    @property\n+    def is_class(self) -> bool:\n+        return (\n+            bool(self) and\n+            self.leaves[0].type == token.NAME and\n+            self.leaves[0].value == 'class'\n+        )\n+\n+    @property\n+    def is_def(self) -> bool:\n+        \"\"\"Also returns True for async defs.\"\"\"\n+        try:\n+            first_leaf = self.leaves[0]\n+        except IndexError:\n+            return False\n+\n+        try:\n+            second_leaf: Optional[Leaf] = self.leaves[1]\n+        except IndexError:\n+            second_leaf = None\n+        return (\n+            (first_leaf.type == token.NAME and first_leaf.value == 'def') or\n+            (\n+                first_leaf.type == token.NAME and\n+                first_leaf.value == 'async' and\n+                second_leaf is not None and\n+                second_leaf.type == token.NAME and\n+                second_leaf.value == 'def'\n+            )\n+        )\n+\n+    @property\n+    def is_flow_control(self) -> bool:\n+        return (\n+            bool(self) and\n+            self.leaves[0].type == token.NAME and\n+            self.leaves[0].value in FLOW_CONTROL\n+        )\n+\n+    @property\n+    def is_yield(self) -> bool:\n+        return (\n+            bool(self) and\n+            self.leaves[0].type == token.NAME and\n+            self.leaves[0].value == 'yield'\n+        )\n+\n+    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n+        if not (\n+            self.leaves and\n+            self.leaves[-1].type == token.COMMA and\n+            closing.type in CLOSING_BRACKETS\n+        ):\n+            return False\n+\n+        if closing.type == token.RSQB or closing.type == token.RBRACE:\n+            self.leaves.pop()\n+            return True\n+\n+        # For parens let's check if it's safe to remove the comma.  If the\n+        # trailing one is the only one, we might mistakenly change a tuple\n+        # into a different type by removing the comma.\n+        depth = closing.bracket_depth + 1  # type: ignore\n+        commas = 0\n+        opening = closing.opening_bracket  # type: ignore\n+        for _opening_index, leaf in enumerate(self.leaves):\n+            if leaf is opening:\n+                break\n+\n+        else:\n+            return False\n+\n+        for leaf in self.leaves[_opening_index + 1:]:\n+            if leaf is closing:\n+                break\n+\n+            bracket_depth = leaf.bracket_depth  # type: ignore\n+            if bracket_depth == depth and leaf.type == token.COMMA:\n+                commas += 1\n+        if commas > 1:\n+            self.leaves.pop()\n+            return True\n+\n+        return False\n+\n+    def maybe_adapt_standalone_comment(self, comment: Leaf) -> bool:\n+        \"\"\"Hack a standalone comment to act as a trailing comment for line splitting.\n+\n+        If this line has brackets and a standalone `comment`, we need to adapt\n+        it to be able to still reformat the line.\n+\n+        This is not perfect, the line to which the standalone comment gets\n+        appended will appear \"too long\" when splitting.\n+        \"\"\"\n+        if not (\n+            comment.type == STANDALONE_COMMENT and\n+            self.bracket_tracker.any_open_brackets()\n+        ):\n+            return False\n+\n+        comment.type = token.COMMENT\n+        comment.prefix = '\\n' + '    ' * (self.depth + 1)\n+        return self.append_comment(comment)\n+\n+    def append_comment(self, comment: Leaf) -> bool:\n+        if comment.type != token.COMMENT:\n+            return False\n+\n+        try:\n+            after = id(self.last_non_delimiter())\n+        except LookupError:\n+            comment.type = STANDALONE_COMMENT\n+            comment.prefix = ''\n+            return False\n+\n+        else:\n+            if after in self.comments:\n+                self.comments[after].value += str(comment)\n+            else:\n+                self.comments[after] = comment\n+            return True\n+\n+    def last_non_delimiter(self) -> Leaf:\n+        for i in range(len(self.leaves)):\n+            last = self.leaves[-i - 1]\n+            if not is_delimiter(last):\n+                return last\n+\n+        raise LookupError(\"No non-delimiters found\")\n+\n+    def __str__(self) -> str:\n+        if not self:\n+            return '\\n'\n+\n+        indent = '    ' * self.depth\n+        leaves = iter(self.leaves)\n+        first = next(leaves)\n+        res = f'{first.prefix}{indent}{first.value}'\n+        for leaf in leaves:\n+            res += str(leaf)\n+        for comment in self.comments.values():\n+            res += str(comment)\n+        return res + '\\n'\n+\n+    def __bool__(self) -> bool:\n+        return bool(self.leaves or self.comments)\n+\n+\n+@dataclass\n+class EmptyLineTracker:\n+    \"\"\"Provides a stateful method that returns the number of potential extra\n+    empty lines needed before and after the currently processed line.\n+\n+    Note: this tracker works on lines that haven't been split yet.\n+    \"\"\"\n+    previous_line: Optional[Line] = attrib(default=None)\n+    previous_after: int = attrib(default=0)\n+    previous_defs: List[int] = attrib(default=Factory(list))\n+\n+    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n+        \"\"\"Returns the number of extra empty lines before and after the `current_line`.\n+\n+        This is for separating `def`, `async def` and `class` with extra empty lines\n+        (two on module-level), as well as providing an extra empty line after flow\n+        control keywords to make them more prominent.\n+        \"\"\"\n+        before, after = self._maybe_empty_lines(current_line)\n+        self.previous_after = after\n+        self.previous_line = current_line\n+        return before, after\n+\n+    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n+        before = 0\n+        depth = current_line.depth\n+        while self.previous_defs and self.previous_defs[-1] >= depth:\n+            self.previous_defs.pop()\n+            before = (1 if depth else 2) - self.previous_after\n+        is_decorator = current_line.is_decorator\n+        if is_decorator or current_line.is_def or current_line.is_class:\n+            if not is_decorator:\n+                self.previous_defs.append(depth)\n+            if self.previous_line is None:\n+                # Don't insert empty lines before the first line in the file.\n+                return 0, 0\n+\n+            if self.previous_line and self.previous_line.is_decorator:\n+                # Don't insert empty lines between decorators.\n+                return 0, 0\n+\n+            newlines = 2\n+            if current_line.depth:\n+                newlines -= 1\n+            newlines -= self.previous_after\n+            return newlines, 0\n+\n+        if current_line.is_flow_control:\n+            return before, 1\n+\n+        if (\n+            self.previous_line and\n+            self.previous_line.is_import and\n+            not current_line.is_import and\n+            depth == self.previous_line.depth\n+        ):\n+            return (before or 1), 0\n+\n+        if (\n+            self.previous_line and\n+            self.previous_line.is_yield and\n+            (not current_line.is_yield or depth != self.previous_line.depth)\n+        ):\n+            return (before or 1), 0\n+\n+        return before, 0\n+\n+\n+@dataclass\n+class LineGenerator(Visitor[Line]):\n+    \"\"\"Generates reformatted Line objects.  Empty lines are not emitted.\n+\n+    Note: destroys the tree it's visiting by mutating prefixes of its leaves\n+    in ways that will no longer stringify to valid Python code on the tree.\n+    \"\"\"\n+    current_line: Line = attrib(default=Factory(Line))\n+    standalone_comments: List[Leaf] = attrib(default=Factory(list))\n+\n+    def line(self, indent: int = 0) -> Iterator[Line]:\n+        \"\"\"Generate a line.\n+\n+        If the line is empty, only emit if it makes sense.\n+        If the line is too long, split it first and then generate.\n+\n+        If any lines were generated, set up a new current_line.\n+        \"\"\"\n+        if not self.current_line:\n+            self.current_line.depth += indent\n+            return  # Line is empty, don't emit. Creating a new one unnecessary.\n+\n+        complete_line = self.current_line\n+        self.current_line = Line(depth=complete_line.depth + indent)\n+        yield complete_line\n+\n+    def visit_default(self, node: LN) -> Iterator[Line]:\n+        if isinstance(node, Leaf):\n+            for comment in generate_comments(node):\n+                if self.current_line.bracket_tracker.any_open_brackets():\n+                    # any comment within brackets is subject to splitting\n+                    self.current_line.append(comment)\n+                elif comment.type == token.COMMENT:\n+                    # regular trailing comment\n+                    self.current_line.append(comment)\n+                    yield from self.line()\n+\n+                else:\n+                    # regular standalone comment, to be processed later (see\n+                    # docstring in `generate_comments()`\n+                    self.standalone_comments.append(comment)\n+            normalize_prefix(node)\n+            if node.type not in WHITESPACE:\n+                for comment in self.standalone_comments:\n+                    yield from self.line()\n+\n+                    self.current_line.append(comment)\n+                    yield from self.line()\n+\n+                self.standalone_comments = []\n+                self.current_line.append(node)\n+        yield from super().visit_default(node)\n+\n+    def visit_suite(self, node: Node) -> Iterator[Line]:\n+        \"\"\"Body of a statement after a colon.\"\"\"\n+        children = iter(node.children)\n+        # Process newline before indenting.  It might contain an inline\n+        # comment that should go right after the colon.\n+        newline = next(children)\n+        yield from self.visit(newline)\n+        yield from self.line(+1)\n+\n+        for child in children:\n+            yield from self.visit(child)\n+\n+        yield from self.line(-1)\n+\n+    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:\n+        \"\"\"Visit a statement.\n+\n+        The relevant Python language keywords for this statement are NAME leaves\n+        within it.\n+        \"\"\"\n+        for child in node.children:\n+            if child.type == token.NAME and child.value in keywords:  # type: ignore\n+                yield from self.line()\n+\n+            yield from self.visit(child)\n+\n+    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n+        \"\"\"A statement without nested statements.\"\"\"\n+        is_suite_like = node.parent and node.parent.type in STATEMENT\n+        if is_suite_like:\n+            yield from self.line(+1)\n+            yield from self.visit_default(node)\n+            yield from self.line(-1)\n+\n+        else:\n+            yield from self.line()\n+            yield from self.visit_default(node)\n+\n+    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n+        yield from self.line()\n+\n+        children = iter(node.children)\n+        for child in children:\n+            yield from self.visit(child)\n+\n+            if child.type == token.NAME and child.value == 'async':  # type: ignore\n+                break\n+\n+        internal_stmt = next(children)\n+        for child in internal_stmt.children:\n+            yield from self.visit(child)\n+\n+    def visit_decorators(self, node: Node) -> Iterator[Line]:\n+        for child in node.children:\n+            yield from self.line()\n+            yield from self.visit(child)\n+\n+    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n+        yield from self.line()\n+\n+    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n+        yield from self.visit_default(leaf)\n+        yield from self.line()\n+\n+    def __attrs_post_init__(self) -> None:\n+        \"\"\"You are in a twisty little maze of passages.\"\"\"\n+        v = self.visit_stmt\n+        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})\n+        self.visit_while_stmt = partial(v, keywords={'while', 'else'})\n+        self.visit_for_stmt = partial(v, keywords={'for', 'else'})\n+        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})\n+        self.visit_except_clause = partial(v, keywords={'except'})\n+        self.visit_funcdef = partial(v, keywords={'def'})\n+        self.visit_with_stmt = partial(v, keywords={'with'})\n+        self.visit_classdef = partial(v, keywords={'class'})\n+        self.visit_async_funcdef = self.visit_async_stmt\n+        self.visit_decorated = self.visit_decorators\n+\n+\n+BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}\n+OPENING_BRACKETS = set(BRACKET.keys())\n+CLOSING_BRACKETS = set(BRACKET.values())\n+BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS\n+\n+\n+def whitespace(leaf: Leaf) -> str:\n+    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n+    NO = ''\n+    SPACE = ' '\n+    DOUBLESPACE = '  '\n+    t = leaf.type\n+    p = leaf.parent\n+    if t == token.COLON:\n+        return NO\n+\n+    if t == token.COMMA:\n+        return NO\n+\n+    if t == token.RPAR:\n+        return NO\n+\n+    if t == token.COMMENT:\n+        return DOUBLESPACE\n+\n+    if t == STANDALONE_COMMENT:\n+        return NO\n+\n+    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n+    if p.type in {syms.parameters, syms.arglist}:\n+        # untyped function signatures or calls\n+        if t == token.RPAR:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if not prev or prev.type != token.COMMA:\n+            return NO\n+\n+    if p.type == syms.varargslist:\n+        # lambdas\n+        if t == token.RPAR:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if prev and prev.type != token.COMMA:\n+            return NO\n+\n+    elif p.type == syms.typedargslist:\n+        # typed function signatures\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            return NO\n+\n+        if t == token.EQUAL:\n+            if prev.type != syms.tname:\n+                return NO\n+\n+        elif prev.type == token.EQUAL:\n+            # A bit hacky: if the equal sign has whitespace, it means we\n+            # previously found it's a typed argument.  So, we're using that, too.\n+            return prev.prefix\n+\n+        elif prev.type != token.COMMA:\n+            return NO\n+\n+    elif p.type == syms.tname:\n+        # type names\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            prevp = preceding_leaf(p)\n+            if not prevp or prevp.type != token.COMMA:\n+                return NO\n+\n+    elif p.type == syms.trailer:\n+        # attributes and calls\n+        if t == token.LPAR or t == token.RPAR:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            if t == token.DOT:\n+                prevp = preceding_leaf(p)\n+                if not prevp or prevp.type != token.NUMBER:\n+                    return NO\n+\n+            elif t == token.LSQB:\n+                return NO\n+\n+        elif prev.type != token.COMMA:\n+            return NO\n+\n+    elif p.type == syms.argument:\n+        # single argument\n+        if t == token.EQUAL:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            prevp = preceding_leaf(p)\n+            if not prevp or prevp.type == token.LPAR:\n+                return NO\n+\n+        elif prev.type == token.EQUAL or prev.type == token.DOUBLESTAR:\n+            return NO\n+\n+    elif p.type == syms.decorator:\n+        # decorators\n+        return NO\n+\n+    elif p.type == syms.dotted_name:\n+        prev = leaf.prev_sibling\n+        if prev:\n+            return NO\n+\n+        prevp = preceding_leaf(p)\n+        if not prevp or prevp.type == token.AT:\n+            return NO\n+\n+    elif p.type == syms.classdef:\n+        if t == token.LPAR:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if prev and prev.type == token.LPAR:\n+            return NO\n+\n+    elif p.type == syms.subscript:\n+        # indexing\n+        if t == token.COLON:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if not prev or prev.type == token.COLON:\n+            return NO\n+\n+    elif p.type in {\n+        syms.test,\n+        syms.not_test,\n+        syms.xor_expr,\n+        syms.or_test,\n+        syms.and_test,\n+        syms.arith_expr,\n+        syms.shift_expr,\n+        syms.yield_expr,\n+        syms.term,\n+        syms.power,\n+        syms.comparison,\n+    }:\n+        # various arithmetic and logic expressions\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            prevp = preceding_leaf(p)\n+            if not prevp or prevp.type in OPENING_BRACKETS:\n+                return NO\n+\n+            if prevp.type == token.EQUAL:\n+                if prevp.parent and prevp.parent.type in {\n+                    syms.varargslist, syms.parameters, syms.arglist, syms.argument\n+                }:\n+                    return NO\n+\n+        return SPACE\n+\n+    elif p.type == syms.atom:\n+        if t in CLOSING_BRACKETS:\n+            return NO\n+\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            prevp = preceding_leaf(p)\n+            if not prevp:\n+                return NO\n+\n+            if prevp.type in OPENING_BRACKETS:\n+                return NO\n+\n+            if prevp.type == token.EQUAL:\n+                if prevp.parent and prevp.parent.type in {\n+                    syms.varargslist, syms.parameters, syms.arglist, syms.argument\n+                }:\n+                    return NO\n+\n+            if prevp.type == token.DOUBLESTAR:\n+                if prevp.parent and prevp.parent.type in {\n+                    syms.varargslist, syms.parameters, syms.arglist, syms.dictsetmaker\n+                }:\n+                    return NO\n+\n+        elif prev.type in OPENING_BRACKETS:\n+            return NO\n+\n+        elif t == token.DOT:\n+            # dots, but not the first one.\n+            return NO\n+\n+    elif (\n+        p.type == syms.listmaker or\n+        p.type == syms.testlist_gexp or\n+        p.type == syms.subscriptlist\n+    ):\n+        # list interior, including unpacking\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            return NO\n+\n+    elif p.type == syms.dictsetmaker:\n+        # dict and set interior, including unpacking\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            return NO\n+\n+        if prev.type == token.DOUBLESTAR:\n+            return NO\n+\n+    elif p.type == syms.factor or p.type == syms.star_expr:\n+        # unary ops\n+        prev = leaf.prev_sibling\n+        if not prev:\n+            prevp = preceding_leaf(p)\n+            if not prevp or prevp.type in OPENING_BRACKETS:\n+                return NO\n+\n+            prevp_parent = prevp.parent\n+            assert prevp_parent is not None\n+            if prevp.type == token.COLON and prevp_parent.type in {\n+                syms.subscript, syms.sliceop\n+            }:\n+                return NO\n+\n+            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n+                return NO\n+\n+        elif t == token.NAME or t == token.NUMBER:\n+            return NO\n+\n+    elif p.type == syms.import_from and t == token.NAME:\n+        prev = leaf.prev_sibling\n+        if prev and prev.type == token.DOT:\n+            return NO\n+\n+    elif p.type == syms.sliceop:\n+        return NO\n+\n+    return SPACE\n+\n+\n+def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n+    \"\"\"Returns the first leaf that precedes `node`, if any.\"\"\"\n+    while node:\n+        res = node.prev_sibling\n+        if res:\n+            if isinstance(res, Leaf):\n+                return res\n+\n+            try:\n+                return list(res.leaves())[-1]\n+\n+            except IndexError:\n+                return None\n+\n+        node = node.parent\n+    return None\n+\n+\n+def is_delimiter(leaf: Leaf) -> int:\n+    \"\"\"Returns the priority of the `leaf` delimiter. Returns 0 if not delimiter.\n+\n+    Higher numbers are higher priority.\n+    \"\"\"\n+    if leaf.type == token.COMMA:\n+        return COMMA_PRIORITY\n+\n+    if leaf.type == token.NAME and leaf.value in LOGIC_OPERATORS:\n+        return LOGIC_PRIORITY\n+\n+    if leaf.type in COMPARATORS:\n+        return COMPARATOR_PRIORITY\n+\n+    if (\n+        leaf.type in MATH_OPERATORS and\n+        leaf.parent and\n+        leaf.parent.type not in {syms.factor, syms.star_expr}\n+    ):\n+        return MATH_PRIORITY\n+\n+    return 0\n+\n+\n+def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n+    \"\"\"Cleans the prefix of the `leaf` and generates comments from it, if any.\n+\n+    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n+    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n+    move because it does away with modifying the grammar to include all the\n+    possible places in which comments can be placed.\n+\n+    The sad consequence for us though is that comments don't \"belong\" anywhere.\n+    This is why this function generates simple parentless Leaf objects for\n+    comments.  We simply don't know what the correct parent should be.\n+\n+    No matter though, we can live without this.  We really only need to\n+    differentiate between inline and standalone comments.  The latter don't\n+    share the line with any code.\n+\n+    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n+    are emitted with a fake STANDALONE_COMMENT token identifier.\n+    \"\"\"\n+    if not leaf.prefix:\n+        return\n+\n+    if '#' not in leaf.prefix:\n+        return\n+\n+    before_comment, content = leaf.prefix.split('#', 1)\n+    content = content.rstrip()\n+    if content and (content[0] not in {' ', '!', '#'}):\n+        content = ' ' + content\n+    is_standalone_comment = (\n+        '\\n' in before_comment or '\\n' in content or leaf.type == token.DEDENT\n+    )\n+    if not is_standalone_comment:\n+        # simple trailing comment\n+        yield Leaf(token.COMMENT, value='#' + content)\n+        return\n+\n+    for line in ('#' + content).split('\\n'):\n+        line = line.lstrip()\n+        if not line.startswith('#'):\n+            continue\n+\n+        yield Leaf(STANDALONE_COMMENT, line)\n+\n+\n+def split_line(line: Line, line_length: int, inner: bool = False) -> Iterator[Line]:\n+    \"\"\"Splits a `line` into potentially many lines.\n+\n+    They should fit in the allotted `line_length` but might not be able to.\n+    `inner` signifies that there were a pair of brackets somewhere around the\n+    current `line`, possibly transitively. This means we can fallback to splitting\n+    by delimiters if the LHS/RHS don't yield any results.\n+    \"\"\"\n+    line_str = str(line).strip('\\n')\n+    if len(line_str) <= line_length and '\\n' not in line_str:\n+        yield line\n+        return\n+\n+    if line.is_def:\n+        split_funcs = [left_hand_split]\n+    elif line.inside_brackets:\n+        split_funcs = [delimiter_split]\n+        if '\\n' not in line_str:\n+            # Only attempt RHS if we don't have multiline strings or comments\n+            # on this line.\n+            split_funcs.append(right_hand_split)\n+    else:\n+        split_funcs = [right_hand_split]\n+    for split_func in split_funcs:\n+        # We are accumulating lines in `result` because we might want to abort\n+        # mission and return the original line in the end, or attempt a different\n+        # split altogether.\n+        result: List[Line] = []\n+        try:\n+            for l in split_func(line):\n+                if str(l).strip('\\n') == line_str:\n+                    raise CannotSplit(\"Split function returned an unchanged result\")\n+\n+                result.extend(split_line(l, line_length=line_length, inner=True))\n+        except CannotSplit as cs:\n+            continue\n+\n+        else:\n+            yield from result\n+            break\n+\n+    else:\n+        yield line\n+\n+\n+def left_hand_split(line: Line) -> Iterator[Line]:\n+    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n+\n+    Note: this usually looks weird, only use this for function definitions.\n+    Prefer RHS otherwise.\n+    \"\"\"\n+    head = Line(depth=line.depth)\n+    body = Line(depth=line.depth + 1, inside_brackets=True)\n+    tail = Line(depth=line.depth)\n+    tail_leaves: List[Leaf] = []\n+    body_leaves: List[Leaf] = []\n+    head_leaves: List[Leaf] = []\n+    current_leaves = head_leaves\n+    matching_bracket = None\n+    for leaf in line.leaves:\n+        if (\n+            current_leaves is body_leaves and\n+            leaf.type in CLOSING_BRACKETS and\n+            leaf.opening_bracket is matching_bracket  # type: ignore\n+        ):\n+            current_leaves = tail_leaves\n+        current_leaves.append(leaf)\n+        if current_leaves is head_leaves:\n+            if leaf.type in OPENING_BRACKETS:\n+                matching_bracket = leaf\n+                current_leaves = body_leaves\n+    # Since body is a new indent level, remove spurious leading whitespace.\n+    if body_leaves:\n+        normalize_prefix(body_leaves[0])\n+    # Build the new lines.\n+    for result, leaves in (\n+        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n+    ):\n+        for leaf in leaves:\n+            result.append(leaf, preformatted=True)\n+            comment_after = line.comments.get(id(leaf))\n+            if comment_after:\n+                result.append(comment_after, preformatted=True)\n+    # Check if the split succeeded.\n+    tail_len = len(str(tail))\n+    if not body:\n+        if tail_len == 0:\n+            raise CannotSplit(\"Splitting brackets produced the same line\")\n+\n+        elif tail_len < 3:\n+            raise CannotSplit(\n+                f\"Splitting brackets on an empty body to save \"\n+                f\"{tail_len} characters is not worth it\"\n+            )\n+\n+    for result in (head, body, tail):\n+        if result:\n+            yield result\n+\n+\n+def right_hand_split(line: Line) -> Iterator[Line]:\n+    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n+    head = Line(depth=line.depth)\n+    body = Line(depth=line.depth + 1, inside_brackets=True)\n+    tail = Line(depth=line.depth)\n+    tail_leaves: List[Leaf] = []\n+    body_leaves: List[Leaf] = []\n+    head_leaves: List[Leaf] = []\n+    current_leaves = tail_leaves\n+    opening_bracket = None\n+    for leaf in reversed(line.leaves):\n+        if current_leaves is body_leaves:\n+            if leaf is opening_bracket:\n+                current_leaves = head_leaves\n+        current_leaves.append(leaf)\n+        if current_leaves is tail_leaves:\n+            if leaf.type in CLOSING_BRACKETS:\n+                opening_bracket = leaf.opening_bracket  # type: ignore\n+                current_leaves = body_leaves\n+    tail_leaves.reverse()\n+    body_leaves.reverse()\n+    head_leaves.reverse()\n+    # Since body is a new indent level, remove spurious leading whitespace.\n+    if body_leaves:\n+        normalize_prefix(body_leaves[0])\n+    # Build the new lines.\n+    for result, leaves in (\n+        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)\n+    ):\n+        for leaf in leaves:\n+            result.append(leaf, preformatted=True)\n+            comment_after = line.comments.get(id(leaf))\n+            if comment_after:\n+                result.append(comment_after, preformatted=True)\n+    # Check if the split succeeded.\n+    tail_len = len(str(tail).strip('\\n'))\n+    if not body:\n+        if tail_len == 0:\n+            raise CannotSplit(\"Splitting brackets produced the same line\")\n+\n+        elif tail_len < 3:\n+            raise CannotSplit(\n+                f\"Splitting brackets on an empty body to save \"\n+                f\"{tail_len} characters is not worth it\"\n+            )\n+\n+    for result in (head, body, tail):\n+        if result:\n+            yield result\n+\n+\n+def delimiter_split(line: Line) -> Iterator[Line]:\n+    \"\"\"Split according to delimiters of the highest priority.\n+\n+    This kind of split doesn't increase indentation.\n+    \"\"\"\n+    try:\n+        last_leaf = line.leaves[-1]\n+    except IndexError:\n+        raise CannotSplit(\"Line empty\")\n+\n+    delimiters = line.bracket_tracker.delimiters\n+    try:\n+        delimiter_priority = line.bracket_tracker.max_priority(exclude={id(last_leaf)})\n+    except ValueError:\n+        raise CannotSplit(\"No delimiters found\")\n+\n+    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n+    for leaf in line.leaves:\n+        current_line.append(leaf, preformatted=True)\n+        comment_after = line.comments.get(id(leaf))\n+        if comment_after:\n+            current_line.append(comment_after, preformatted=True)\n+        leaf_priority = delimiters.get(id(leaf))\n+        if leaf_priority == delimiter_priority:\n+            normalize_prefix(current_line.leaves[0])\n+            yield current_line\n+\n+            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n+    if current_line:\n+        if (\n+            delimiter_priority == COMMA_PRIORITY and\n+            current_line.leaves[-1].type != token.COMMA\n+        ):\n+            current_line.append(Leaf(token.COMMA, ','))\n+        normalize_prefix(current_line.leaves[0])\n+        yield current_line\n+\n+\n+def is_import(leaf: Leaf) -> bool:\n+    \"\"\"Returns True if the given leaf starts an import statement.\"\"\"\n+    p = leaf.parent\n+    t = leaf.type\n+    v = leaf.value\n+    return bool(\n+        t == token.NAME and\n+        (\n+            (v == 'import' and p and p.type == syms.import_name) or\n+            (v == 'from' and p and p.type == syms.import_from)\n+        )\n+    )\n+\n+\n+def normalize_prefix(leaf: Leaf) -> None:\n+    \"\"\"Leave existing extra newlines for imports.  Remove everything else.\"\"\"\n+    if is_import(leaf):\n+        spl = leaf.prefix.split('#', 1)\n+        nl_count = spl[0].count('\\n')\n+        if len(spl) > 1:\n+            # Skip one newline since it was for a standalone comment.\n+            nl_count -= 1\n+        leaf.prefix = '\\n' * nl_count\n+        return\n+\n+    leaf.prefix = ''\n+\n+\n+PYTHON_EXTENSIONS = {'.py'}\n+BLACKLISTED_DIRECTORIES = {\n+    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'\n+}\n+\n+\n+def gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n+    for child in path.iterdir():\n+        if child.is_dir():\n+            if child.name in BLACKLISTED_DIRECTORIES:\n+                continue\n+\n+            yield from gen_python_files_in_dir(child)\n+\n+        elif child.suffix in PYTHON_EXTENSIONS:\n+            yield child\n+\n+\n+@dataclass\n+class Report:\n+    \"\"\"Provides a reformatting counter.\"\"\"\n+    change_count: int = attrib(default=0)\n+    same_count: int = attrib(default=0)\n+    failure_count: int = attrib(default=0)\n+\n+    def done(self, src: Path, changed: bool) -> None:\n+        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n+        if changed:\n+            out(f'reformatted {src}')\n+            self.change_count += 1\n+        else:\n+            out(f'{src} already well formatted, good job.', bold=False)\n+            self.same_count += 1\n+\n+    def failed(self, src: Path, message: str) -> None:\n+        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n+        err(f'error: cannot format {src}: {message}')\n+        self.failure_count += 1\n+\n+    @property\n+    def return_code(self) -> int:\n+        \"\"\"Which return code should the app use considering the current state.\"\"\"\n+        return 1 if self.failure_count else 0\n+\n+    def __str__(self) -> str:\n+        \"\"\"A color report of the current state.\n+\n+        Use `click.unstyle` to remove colors.\n+        \"\"\"\n+        report = []\n+        if self.change_count:\n+            s = 's' if self.change_count > 1 else ''\n+            report.append(\n+                click.style(f'{self.change_count} file{s} reformatted', bold=True)\n+            )\n+        if self.same_count:\n+            s = 's' if self.same_count > 1 else ''\n+            report.append(f'{self.same_count} file{s} left unchanged')\n+        if self.failure_count:\n+            s = 's' if self.failure_count > 1 else ''\n+            report.append(\n+                click.style(\n+                    f'{self.failure_count} file{s} failed to reformat', fg='red'\n+                )\n+            )\n+        return ', '.join(report) + '.'\n+\n+\n+def assert_equivalent(src: str, dst: str) -> None:\n+    \"\"\"Raises AssertionError if `src` and `dst` aren't equivalent.\n+\n+    This is a temporary sanity check until Black becomes stable.\n+    \"\"\"\n+\n+    import ast\n+    import traceback\n+\n+    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n+        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n+        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n+\n+        for field in sorted(node._fields):\n+            try:\n+                value = getattr(node, field)\n+            except AttributeError:\n+                continue\n+\n+            yield f\"{'  ' * (depth+1)}{field}=\"\n+\n+            if isinstance(value, list):\n+                for item in value:\n+                    if isinstance(item, ast.AST):\n+                        yield from _v(item, depth + 2)\n+\n+            elif isinstance(value, ast.AST):\n+                yield from _v(value, depth + 2)\n+\n+            else:\n+                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n+\n+        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n+\n+    try:\n+        src_ast = ast.parse(src)\n+    except Exception as exc:\n+        raise AssertionError(f\"cannot parse source: {exc}\") from None\n+\n+    try:\n+        dst_ast = ast.parse(dst)\n+    except Exception as exc:\n+        log = dump_to_file(''.join(traceback.format_tb(exc.__traceback__)), dst)\n+        raise AssertionError(\n+            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n+            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n+            f\"This invalid output might be helpful: {log}\",\n+        ) from None\n+\n+    src_ast_str = '\\n'.join(_v(src_ast))\n+    dst_ast_str = '\\n'.join(_v(dst_ast))\n+    if src_ast_str != dst_ast_str:\n+        log = dump_to_file(diff(src_ast_str, dst_ast_str, 'src', 'dst'))\n+        raise AssertionError(\n+            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n+            f\"the source.  \"\n+            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n+            f\"This diff might be helpful: {log}\",\n+        ) from None\n+\n+\n+def assert_stable(src: str, dst: str, line_length: int) -> None:\n+    \"\"\"Raises AssertionError if `dst` reformats differently the second time.\n+\n+    This is a temporary sanity check until Black becomes stable.\n+    \"\"\"\n+    newdst = format_str(dst, line_length=line_length)\n+    if dst != newdst:\n+        log = dump_to_file(\n+            diff(src, dst, 'source', 'first pass'),\n+            diff(dst, newdst, 'first pass', 'second pass'),\n+        )\n+        raise AssertionError(\n+            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n+            f\"of the formatter.  \"\n+            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n+            f\"This diff might be helpful: {log}\",\n+        ) from None\n+\n+\n+def dump_to_file(*output: str) -> str:\n+    \"\"\"Dumps `output` to a temporary file. Returns path to the file.\"\"\"\n+    import tempfile\n+\n+    with tempfile.NamedTemporaryFile(\n+        mode='w', prefix='blk_', suffix='.log', delete=False\n+    ) as f:\n+        for lines in output:\n+            f.write(lines)\n+            f.write('\\n')\n+    return f.name\n+\n+\n+def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n+    \"\"\"Returns a udiff string between strings `a` and `b`.\"\"\"\n+    import difflib\n+\n+    a_lines = [line + '\\n' for line in a.split('\\n')]\n+    b_lines = [line + '\\n' for line in b.split('\\n')]\n+    return ''.join(\n+        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n+    )\n+\n+\n+if __name__ == '__main__':\n+    main()\n",
          "files_name_in_blame_commit": [
            "pygram.pyi",
            "grammar.pyi",
            "literals.pyi",
            "comments2.py",
            "token.pyi",
            "grammar.py",
            "test_black.py",
            "tokenize.pyi",
            "__init__.py",
            "pytree.pyi",
            "composition.py",
            "expression.py",
            "pgen.pyi",
            "__init__.pyi",
            "setup.py",
            "function.py",
            "token.py",
            "tokenize.py",
            "driver.pyi",
            "pgen.py",
            "cantfit.py",
            "import_spacing.py",
            "conv.py",
            "driver.py",
            "literals.py",
            "pytree.py",
            "pygram.py",
            "parse.pyi",
            "black.py",
            "parse.py",
            "comments.py"
          ]
        }
      }
    }
  }
}
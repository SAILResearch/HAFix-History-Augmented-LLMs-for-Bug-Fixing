{
  "id": "24",
  "blame_commit": {
    "commit": {
      "commit_id": "2c99cbc8746735381eec6e4ee3f5ae8b9e7d7971",
      "commit_message": "eos_eapi: adding the desired state config to the new vrf fixes #32111 (#32112)\n\n* adding the desired state config to the new vrf fixes #32111\r\n\r\n* fix default vrf initial configured\r\n\r\n* add unit test",
      "commit_author": "Dave Thelen",
      "commit_date": "2017-11-01 22:18:52",
      "commit_parent": "4faf4ff2151cc417d8b29584393eb146be8a71c5"
    },
    "function": {
      "function_name": "map_obj_to_commands",
      "function_code_before": "def map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    (want, have) = updates\n    needs_update = lambda x: want.get(x) is not None and want.get(x) != have.get(x)\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        elif have['http'] is False and want['http'] in (False, None):\n            warnings.append('protocol http is not enabled, not configuring http port value')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        elif have['https'] is False and want['https'] in (False, None):\n            warnings.append('protocol https is not enabled, not configuring https port value')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        elif have['local_http'] is False and want['local_http'] in (False, None):\n            warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    return commands",
      "function_code_after": "def map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    (want, have) = updates\n    needs_update = lambda x: want.get(x) is not None and want.get(x) != have.get(x)\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        elif have['http'] is False and want['http'] in (False, None):\n            warnings.append('protocol http is not enabled, not configuring http port value')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        elif have['https'] is False and want['https'] in (False, None):\n            warnings.append('protocol https is not enabled, not configuring https port value')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        elif have['local_http'] is False and want['local_http'] in (False, None):\n            warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n    if needs_update('state') and (not needs_update('vrf')):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    return commands",
      "function_before_start_line": 216,
      "function_before_end_line": 273,
      "function_after_start_line": 216,
      "function_after_end_line": 279,
      "function_before_token_count": 345,
      "function_after_token_count": 375,
      "functions_name_modified_file": [
        "map_config_to_obj",
        "validate_local_http_port",
        "verify_state",
        "validate_http_port",
        "collect_facts",
        "parse_state",
        "map_params_to_obj",
        "main",
        "validate_https_port",
        "validate_vrf",
        "check_transport",
        "map_obj_to_commands"
      ],
      "functions_name_all_files": [
        "map_config_to_obj",
        "test_eos_eapi_http_port",
        "tearDown",
        "test_eos_eapi_state_absent",
        "test_eos_eapi_state_failed",
        "start_configured",
        "test_eos_eapi_http_disable",
        "test_eos_eapi_change_from_default_vrf",
        "validate_local_http_port",
        "verify_state",
        "test_eos_eapi_https_enable",
        "main",
        "load_fixtures",
        "test_eos_eapi_local_http_enable",
        "test_eos_eapi_vrf_missing",
        "map_obj_to_commands",
        "test_eos_eapi_http_invalid",
        "validate_http_port",
        "test_eos_eapi_local_http_disable",
        "validate_https_port",
        "validate_vrf",
        "check_transport",
        "setUp",
        "collect_facts",
        "start_unconfigured",
        "test_eos_eapi_local_http_port",
        "test_eos_eapi_https_disable",
        "parse_state",
        "map_params_to_obj",
        "test_eos_eapi_https_port",
        "test_eos_eapi_http_enable",
        "test_eos_eapi_vrf"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_eos_eapi_change_from_default_vrf"
      ]
    },
    "file": {
      "file_name": "eos_eapi.py",
      "file_nloc": 347,
      "file_complexity": 65,
      "file_token_count": 1511,
      "file_before": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\nextends_documentation_fragment: eos\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always\n  type: list\n  sample:\n    - management api http-commands\n    - protocol http port 81\n    - no protocol https\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\nsession_name:\n  description: The EOS config session name used to load the configuration\n  returned: when changed is True\n  type: str\n  sample: ansible_1479315771\n\"\"\"\nimport re\nimport time\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.eos import run_commands, load_config\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.eos import eos_argument_spec, check_args\n\ndef check_transport(module):\n    transport = module.params['transport']\n    provider_transport = (module.params['provider'] or {}).get('transport')\n\n    if 'eapi' in (transport, provider_transport):\n        module.fail_json(msg='eos_eapi module is only supported over cli transport')\n\ndef validate_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_https_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_local_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_vrf(value, module):\n    out = run_commands(module, ['show vrf'])\n    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0], re.M)\n    configured_vrfs.append('default')\n    if value not in configured_vrfs:\n        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n\ndef map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    want, have = updates\n\n    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            if have['http'] is False and want['http'] in (False, None):\n                warnings.append('protocol http is not enabled, not configuring http port value')\n            else:\n                port = want['http_port'] or 80\n                add('protocol http port %s' % port)\n\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            if have['https'] is False and want['https'] in (False, None):\n                warnings.append('protocol https is not enabled, not configuring https port value')\n            else:\n                port = want['https_port'] or 443\n                add('protocol https port %s' % port)\n\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            if have['local_http'] is False and want['local_http'] in (False, None):\n                warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n            else:\n                port = want['local_http_port'] or 8080\n                add('protocol http localhost port %s' % port)\n\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n\n\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n    return commands\n\ndef parse_state(data):\n    if data[0]['enabled']:\n        return 'started'\n    else:\n        return 'stopped'\n\n\ndef map_config_to_obj(module):\n    out = run_commands(module, ['show management api http-commands | json'])\n    return {\n        'http': out[0]['httpServer']['configured'],\n        'http_port': out[0]['httpServer']['port'],\n        'https': out[0]['httpsServer']['configured'],\n        'https_port': out[0]['httpsServer']['port'],\n        'local_http': out[0]['localHttpServer']['configured'],\n        'local_http_port': out[0]['localHttpServer']['port'],\n        'socket': out[0]['unixSocketServer']['configured'],\n        'vrf': out[0]['vrf'],\n        'state': parse_state(out)\n    }\n\ndef map_params_to_obj(module):\n    obj = {\n        'http': module.params['http'],\n        'http_port': module.params['http_port'],\n        'https': module.params['https'],\n        'https_port': module.params['https_port'],\n        'local_http': module.params['local_http'],\n        'local_http_port': module.params['local_http_port'],\n        'socket': module.params['socket'],\n        'vrf': module.params['vrf'],\n        'state': module.params['state']\n    }\n\n    for key, value in iteritems(obj):\n        if value:\n            validator = globals().get('validate_%s' % key)\n            if validator:\n                validator(value, module)\n\n    return obj\n\ndef verify_state(updates, module):\n    want, have = updates\n\n    invalid_state = [('http', 'httpServer'),\n                     ('https', 'httpsServer'),\n                     ('local_http', 'localHttpServer'),\n                     ('socket', 'unixSocketServer')]\n\n    timeout = module.params['timeout'] or 30\n    state = module.params['state']\n\n    while invalid_state:\n        out = run_commands(module, ['show management api http-commands | json'])\n        for index, item in enumerate(invalid_state):\n            want_key, eapi_key = item\n            if want[want_key] is not None:\n                if want[want_key] == out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            elif state == 'stopped':\n                if not out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            else:\n                del invalid_state[index]\n        time.sleep(1)\n        timeout -= 1\n        if timeout == 0:\n            module.fail_json(msg='timeout expired before eapi running state changed')\n\ndef collect_facts(module, result):\n    out = run_commands(module, ['show management api http-commands | json'])\n    facts = dict(eos_eapi_urls=dict())\n    for each in out[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], type='bool'),\n        http_port=dict(type='int'),\n\n        https=dict(aliases=['enable_https'], type='bool'),\n        https_port=dict(type='int'),\n\n        local_http=dict(aliases=['enable_local_http'], type='bool'),\n        local_http_port=dict(type='int'),\n\n        socket=dict(aliases=['enable_socket'], type='bool'),\n\n        vrf=dict(default='default'),\n\n        config=dict(),\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    argument_spec.update(eos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    check_transport(module)\n\n    result = {'changed': False}\n\n    warnings = list()\n    if module.params['config']:\n        warnings.append('config parameter is no longer necessary and will be ignored')\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have), module, warnings)\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        response = load_config(module, commands, commit=commit)\n        if response.get('diff') and module._diff:\n            result['diff'] = {'prepared': response.get('diff')}\n        result['session_name'] = response.get('session')\n        result['changed'] = True\n\n    if result['changed']:\n        verify_state((want, have), module)\n\n    collect_facts(module, result)\n\n    if warnings:\n        result['warnings'] = warnings\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
      "file_after": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\nextends_documentation_fragment: eos\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always\n  type: list\n  sample:\n    - management api http-commands\n    - protocol http port 81\n    - no protocol https\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\nsession_name:\n  description: The EOS config session name used to load the configuration\n  returned: when changed is True\n  type: str\n  sample: ansible_1479315771\n\"\"\"\nimport re\nimport time\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.eos import run_commands, load_config\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.eos import eos_argument_spec, check_args\n\ndef check_transport(module):\n    transport = module.params['transport']\n    provider_transport = (module.params['provider'] or {}).get('transport')\n\n    if 'eapi' in (transport, provider_transport):\n        module.fail_json(msg='eos_eapi module is only supported over cli transport')\n\ndef validate_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_https_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_local_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_vrf(value, module):\n    out = run_commands(module, ['show vrf'])\n    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0], re.M)\n    configured_vrfs.append('default')\n    if value not in configured_vrfs:\n        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n\ndef map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    want, have = updates\n\n    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            if have['http'] is False and want['http'] in (False, None):\n                warnings.append('protocol http is not enabled, not configuring http port value')\n            else:\n                port = want['http_port'] or 80\n                add('protocol http port %s' % port)\n\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            if have['https'] is False and want['https'] in (False, None):\n                warnings.append('protocol https is not enabled, not configuring https port value')\n            else:\n                port = want['https_port'] or 443\n                add('protocol https port %s' % port)\n\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            if have['local_http'] is False and want['local_http'] in (False, None):\n                warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n            else:\n                port = want['local_http_port'] or 8080\n                add('protocol http localhost port %s' % port)\n\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n\n    if needs_update('state') and not needs_update('vrf'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n        # switching operational vrfs here\n        # need to add the desired state as well\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n    return commands\n\ndef parse_state(data):\n    if data[0]['enabled']:\n        return 'started'\n    else:\n        return 'stopped'\n\n\ndef map_config_to_obj(module):\n    out = run_commands(module, ['show management api http-commands | json'])\n    return {\n        'http': out[0]['httpServer']['configured'],\n        'http_port': out[0]['httpServer']['port'],\n        'https': out[0]['httpsServer']['configured'],\n        'https_port': out[0]['httpsServer']['port'],\n        'local_http': out[0]['localHttpServer']['configured'],\n        'local_http_port': out[0]['localHttpServer']['port'],\n        'socket': out[0]['unixSocketServer']['configured'],\n        'vrf': out[0]['vrf'],\n        'state': parse_state(out)\n    }\n\ndef map_params_to_obj(module):\n    obj = {\n        'http': module.params['http'],\n        'http_port': module.params['http_port'],\n        'https': module.params['https'],\n        'https_port': module.params['https_port'],\n        'local_http': module.params['local_http'],\n        'local_http_port': module.params['local_http_port'],\n        'socket': module.params['socket'],\n        'vrf': module.params['vrf'],\n        'state': module.params['state']\n    }\n\n    for key, value in iteritems(obj):\n        if value:\n            validator = globals().get('validate_%s' % key)\n            if validator:\n                validator(value, module)\n\n    return obj\n\ndef verify_state(updates, module):\n    want, have = updates\n\n    invalid_state = [('http', 'httpServer'),\n                     ('https', 'httpsServer'),\n                     ('local_http', 'localHttpServer'),\n                     ('socket', 'unixSocketServer')]\n\n    timeout = module.params['timeout'] or 30\n    state = module.params['state']\n\n    while invalid_state:\n        out = run_commands(module, ['show management api http-commands | json'])\n        for index, item in enumerate(invalid_state):\n            want_key, eapi_key = item\n            if want[want_key] is not None:\n                if want[want_key] == out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            elif state == 'stopped':\n                if not out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            else:\n                del invalid_state[index]\n        time.sleep(1)\n        timeout -= 1\n        if timeout == 0:\n            module.fail_json(msg='timeout expired before eapi running state changed')\n\ndef collect_facts(module, result):\n    out = run_commands(module, ['show management api http-commands | json'])\n    facts = dict(eos_eapi_urls=dict())\n    for each in out[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], type='bool'),\n        http_port=dict(type='int'),\n\n        https=dict(aliases=['enable_https'], type='bool'),\n        https_port=dict(type='int'),\n\n        local_http=dict(aliases=['enable_local_http'], type='bool'),\n        local_http_port=dict(type='int'),\n\n        socket=dict(aliases=['enable_socket'], type='bool'),\n\n        vrf=dict(default='default'),\n\n        config=dict(),\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    argument_spec.update(eos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    check_transport(module)\n\n    result = {'changed': False}\n\n    warnings = list()\n    if module.params['config']:\n        warnings.append('config parameter is no longer necessary and will be ignored')\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have), module, warnings)\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        response = load_config(module, commands, commit=commit)\n        if response.get('diff') and module._diff:\n            result['diff'] = {'prepared': response.get('diff')}\n        result['session_name'] = response.get('session')\n        result['changed'] = True\n\n    if result['changed']:\n        verify_state((want, have), module)\n\n    collect_facts(module, result)\n\n    if warnings:\n        result['warnings'] = warnings\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
      "file_patch": "@@ -260,11 +260,17 @@ def map_obj_to_commands(updates, module, warnings):\n         else:\n             add('protocol unix-socket')\n \n+    if needs_update('state') and not needs_update('vrf'):\n+        if want['state'] == 'stopped':\n+            add('shutdown')\n+        elif want['state'] == 'started':\n+            add('no shutdown')\n+\n \n     if needs_update('vrf'):\n         add('vrf %s' % want['vrf'])\n-\n-    if needs_update('state'):\n+        # switching operational vrfs here\n+        # need to add the desired state as well\n         if want['state'] == 'stopped':\n             add('shutdown')\n         elif want['state'] == 'started':\n",
      "files_name_in_blame_commit": [
        "eos_eapi.py",
        "test_eos_eapi.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 34
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "216": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "def map_obj_to_commands(updates, module, warnings):",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "217": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    commands = list()",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "218": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    want, have = updates",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "219": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "220": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "221": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "222": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    def add(cmd):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "223": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        if 'management api http-commands' not in commands:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "224": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            commands.insert(0, 'management api http-commands')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "225": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        commands.append(cmd)",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "226": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "227": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    if any((needs_update('http'), needs_update('http_port'))):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "228": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        if want['http'] is False:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "229": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            add('no protocol http')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "230": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "        else:",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "231": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "            if have['http'] is False and want['http'] in (False, None):",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "232": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "                warnings.append('protocol http is not enabled, not configuring http port value')",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "233": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            else:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "234": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                port = want['http_port'] or 80",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "235": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                add('protocol http port %s' % port)",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "236": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "237": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    if any((needs_update('https'), needs_update('https_port'))):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "238": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        if want['https'] is False:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "239": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            add('no protocol https')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "240": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "        else:",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "241": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "            if have['https'] is False and want['https'] in (False, None):",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "242": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "                warnings.append('protocol https is not enabled, not configuring https port value')",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "243": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            else:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "244": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                port = want['https_port'] or 443",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "245": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                add('protocol https port %s' % port)",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "246": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "247": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    if any((needs_update('local_http'), needs_update('local_http_port'))):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "248": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        if want['local_http'] is False:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "249": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            add('no protocol http localhost')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "250": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "        else:",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "251": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "            if have['local_http'] is False and want['local_http'] in (False, None):",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "252": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "                warnings.append('protocol local_http is not enabled, not configuring local_http port value')",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "253": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            else:",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "254": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                port = want['local_http_port'] or 8080",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "255": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "                add('protocol http localhost port %s' % port)",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "256": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "257": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "    if any((needs_update('socket'), needs_update('socket'))):",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "258": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "        if want['socket'] is False:",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "259": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "            add('no protocol unix-socket')",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "260": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "        else:",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "261": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "            add('protocol unix-socket')",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 1
      },
      "262": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 0
      },
      "263": {
        "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
        "line_code": "",
        "commit_date": "2017-02-25 17:18:46",
        "valid": 0
      },
      "264": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    if needs_update('vrf'):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "265": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        add('vrf %s' % want['vrf'])",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "266": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "267": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    if needs_update('state'):",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "268": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        if want['state'] == 'stopped':",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "269": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            add('shutdown')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "270": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "        elif want['state'] == 'started':",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "271": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "            add('no shutdown')",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      },
      "272": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 0
      },
      "273": {
        "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
        "line_code": "    return commands",
        "commit_date": "2017-01-27 08:44:57",
        "valid": 1
      }
    },
    "commits": {
      "16a39639f568f4dd5cb233df2d0631bdab3a05e9": {
        "commit": {
          "commit_id": "16a39639f568f4dd5cb233df2d0631bdab3a05e9",
          "commit_message": "fixes minor bugs in eos_eapi module (#21925)\n\n* module will now check protocol running state before return\r\n* warns on config argument no longer being needed\r\n* lots of integration test cases updated\r\n* updates unit and integration test cases for state check\r\n\r\nfixes #21908",
          "commit_author": "Peter Sprygada",
          "commit_date": "2017-02-25 17:18:46",
          "commit_parent": "7c3957cc0cc3e12e7a7cfefb89a413280bc4e873"
        },
        "function": {
          "function_name": "map_obj_to_commands",
          "function_code_before": "def map_obj_to_commands(updates, module):\n    commands = list()\n    (want, have) = updates\n    needs_update = lambda x: want.get(x) is not None and want.get(x) != have.get(x)\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    return commands",
          "function_code_after": "def map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    (want, have) = updates\n    needs_update = lambda x: want.get(x) is not None and want.get(x) != have.get(x)\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        elif have['http'] is False and want['http'] in (False, None):\n            warnings.append('protocol http is not enabled, not configuring http port value')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        elif have['https'] is False and want['https'] in (False, None):\n            warnings.append('protocol https is not enabled, not configuring https port value')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        elif have['local_http'] is False and want['local_http'] in (False, None):\n            warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    return commands",
          "function_before_start_line": 208,
          "function_before_end_line": 249,
          "function_after_start_line": 209,
          "function_after_end_line": 266,
          "function_before_token_count": 228,
          "function_after_token_count": 345,
          "functions_name_modified_file": [
            "map_config_to_obj",
            "validate_local_http_port",
            "verify_state",
            "validate_http_port",
            "collect_facts",
            "parse_state",
            "map_params_to_obj",
            "main",
            "validate_https_port",
            "validate_vrf",
            "map_obj_to_commands"
          ],
          "functions_name_all_files": [
            "map_config_to_obj",
            "test_eos_eapi_http_port",
            "tearDown",
            "test_eos_eapi_state_absent",
            "test_eos_eapi_state_failed",
            "start_configured",
            "test_eos_eapi_http_disable",
            "validate_local_http_port",
            "verify_state",
            "test_eos_eapi_https_enable",
            "main",
            "load_fixtures",
            "test_eos_eapi_local_http_enable",
            "test_eos_eapi_vrf_missing",
            "map_obj_to_commands",
            "test_eos_eapi_http_invalid",
            "validate_http_port",
            "test_eos_eapi_local_http_disable",
            "validate_https_port",
            "validate_vrf",
            "setUp",
            "collect_facts",
            "start_unconfigured",
            "test_eos_eapi_local_http_port",
            "test_eos_eapi_https_disable",
            "parse_state",
            "map_params_to_obj",
            "test_eos_eapi_https_port",
            "test_eos_eapi_http_enable",
            "test_eos_eapi_vrf"
          ],
          "functions_name_co_evolved_modified_file": [
            "verify_state",
            "main"
          ],
          "functions_name_co_evolved_all_files": [
            "tearDown",
            "verify_state",
            "main",
            "test_eos_eapi_state_failed",
            "setUp"
          ]
        },
        "file": {
          "file_name": "eos_eapi.py",
          "file_nloc": 338,
          "file_complexity": 59,
          "file_token_count": 1428,
          "file_before": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {\n    'status': ['preview'],\n    'supported_by': 'core',\n    'version': '1.0'\n}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always\n  type: list\n  sample:\n    - management api http-commands\n    - protocol http port 81\n    - no protocol https\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\nsession_name:\n  description: The EOS config session name used to load the configuration\n  returned: when changed is True\n  type: str\n  sample: ansible_1479315771\n\"\"\"\nimport re\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.eos import run_commands, load_config\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.eos import eos_argument_spec, check_args\n\ndef validate_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_https_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_local_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_vrf(value, module):\n    out = run_commands(module, ['show vrf'])\n    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0], re.M)\n    configured_vrfs.append('default')\n    if value not in configured_vrfs:\n        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n\ndef map_obj_to_commands(updates, module):\n    commands = list()\n    want, have = updates\n\n    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n    return commands\n\ndef parse_state(data):\n    if data[0]['enabled']:\n        return 'started'\n    else:\n        return 'stopped'\n\n\ndef map_config_to_obj(module):\n    out = run_commands(module, ['show management api http-commands | json'])\n    return {\n        'http': out[0]['httpServer']['configured'],\n        'http_port': out[0]['httpServer']['port'],\n        'https': out[0]['httpsServer']['configured'],\n        'https_port': out[0]['httpsServer']['port'],\n        'local_http': out[0]['localHttpServer']['configured'],\n        'local_http_port': out[0]['localHttpServer']['port'],\n        'socket': out[0]['unixSocketServer']['configured'],\n        'vrf': out[0]['vrf'],\n        'state': parse_state(out)\n    }\n\ndef map_params_to_obj(module):\n    obj = {\n        'http': module.params['http'],\n        'http_port': module.params['http_port'],\n        'https': module.params['https'],\n        'https_port': module.params['https_port'],\n        'local_http': module.params['local_http'],\n        'local_http_port': module.params['local_http_port'],\n        'socket': module.params['socket'],\n        'vrf': module.params['vrf'],\n        'state': module.params['state']\n    }\n\n    for key, value in iteritems(obj):\n        if value:\n            validator = globals().get('validate_%s' % key)\n            if validator:\n                validator(value, module)\n\n    return obj\n\ndef collect_facts(module, result):\n    out = run_commands(module, ['show management api http-commands | json'])\n    facts = dict(eos_eapi_urls=dict())\n    for each in out[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], type='bool'),\n        http_port=dict(type='int'),\n\n        https=dict(aliases=['enable_https'], type='bool'),\n        https_port=dict(type='int'),\n\n        local_http=dict(aliases=['enable_local_http'], type='bool'),\n        local_http_port=dict(type='int'),\n\n        socket=dict(aliases=['enable_socket'], type='bool'),\n\n        vrf=dict(default='default'),\n\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    argument_spec.update(eos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have), module)\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        response = load_config(module, commands, commit=commit)\n        if response.get('diff') and module._diff:\n            result['diff'] = {'prepared': response.get('diff')}\n        result['session_name'] = response.get('session')\n        result['changed'] = True\n\n    collect_facts(module, result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_after": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {\n    'status': ['preview'],\n    'supported_by': 'core',\n    'version': '1.0'\n}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always\n  type: list\n  sample:\n    - management api http-commands\n    - protocol http port 81\n    - no protocol https\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\nsession_name:\n  description: The EOS config session name used to load the configuration\n  returned: when changed is True\n  type: str\n  sample: ansible_1479315771\n\"\"\"\nimport re\nimport time\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.eos import run_commands, load_config\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.eos import eos_argument_spec, check_args\n\ndef validate_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_https_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_local_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_vrf(value, module):\n    out = run_commands(module, ['show vrf'])\n    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0], re.M)\n    configured_vrfs.append('default')\n    if value not in configured_vrfs:\n        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n\ndef map_obj_to_commands(updates, module, warnings):\n    commands = list()\n    want, have = updates\n\n    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            if have['http'] is False and want['http'] in (False, None):\n                warnings.append('protocol http is not enabled, not configuring http port value')\n            else:\n                port = want['http_port'] or 80\n                add('protocol http port %s' % port)\n\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            if have['https'] is False and want['https'] in (False, None):\n                warnings.append('protocol https is not enabled, not configuring https port value')\n            else:\n                port = want['https_port'] or 443\n                add('protocol https port %s' % port)\n\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            if have['local_http'] is False and want['local_http'] in (False, None):\n                warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n            else:\n                port = want['local_http_port'] or 8080\n                add('protocol http localhost port %s' % port)\n\n    if any((needs_update('socket'), needs_update('socket'))):\n        if want['socket'] is False:\n            add('no protocol unix-socket')\n        else:\n            add('protocol unix-socket')\n\n\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n    return commands\n\ndef parse_state(data):\n    if data[0]['enabled']:\n        return 'started'\n    else:\n        return 'stopped'\n\n\ndef map_config_to_obj(module):\n    out = run_commands(module, ['show management api http-commands | json'])\n    return {\n        'http': out[0]['httpServer']['configured'],\n        'http_port': out[0]['httpServer']['port'],\n        'https': out[0]['httpsServer']['configured'],\n        'https_port': out[0]['httpsServer']['port'],\n        'local_http': out[0]['localHttpServer']['configured'],\n        'local_http_port': out[0]['localHttpServer']['port'],\n        'socket': out[0]['unixSocketServer']['configured'],\n        'vrf': out[0]['vrf'],\n        'state': parse_state(out)\n    }\n\ndef map_params_to_obj(module):\n    obj = {\n        'http': module.params['http'],\n        'http_port': module.params['http_port'],\n        'https': module.params['https'],\n        'https_port': module.params['https_port'],\n        'local_http': module.params['local_http'],\n        'local_http_port': module.params['local_http_port'],\n        'socket': module.params['socket'],\n        'vrf': module.params['vrf'],\n        'state': module.params['state']\n    }\n\n    for key, value in iteritems(obj):\n        if value:\n            validator = globals().get('validate_%s' % key)\n            if validator:\n                validator(value, module)\n\n    return obj\n\ndef verify_state(updates, module):\n    want, have = updates\n\n    invalid_state = [('http', 'httpServer'),\n                     ('https', 'httpsServer'),\n                     ('local_http', 'localHttpServer'),\n                     ('socket', 'unixSocketServer')]\n\n    timeout = module.params['timeout'] or 30\n    state = module.params['state']\n\n    while invalid_state:\n        out = run_commands(module, ['show management api http-commands | json'])\n        for index, item in enumerate(invalid_state):\n            want_key, eapi_key = item\n            if want[want_key] is not None:\n                if want[want_key] == out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            elif state == 'stopped':\n                if not out[0][eapi_key]['running']:\n                    del invalid_state[index]\n            else:\n                del invalid_state[index]\n        time.sleep(1)\n        timeout -= 1\n        if timeout == 0:\n            module.fail_json(msg='timeout expired before eapi running state changed')\n\ndef collect_facts(module, result):\n    out = run_commands(module, ['show management api http-commands | json'])\n    facts = dict(eos_eapi_urls=dict())\n    for each in out[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], type='bool'),\n        http_port=dict(type='int'),\n\n        https=dict(aliases=['enable_https'], type='bool'),\n        https_port=dict(type='int'),\n\n        local_http=dict(aliases=['enable_local_http'], type='bool'),\n        local_http_port=dict(type='int'),\n\n        socket=dict(aliases=['enable_socket'], type='bool'),\n\n        vrf=dict(default='default'),\n\n        config=dict(),\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    argument_spec.update(eos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n\n    result = {'changed': False}\n\n    warnings = list()\n    if module.params['config']:\n        warnings.append('config parameter is no longer necessary and will be ignored')\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have), module, warnings)\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        response = load_config(module, commands, commit=commit)\n        if response.get('diff') and module._diff:\n            result['diff'] = {'prepared': response.get('diff')}\n        result['session_name'] = response.get('session')\n        result['changed'] = True\n\n    if result['changed']:\n        verify_state((want, have), module)\n\n    collect_facts(module, result)\n\n    if warnings:\n        result['warnings'] = warnings\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_patch": "@@ -180,6 +180,7 @@ session_name:\n   sample: ansible_1479315771\n \"\"\"\n import re\n+import time\n \n from ansible.module_utils.basic import AnsibleModule\n from ansible.module_utils.eos import run_commands, load_config\n@@ -205,7 +206,7 @@ def validate_vrf(value, module):\n     if value not in configured_vrfs:\n         module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n \n-def map_obj_to_commands(updates, module):\n+def map_obj_to_commands(updates, module, warnings):\n     commands = list()\n     want, have = updates\n \n@@ -220,22 +221,38 @@ def map_obj_to_commands(updates, module):\n         if want['http'] is False:\n             add('no protocol http')\n         else:\n-            port = want['http_port'] or 80\n-            add('protocol http port %s' % port)\n+            if have['http'] is False and want['http'] in (False, None):\n+                warnings.append('protocol http is not enabled, not configuring http port value')\n+            else:\n+                port = want['http_port'] or 80\n+                add('protocol http port %s' % port)\n \n     if any((needs_update('https'), needs_update('https_port'))):\n         if want['https'] is False:\n             add('no protocol https')\n         else:\n-            port = want['https_port'] or 443\n-            add('protocol https port %s' % port)\n+            if have['https'] is False and want['https'] in (False, None):\n+                warnings.append('protocol https is not enabled, not configuring https port value')\n+            else:\n+                port = want['https_port'] or 443\n+                add('protocol https port %s' % port)\n \n     if any((needs_update('local_http'), needs_update('local_http_port'))):\n         if want['local_http'] is False:\n             add('no protocol http localhost')\n         else:\n-            port = want['local_http_port'] or 8080\n-            add('protocol http localhost port %s' % port)\n+            if have['local_http'] is False and want['local_http'] in (False, None):\n+                warnings.append('protocol local_http is not enabled, not configuring local_http port value')\n+            else:\n+                port = want['local_http_port'] or 8080\n+                add('protocol http localhost port %s' % port)\n+\n+    if any((needs_update('socket'), needs_update('socket'))):\n+        if want['socket'] is False:\n+            add('no protocol unix-socket')\n+        else:\n+            add('protocol unix-socket')\n+\n \n     if needs_update('vrf'):\n         add('vrf %s' % want['vrf'])\n@@ -290,6 +307,34 @@ def map_params_to_obj(module):\n \n     return obj\n \n+def verify_state(updates, module):\n+    want, have = updates\n+\n+    invalid_state = [('http', 'httpServer'),\n+                     ('https', 'httpsServer'),\n+                     ('local_http', 'localHttpServer'),\n+                     ('socket', 'unixSocketServer')]\n+\n+    timeout = module.params['timeout'] or 30\n+    state = module.params['state']\n+\n+    while invalid_state:\n+        out = run_commands(module, ['show management api http-commands | json'])\n+        for index, item in enumerate(invalid_state):\n+            want_key, eapi_key = item\n+            if want[want_key] is not None:\n+                if want[want_key] == out[0][eapi_key]['running']:\n+                    del invalid_state[index]\n+            elif state == 'stopped':\n+                if not out[0][eapi_key]['running']:\n+                    del invalid_state[index]\n+            else:\n+                del invalid_state[index]\n+        time.sleep(1)\n+        timeout -= 1\n+        if timeout == 0:\n+            module.fail_json(msg='timeout expired before eapi running state changed')\n+\n def collect_facts(module, result):\n     out = run_commands(module, ['show management api http-commands | json'])\n     facts = dict(eos_eapi_urls=dict())\n@@ -318,6 +363,7 @@ def main():\n \n         vrf=dict(default='default'),\n \n+        config=dict(),\n         state=dict(default='started', choices=['stopped', 'started']),\n     )\n \n@@ -326,12 +372,17 @@ def main():\n     module = AnsibleModule(argument_spec=argument_spec,\n                            supports_check_mode=True)\n \n+\n     result = {'changed': False}\n \n+    warnings = list()\n+    if module.params['config']:\n+        warnings.append('config parameter is no longer necessary and will be ignored')\n+\n     want = map_params_to_obj(module)\n     have = map_config_to_obj(module)\n \n-    commands = map_obj_to_commands((want, have), module)\n+    commands = map_obj_to_commands((want, have), module, warnings)\n     result['commands'] = commands\n \n     if commands:\n@@ -342,8 +393,14 @@ def main():\n         result['session_name'] = response.get('session')\n         result['changed'] = True\n \n+    if result['changed']:\n+        verify_state((want, have), module)\n+\n     collect_facts(module, result)\n \n+    if warnings:\n+        result['warnings'] = warnings\n+\n     module.exit_json(**result)\n \n \n",
          "files_name_in_blame_commit": [
            "eos_eapi.py",
            "test_eos_eapi.py"
          ]
        }
      },
      "57660abf3376458fbd43cb8749158031d981418d": {
        "commit": {
          "commit_id": "57660abf3376458fbd43cb8749158031d981418d",
          "commit_message": "refactor eos_eapi module (#20740)\n\n* eos_eapi module now requires network_cli plugin\r\n* adds unit test cases for eos_eapi module",
          "commit_author": "Peter Sprygada",
          "commit_date": "2017-01-27 08:44:57",
          "commit_parent": "cd14d9dcfc06c54a46e75beb26368c533f0635f0"
        },
        "function": {
          "function_name": "map_obj_to_commands",
          "function_code_before": "",
          "function_code_after": "def map_obj_to_commands(updates, module):\n    commands = list()\n    (want, have) = updates\n    needs_update = lambda x: want.get(x) is not None and want.get(x) != have.get(x)\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n    return commands",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 222,
          "function_after_end_line": 263,
          "function_before_token_count": 0,
          "function_after_token_count": 228,
          "functions_name_modified_file": [
            "map_config_to_obj",
            "validate_local_http_port",
            "collect_facts",
            "validate_http_port",
            "parse_state",
            "map_params_to_obj",
            "main",
            "validate_https_port",
            "validate_vrf",
            "map_obj_to_commands"
          ],
          "functions_name_all_files": [
            "map_config_to_obj",
            "test_eos_eapi_http_port",
            "tearDown",
            "test_eos_eapi_state_absent",
            "execute_module",
            "start_configured",
            "test_eos_eapi_http_disable",
            "validate_local_http_port",
            "test_eos_eapi_https_enable",
            "main",
            "test_eos_eapi_local_http_enable",
            "load_fixture",
            "test_eos_eapi_vrf_missing",
            "set_module_args",
            "map_obj_to_commands",
            "test_eos_eapi_http_invalid",
            "validate_http_port",
            "test_eos_eapi_local_http_disable",
            "validate_https_port",
            "validate_vrf",
            "setUp",
            "collect_facts",
            "start_unconfigured",
            "test_eos_eapi_local_http_port",
            "test_eos_eapi_https_disable",
            "parse_state",
            "map_params_to_obj",
            "test_eos_eapi_https_port",
            "test_eos_eapi_http_enable",
            "test_eos_eapi_vrf"
          ],
          "functions_name_co_evolved_modified_file": [
            "map_config_to_obj",
            "load_config",
            "load",
            "get_config",
            "set_protocol_http",
            "validate_local_http_port",
            "main",
            "set_vrf",
            "set_local_http",
            "validate_http_port",
            "validate_https_port",
            "validate_vrf",
            "invoke",
            "set_socket",
            "collect_facts",
            "get_instance",
            "started",
            "parse_state",
            "map_params_to_obj",
            "set_protocol_https",
            "clean_result",
            "stopped"
          ],
          "functions_name_co_evolved_all_files": [
            "map_config_to_obj",
            "test_eos_eapi_http_port",
            "tearDown",
            "test_eos_eapi_state_absent",
            "load_config",
            "load",
            "execute_module",
            "start_configured",
            "get_config",
            "test_eos_eapi_http_disable",
            "set_protocol_http",
            "validate_local_http_port",
            "test_eos_eapi_https_enable",
            "main",
            "set_vrf",
            "test_eos_eapi_local_http_enable",
            "load_fixture",
            "test_eos_eapi_vrf_missing",
            "set_local_http",
            "set_module_args",
            "test_eos_eapi_http_invalid",
            "validate_http_port",
            "test_eos_eapi_local_http_disable",
            "validate_https_port",
            "validate_vrf",
            "test_eos_eapi_vrf",
            "setUp",
            "invoke",
            "set_socket",
            "collect_facts",
            "get_instance",
            "started",
            "test_eos_eapi_https_disable",
            "start_unconfigured",
            "parse_state",
            "map_params_to_obj",
            "test_eos_eapi_https_port",
            "test_eos_eapi_local_http_port",
            "set_protocol_https",
            "test_eos_eapi_http_enable",
            "clean_result",
            "stopped"
          ]
        },
        "file": {
          "file_name": "eos_eapi.py",
          "file_nloc": 304,
          "file_complexity": 39,
          "file_token_count": 1084,
          "file_before": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n\nANSIBLE_METADATA = {'status': ['preview'],\n                    'supported_by': 'core',\n                    'version': '1.0'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\nextends_documentation_fragment: eos\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n# Note: examples below use the following provider dict to handle\n#       transport and authentication to the node.\nvars:\n  cli:\n    host: \"{{ inventory_hostname }}\"\n    username: admin\n    password: admin\n\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n    provider: \"{{ cli }}\"\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n    provider: \"{{ cli }}\"\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n    provider: \"{{ cli }}\"\n\"\"\"\n\nRETURN = \"\"\"\nupdates:\n  description:\n    - Set of commands to be executed on remote device\n  returned: always\n  type: list\n  sample: ['management api http-commands', 'shutdown']\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\n\"\"\"\nimport re\nimport time\n\nimport ansible.module_utils.eos\n\nfrom ansible.module_utils.basic import get_exception\nfrom ansible.module_utils.network import NetworkModule, NetworkError\nfrom ansible.module_utils.netcfg import NetworkConfig, dumps\n\nPRIVATE_KEYS_RE = re.compile('__.+__')\n\n\ndef invoke(name, *args, **kwargs):\n    func = globals().get(name)\n    if func:\n        return func(*args, **kwargs)\n\ndef get_instance(module):\n    try:\n        resp = module.cli('show management api http-commands', 'json')\n        return dict(\n            http=resp[0]['httpServer']['configured'],\n            http_port=resp[0]['httpServer']['port'],\n            https=resp[0]['httpsServer']['configured'],\n            https_port=resp[0]['httpsServer']['port'],\n            local_http=resp[0]['localHttpServer']['configured'],\n            local_http_port=resp[0]['localHttpServer']['port'],\n            socket=resp[0]['unixSocketServer']['configured'],\n            vrf=resp[0]['vrf']\n        )\n    except NetworkError:\n        exc = get_exception()\n        module.fail_json(msg=str(exc), **exc.kwargs)\n\ndef started(module, instance, commands):\n    commands.append('no shutdown')\n    setters = set()\n    for key, value in module.argument_spec.items():\n        if module.params[key] is not None:\n            setter = value.get('setter') or 'set_%s' % key\n            if setter not in setters:\n                setters.add(setter)\n            invoke(setter, module, instance, commands)\n\ndef stopped(module, instance, commands):\n    commands.append('shutdown')\n\ndef set_protocol_http(module, instance, commands):\n    port = module.params['http_port']\n    if not 1 <= port <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n    elif any((module.params['http'], instance['http'])):\n        commands.append('protocol http port %s' % port)\n    elif module.params['http'] is False:\n        commands.append('no protocol http')\n\ndef set_protocol_https(module, instance, commands):\n    port = module.params['https_port']\n    if not 1 <= port <= 65535:\n        module.fail_json(msg='https_port must be between 1 and 65535')\n    elif any((module.params['https'], instance['https'])):\n        commands.append('protocol https port %s' % port)\n    elif module.params['https'] is False:\n        commands.append('no protocol https')\n\ndef set_local_http(module, instance, commands):\n    port = module.params['local_http_port']\n    if not 1 <= port <= 65535:\n        module.fail_json(msg='local_http_port must be between 1 and 65535')\n    elif any((module.params['local_http'], instance['local_http'])):\n        commands.append('protocol http localhost port %s' % port)\n    elif module.params['local_http'] is False:\n        commands.append('no protocol http localhost port 8080')\n\ndef set_socket(module, instance, commands):\n    if any((module.params['socket'], instance['socket'])):\n        commands.append('protocol unix-socket')\n    elif module.params['socket'] is False:\n        commands.append('no protocol unix-socket')\n\ndef set_vrf(module, instance, commands):\n    vrf = module.params['vrf']\n    if vrf != 'default':\n        resp = module.cli(['show vrf'])\n        if vrf not in resp[0]:\n            module.fail_json(msg=\"vrf '%s' is not configured\" % vrf)\n    commands.append('vrf %s' % vrf)\n\ndef get_config(module):\n    contents = module.params['config']\n    if not contents:\n        cmd = 'show running-config all section management api http-commands'\n        contents = module.cli([cmd])\n    config = NetworkConfig(indent=3, contents=contents[0])\n    return config\n\ndef load_config(module, instance, commands, result):\n    commit = not module.check_mode\n    diff = module.config.load_config(commands, commit=commit)\n    if diff:\n        result['diff'] = dict(prepared=diff)\n        result['changed'] = True\n\ndef load(module, instance, commands, result):\n    candidate = NetworkConfig(indent=3)\n    candidate.add(commands, parents=['management api http-commands'])\n\n    config = get_config(module)\n    configobjs = candidate.difference(config)\n\n    if configobjs:\n        commands = dumps(configobjs, 'commands').split('\\n')\n        result['updates'] = commands\n        load_config(module, instance, commands, result)\n\ndef clean_result(result):\n    # strip out any keys that have two leading and two trailing\n    # underscore characters\n    for key in result.keys():\n        if PRIVATE_KEYS_RE.match(key):\n            del result[key]\n\ndef collect_facts(module, result):\n    resp = module.cli(['show management api http-commands'], output='json')\n    facts = dict(eos_eapi_urls=dict())\n    for each in resp[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if  key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], default=False, type='bool', setter='set_protocol_http'),\n        http_port=dict(default=80, type='int', setter='set_protocol_http'),\n\n        https=dict(aliases=['enable_https'], default=True, type='bool', setter='set_protocol_https'),\n        https_port=dict(default=443, type='int', setter='set_protocol_https'),\n\n        local_http=dict(aliases=['enable_local_http'], default=False, type='bool', setter='set_local_http'),\n        local_http_port=dict(default=8080, type='int', setter='set_local_http'),\n\n        socket=dict(aliases=['enable_socket'], default=False, type='bool'),\n\n        vrf=dict(default='default'),\n\n        config=dict(),\n\n        # Only allow use of transport cli when configuring eAPI\n        transport=dict(default='cli', choices=['cli']),\n\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    module = NetworkModule(argument_spec=argument_spec,\n                           connect_on_load=False,\n                           supports_check_mode=True)\n\n    state = module.params['state']\n\n    result = dict(changed=False)\n\n    commands = list()\n    instance = get_instance(module)\n\n    invoke(state, module, instance, commands)\n\n    try:\n        load(module, instance, commands, result)\n    except NetworkError:\n        exc = get_exception()\n        module.fail_json(msg=str(exc), **exc.kwargs)\n\n    collect_facts(module, result)\n    clean_result(result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_after": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {\n    'status': ['preview'],\n    'supported_by': 'core',\n    'version': '1.0'\n}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: eos_eapi\nversion_added: \"2.1\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage and configure Arista EOS eAPI.\nrequirements:\n  - \"EOS v4.12 or greater\"\ndescription:\n  - Use to enable or disable eAPI access, and set the port and state\n    of http, https, local_http and unix-socket servers.\n  - When enabling eAPI access the default is to enable HTTP on port\n    80, enable HTTPS on port 443, disable local HTTP, and disable\n    Unix socket server. Use the options listed below to override the\n    default configuration.\n  - Requires EOS v4.12 or greater.\noptions:\n  http:\n    description:\n      - The C(http) argument controls the operating state of the HTTP\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTP protocol is enabled and\n        when the value is set to False, the HTTP protocol is disabled.\n        By default, when eAPI is first configured, the HTTP protocol is\n        disabled.\n    required: false\n    default: no\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 80\n  https:\n    description:\n      - The C(https) argument controls the operating state of the HTTPS\n        transport protocol when eAPI is present in the running-config.\n        When the value is set to True, the HTTPS protocol is enabled and\n        when the value is set to False, the HTTPS protocol is disabled.\n        By default, when eAPI is first configured, the HTTPS protocol is\n        enabled.\n    required: false\n    default: yes\n    choices: ['yes', 'no']\n    aliases: ['enable_http']\n  https_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 443\n  local_http:\n    description:\n      - The C(local_http) argument controls the operating state of the\n        local HTTP transport protocol when eAPI is present in the\n        running-config.  When the value is set to True, the HTTP protocol\n        is enabled and restricted to connections from localhost only.  When\n        the value is set to False, the HTTP local protocol is disabled.\n      - Note is value is independent of the C(http) argument\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_local_http']\n  local_http_port:\n    description:\n      - Configures the HTTP port that will listen for connections when\n        the HTTP transport protocol is enabled.  This argument accepts\n        integer values in the valid range of 1 to 65535.\n    required: false\n    default: 8080\n  socket:\n    description:\n      - The C(socket) argument controls the operating state of the UNIX\n        Domain Socket used to receive eAPI requests.  When the value\n        of this argument is set to True, the UDS will listen for eAPI\n        requests.  When the value is set to False, the UDS will not be\n        available to handle requests.  By default when eAPI is first\n        configured, the UDS is disabled.\n    required: false\n    default: false\n    choices: ['yes', 'no']\n    aliases: ['enable_socket']\n  vrf:\n    description:\n      - The C(vrf) argument will configure eAPI to listen for connections\n        in the specified VRF.  By default, eAPI transports will listen\n        for connections in the global table.  This value requires the\n        VRF to already be created otherwise the task will fail.\n    required: false\n    default: default\n    version_added: \"2.2\"\n  config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    required: false\n    default: nul\n    version_added: \"2.2\"\n  state:\n    description:\n      - The C(state) argument controls the operational state of eAPI\n        on the remote device.  When this argument is set to C(started),\n        eAPI is enabled to receive requests and when this argument is\n        C(stopped), eAPI is disabled and will not receive requests.\n    required: false\n    default: started\n    choices: ['started', 'stopped']\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Enable eAPI access with default configuration\n  eos_eapi:\n    state: started\n\n- name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n  eos_eapi:\n    state: started\n    http: false\n    https_port: 9443\n    local_http: yes\n    local_http_port: 80\n    socket: yes\n\n- name: Shutdown eAPI access\n  eos_eapi:\n    state: stopped\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always\n  type: list\n  sample:\n    - management api http-commands\n    - protocol http port 81\n    - no protocol https\nurls:\n  description: Hash of URL endpoints eAPI is listening on per interface\n  returned: when eAPI is started\n  type: dict\n  sample: {'Management1': ['http://172.26.10.1:80']}\nsession_name:\n  description: The EOS config session name used to load the configuration\n  returned: when changed is True\n  type: str\n  sample: ansible_1479315771\nstart:\n  description: The time the job started\n  returned: always\n  type: str\n  sample: \"2016-11-16 10:38:15.126146\"\nend:\n  description: The time the job ended\n  returned: always\n  type: str\n  sample: \"2016-11-16 10:38:25.595612\"\ndelta:\n  description: The time elapsed to perform all operations\n  returned: always\n  type: str\n  sample: \"0:00:10.469466\"\n\"\"\"\nimport re\n\nfrom ansible.module_utils.local import LocalAnsibleModule\nfrom ansible.module_utils.eos import run_commands, load_config\nfrom ansible.module_utils.six import iteritems\n\ndef validate_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_https_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_local_http_port(value, module):\n    if not 1 <= value <= 65535:\n        module.fail_json(msg='http_port must be between 1 and 65535')\n\ndef validate_vrf(value, module):\n    rc, out, err = run_commands(module, ['show vrf'])\n    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0],re.M)\n    configured_vrfs.append('default')\n    if value not in configured_vrfs:\n        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n\ndef map_obj_to_commands(updates, module):\n    commands = list()\n    want, have = updates\n\n    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n\n    def add(cmd):\n        if 'management api http-commands' not in commands:\n            commands.insert(0, 'management api http-commands')\n        commands.append(cmd)\n\n    if any((needs_update('http'), needs_update('http_port'))):\n        if want['http'] is False:\n            add('no protocol http')\n        else:\n            port = want['http_port'] or 80\n            add('protocol http port %s' % port)\n\n    if any((needs_update('https'), needs_update('https_port'))):\n        if want['https'] is False:\n            add('no protocol https')\n        else:\n            port = want['https_port'] or 443\n            add('protocol https port %s' % port)\n\n    if any((needs_update('local_http'), needs_update('local_http_port'))):\n        if want['local_http'] is False:\n            add('no protocol http localhost')\n        else:\n            port = want['local_http_port'] or 8080\n            add('protocol http localhost port %s' % port)\n\n    if needs_update('vrf'):\n        add('vrf %s' % want['vrf'])\n\n    if needs_update('state'):\n        if want['state'] == 'stopped':\n            add('shutdown')\n        elif want['state'] == 'started':\n            add('no shutdown')\n\n    return commands\n\ndef parse_state(data):\n    if data[0]['enabled']:\n        return 'started'\n    else:\n        return 'stopped'\n\n\ndef map_config_to_obj(module):\n    rc, out, err = run_commands(module, ['show management api http-commands | json'])\n    return {\n        'http': out[0]['httpServer']['configured'],\n        'http_port': out[0]['httpServer']['port'],\n        'https': out[0]['httpsServer']['configured'],\n        'https_port': out[0]['httpsServer']['port'],\n        'local_http': out[0]['localHttpServer']['configured'],\n        'local_http_port': out[0]['localHttpServer']['port'],\n        'socket': out[0]['unixSocketServer']['configured'],\n        'vrf': out[0]['vrf'],\n        'state': parse_state(out)\n    }\n\ndef  map_params_to_obj(module):\n    obj = {\n        'http': module.params['http'],\n        'http_port': module.params['http_port'],\n        'https': module.params['https'],\n        'https_port': module.params['https_port'],\n        'local_http': module.params['local_http'],\n        'local_http_port': module.params['local_http_port'],\n        'socket': module.params['socket'],\n        'vrf': module.params['vrf'],\n        'state': module.params['state']\n    }\n\n    for key, value in iteritems(obj):\n        if value:\n            validator = globals().get('validate_%s' % key)\n            if validator:\n                validator(value, module)\n\n    return obj\n\ndef collect_facts(module, result):\n    rc, out, err = run_commands(module, ['show management api http-commands | json'])\n    facts = dict(eos_eapi_urls=dict())\n    for each in out[0]['urls']:\n        intf, url = each.split(' : ')\n        key = str(intf).strip()\n        if  key not in facts['eos_eapi_urls']:\n            facts['eos_eapi_urls'][key] = list()\n        facts['eos_eapi_urls'][key].append(str(url).strip())\n    result['ansible_facts'] = facts\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        http=dict(aliases=['enable_http'], type='bool'),\n        http_port=dict(type='int'),\n\n        https=dict(aliases=['enable_https'], type='bool'),\n        https_port=dict(type='int'),\n\n        local_http=dict(aliases=['enable_local_http'], type='bool'),\n        local_http_port=dict(type='int'),\n\n        socket=dict(aliases=['enable_socket'], type='bool'),\n\n        vrf=dict(default='default'),\n\n        state=dict(default='started', choices=['stopped', 'started']),\n    )\n\n    module = LocalAnsibleModule(argument_spec=argument_spec,\n                                supports_check_mode=True)\n\n    result = {'changed': False}\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have), module)\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        response = load_config(module, commands, commit=commit)\n        if response.get('diff') and module._diff:\n            result['diff'] = {'prepared': response.get('diff')}\n        result['session_name'] = response.get('session')\n        result['changed'] = True\n\n    collect_facts(module, result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n",
          "file_patch": "@@ -16,10 +16,11 @@\n # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n #\n \n-\n-ANSIBLE_METADATA = {'status': ['preview'],\n-                    'supported_by': 'core',\n-                    'version': '1.0'}\n+ANSIBLE_METADATA = {\n+    'status': ['preview'],\n+    'supported_by': 'core',\n+    'version': '1.0'\n+}\n \n DOCUMENTATION = \"\"\"\n ---\n@@ -37,7 +38,6 @@ description:\n     Unix socket server. Use the options listed below to override the\n     default configuration.\n   - Requires EOS v4.12 or greater.\n-extends_documentation_fragment: eos\n options:\n   http:\n     description:\n@@ -141,18 +141,9 @@ options:\n \"\"\"\n \n EXAMPLES = \"\"\"\n-# Note: examples below use the following provider dict to handle\n-#       transport and authentication to the node.\n-vars:\n-  cli:\n-    host: \"{{ inventory_hostname }}\"\n-    username: admin\n-    password: admin\n-\n - name: Enable eAPI access with default configuration\n   eos_eapi:\n     state: started\n-    provider: \"{{ cli }}\"\n \n - name: Enable eAPI with no HTTP, HTTPS at port 9443, local HTTP at port 80, and socket enabled\n   eos_eapi:\n@@ -162,153 +153,161 @@ vars:\n     local_http: yes\n     local_http_port: 80\n     socket: yes\n-    provider: \"{{ cli }}\"\n \n - name: Shutdown eAPI access\n   eos_eapi:\n     state: stopped\n-    provider: \"{{ cli }}\"\n \"\"\"\n \n RETURN = \"\"\"\n-updates:\n-  description:\n-    - Set of commands to be executed on remote device\n+commands:\n+  description: The list of configuration mode commands to send to the device\n   returned: always\n   type: list\n-  sample: ['management api http-commands', 'shutdown']\n+  sample:\n+    - management api http-commands\n+    - protocol http port 81\n+    - no protocol https\n urls:\n   description: Hash of URL endpoints eAPI is listening on per interface\n   returned: when eAPI is started\n   type: dict\n   sample: {'Management1': ['http://172.26.10.1:80']}\n+session_name:\n+  description: The EOS config session name used to load the configuration\n+  returned: when changed is True\n+  type: str\n+  sample: ansible_1479315771\n+start:\n+  description: The time the job started\n+  returned: always\n+  type: str\n+  sample: \"2016-11-16 10:38:15.126146\"\n+end:\n+  description: The time the job ended\n+  returned: always\n+  type: str\n+  sample: \"2016-11-16 10:38:25.595612\"\n+delta:\n+  description: The time elapsed to perform all operations\n+  returned: always\n+  type: str\n+  sample: \"0:00:10.469466\"\n \"\"\"\n import re\n-import time\n-\n-import ansible.module_utils.eos\n-\n-from ansible.module_utils.basic import get_exception\n-from ansible.module_utils.network import NetworkModule, NetworkError\n-from ansible.module_utils.netcfg import NetworkConfig, dumps\n-\n-PRIVATE_KEYS_RE = re.compile('__.+__')\n-\n-\n-def invoke(name, *args, **kwargs):\n-    func = globals().get(name)\n-    if func:\n-        return func(*args, **kwargs)\n-\n-def get_instance(module):\n-    try:\n-        resp = module.cli('show management api http-commands', 'json')\n-        return dict(\n-            http=resp[0]['httpServer']['configured'],\n-            http_port=resp[0]['httpServer']['port'],\n-            https=resp[0]['httpsServer']['configured'],\n-            https_port=resp[0]['httpsServer']['port'],\n-            local_http=resp[0]['localHttpServer']['configured'],\n-            local_http_port=resp[0]['localHttpServer']['port'],\n-            socket=resp[0]['unixSocketServer']['configured'],\n-            vrf=resp[0]['vrf']\n-        )\n-    except NetworkError:\n-        exc = get_exception()\n-        module.fail_json(msg=str(exc), **exc.kwargs)\n-\n-def started(module, instance, commands):\n-    commands.append('no shutdown')\n-    setters = set()\n-    for key, value in module.argument_spec.items():\n-        if module.params[key] is not None:\n-            setter = value.get('setter') or 'set_%s' % key\n-            if setter not in setters:\n-                setters.add(setter)\n-            invoke(setter, module, instance, commands)\n-\n-def stopped(module, instance, commands):\n-    commands.append('shutdown')\n-\n-def set_protocol_http(module, instance, commands):\n-    port = module.params['http_port']\n-    if not 1 <= port <= 65535:\n+\n+from ansible.module_utils.local import LocalAnsibleModule\n+from ansible.module_utils.eos import run_commands, load_config\n+from ansible.module_utils.six import iteritems\n+\n+def validate_http_port(value, module):\n+    if not 1 <= value <= 65535:\n         module.fail_json(msg='http_port must be between 1 and 65535')\n-    elif any((module.params['http'], instance['http'])):\n-        commands.append('protocol http port %s' % port)\n-    elif module.params['http'] is False:\n-        commands.append('no protocol http')\n-\n-def set_protocol_https(module, instance, commands):\n-    port = module.params['https_port']\n-    if not 1 <= port <= 65535:\n-        module.fail_json(msg='https_port must be between 1 and 65535')\n-    elif any((module.params['https'], instance['https'])):\n-        commands.append('protocol https port %s' % port)\n-    elif module.params['https'] is False:\n-        commands.append('no protocol https')\n-\n-def set_local_http(module, instance, commands):\n-    port = module.params['local_http_port']\n-    if not 1 <= port <= 65535:\n-        module.fail_json(msg='local_http_port must be between 1 and 65535')\n-    elif any((module.params['local_http'], instance['local_http'])):\n-        commands.append('protocol http localhost port %s' % port)\n-    elif module.params['local_http'] is False:\n-        commands.append('no protocol http localhost port 8080')\n-\n-def set_socket(module, instance, commands):\n-    if any((module.params['socket'], instance['socket'])):\n-        commands.append('protocol unix-socket')\n-    elif module.params['socket'] is False:\n-        commands.append('no protocol unix-socket')\n-\n-def set_vrf(module, instance, commands):\n-    vrf = module.params['vrf']\n-    if vrf != 'default':\n-        resp = module.cli(['show vrf'])\n-        if vrf not in resp[0]:\n-            module.fail_json(msg=\"vrf '%s' is not configured\" % vrf)\n-    commands.append('vrf %s' % vrf)\n-\n-def get_config(module):\n-    contents = module.params['config']\n-    if not contents:\n-        cmd = 'show running-config all section management api http-commands'\n-        contents = module.cli([cmd])\n-    config = NetworkConfig(indent=3, contents=contents[0])\n-    return config\n-\n-def load_config(module, instance, commands, result):\n-    commit = not module.check_mode\n-    diff = module.config.load_config(commands, commit=commit)\n-    if diff:\n-        result['diff'] = dict(prepared=diff)\n-        result['changed'] = True\n \n-def load(module, instance, commands, result):\n-    candidate = NetworkConfig(indent=3)\n-    candidate.add(commands, parents=['management api http-commands'])\n+def validate_https_port(value, module):\n+    if not 1 <= value <= 65535:\n+        module.fail_json(msg='http_port must be between 1 and 65535')\n \n-    config = get_config(module)\n-    configobjs = candidate.difference(config)\n+def validate_local_http_port(value, module):\n+    if not 1 <= value <= 65535:\n+        module.fail_json(msg='http_port must be between 1 and 65535')\n \n-    if configobjs:\n-        commands = dumps(configobjs, 'commands').split('\\n')\n-        result['updates'] = commands\n-        load_config(module, instance, commands, result)\n+def validate_vrf(value, module):\n+    rc, out, err = run_commands(module, ['show vrf'])\n+    configured_vrfs = re.findall('^\\s+(\\w+)(?=\\s)', out[0],re.M)\n+    configured_vrfs.append('default')\n+    if value not in configured_vrfs:\n+        module.fail_json(msg='vrf `%s` is not configured on the system' % value)\n \n-def clean_result(result):\n-    # strip out any keys that have two leading and two trailing\n-    # underscore characters\n-    for key in result.keys():\n-        if PRIVATE_KEYS_RE.match(key):\n-            del result[key]\n+def map_obj_to_commands(updates, module):\n+    commands = list()\n+    want, have = updates\n+\n+    needs_update = lambda x: want.get(x) is not None and (want.get(x) != have.get(x))\n+\n+    def add(cmd):\n+        if 'management api http-commands' not in commands:\n+            commands.insert(0, 'management api http-commands')\n+        commands.append(cmd)\n+\n+    if any((needs_update('http'), needs_update('http_port'))):\n+        if want['http'] is False:\n+            add('no protocol http')\n+        else:\n+            port = want['http_port'] or 80\n+            add('protocol http port %s' % port)\n+\n+    if any((needs_update('https'), needs_update('https_port'))):\n+        if want['https'] is False:\n+            add('no protocol https')\n+        else:\n+            port = want['https_port'] or 443\n+            add('protocol https port %s' % port)\n+\n+    if any((needs_update('local_http'), needs_update('local_http_port'))):\n+        if want['local_http'] is False:\n+            add('no protocol http localhost')\n+        else:\n+            port = want['local_http_port'] or 8080\n+            add('protocol http localhost port %s' % port)\n+\n+    if needs_update('vrf'):\n+        add('vrf %s' % want['vrf'])\n+\n+    if needs_update('state'):\n+        if want['state'] == 'stopped':\n+            add('shutdown')\n+        elif want['state'] == 'started':\n+            add('no shutdown')\n+\n+    return commands\n+\n+def parse_state(data):\n+    if data[0]['enabled']:\n+        return 'started'\n+    else:\n+        return 'stopped'\n+\n+\n+def map_config_to_obj(module):\n+    rc, out, err = run_commands(module, ['show management api http-commands | json'])\n+    return {\n+        'http': out[0]['httpServer']['configured'],\n+        'http_port': out[0]['httpServer']['port'],\n+        'https': out[0]['httpsServer']['configured'],\n+        'https_port': out[0]['httpsServer']['port'],\n+        'local_http': out[0]['localHttpServer']['configured'],\n+        'local_http_port': out[0]['localHttpServer']['port'],\n+        'socket': out[0]['unixSocketServer']['configured'],\n+        'vrf': out[0]['vrf'],\n+        'state': parse_state(out)\n+    }\n+\n+def  map_params_to_obj(module):\n+    obj = {\n+        'http': module.params['http'],\n+        'http_port': module.params['http_port'],\n+        'https': module.params['https'],\n+        'https_port': module.params['https_port'],\n+        'local_http': module.params['local_http'],\n+        'local_http_port': module.params['local_http_port'],\n+        'socket': module.params['socket'],\n+        'vrf': module.params['vrf'],\n+        'state': module.params['state']\n+    }\n+\n+    for key, value in iteritems(obj):\n+        if value:\n+            validator = globals().get('validate_%s' % key)\n+            if validator:\n+                validator(value, module)\n+\n+    return obj\n \n def collect_facts(module, result):\n-    resp = module.cli(['show management api http-commands'], output='json')\n+    rc, out, err = run_commands(module, ['show management api http-commands | json'])\n     facts = dict(eos_eapi_urls=dict())\n-    for each in resp[0]['urls']:\n+    for each in out[0]['urls']:\n         intf, url = each.split(' : ')\n         key = str(intf).strip()\n         if  key not in facts['eos_eapi_urls']:\n@@ -316,54 +315,46 @@ def collect_facts(module, result):\n         facts['eos_eapi_urls'][key].append(str(url).strip())\n     result['ansible_facts'] = facts\n \n-\n def main():\n     \"\"\" main entry point for module execution\n     \"\"\"\n-\n     argument_spec = dict(\n-        http=dict(aliases=['enable_http'], default=False, type='bool', setter='set_protocol_http'),\n-        http_port=dict(default=80, type='int', setter='set_protocol_http'),\n+        http=dict(aliases=['enable_http'], type='bool'),\n+        http_port=dict(type='int'),\n \n-        https=dict(aliases=['enable_https'], default=True, type='bool', setter='set_protocol_https'),\n-        https_port=dict(default=443, type='int', setter='set_protocol_https'),\n+        https=dict(aliases=['enable_https'], type='bool'),\n+        https_port=dict(type='int'),\n \n-        local_http=dict(aliases=['enable_local_http'], default=False, type='bool', setter='set_local_http'),\n-        local_http_port=dict(default=8080, type='int', setter='set_local_http'),\n+        local_http=dict(aliases=['enable_local_http'], type='bool'),\n+        local_http_port=dict(type='int'),\n \n-        socket=dict(aliases=['enable_socket'], default=False, type='bool'),\n+        socket=dict(aliases=['enable_socket'], type='bool'),\n \n         vrf=dict(default='default'),\n \n-        config=dict(),\n-\n-        # Only allow use of transport cli when configuring eAPI\n-        transport=dict(default='cli', choices=['cli']),\n-\n         state=dict(default='started', choices=['stopped', 'started']),\n     )\n \n-    module = NetworkModule(argument_spec=argument_spec,\n-                           connect_on_load=False,\n-                           supports_check_mode=True)\n-\n-    state = module.params['state']\n+    module = LocalAnsibleModule(argument_spec=argument_spec,\n+                                supports_check_mode=True)\n \n-    result = dict(changed=False)\n+    result = {'changed': False}\n \n-    commands = list()\n-    instance = get_instance(module)\n+    want = map_params_to_obj(module)\n+    have = map_config_to_obj(module)\n \n-    invoke(state, module, instance, commands)\n+    commands = map_obj_to_commands((want, have), module)\n+    result['commands'] = commands\n \n-    try:\n-        load(module, instance, commands, result)\n-    except NetworkError:\n-        exc = get_exception()\n-        module.fail_json(msg=str(exc), **exc.kwargs)\n+    if commands:\n+        commit = not module.check_mode\n+        response = load_config(module, commands, commit=commit)\n+        if response.get('diff') and module._diff:\n+            result['diff'] = {'prepared': response.get('diff')}\n+        result['session_name'] = response.get('session')\n+        result['changed'] = True\n \n     collect_facts(module, result)\n-    clean_result(result)\n \n     module.exit_json(**result)\n \n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "eos_eapi.py",
            "test_eos_eapi.py"
          ]
        }
      }
    }
  }
}
{
  "id": "22",
  "blame_commit": {
    "commit": {
      "commit_id": "29eb5174031cfc0b5de556da3da7761ac377de4e",
      "commit_message": "Add webpage_url_basename info_dict field (Fixes #1938)",
      "commit_author": "Philipp Hagemeister",
      "commit_date": "2013-12-17 04:13:36",
      "commit_parent": "44c471c3b873473157adb8ba8a55667ab54b2602"
    },
    "function": {
      "function_name": "url_basename",
      "function_code_before": "",
      "function_code_after": "def url_basename(url):\n    m = re.match('(?:https?:|)//[^/]+/(?:[^/?#]+/)?([^/?#]+)/?(?:[?#]|$)', url)\n    if not m:\n        return u''\n    return m.group(1)",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 1089,
      "function_after_end_line": 1093,
      "function_before_token_count": 0,
      "function_after_token_count": 30,
      "functions_name_modified_file": [
        "shell_quote",
        "str_to_int",
        "compat_ord",
        "write_string",
        "read",
        "find_startpos",
        "deflate",
        "platform_name",
        "write",
        "remove_start",
        "clean_html",
        "fix_xml_all_ampersand",
        "_unquote",
        "make_HTTPS_handler",
        "handle_starttag",
        "sanitize_open",
        "format_traceback",
        "unified_strdate",
        "determine_ext",
        "__exit__",
        "error",
        "unsmuggle_url",
        "__enter__",
        "__iter__",
        "format_bytes",
        "__contains__",
        "bytes_to_intlist",
        "month_by_name",
        "unescapeHTML",
        "loads",
        "get_cachedir",
        "takewhile_inclusive",
        "get_result",
        "_parse_qsl",
        "handle_endtag",
        "url_basename",
        "timeconvert",
        "addinfourl_wrapper",
        "_unlock_file",
        "date_from_str",
        "encodeFilename",
        "setproctitle",
        "xpath_with_ns",
        "__str__",
        "sanitize_filename",
        "get_element_by_attribute",
        "__init",
        "day",
        "_lock_file",
        "htmlentity_transform",
        "find_xpath_attr",
        "preferredencoding",
        "__init__",
        "get_meta_content",
        "get_term_width",
        "http_request",
        "smuggle_url",
        "write_json_file",
        "get_element_by_id",
        "decodeOption",
        "intlist_to_bytes",
        "http_response",
        "compat_print",
        "orderedSet",
        "compat_parse_qs",
        "subtitles_filename",
        "formatSeconds"
      ],
      "functions_name_all_files": [
        "list_formats",
        "str_to_int",
        "to_stderr",
        "deflate",
        "test_unescape_html",
        "_setup_opener",
        "remove_start",
        "clean_html",
        "format_bytes",
        "urlopen",
        "error",
        "unsmuggle_url",
        "month_by_name",
        "takewhile_inclusive",
        "add_post_processor",
        "_parse_qsl",
        "handle_endtag",
        "prepare_filename",
        "sanitize_filename",
        "test_shell_quote",
        "save_console_title",
        "_match_entry",
        "get_meta_content",
        "__init__",
        "preferredencoding",
        "download",
        "write_json_file",
        "test_xpath_with_ns",
        "decodeOption",
        "http_response",
        "compat_print",
        "test_smuggle_url",
        "select_format",
        "record_download_archive",
        "write_string",
        "extract_info",
        "in_download_archive",
        "platform_name",
        "write",
        "fix_xml_all_ampersand",
        "_unquote",
        "format_traceback",
        "sanitize_open",
        "add_default_info_extractors",
        "__contains__",
        "process_ie_result",
        "post_process",
        "test_ordered_set",
        "addinfourl_wrapper",
        "to_console_title",
        "to_screen",
        "__str__",
        "day",
        "_lock_file",
        "htmlentity_transform",
        "print_debug_header",
        "add_info_extractor",
        "test_url_basename",
        "shell_quote",
        "smuggle_url",
        "orderedSet",
        "test_sanitize_ids",
        "subtitles_filename",
        "test_sanitize_filename_restricted",
        "compat_ord",
        "test_meta_parser",
        "read",
        "find_startpos",
        "_make_archive_id",
        "__enter__",
        "trouble",
        "increment_downloads",
        "bytes_to_intlist",
        "process_info",
        "unescapeHTML",
        "loads",
        "test_find_xpath_attr",
        "encodeFilename",
        "find_xpath_attr",
        "get_info_extractor",
        "_bidi_workaround",
        "process_video_result",
        "formatSeconds",
        "test_daterange",
        "add_extra_info",
        "test_str_to_int",
        "restore_console_title",
        "report_warning",
        "make_HTTPS_handler",
        "handle_starttag",
        "unified_strdate",
        "__exit__",
        "determine_ext",
        "__iter__",
        "test_unified_dates",
        "get_cachedir",
        "get_result",
        "url_basename",
        "timeconvert",
        "_unlock_file",
        "date_from_str",
        "setproctitle",
        "xpath_with_ns",
        "get_element_by_attribute",
        "__init",
        "test_sanitize_filename",
        "download_with_info_file",
        "report_error",
        "format_resolution",
        "http_request",
        "test_timeconvert",
        "get_term_width",
        "get_element_by_id",
        "intlist_to_bytes",
        "report_file_already_downloaded",
        "compat_parse_qs",
        "to_stdout"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_url_basename",
        "process_ie_result",
        "extract_info"
      ]
    },
    "file": {
      "file_name": "utils.py",
      "file_nloc": 843,
      "file_complexity": 236,
      "file_token_count": 5429,
      "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport ctypes\nimport datetime\nimport email.utils\nimport errno\nimport gzip\nimport io\nimport json\nimport locale\nimport math\nimport os\nimport pipes\nimport platform\nimport re\nimport ssl\nimport socket\nimport subprocess\nimport sys\nimport traceback\nimport zlib\n\ntry:\n    import urllib.request as compat_urllib_request\nexcept ImportError: # Python 2\n    import urllib2 as compat_urllib_request\n\ntry:\n    import urllib.error as compat_urllib_error\nexcept ImportError: # Python 2\n    import urllib2 as compat_urllib_error\n\ntry:\n    import urllib.parse as compat_urllib_parse\nexcept ImportError: # Python 2\n    import urllib as compat_urllib_parse\n\ntry:\n    from urllib.parse import urlparse as compat_urllib_parse_urlparse\nexcept ImportError: # Python 2\n    from urlparse import urlparse as compat_urllib_parse_urlparse\n\ntry:\n    import urllib.parse as compat_urlparse\nexcept ImportError: # Python 2\n    import urlparse as compat_urlparse\n\ntry:\n    import http.cookiejar as compat_cookiejar\nexcept ImportError: # Python 2\n    import cookielib as compat_cookiejar\n\ntry:\n    import html.entities as compat_html_entities\nexcept ImportError: # Python 2\n    import htmlentitydefs as compat_html_entities\n\ntry:\n    import html.parser as compat_html_parser\nexcept ImportError: # Python 2\n    import HTMLParser as compat_html_parser\n\ntry:\n    import http.client as compat_http_client\nexcept ImportError: # Python 2\n    import httplib as compat_http_client\n\ntry:\n    from urllib.error import HTTPError as compat_HTTPError\nexcept ImportError:  # Python 2\n    from urllib2 import HTTPError as compat_HTTPError\n\ntry:\n    from urllib.request import urlretrieve as compat_urlretrieve\nexcept ImportError:  # Python 2\n    from urllib import urlretrieve as compat_urlretrieve\n\n\ntry:\n    from subprocess import DEVNULL\n    compat_subprocess_get_DEVNULL = lambda: DEVNULL\nexcept ImportError:\n    compat_subprocess_get_DEVNULL = lambda: open(os.path.devnull, 'w')\n\ntry:\n    from urllib.parse import parse_qs as compat_parse_qs\nexcept ImportError: # Python 2\n    # HACK: The following is the correct parse_qs implementation from cpython 3's stdlib.\n    # Python 2's version is apparently totally broken\n    def _unquote(string, encoding='utf-8', errors='replace'):\n        if string == '':\n            return string\n        res = string.split('%')\n        if len(res) == 1:\n            return string\n        if encoding is None:\n            encoding = 'utf-8'\n        if errors is None:\n            errors = 'replace'\n        # pct_sequence: contiguous sequence of percent-encoded bytes, decoded\n        pct_sequence = b''\n        string = res[0]\n        for item in res[1:]:\n            try:\n                if not item:\n                    raise ValueError\n                pct_sequence += item[:2].decode('hex')\n                rest = item[2:]\n                if not rest:\n                    # This segment was just a single percent-encoded character.\n                    # May be part of a sequence of code units, so delay decoding.\n                    # (Stored in pct_sequence).\n                    continue\n            except ValueError:\n                rest = '%' + item\n            # Encountered non-percent-encoded characters. Flush the current\n            # pct_sequence.\n            string += pct_sequence.decode(encoding, errors) + rest\n            pct_sequence = b''\n        if pct_sequence:\n            # Flush the final pct_sequence\n            string += pct_sequence.decode(encoding, errors)\n        return string\n\n    def _parse_qsl(qs, keep_blank_values=False, strict_parsing=False,\n                encoding='utf-8', errors='replace'):\n        qs, _coerce_result = qs, unicode\n        pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n        r = []\n        for name_value in pairs:\n            if not name_value and not strict_parsing:\n                continue\n            nv = name_value.split('=', 1)\n            if len(nv) != 2:\n                if strict_parsing:\n                    raise ValueError(\"bad query field: %r\" % (name_value,))\n                # Handle case of a control-name with no equal sign\n                if keep_blank_values:\n                    nv.append('')\n                else:\n                    continue\n            if len(nv[1]) or keep_blank_values:\n                name = nv[0].replace('+', ' ')\n                name = _unquote(name, encoding=encoding, errors=errors)\n                name = _coerce_result(name)\n                value = nv[1].replace('+', ' ')\n                value = _unquote(value, encoding=encoding, errors=errors)\n                value = _coerce_result(value)\n                r.append((name, value))\n        return r\n\n    def compat_parse_qs(qs, keep_blank_values=False, strict_parsing=False,\n                encoding='utf-8', errors='replace'):\n        parsed_result = {}\n        pairs = _parse_qsl(qs, keep_blank_values, strict_parsing,\n                        encoding=encoding, errors=errors)\n        for name, value in pairs:\n            if name in parsed_result:\n                parsed_result[name].append(value)\n            else:\n                parsed_result[name] = [value]\n        return parsed_result\n\ntry:\n    compat_str = unicode # Python 2\nexcept NameError:\n    compat_str = str\n\ntry:\n    compat_chr = unichr # Python 2\nexcept NameError:\n    compat_chr = chr\n\ndef compat_ord(c):\n    if type(c) is int: return c\n    else: return ord(c)\n\n# This is not clearly defined otherwise\ncompiled_regex_type = type(re.compile(''))\n\nstd_headers = {\n    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0 (Chrome)',\n    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Encoding': 'gzip, deflate',\n    'Accept-Language': 'en-us,en;q=0.5',\n}\n\ndef preferredencoding():\n    \"\"\"Get preferred encoding.\n\n    Returns the best encoding scheme for the system, based on\n    locale.getpreferredencoding() and some further tweaks.\n    \"\"\"\n    try:\n        pref = locale.getpreferredencoding()\n        u'TEST'.encode(pref)\n    except:\n        pref = 'UTF-8'\n\n    return pref\n\nif sys.version_info < (3,0):\n    def compat_print(s):\n        print(s.encode(preferredencoding(), 'xmlcharrefreplace'))\nelse:\n    def compat_print(s):\n        assert type(s) == type(u'')\n        print(s)\n\n# In Python 2.x, json.dump expects a bytestream.\n# In Python 3.x, it writes to a character stream\nif sys.version_info < (3,0):\n    def write_json_file(obj, fn):\n        with open(fn, 'wb') as f:\n            json.dump(obj, f)\nelse:\n    def write_json_file(obj, fn):\n        with open(fn, 'w', encoding='utf-8') as f:\n            json.dump(obj, f)\n\nif sys.version_info >= (2,7):\n    def find_xpath_attr(node, xpath, key, val):\n        \"\"\" Find the xpath xpath[@key=val] \"\"\"\n        assert re.match(r'^[a-zA-Z]+$', key)\n        assert re.match(r'^[a-zA-Z0-9@\\s]*$', val)\n        expr = xpath + u\"[@%s='%s']\" % (key, val)\n        return node.find(expr)\nelse:\n    def find_xpath_attr(node, xpath, key, val):\n        for f in node.findall(xpath):\n            if f.attrib.get(key) == val:\n                return f\n        return None\n\n# On python2.6 the xml.etree.ElementTree.Element methods don't support\n# the namespace parameter\ndef xpath_with_ns(path, ns_map):\n    components = [c.split(':') for c in path.split('/')]\n    replaced = []\n    for c in components:\n        if len(c) == 1:\n            replaced.append(c[0])\n        else:\n            ns, tag = c\n            replaced.append('{%s}%s' % (ns_map[ns], tag))\n    return '/'.join(replaced)\n\ndef htmlentity_transform(matchobj):\n    \"\"\"Transforms an HTML entity to a character.\n\n    This function receives a match object and is intended to be used with\n    the re.sub() function.\n    \"\"\"\n    entity = matchobj.group(1)\n\n    # Known non-numeric HTML entity\n    if entity in compat_html_entities.name2codepoint:\n        return compat_chr(compat_html_entities.name2codepoint[entity])\n\n    mobj = re.match(u'(?u)#(x?\\\\d+)', entity)\n    if mobj is not None:\n        numstr = mobj.group(1)\n        if numstr.startswith(u'x'):\n            base = 16\n            numstr = u'0%s' % numstr\n        else:\n            base = 10\n        return compat_chr(int(numstr, base))\n\n    # Unknown entity in name, return its literal representation\n    return (u'&%s;' % entity)\n\ncompat_html_parser.locatestarttagend = re.compile(r\"\"\"<[a-zA-Z][-.a-zA-Z0-9:_]*(?:\\s+(?:(?<=['\"\\s])[^\\s/>][^\\s/=>]*(?:\\s*=+\\s*(?:'[^']*'|\"[^\"]*\"|(?!['\"])[^>\\s]*))?\\s*)*)?\\s*\"\"\", re.VERBOSE) # backport bugfix\nclass BaseHTMLParser(compat_html_parser.HTMLParser):\n    def __init(self):\n        compat_html_parser.HTMLParser.__init__(self)\n        self.html = None\n\n    def loads(self, html):\n        self.html = html\n        self.feed(html)\n        self.close()\n\nclass AttrParser(BaseHTMLParser):\n    \"\"\"Modified HTMLParser that isolates a tag with the specified attribute\"\"\"\n    def __init__(self, attribute, value):\n        self.attribute = attribute\n        self.value = value\n        self.result = None\n        self.started = False\n        self.depth = {}\n        self.watch_startpos = False\n        self.error_count = 0\n        BaseHTMLParser.__init__(self)\n\n    def error(self, message):\n        if self.error_count > 10 or self.started:\n            raise compat_html_parser.HTMLParseError(message, self.getpos())\n        self.rawdata = '\\n'.join(self.html.split('\\n')[self.getpos()[0]:]) # skip one line\n        self.error_count += 1\n        self.goahead(1)\n\n    def handle_starttag(self, tag, attrs):\n        attrs = dict(attrs)\n        if self.started:\n            self.find_startpos(None)\n        if self.attribute in attrs and attrs[self.attribute] == self.value:\n            self.result = [tag]\n            self.started = True\n            self.watch_startpos = True\n        if self.started:\n            if not tag in self.depth: self.depth[tag] = 0\n            self.depth[tag] += 1\n\n    def handle_endtag(self, tag):\n        if self.started:\n            if tag in self.depth: self.depth[tag] -= 1\n            if self.depth[self.result[0]] == 0:\n                self.started = False\n                self.result.append(self.getpos())\n\n    def find_startpos(self, x):\n        \"\"\"Needed to put the start position of the result (self.result[1])\n        after the opening tag with the requested id\"\"\"\n        if self.watch_startpos:\n            self.watch_startpos = False\n            self.result.append(self.getpos())\n    handle_entityref = handle_charref = handle_data = handle_comment = \\\n    handle_decl = handle_pi = unknown_decl = find_startpos\n\n    def get_result(self):\n        if self.result is None:\n            return None\n        if len(self.result) != 3:\n            return None\n        lines = self.html.split('\\n')\n        lines = lines[self.result[1][0]-1:self.result[2][0]]\n        lines[0] = lines[0][self.result[1][1]:]\n        if len(lines) == 1:\n            lines[-1] = lines[-1][:self.result[2][1]-self.result[1][1]]\n        lines[-1] = lines[-1][:self.result[2][1]]\n        return '\\n'.join(lines).strip()\n# Hack for https://github.com/rg3/youtube-dl/issues/662\nif sys.version_info < (2, 7, 3):\n    AttrParser.parse_endtag = (lambda self, i:\n        i + len(\"</scr'+'ipt>\")\n        if self.rawdata[i:].startswith(\"</scr'+'ipt>\")\n        else compat_html_parser.HTMLParser.parse_endtag(self, i))\n\ndef get_element_by_id(id, html):\n    \"\"\"Return the content of the tag with the specified ID in the passed HTML document\"\"\"\n    return get_element_by_attribute(\"id\", id, html)\n\ndef get_element_by_attribute(attribute, value, html):\n    \"\"\"Return the content of the tag with the specified attribute in the passed HTML document\"\"\"\n    parser = AttrParser(attribute, value)\n    try:\n        parser.loads(html)\n    except compat_html_parser.HTMLParseError:\n        pass\n    return parser.get_result()\n\nclass MetaParser(BaseHTMLParser):\n    \"\"\"\n    Modified HTMLParser that isolates a meta tag with the specified name \n    attribute.\n    \"\"\"\n    def __init__(self, name):\n        BaseHTMLParser.__init__(self)\n        self.name = name\n        self.content = None\n        self.result = None\n\n    def handle_starttag(self, tag, attrs):\n        if tag != 'meta':\n            return\n        attrs = dict(attrs)\n        if attrs.get('name') == self.name:\n            self.result = attrs.get('content')\n\n    def get_result(self):\n        return self.result\n\ndef get_meta_content(name, html):\n    \"\"\"\n    Return the content attribute from the meta tag with the given name attribute.\n    \"\"\"\n    parser = MetaParser(name)\n    try:\n        parser.loads(html)\n    except compat_html_parser.HTMLParseError:\n        pass\n    return parser.get_result()\n\n\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n    # Newline vs <br />\n    html = html.replace('\\n', ' ')\n    html = re.sub(r'\\s*<\\s*br\\s*/?\\s*>\\s*', '\\n', html)\n    html = re.sub(r'<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>', '\\n', html)\n    # Strip html tags\n    html = re.sub('<.*?>', '', html)\n    # Replace html entities\n    html = unescapeHTML(html)\n    return html.strip()\n\n\ndef sanitize_open(filename, open_mode):\n    \"\"\"Try to open the given filename, and slightly tweak it if this fails.\n\n    Attempts to open the given filename. If this fails, it tries to change\n    the filename slightly, step by step, until it's either able to open it\n    or it fails and raises a final exception, like the standard open()\n    function.\n\n    It returns the tuple (stream, definitive_file_name).\n    \"\"\"\n    try:\n        if filename == u'-':\n            if sys.platform == 'win32':\n                import msvcrt\n                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n            return (sys.stdout.buffer if hasattr(sys.stdout, 'buffer') else sys.stdout, filename)\n        stream = open(encodeFilename(filename), open_mode)\n        return (stream, filename)\n    except (IOError, OSError) as err:\n        if err.errno in (errno.EACCES,):\n            raise\n\n        # In case of error, try to remove win32 forbidden chars\n        alt_filename = os.path.join(\n                        re.sub(u'[/<>:\"\\\\|\\\\\\\\?\\\\*]', u'#', path_part)\n                        for path_part in os.path.split(filename)\n                       )\n        if alt_filename == filename:\n            raise\n        else:\n            # An exception here should be caught in the caller\n            stream = open(encodeFilename(filename), open_mode)\n            return (stream, alt_filename)\n\n\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp\n\ndef sanitize_filename(s, restricted=False, is_id=False):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    If restricted is set, use a stricter subset of allowed characters.\n    Set is_id if this is not an arbitrary string, but an ID that should be kept if possible\n    \"\"\"\n    def replace_insane(char):\n        if char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else '\\''\n        elif char == ':':\n            return '_-' if restricted else ' -'\n        elif char in '\\\\/|*<>':\n            return '_'\n        if restricted and (char in '!&\\'()[]{}$;`^,#' or char.isspace()):\n            return '_'\n        if restricted and ord(char) > 127:\n            return '_'\n        return char\n\n    result = u''.join(map(replace_insane, s))\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        # Common case of \"Foreign band name - English song title\"\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if not result:\n            result = '_'\n    return result\n\ndef orderedSet(iterable):\n    \"\"\" Remove all duplicates from the input iterable \"\"\"\n    res = []\n    for el in iterable:\n        if el not in res:\n            res.append(el)\n    return res\n\ndef unescapeHTML(s):\n    \"\"\"\n    @param s a string\n    \"\"\"\n    assert type(s) == type(u'')\n\n    result = re.sub(u'(?u)&(.+?);', htmlentity_transform, s)\n    return result\n\ndef encodeFilename(s):\n    \"\"\"\n    @param s The name of the file\n    \"\"\"\n\n    assert type(s) == type(u'')\n\n    # Python 3 has a Unicode API\n    if sys.version_info >= (3, 0):\n        return s\n\n    if sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        # Pass u'' directly to use Unicode APIs on Windows 2000 and up\n        # (Detecting Windows NT 4 is tricky because 'major >= 4' would\n        # match Windows 9x series as well. Besides, NT 4 is obsolete.)\n        return s\n    else:\n        encoding = sys.getfilesystemencoding()\n        if encoding is None:\n            encoding = 'utf-8'\n        return s.encode(encoding, 'ignore')\n\ndef decodeOption(optval):\n    if optval is None:\n        return optval\n    if isinstance(optval, bytes):\n        optval = optval.decode(preferredencoding())\n\n    assert isinstance(optval, compat_str)\n    return optval\n\ndef formatSeconds(secs):\n    if secs > 3600:\n        return '%d:%02d:%02d' % (secs // 3600, (secs % 3600) // 60, secs % 60)\n    elif secs > 60:\n        return '%d:%02d' % (secs // 60, secs % 60)\n    else:\n        return '%d' % secs\n\ndef make_HTTPS_handler(opts_no_check_certificate):\n    if sys.version_info < (3, 2):\n        import httplib\n\n        class HTTPSConnectionV3(httplib.HTTPSConnection):\n            def __init__(self, *args, **kwargs):\n                httplib.HTTPSConnection.__init__(self, *args, **kwargs)\n\n            def connect(self):\n                sock = socket.create_connection((self.host, self.port), self.timeout)\n                if getattr(self, '_tunnel_host', False):\n                    self.sock = sock\n                    self._tunnel()\n                try:\n                    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_SSLv3)\n                except ssl.SSLError:\n                    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_SSLv23)\n\n        class HTTPSHandlerV3(compat_urllib_request.HTTPSHandler):\n            def https_open(self, req):\n                return self.do_open(HTTPSConnectionV3, req)\n        return HTTPSHandlerV3()\n    else:\n        context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        context.verify_mode = (ssl.CERT_NONE\n                               if opts_no_check_certificate\n                               else ssl.CERT_REQUIRED)\n        context.set_default_verify_paths()\n        try:\n            context.load_default_certs()\n        except AttributeError:\n            pass  # Python < 3.4\n        return compat_urllib_request.HTTPSHandler(context=context)\n\nclass ExtractorError(Exception):\n    \"\"\"Error during info extraction.\"\"\"\n    def __init__(self, msg, tb=None, expected=False, cause=None):\n        \"\"\" tb, if given, is the original traceback (so that it can be printed out).\n        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.\n        \"\"\"\n\n        if sys.exc_info()[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError):\n            expected = True\n        if not expected:\n            msg = msg + u'; please report this issue on https://yt-dl.org/bug . Be sure to call youtube-dl with the --verbose flag and include its complete output. Make sure you are using the latest version; type  youtube-dl -U  to update.'\n        super(ExtractorError, self).__init__(msg)\n\n        self.traceback = tb\n        self.exc_info = sys.exc_info()  # preserve original exception\n        self.cause = cause\n\n    def format_traceback(self):\n        if self.traceback is None:\n            return None\n        return u''.join(traceback.format_tb(self.traceback))\n\n\nclass RegexNotFoundError(ExtractorError):\n    \"\"\"Error when a regex didn't match\"\"\"\n    pass\n\n\nclass DownloadError(Exception):\n    \"\"\"Download Error exception.\n\n    This exception may be thrown by FileDownloader objects if they are not\n    configured to continue on errors. They will contain the appropriate\n    error message.\n    \"\"\"\n    def __init__(self, msg, exc_info=None):\n        \"\"\" exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). \"\"\"\n        super(DownloadError, self).__init__(msg)\n        self.exc_info = exc_info\n\n\nclass SameFileError(Exception):\n    \"\"\"Same File exception.\n\n    This exception will be thrown by FileDownloader objects if they detect\n    multiple files would have to be downloaded to the same file on disk.\n    \"\"\"\n    pass\n\n\nclass PostProcessingError(Exception):\n    \"\"\"Post Processing exception.\n\n    This exception may be raised by PostProcessor's .run() method to\n    indicate an error in the postprocessing task.\n    \"\"\"\n    def __init__(self, msg):\n        self.msg = msg\n\nclass MaxDownloadsReached(Exception):\n    \"\"\" --max-downloads limit has been reached. \"\"\"\n    pass\n\n\nclass UnavailableVideoError(Exception):\n    \"\"\"Unavailable Format exception.\n\n    This exception will be thrown when a video is requested\n    in a format that is not available for that video.\n    \"\"\"\n    pass\n\n\nclass ContentTooShortError(Exception):\n    \"\"\"Content Too Short exception.\n\n    This exception may be raised by FileDownloader objects when a file they\n    download is too small for what the server announced first, indicating\n    the connection was probably interrupted.\n    \"\"\"\n    # Both in bytes\n    downloaded = None\n    expected = None\n\n    def __init__(self, downloaded, expected):\n        self.downloaded = downloaded\n        self.expected = expected\n\nclass YoutubeDLHandler(compat_urllib_request.HTTPHandler):\n    \"\"\"Handler for HTTP requests and responses.\n\n    This class, when installed with an OpenerDirector, automatically adds\n    the standard headers to every HTTP request and handles gzipped and\n    deflated responses from web servers. If compression is to be avoided in\n    a particular request, the original request in the program code only has\n    to include the HTTP header \"Youtubedl-No-Compression\", which will be\n    removed before making the real request.\n\n    Part of this code was copied from:\n\n    http://techknack.net/python-urllib2-handlers/\n\n    Andrew Rowls, the author of that code, agreed to release it to the\n    public domain.\n    \"\"\"\n\n    @staticmethod\n    def deflate(data):\n        try:\n            return zlib.decompress(data, -zlib.MAX_WBITS)\n        except zlib.error:\n            return zlib.decompress(data)\n\n    @staticmethod\n    def addinfourl_wrapper(stream, headers, url, code):\n        if hasattr(compat_urllib_request.addinfourl, 'getcode'):\n            return compat_urllib_request.addinfourl(stream, headers, url, code)\n        ret = compat_urllib_request.addinfourl(stream, headers, url)\n        ret.code = code\n        return ret\n\n    def http_request(self, req):\n        for h,v in std_headers.items():\n            if h in req.headers:\n                del req.headers[h]\n            req.add_header(h, v)\n        if 'Youtubedl-no-compression' in req.headers:\n            if 'Accept-encoding' in req.headers:\n                del req.headers['Accept-encoding']\n            del req.headers['Youtubedl-no-compression']\n        if 'Youtubedl-user-agent' in req.headers:\n            if 'User-agent' in req.headers:\n                del req.headers['User-agent']\n            req.headers['User-agent'] = req.headers['Youtubedl-user-agent']\n            del req.headers['Youtubedl-user-agent']\n        return req\n\n    def http_response(self, req, resp):\n        old_resp = resp\n        # gzip\n        if resp.headers.get('Content-encoding', '') == 'gzip':\n            content = resp.read()\n            gz = gzip.GzipFile(fileobj=io.BytesIO(content), mode='rb')\n            try:\n                uncompressed = io.BytesIO(gz.read())\n            except IOError as original_ioerror:\n                # There may be junk add the end of the file\n                # See http://stackoverflow.com/q/4928560/35070 for details\n                for i in range(1, 1024):\n                    try:\n                        gz = gzip.GzipFile(fileobj=io.BytesIO(content[:-i]), mode='rb')\n                        uncompressed = io.BytesIO(gz.read())\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise original_ioerror\n            resp = self.addinfourl_wrapper(uncompressed, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n        # deflate\n        if resp.headers.get('Content-encoding', '') == 'deflate':\n            gz = io.BytesIO(self.deflate(resp.read()))\n            resp = self.addinfourl_wrapper(gz, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n        return resp\n\n    https_request = http_request\n    https_response = http_response\n\ndef unified_strdate(date_str):\n    \"\"\"Return a string with the date in the format YYYYMMDD\"\"\"\n    upload_date = None\n    #Replace commas\n    date_str = date_str.replace(',',' ')\n    # %z (UTC offset) is only supported in python>=3.2\n    date_str = re.sub(r' (\\+|-)[\\d]*$', '', date_str)\n    format_expressions = [\n        '%d %B %Y',\n        '%B %d %Y',\n        '%b %d %Y',\n        '%Y-%m-%d',\n        '%d/%m/%Y',\n        '%Y/%m/%d %H:%M:%S',\n        '%d.%m.%Y %H:%M',\n        '%Y-%m-%dT%H:%M:%SZ',\n        '%Y-%m-%dT%H:%M:%S.%fZ',\n        '%Y-%m-%dT%H:%M:%S.%f0Z',\n        '%Y-%m-%dT%H:%M:%S',\n    ]\n    for expression in format_expressions:\n        try:\n            upload_date = datetime.datetime.strptime(date_str, expression).strftime('%Y%m%d')\n        except:\n            pass\n    return upload_date\n\ndef determine_ext(url, default_ext=u'unknown_video'):\n    guess = url.partition(u'?')[0].rpartition(u'.')[2]\n    if re.match(r'^[A-Za-z0-9]+$', guess):\n        return guess\n    else:\n        return default_ext\n\ndef subtitles_filename(filename, sub_lang, sub_format):\n    return filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n\ndef date_from_str(date_str):\n    \"\"\"\n    Return a datetime object from a string in the format YYYYMMDD or\n    (now|today)[+-][0-9](day|week|month|year)(s)?\"\"\"\n    today = datetime.date.today()\n    if date_str == 'now'or date_str == 'today':\n        return today\n    match = re.match('(now|today)(?P<sign>[+-])(?P<time>\\d+)(?P<unit>day|week|month|year)(s)?', date_str)\n    if match is not None:\n        sign = match.group('sign')\n        time = int(match.group('time'))\n        if sign == '-':\n            time = -time\n        unit = match.group('unit')\n        #A bad aproximation?\n        if unit == 'month':\n            unit = 'day'\n            time *= 30\n        elif unit == 'year':\n            unit = 'day'\n            time *= 365\n        unit += 's'\n        delta = datetime.timedelta(**{unit: time})\n        return today + delta\n    return datetime.datetime.strptime(date_str, \"%Y%m%d\").date()\n    \nclass DateRange(object):\n    \"\"\"Represents a time interval between two dates\"\"\"\n    def __init__(self, start=None, end=None):\n        \"\"\"start and end must be strings in the format accepted by date\"\"\"\n        if start is not None:\n            self.start = date_from_str(start)\n        else:\n            self.start = datetime.datetime.min.date()\n        if end is not None:\n            self.end = date_from_str(end)\n        else:\n            self.end = datetime.datetime.max.date()\n        if self.start > self.end:\n            raise ValueError('Date range: \"%s\" , the start date must be before the end date' % self)\n    @classmethod\n    def day(cls, day):\n        \"\"\"Returns a range that only contains the given day\"\"\"\n        return cls(day,day)\n    def __contains__(self, date):\n        \"\"\"Check if the date is in the range\"\"\"\n        if not isinstance(date, datetime.date):\n            date = date_from_str(date)\n        return self.start <= date <= self.end\n    def __str__(self):\n        return '%s - %s' % ( self.start.isoformat(), self.end.isoformat())\n\n\ndef platform_name():\n    \"\"\" Returns the platform name as a compat_str \"\"\"\n    res = platform.platform()\n    if isinstance(res, bytes):\n        res = res.decode(preferredencoding())\n\n    assert isinstance(res, compat_str)\n    return res\n\n\ndef write_string(s, out=None):\n    if out is None:\n        out = sys.stderr\n    assert type(s) == type(u'')\n\n    if ('b' in getattr(out, 'mode', '') or\n            sys.version_info[0] < 3):  # Python 2 lies about mode of sys.stderr\n        s = s.encode(preferredencoding(), 'ignore')\n    out.write(s)\n    out.flush()\n\n\ndef bytes_to_intlist(bs):\n    if not bs:\n        return []\n    if isinstance(bs[0], int):  # Python 3\n        return list(bs)\n    else:\n        return [ord(c) for c in bs]\n\n\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    if isinstance(chr(0), bytes):  # Python 2\n        return ''.join([chr(x) for x in xs])\n    else:\n        return bytes(xs)\n\n\ndef get_cachedir(params={}):\n    cache_root = os.environ.get('XDG_CACHE_HOME',\n                                os.path.expanduser('~/.cache'))\n    return params.get('cachedir', os.path.join(cache_root, 'youtube-dl'))\n\n\n# Cross-platform file locking\nif sys.platform == 'win32':\n    import ctypes.wintypes\n    import msvcrt\n\n    class OVERLAPPED(ctypes.Structure):\n        _fields_ = [\n            ('Internal', ctypes.wintypes.LPVOID),\n            ('InternalHigh', ctypes.wintypes.LPVOID),\n            ('Offset', ctypes.wintypes.DWORD),\n            ('OffsetHigh', ctypes.wintypes.DWORD),\n            ('hEvent', ctypes.wintypes.HANDLE),\n        ]\n\n    kernel32 = ctypes.windll.kernel32\n    LockFileEx = kernel32.LockFileEx\n    LockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwFlags\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    LockFileEx.restype = ctypes.wintypes.BOOL\n    UnlockFileEx = kernel32.UnlockFileEx\n    UnlockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    UnlockFileEx.restype = ctypes.wintypes.BOOL\n    whole_low = 0xffffffff\n    whole_high = 0x7fffffff\n\n    def _lock_file(f, exclusive):\n        overlapped = OVERLAPPED()\n        overlapped.Offset = 0\n        overlapped.OffsetHigh = 0\n        overlapped.hEvent = 0\n        f._lock_file_overlapped_p = ctypes.pointer(overlapped)\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not LockFileEx(handle, 0x2 if exclusive else 0x0, 0,\n                          whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Locking file failed: %r' % ctypes.FormatError())\n\n    def _unlock_file(f):\n        assert f._lock_file_overlapped_p\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not UnlockFileEx(handle, 0,\n                            whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Unlocking file failed: %r' % ctypes.FormatError())\n\nelse:\n    import fcntl\n\n    def _lock_file(f, exclusive):\n        fcntl.lockf(f, fcntl.LOCK_EX if exclusive else fcntl.LOCK_SH)\n\n    def _unlock_file(f):\n        fcntl.lockf(f, fcntl.LOCK_UN)\n\n\nclass locked_file(object):\n    def __init__(self, filename, mode, encoding=None):\n        assert mode in ['r', 'a', 'w']\n        self.f = io.open(filename, mode, encoding=encoding)\n        self.mode = mode\n\n    def __enter__(self):\n        exclusive = self.mode != 'r'\n        try:\n            _lock_file(self.f, exclusive)\n        except IOError:\n            self.f.close()\n            raise\n        return self\n\n    def __exit__(self, etype, value, traceback):\n        try:\n            _unlock_file(self.f)\n        finally:\n            self.f.close()\n\n    def __iter__(self):\n        return iter(self.f)\n\n    def write(self, *args):\n        return self.f.write(*args)\n\n    def read(self, *args):\n        return self.f.read(*args)\n\n\ndef shell_quote(args):\n    quoted_args = []\n    encoding = sys.getfilesystemencoding()\n    if encoding is None:\n        encoding = 'utf-8'\n    for a in args:\n        if isinstance(a, bytes):\n            # We may get a filename encoded with 'encodeFilename'\n            a = a.decode(encoding)\n        quoted_args.append(pipes.quote(a))\n    return u' '.join(quoted_args)\n\n\ndef takewhile_inclusive(pred, seq):\n    \"\"\" Like itertools.takewhile, but include the latest evaluated element\n        (the first element so that Not pred(e)) \"\"\"\n    for e in seq:\n        yield e\n        if not pred(e):\n            return\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n\n    sdata = compat_urllib_parse.urlencode(\n        {u'__youtubedl_smuggle': json.dumps(data)})\n    return url + u'#' + sdata\n\n\ndef unsmuggle_url(smug_url):\n    if not '#__youtubedl_smuggle' in smug_url:\n        return smug_url, None\n    url, _, sdata = smug_url.rpartition(u'#')\n    jsond = compat_parse_qs(sdata)[u'__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef format_bytes(bytes):\n    if bytes is None:\n        return u'N/A'\n    if type(bytes) is str:\n        bytes = float(bytes)\n    if bytes == 0.0:\n        exponent = 0\n    else:\n        exponent = int(math.log(bytes, 1024.0))\n    suffix = [u'B', u'KiB', u'MiB', u'GiB', u'TiB', u'PiB', u'EiB', u'ZiB', u'YiB'][exponent]\n    converted = float(bytes) / float(1024 ** exponent)\n    return u'%.2f%s' % (converted, suffix)\n\n\ndef str_to_int(int_str):\n    int_str = re.sub(r'[,\\.]', u'', int_str)\n    return int(int_str)\n\n\ndef get_term_width():\n    columns = os.environ.get('COLUMNS', None)\n    if columns:\n        return int(columns)\n\n    try:\n        sp = subprocess.Popen(\n            ['stty', 'size'],\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = sp.communicate()\n        return int(out.split()[1])\n    except:\n        pass\n    return None\n\n\ndef month_by_name(name):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n\n    ENGLISH_NAMES = [\n        u'January', u'February', u'March', u'April', u'May', u'June',\n        u'July', u'August', u'September', u'October', u'November', u'December']\n    try:\n        return ENGLISH_NAMES.index(name) + 1\n    except ValueError:\n        return None\n\n\ndef fix_xml_all_ampersand(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return xml_str.replace(u'&', u'&amp;')\n\n\ndef setproctitle(title):\n    assert isinstance(title, type(u''))\n    try:\n        libc = ctypes.cdll.LoadLibrary(\"libc.so.6\")\n    except OSError:\n        return\n    title = title\n    buf = ctypes.create_string_buffer(len(title) + 1)\n    buf.value = title.encode('utf-8')\n    try:\n        libc.prctl(15, ctypes.byref(buf), 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    if s.startswith(start):\n        return s[len(start):]\n    return s\n",
      "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport ctypes\nimport datetime\nimport email.utils\nimport errno\nimport gzip\nimport io\nimport json\nimport locale\nimport math\nimport os\nimport pipes\nimport platform\nimport re\nimport ssl\nimport socket\nimport subprocess\nimport sys\nimport traceback\nimport zlib\n\ntry:\n    import urllib.request as compat_urllib_request\nexcept ImportError: # Python 2\n    import urllib2 as compat_urllib_request\n\ntry:\n    import urllib.error as compat_urllib_error\nexcept ImportError: # Python 2\n    import urllib2 as compat_urllib_error\n\ntry:\n    import urllib.parse as compat_urllib_parse\nexcept ImportError: # Python 2\n    import urllib as compat_urllib_parse\n\ntry:\n    from urllib.parse import urlparse as compat_urllib_parse_urlparse\nexcept ImportError: # Python 2\n    from urlparse import urlparse as compat_urllib_parse_urlparse\n\ntry:\n    import urllib.parse as compat_urlparse\nexcept ImportError: # Python 2\n    import urlparse as compat_urlparse\n\ntry:\n    import http.cookiejar as compat_cookiejar\nexcept ImportError: # Python 2\n    import cookielib as compat_cookiejar\n\ntry:\n    import html.entities as compat_html_entities\nexcept ImportError: # Python 2\n    import htmlentitydefs as compat_html_entities\n\ntry:\n    import html.parser as compat_html_parser\nexcept ImportError: # Python 2\n    import HTMLParser as compat_html_parser\n\ntry:\n    import http.client as compat_http_client\nexcept ImportError: # Python 2\n    import httplib as compat_http_client\n\ntry:\n    from urllib.error import HTTPError as compat_HTTPError\nexcept ImportError:  # Python 2\n    from urllib2 import HTTPError as compat_HTTPError\n\ntry:\n    from urllib.request import urlretrieve as compat_urlretrieve\nexcept ImportError:  # Python 2\n    from urllib import urlretrieve as compat_urlretrieve\n\n\ntry:\n    from subprocess import DEVNULL\n    compat_subprocess_get_DEVNULL = lambda: DEVNULL\nexcept ImportError:\n    compat_subprocess_get_DEVNULL = lambda: open(os.path.devnull, 'w')\n\ntry:\n    from urllib.parse import parse_qs as compat_parse_qs\nexcept ImportError: # Python 2\n    # HACK: The following is the correct parse_qs implementation from cpython 3's stdlib.\n    # Python 2's version is apparently totally broken\n    def _unquote(string, encoding='utf-8', errors='replace'):\n        if string == '':\n            return string\n        res = string.split('%')\n        if len(res) == 1:\n            return string\n        if encoding is None:\n            encoding = 'utf-8'\n        if errors is None:\n            errors = 'replace'\n        # pct_sequence: contiguous sequence of percent-encoded bytes, decoded\n        pct_sequence = b''\n        string = res[0]\n        for item in res[1:]:\n            try:\n                if not item:\n                    raise ValueError\n                pct_sequence += item[:2].decode('hex')\n                rest = item[2:]\n                if not rest:\n                    # This segment was just a single percent-encoded character.\n                    # May be part of a sequence of code units, so delay decoding.\n                    # (Stored in pct_sequence).\n                    continue\n            except ValueError:\n                rest = '%' + item\n            # Encountered non-percent-encoded characters. Flush the current\n            # pct_sequence.\n            string += pct_sequence.decode(encoding, errors) + rest\n            pct_sequence = b''\n        if pct_sequence:\n            # Flush the final pct_sequence\n            string += pct_sequence.decode(encoding, errors)\n        return string\n\n    def _parse_qsl(qs, keep_blank_values=False, strict_parsing=False,\n                encoding='utf-8', errors='replace'):\n        qs, _coerce_result = qs, unicode\n        pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n        r = []\n        for name_value in pairs:\n            if not name_value and not strict_parsing:\n                continue\n            nv = name_value.split('=', 1)\n            if len(nv) != 2:\n                if strict_parsing:\n                    raise ValueError(\"bad query field: %r\" % (name_value,))\n                # Handle case of a control-name with no equal sign\n                if keep_blank_values:\n                    nv.append('')\n                else:\n                    continue\n            if len(nv[1]) or keep_blank_values:\n                name = nv[0].replace('+', ' ')\n                name = _unquote(name, encoding=encoding, errors=errors)\n                name = _coerce_result(name)\n                value = nv[1].replace('+', ' ')\n                value = _unquote(value, encoding=encoding, errors=errors)\n                value = _coerce_result(value)\n                r.append((name, value))\n        return r\n\n    def compat_parse_qs(qs, keep_blank_values=False, strict_parsing=False,\n                encoding='utf-8', errors='replace'):\n        parsed_result = {}\n        pairs = _parse_qsl(qs, keep_blank_values, strict_parsing,\n                        encoding=encoding, errors=errors)\n        for name, value in pairs:\n            if name in parsed_result:\n                parsed_result[name].append(value)\n            else:\n                parsed_result[name] = [value]\n        return parsed_result\n\ntry:\n    compat_str = unicode # Python 2\nexcept NameError:\n    compat_str = str\n\ntry:\n    compat_chr = unichr # Python 2\nexcept NameError:\n    compat_chr = chr\n\ndef compat_ord(c):\n    if type(c) is int: return c\n    else: return ord(c)\n\n# This is not clearly defined otherwise\ncompiled_regex_type = type(re.compile(''))\n\nstd_headers = {\n    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0 (Chrome)',\n    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Encoding': 'gzip, deflate',\n    'Accept-Language': 'en-us,en;q=0.5',\n}\n\ndef preferredencoding():\n    \"\"\"Get preferred encoding.\n\n    Returns the best encoding scheme for the system, based on\n    locale.getpreferredencoding() and some further tweaks.\n    \"\"\"\n    try:\n        pref = locale.getpreferredencoding()\n        u'TEST'.encode(pref)\n    except:\n        pref = 'UTF-8'\n\n    return pref\n\nif sys.version_info < (3,0):\n    def compat_print(s):\n        print(s.encode(preferredencoding(), 'xmlcharrefreplace'))\nelse:\n    def compat_print(s):\n        assert type(s) == type(u'')\n        print(s)\n\n# In Python 2.x, json.dump expects a bytestream.\n# In Python 3.x, it writes to a character stream\nif sys.version_info < (3,0):\n    def write_json_file(obj, fn):\n        with open(fn, 'wb') as f:\n            json.dump(obj, f)\nelse:\n    def write_json_file(obj, fn):\n        with open(fn, 'w', encoding='utf-8') as f:\n            json.dump(obj, f)\n\nif sys.version_info >= (2,7):\n    def find_xpath_attr(node, xpath, key, val):\n        \"\"\" Find the xpath xpath[@key=val] \"\"\"\n        assert re.match(r'^[a-zA-Z]+$', key)\n        assert re.match(r'^[a-zA-Z0-9@\\s]*$', val)\n        expr = xpath + u\"[@%s='%s']\" % (key, val)\n        return node.find(expr)\nelse:\n    def find_xpath_attr(node, xpath, key, val):\n        for f in node.findall(xpath):\n            if f.attrib.get(key) == val:\n                return f\n        return None\n\n# On python2.6 the xml.etree.ElementTree.Element methods don't support\n# the namespace parameter\ndef xpath_with_ns(path, ns_map):\n    components = [c.split(':') for c in path.split('/')]\n    replaced = []\n    for c in components:\n        if len(c) == 1:\n            replaced.append(c[0])\n        else:\n            ns, tag = c\n            replaced.append('{%s}%s' % (ns_map[ns], tag))\n    return '/'.join(replaced)\n\ndef htmlentity_transform(matchobj):\n    \"\"\"Transforms an HTML entity to a character.\n\n    This function receives a match object and is intended to be used with\n    the re.sub() function.\n    \"\"\"\n    entity = matchobj.group(1)\n\n    # Known non-numeric HTML entity\n    if entity in compat_html_entities.name2codepoint:\n        return compat_chr(compat_html_entities.name2codepoint[entity])\n\n    mobj = re.match(u'(?u)#(x?\\\\d+)', entity)\n    if mobj is not None:\n        numstr = mobj.group(1)\n        if numstr.startswith(u'x'):\n            base = 16\n            numstr = u'0%s' % numstr\n        else:\n            base = 10\n        return compat_chr(int(numstr, base))\n\n    # Unknown entity in name, return its literal representation\n    return (u'&%s;' % entity)\n\ncompat_html_parser.locatestarttagend = re.compile(r\"\"\"<[a-zA-Z][-.a-zA-Z0-9:_]*(?:\\s+(?:(?<=['\"\\s])[^\\s/>][^\\s/=>]*(?:\\s*=+\\s*(?:'[^']*'|\"[^\"]*\"|(?!['\"])[^>\\s]*))?\\s*)*)?\\s*\"\"\", re.VERBOSE) # backport bugfix\nclass BaseHTMLParser(compat_html_parser.HTMLParser):\n    def __init(self):\n        compat_html_parser.HTMLParser.__init__(self)\n        self.html = None\n\n    def loads(self, html):\n        self.html = html\n        self.feed(html)\n        self.close()\n\nclass AttrParser(BaseHTMLParser):\n    \"\"\"Modified HTMLParser that isolates a tag with the specified attribute\"\"\"\n    def __init__(self, attribute, value):\n        self.attribute = attribute\n        self.value = value\n        self.result = None\n        self.started = False\n        self.depth = {}\n        self.watch_startpos = False\n        self.error_count = 0\n        BaseHTMLParser.__init__(self)\n\n    def error(self, message):\n        if self.error_count > 10 or self.started:\n            raise compat_html_parser.HTMLParseError(message, self.getpos())\n        self.rawdata = '\\n'.join(self.html.split('\\n')[self.getpos()[0]:]) # skip one line\n        self.error_count += 1\n        self.goahead(1)\n\n    def handle_starttag(self, tag, attrs):\n        attrs = dict(attrs)\n        if self.started:\n            self.find_startpos(None)\n        if self.attribute in attrs and attrs[self.attribute] == self.value:\n            self.result = [tag]\n            self.started = True\n            self.watch_startpos = True\n        if self.started:\n            if not tag in self.depth: self.depth[tag] = 0\n            self.depth[tag] += 1\n\n    def handle_endtag(self, tag):\n        if self.started:\n            if tag in self.depth: self.depth[tag] -= 1\n            if self.depth[self.result[0]] == 0:\n                self.started = False\n                self.result.append(self.getpos())\n\n    def find_startpos(self, x):\n        \"\"\"Needed to put the start position of the result (self.result[1])\n        after the opening tag with the requested id\"\"\"\n        if self.watch_startpos:\n            self.watch_startpos = False\n            self.result.append(self.getpos())\n    handle_entityref = handle_charref = handle_data = handle_comment = \\\n    handle_decl = handle_pi = unknown_decl = find_startpos\n\n    def get_result(self):\n        if self.result is None:\n            return None\n        if len(self.result) != 3:\n            return None\n        lines = self.html.split('\\n')\n        lines = lines[self.result[1][0]-1:self.result[2][0]]\n        lines[0] = lines[0][self.result[1][1]:]\n        if len(lines) == 1:\n            lines[-1] = lines[-1][:self.result[2][1]-self.result[1][1]]\n        lines[-1] = lines[-1][:self.result[2][1]]\n        return '\\n'.join(lines).strip()\n# Hack for https://github.com/rg3/youtube-dl/issues/662\nif sys.version_info < (2, 7, 3):\n    AttrParser.parse_endtag = (lambda self, i:\n        i + len(\"</scr'+'ipt>\")\n        if self.rawdata[i:].startswith(\"</scr'+'ipt>\")\n        else compat_html_parser.HTMLParser.parse_endtag(self, i))\n\ndef get_element_by_id(id, html):\n    \"\"\"Return the content of the tag with the specified ID in the passed HTML document\"\"\"\n    return get_element_by_attribute(\"id\", id, html)\n\ndef get_element_by_attribute(attribute, value, html):\n    \"\"\"Return the content of the tag with the specified attribute in the passed HTML document\"\"\"\n    parser = AttrParser(attribute, value)\n    try:\n        parser.loads(html)\n    except compat_html_parser.HTMLParseError:\n        pass\n    return parser.get_result()\n\nclass MetaParser(BaseHTMLParser):\n    \"\"\"\n    Modified HTMLParser that isolates a meta tag with the specified name \n    attribute.\n    \"\"\"\n    def __init__(self, name):\n        BaseHTMLParser.__init__(self)\n        self.name = name\n        self.content = None\n        self.result = None\n\n    def handle_starttag(self, tag, attrs):\n        if tag != 'meta':\n            return\n        attrs = dict(attrs)\n        if attrs.get('name') == self.name:\n            self.result = attrs.get('content')\n\n    def get_result(self):\n        return self.result\n\ndef get_meta_content(name, html):\n    \"\"\"\n    Return the content attribute from the meta tag with the given name attribute.\n    \"\"\"\n    parser = MetaParser(name)\n    try:\n        parser.loads(html)\n    except compat_html_parser.HTMLParseError:\n        pass\n    return parser.get_result()\n\n\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n    # Newline vs <br />\n    html = html.replace('\\n', ' ')\n    html = re.sub(r'\\s*<\\s*br\\s*/?\\s*>\\s*', '\\n', html)\n    html = re.sub(r'<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>', '\\n', html)\n    # Strip html tags\n    html = re.sub('<.*?>', '', html)\n    # Replace html entities\n    html = unescapeHTML(html)\n    return html.strip()\n\n\ndef sanitize_open(filename, open_mode):\n    \"\"\"Try to open the given filename, and slightly tweak it if this fails.\n\n    Attempts to open the given filename. If this fails, it tries to change\n    the filename slightly, step by step, until it's either able to open it\n    or it fails and raises a final exception, like the standard open()\n    function.\n\n    It returns the tuple (stream, definitive_file_name).\n    \"\"\"\n    try:\n        if filename == u'-':\n            if sys.platform == 'win32':\n                import msvcrt\n                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n            return (sys.stdout.buffer if hasattr(sys.stdout, 'buffer') else sys.stdout, filename)\n        stream = open(encodeFilename(filename), open_mode)\n        return (stream, filename)\n    except (IOError, OSError) as err:\n        if err.errno in (errno.EACCES,):\n            raise\n\n        # In case of error, try to remove win32 forbidden chars\n        alt_filename = os.path.join(\n                        re.sub(u'[/<>:\"\\\\|\\\\\\\\?\\\\*]', u'#', path_part)\n                        for path_part in os.path.split(filename)\n                       )\n        if alt_filename == filename:\n            raise\n        else:\n            # An exception here should be caught in the caller\n            stream = open(encodeFilename(filename), open_mode)\n            return (stream, alt_filename)\n\n\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp\n\ndef sanitize_filename(s, restricted=False, is_id=False):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    If restricted is set, use a stricter subset of allowed characters.\n    Set is_id if this is not an arbitrary string, but an ID that should be kept if possible\n    \"\"\"\n    def replace_insane(char):\n        if char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else '\\''\n        elif char == ':':\n            return '_-' if restricted else ' -'\n        elif char in '\\\\/|*<>':\n            return '_'\n        if restricted and (char in '!&\\'()[]{}$;`^,#' or char.isspace()):\n            return '_'\n        if restricted and ord(char) > 127:\n            return '_'\n        return char\n\n    result = u''.join(map(replace_insane, s))\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        # Common case of \"Foreign band name - English song title\"\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if not result:\n            result = '_'\n    return result\n\ndef orderedSet(iterable):\n    \"\"\" Remove all duplicates from the input iterable \"\"\"\n    res = []\n    for el in iterable:\n        if el not in res:\n            res.append(el)\n    return res\n\ndef unescapeHTML(s):\n    \"\"\"\n    @param s a string\n    \"\"\"\n    assert type(s) == type(u'')\n\n    result = re.sub(u'(?u)&(.+?);', htmlentity_transform, s)\n    return result\n\ndef encodeFilename(s):\n    \"\"\"\n    @param s The name of the file\n    \"\"\"\n\n    assert type(s) == type(u'')\n\n    # Python 3 has a Unicode API\n    if sys.version_info >= (3, 0):\n        return s\n\n    if sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        # Pass u'' directly to use Unicode APIs on Windows 2000 and up\n        # (Detecting Windows NT 4 is tricky because 'major >= 4' would\n        # match Windows 9x series as well. Besides, NT 4 is obsolete.)\n        return s\n    else:\n        encoding = sys.getfilesystemencoding()\n        if encoding is None:\n            encoding = 'utf-8'\n        return s.encode(encoding, 'ignore')\n\ndef decodeOption(optval):\n    if optval is None:\n        return optval\n    if isinstance(optval, bytes):\n        optval = optval.decode(preferredencoding())\n\n    assert isinstance(optval, compat_str)\n    return optval\n\ndef formatSeconds(secs):\n    if secs > 3600:\n        return '%d:%02d:%02d' % (secs // 3600, (secs % 3600) // 60, secs % 60)\n    elif secs > 60:\n        return '%d:%02d' % (secs // 60, secs % 60)\n    else:\n        return '%d' % secs\n\ndef make_HTTPS_handler(opts_no_check_certificate):\n    if sys.version_info < (3, 2):\n        import httplib\n\n        class HTTPSConnectionV3(httplib.HTTPSConnection):\n            def __init__(self, *args, **kwargs):\n                httplib.HTTPSConnection.__init__(self, *args, **kwargs)\n\n            def connect(self):\n                sock = socket.create_connection((self.host, self.port), self.timeout)\n                if getattr(self, '_tunnel_host', False):\n                    self.sock = sock\n                    self._tunnel()\n                try:\n                    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_SSLv3)\n                except ssl.SSLError:\n                    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_SSLv23)\n\n        class HTTPSHandlerV3(compat_urllib_request.HTTPSHandler):\n            def https_open(self, req):\n                return self.do_open(HTTPSConnectionV3, req)\n        return HTTPSHandlerV3()\n    else:\n        context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        context.verify_mode = (ssl.CERT_NONE\n                               if opts_no_check_certificate\n                               else ssl.CERT_REQUIRED)\n        context.set_default_verify_paths()\n        try:\n            context.load_default_certs()\n        except AttributeError:\n            pass  # Python < 3.4\n        return compat_urllib_request.HTTPSHandler(context=context)\n\nclass ExtractorError(Exception):\n    \"\"\"Error during info extraction.\"\"\"\n    def __init__(self, msg, tb=None, expected=False, cause=None):\n        \"\"\" tb, if given, is the original traceback (so that it can be printed out).\n        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.\n        \"\"\"\n\n        if sys.exc_info()[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError):\n            expected = True\n        if not expected:\n            msg = msg + u'; please report this issue on https://yt-dl.org/bug . Be sure to call youtube-dl with the --verbose flag and include its complete output. Make sure you are using the latest version; type  youtube-dl -U  to update.'\n        super(ExtractorError, self).__init__(msg)\n\n        self.traceback = tb\n        self.exc_info = sys.exc_info()  # preserve original exception\n        self.cause = cause\n\n    def format_traceback(self):\n        if self.traceback is None:\n            return None\n        return u''.join(traceback.format_tb(self.traceback))\n\n\nclass RegexNotFoundError(ExtractorError):\n    \"\"\"Error when a regex didn't match\"\"\"\n    pass\n\n\nclass DownloadError(Exception):\n    \"\"\"Download Error exception.\n\n    This exception may be thrown by FileDownloader objects if they are not\n    configured to continue on errors. They will contain the appropriate\n    error message.\n    \"\"\"\n    def __init__(self, msg, exc_info=None):\n        \"\"\" exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). \"\"\"\n        super(DownloadError, self).__init__(msg)\n        self.exc_info = exc_info\n\n\nclass SameFileError(Exception):\n    \"\"\"Same File exception.\n\n    This exception will be thrown by FileDownloader objects if they detect\n    multiple files would have to be downloaded to the same file on disk.\n    \"\"\"\n    pass\n\n\nclass PostProcessingError(Exception):\n    \"\"\"Post Processing exception.\n\n    This exception may be raised by PostProcessor's .run() method to\n    indicate an error in the postprocessing task.\n    \"\"\"\n    def __init__(self, msg):\n        self.msg = msg\n\nclass MaxDownloadsReached(Exception):\n    \"\"\" --max-downloads limit has been reached. \"\"\"\n    pass\n\n\nclass UnavailableVideoError(Exception):\n    \"\"\"Unavailable Format exception.\n\n    This exception will be thrown when a video is requested\n    in a format that is not available for that video.\n    \"\"\"\n    pass\n\n\nclass ContentTooShortError(Exception):\n    \"\"\"Content Too Short exception.\n\n    This exception may be raised by FileDownloader objects when a file they\n    download is too small for what the server announced first, indicating\n    the connection was probably interrupted.\n    \"\"\"\n    # Both in bytes\n    downloaded = None\n    expected = None\n\n    def __init__(self, downloaded, expected):\n        self.downloaded = downloaded\n        self.expected = expected\n\nclass YoutubeDLHandler(compat_urllib_request.HTTPHandler):\n    \"\"\"Handler for HTTP requests and responses.\n\n    This class, when installed with an OpenerDirector, automatically adds\n    the standard headers to every HTTP request and handles gzipped and\n    deflated responses from web servers. If compression is to be avoided in\n    a particular request, the original request in the program code only has\n    to include the HTTP header \"Youtubedl-No-Compression\", which will be\n    removed before making the real request.\n\n    Part of this code was copied from:\n\n    http://techknack.net/python-urllib2-handlers/\n\n    Andrew Rowls, the author of that code, agreed to release it to the\n    public domain.\n    \"\"\"\n\n    @staticmethod\n    def deflate(data):\n        try:\n            return zlib.decompress(data, -zlib.MAX_WBITS)\n        except zlib.error:\n            return zlib.decompress(data)\n\n    @staticmethod\n    def addinfourl_wrapper(stream, headers, url, code):\n        if hasattr(compat_urllib_request.addinfourl, 'getcode'):\n            return compat_urllib_request.addinfourl(stream, headers, url, code)\n        ret = compat_urllib_request.addinfourl(stream, headers, url)\n        ret.code = code\n        return ret\n\n    def http_request(self, req):\n        for h,v in std_headers.items():\n            if h in req.headers:\n                del req.headers[h]\n            req.add_header(h, v)\n        if 'Youtubedl-no-compression' in req.headers:\n            if 'Accept-encoding' in req.headers:\n                del req.headers['Accept-encoding']\n            del req.headers['Youtubedl-no-compression']\n        if 'Youtubedl-user-agent' in req.headers:\n            if 'User-agent' in req.headers:\n                del req.headers['User-agent']\n            req.headers['User-agent'] = req.headers['Youtubedl-user-agent']\n            del req.headers['Youtubedl-user-agent']\n        return req\n\n    def http_response(self, req, resp):\n        old_resp = resp\n        # gzip\n        if resp.headers.get('Content-encoding', '') == 'gzip':\n            content = resp.read()\n            gz = gzip.GzipFile(fileobj=io.BytesIO(content), mode='rb')\n            try:\n                uncompressed = io.BytesIO(gz.read())\n            except IOError as original_ioerror:\n                # There may be junk add the end of the file\n                # See http://stackoverflow.com/q/4928560/35070 for details\n                for i in range(1, 1024):\n                    try:\n                        gz = gzip.GzipFile(fileobj=io.BytesIO(content[:-i]), mode='rb')\n                        uncompressed = io.BytesIO(gz.read())\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise original_ioerror\n            resp = self.addinfourl_wrapper(uncompressed, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n        # deflate\n        if resp.headers.get('Content-encoding', '') == 'deflate':\n            gz = io.BytesIO(self.deflate(resp.read()))\n            resp = self.addinfourl_wrapper(gz, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n        return resp\n\n    https_request = http_request\n    https_response = http_response\n\ndef unified_strdate(date_str):\n    \"\"\"Return a string with the date in the format YYYYMMDD\"\"\"\n    upload_date = None\n    #Replace commas\n    date_str = date_str.replace(',',' ')\n    # %z (UTC offset) is only supported in python>=3.2\n    date_str = re.sub(r' (\\+|-)[\\d]*$', '', date_str)\n    format_expressions = [\n        '%d %B %Y',\n        '%B %d %Y',\n        '%b %d %Y',\n        '%Y-%m-%d',\n        '%d/%m/%Y',\n        '%Y/%m/%d %H:%M:%S',\n        '%d.%m.%Y %H:%M',\n        '%Y-%m-%dT%H:%M:%SZ',\n        '%Y-%m-%dT%H:%M:%S.%fZ',\n        '%Y-%m-%dT%H:%M:%S.%f0Z',\n        '%Y-%m-%dT%H:%M:%S',\n    ]\n    for expression in format_expressions:\n        try:\n            upload_date = datetime.datetime.strptime(date_str, expression).strftime('%Y%m%d')\n        except:\n            pass\n    return upload_date\n\ndef determine_ext(url, default_ext=u'unknown_video'):\n    guess = url.partition(u'?')[0].rpartition(u'.')[2]\n    if re.match(r'^[A-Za-z0-9]+$', guess):\n        return guess\n    else:\n        return default_ext\n\ndef subtitles_filename(filename, sub_lang, sub_format):\n    return filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n\ndef date_from_str(date_str):\n    \"\"\"\n    Return a datetime object from a string in the format YYYYMMDD or\n    (now|today)[+-][0-9](day|week|month|year)(s)?\"\"\"\n    today = datetime.date.today()\n    if date_str == 'now'or date_str == 'today':\n        return today\n    match = re.match('(now|today)(?P<sign>[+-])(?P<time>\\d+)(?P<unit>day|week|month|year)(s)?', date_str)\n    if match is not None:\n        sign = match.group('sign')\n        time = int(match.group('time'))\n        if sign == '-':\n            time = -time\n        unit = match.group('unit')\n        #A bad aproximation?\n        if unit == 'month':\n            unit = 'day'\n            time *= 30\n        elif unit == 'year':\n            unit = 'day'\n            time *= 365\n        unit += 's'\n        delta = datetime.timedelta(**{unit: time})\n        return today + delta\n    return datetime.datetime.strptime(date_str, \"%Y%m%d\").date()\n    \nclass DateRange(object):\n    \"\"\"Represents a time interval between two dates\"\"\"\n    def __init__(self, start=None, end=None):\n        \"\"\"start and end must be strings in the format accepted by date\"\"\"\n        if start is not None:\n            self.start = date_from_str(start)\n        else:\n            self.start = datetime.datetime.min.date()\n        if end is not None:\n            self.end = date_from_str(end)\n        else:\n            self.end = datetime.datetime.max.date()\n        if self.start > self.end:\n            raise ValueError('Date range: \"%s\" , the start date must be before the end date' % self)\n    @classmethod\n    def day(cls, day):\n        \"\"\"Returns a range that only contains the given day\"\"\"\n        return cls(day,day)\n    def __contains__(self, date):\n        \"\"\"Check if the date is in the range\"\"\"\n        if not isinstance(date, datetime.date):\n            date = date_from_str(date)\n        return self.start <= date <= self.end\n    def __str__(self):\n        return '%s - %s' % ( self.start.isoformat(), self.end.isoformat())\n\n\ndef platform_name():\n    \"\"\" Returns the platform name as a compat_str \"\"\"\n    res = platform.platform()\n    if isinstance(res, bytes):\n        res = res.decode(preferredencoding())\n\n    assert isinstance(res, compat_str)\n    return res\n\n\ndef write_string(s, out=None):\n    if out is None:\n        out = sys.stderr\n    assert type(s) == type(u'')\n\n    if ('b' in getattr(out, 'mode', '') or\n            sys.version_info[0] < 3):  # Python 2 lies about mode of sys.stderr\n        s = s.encode(preferredencoding(), 'ignore')\n    out.write(s)\n    out.flush()\n\n\ndef bytes_to_intlist(bs):\n    if not bs:\n        return []\n    if isinstance(bs[0], int):  # Python 3\n        return list(bs)\n    else:\n        return [ord(c) for c in bs]\n\n\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    if isinstance(chr(0), bytes):  # Python 2\n        return ''.join([chr(x) for x in xs])\n    else:\n        return bytes(xs)\n\n\ndef get_cachedir(params={}):\n    cache_root = os.environ.get('XDG_CACHE_HOME',\n                                os.path.expanduser('~/.cache'))\n    return params.get('cachedir', os.path.join(cache_root, 'youtube-dl'))\n\n\n# Cross-platform file locking\nif sys.platform == 'win32':\n    import ctypes.wintypes\n    import msvcrt\n\n    class OVERLAPPED(ctypes.Structure):\n        _fields_ = [\n            ('Internal', ctypes.wintypes.LPVOID),\n            ('InternalHigh', ctypes.wintypes.LPVOID),\n            ('Offset', ctypes.wintypes.DWORD),\n            ('OffsetHigh', ctypes.wintypes.DWORD),\n            ('hEvent', ctypes.wintypes.HANDLE),\n        ]\n\n    kernel32 = ctypes.windll.kernel32\n    LockFileEx = kernel32.LockFileEx\n    LockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwFlags\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    LockFileEx.restype = ctypes.wintypes.BOOL\n    UnlockFileEx = kernel32.UnlockFileEx\n    UnlockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    UnlockFileEx.restype = ctypes.wintypes.BOOL\n    whole_low = 0xffffffff\n    whole_high = 0x7fffffff\n\n    def _lock_file(f, exclusive):\n        overlapped = OVERLAPPED()\n        overlapped.Offset = 0\n        overlapped.OffsetHigh = 0\n        overlapped.hEvent = 0\n        f._lock_file_overlapped_p = ctypes.pointer(overlapped)\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not LockFileEx(handle, 0x2 if exclusive else 0x0, 0,\n                          whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Locking file failed: %r' % ctypes.FormatError())\n\n    def _unlock_file(f):\n        assert f._lock_file_overlapped_p\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not UnlockFileEx(handle, 0,\n                            whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Unlocking file failed: %r' % ctypes.FormatError())\n\nelse:\n    import fcntl\n\n    def _lock_file(f, exclusive):\n        fcntl.lockf(f, fcntl.LOCK_EX if exclusive else fcntl.LOCK_SH)\n\n    def _unlock_file(f):\n        fcntl.lockf(f, fcntl.LOCK_UN)\n\n\nclass locked_file(object):\n    def __init__(self, filename, mode, encoding=None):\n        assert mode in ['r', 'a', 'w']\n        self.f = io.open(filename, mode, encoding=encoding)\n        self.mode = mode\n\n    def __enter__(self):\n        exclusive = self.mode != 'r'\n        try:\n            _lock_file(self.f, exclusive)\n        except IOError:\n            self.f.close()\n            raise\n        return self\n\n    def __exit__(self, etype, value, traceback):\n        try:\n            _unlock_file(self.f)\n        finally:\n            self.f.close()\n\n    def __iter__(self):\n        return iter(self.f)\n\n    def write(self, *args):\n        return self.f.write(*args)\n\n    def read(self, *args):\n        return self.f.read(*args)\n\n\ndef shell_quote(args):\n    quoted_args = []\n    encoding = sys.getfilesystemencoding()\n    if encoding is None:\n        encoding = 'utf-8'\n    for a in args:\n        if isinstance(a, bytes):\n            # We may get a filename encoded with 'encodeFilename'\n            a = a.decode(encoding)\n        quoted_args.append(pipes.quote(a))\n    return u' '.join(quoted_args)\n\n\ndef takewhile_inclusive(pred, seq):\n    \"\"\" Like itertools.takewhile, but include the latest evaluated element\n        (the first element so that Not pred(e)) \"\"\"\n    for e in seq:\n        yield e\n        if not pred(e):\n            return\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n\n    sdata = compat_urllib_parse.urlencode(\n        {u'__youtubedl_smuggle': json.dumps(data)})\n    return url + u'#' + sdata\n\n\ndef unsmuggle_url(smug_url):\n    if not '#__youtubedl_smuggle' in smug_url:\n        return smug_url, None\n    url, _, sdata = smug_url.rpartition(u'#')\n    jsond = compat_parse_qs(sdata)[u'__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef format_bytes(bytes):\n    if bytes is None:\n        return u'N/A'\n    if type(bytes) is str:\n        bytes = float(bytes)\n    if bytes == 0.0:\n        exponent = 0\n    else:\n        exponent = int(math.log(bytes, 1024.0))\n    suffix = [u'B', u'KiB', u'MiB', u'GiB', u'TiB', u'PiB', u'EiB', u'ZiB', u'YiB'][exponent]\n    converted = float(bytes) / float(1024 ** exponent)\n    return u'%.2f%s' % (converted, suffix)\n\n\ndef str_to_int(int_str):\n    int_str = re.sub(r'[,\\.]', u'', int_str)\n    return int(int_str)\n\n\ndef get_term_width():\n    columns = os.environ.get('COLUMNS', None)\n    if columns:\n        return int(columns)\n\n    try:\n        sp = subprocess.Popen(\n            ['stty', 'size'],\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = sp.communicate()\n        return int(out.split()[1])\n    except:\n        pass\n    return None\n\n\ndef month_by_name(name):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n\n    ENGLISH_NAMES = [\n        u'January', u'February', u'March', u'April', u'May', u'June',\n        u'July', u'August', u'September', u'October', u'November', u'December']\n    try:\n        return ENGLISH_NAMES.index(name) + 1\n    except ValueError:\n        return None\n\n\ndef fix_xml_all_ampersand(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return xml_str.replace(u'&', u'&amp;')\n\n\ndef setproctitle(title):\n    assert isinstance(title, type(u''))\n    try:\n        libc = ctypes.cdll.LoadLibrary(\"libc.so.6\")\n    except OSError:\n        return\n    title = title\n    buf = ctypes.create_string_buffer(len(title) + 1)\n    buf.value = title.encode('utf-8')\n    try:\n        libc.prctl(15, ctypes.byref(buf), 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    if s.startswith(start):\n        return s[len(start):]\n    return s\n\n\ndef url_basename(url):\n    m = re.match(r'(?:https?:|)//[^/]+/(?:[^/?#]+/)?([^/?#]+)/?(?:[?#]|$)', url)\n    if not m:\n        return u''\n    return m.group(1)\n",
      "file_patch": "@@ -1084,3 +1084,10 @@ def remove_start(s, start):\n     if s.startswith(start):\n         return s[len(start):]\n     return s\n+\n+\n+def url_basename(url):\n+    m = re.match(r'(?:https?:|)//[^/]+/(?:[^/?#]+/)?([^/?#]+)/?(?:[?#]|$)', url)\n+    if not m:\n+        return u''\n+    return m.group(1)\n",
      "files_name_in_blame_commit": [
        "utils.py",
        "test_utils.py",
        "YoutubeDL.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 131
  },
  "recursive_blame_commits": {}
}
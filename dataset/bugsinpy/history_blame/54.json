{
  "id": "54",
  "blame_commit": {
    "commit": {
      "commit_id": "ab6b980c42dbaff73ed63deb200f1a23467f3529",
      "commit_message": "A new IOLoop is automatically \"current\" if there isn't already one.\n\nIOLoop keyword arguments throughout the library are now deprecated\nin favor of IOLoop.current(). This is because the gen module\nuses IOLoop.current() with no opportunity to pass in a different\ninstance, making it impossible in some cases to use a non-current\nIOLoop with AsyncHTTPClient.\n\nCloses #1252.",
      "commit_author": "Ben Darnell",
      "commit_date": "2015-01-18 13:13:41",
      "commit_parent": "98119734c86effbb6abd23154097797bbc606b94"
    },
    "function": {
      "function_name": "initialize",
      "function_code_before": "def initialize(self):\n    pass",
      "function_code_after": "def initialize(self):\n    if IOLoop.current(instance=False) is None:\n        self.make_current()",
      "function_before_start_line": 226,
      "function_before_end_line": 227,
      "function_after_start_line": 228,
      "function_after_end_line": 230,
      "function_before_token_count": 6,
      "function_after_token_count": 22,
      "functions_name_modified_file": [
        "clear_current",
        "instance",
        "_run_callback",
        "log_stack",
        "time",
        "configurable_default",
        "remove_handler",
        "start",
        "call_at",
        "add_future",
        "add_timeout",
        "make_current",
        "_run",
        "_setup_logging",
        "initialize",
        "install",
        "handle_callback_exception",
        "__le__",
        "add_callback",
        "set_blocking_signal_threshold",
        "run_sync",
        "clear_instance",
        "split_fd",
        "close",
        "initialized",
        "__lt__",
        "_schedule_next",
        "add_callback_from_signal",
        "update_handler",
        "is_running",
        "__init__",
        "call_later",
        "close_fd",
        "remove_timeout",
        "current",
        "add_handler",
        "stop",
        "spawn_callback",
        "configurable_base",
        "set_blocking_log_threshold"
      ],
      "functions_name_all_files": [
        "on_connection_close",
        "_receive_frame",
        "handle_exception",
        "seconds",
        "_reseed_random",
        "select_subprotocol",
        "_removeDelayedCall",
        "callLater",
        "_cleanup",
        "make_current",
        "active",
        "_on_frame_start",
        "getReaders",
        "_on_frame_length_64",
        "headers_received",
        "write_to_fd",
        "header_callback",
        "__le__",
        "writing",
        "read_until_close",
        "__getattr__",
        "set_blocking_signal_threshold",
        "mainLoop",
        "delay",
        "_wrap_method",
        "__new__",
        "coroutine",
        "doctests",
        "fileno",
        "_try_inline_read",
        "update_handler",
        "_handle_read",
        "headers",
        "__init__",
        "read_bytes",
        "callFromThread",
        "_called",
        "add_accept_handler",
        "_check_file",
        "_verify_cert",
        "_do_ssl_handshake",
        "stop",
        "_add_io_state",
        "_parse_extensions_header",
        "set_blocking_log_threshold",
        "get_fd_error",
        "write_message",
        "_on_frame_length_16",
        "_on_masked_frame_data",
        "connectionLost",
        "_maybe_run_close_callback",
        "cancel",
        "_run_callback",
        "ping",
        "_reload",
        "engine",
        "connect",
        "call_at",
        "add_future",
        "is_ready",
        "read_message",
        "websocket_connect",
        "doRead",
        "write",
        "_read_to_buffer_loop",
        "_write_frame",
        "uninitialize",
        "open",
        "main",
        "reset",
        "compress",
        "write_ping",
        "run",
        "set_exit_callback",
        "on_connect_done",
        "on_message",
        "_on_masking_key",
        "_run_streaming_callback",
        "body",
        "streaming_callback",
        "initialized",
        "bind_unix_socket",
        "__lt__",
        "_double_prefix",
        "installWaker",
        "_get_body",
        "removeReader",
        "_async_clients",
        "body_producer",
        "set_timout",
        "multi_future",
        "fetch_impl",
        "_set_returncode",
        "accept_connection",
        "clear_timeout",
        "_handle_events",
        "on_close",
        "compute_accept_value",
        "resolve",
        "ssl_options_to_context",
        "_sock_state_cb",
        "configurable_base",
        "_handle_websocket_headers",
        "_deactivate_stack_context",
        "closed",
        "_make_coroutine_wrapper",
        "with_timeout",
        "clear_current",
        "_merge_prefix",
        "_create_decompressor",
        "instance",
        "removeWriter",
        "crash",
        "decompress",
        "logPrefix",
        "time",
        "_create_compressors",
        "prepare_curl_callback",
        "remove_handler",
        "_consume",
        "getWriters",
        "send_error",
        "addWriter",
        "ssl_wrap_socket",
        "watch",
        "read_until_regex",
        "initialize",
        "_try_cleanup_process",
        "on_timeout",
        "reading",
        "install",
        "handle_callback_exception",
        "wakeUp",
        "add_callback",
        "split_fd",
        "is_valid_ip",
        "_argument_adapter",
        "_check_max_bytes",
        "set_result",
        "rethrow",
        "_check_closed",
        "_process_server_headers",
        "_accept_connection",
        "add_callback_from_signal",
        "set_nodelay",
        "getDelayedCalls",
        "__repr__",
        "set_close_callback",
        "_invoke_callback",
        "start_tls",
        "current",
        "add_handler",
        "addReader",
        "split",
        "check_origin",
        "_run_read_callback",
        "listenTCP",
        "task_id",
        "_handle_connect",
        "_find_read_pos",
        "on_pong",
        "_create_threadpool",
        "_abort",
        "_create_compressor",
        "read_from_fd",
        "pop_result",
        "_read_to_buffer",
        "_create_stream",
        "maybe_future",
        "removeAll",
        "log_stack",
        "_on_http_response",
        "start",
        "configurable_default",
        "_on_frame_data",
        "add_reload_hook",
        "getTime",
        "try_connect",
        "_challenge_response",
        "add_timeout",
        "_set_read_callback",
        "_run",
        "_get_compressor_options",
        "handle_yield",
        "_maybe_add_error_listener",
        "_handle_message",
        "_setup_logging",
        "_handle_write",
        "wait",
        "Task",
        "run_sync",
        "bind_sockets",
        "clear_instance",
        "close",
        "doWrite",
        "get_result",
        "_schedule_next",
        "get",
        "is_running",
        "read_until",
        "configure",
        "cpu_count",
        "__del__",
        "call_later",
        "close_fd",
        "remove_timeout",
        "listenUDP",
        "fork_processes",
        "get_compression_options",
        "doIteration",
        "_reload_on_update",
        "_read_from_buffer",
        "spawn_callback",
        "result_callback",
        "register_callback",
        "_pipe_cloexec",
        "fetch"
      ],
      "functions_name_co_evolved_modified_file": [
        "current",
        "make_current"
      ],
      "functions_name_co_evolved_all_files": [
        "__init__",
        "make_current",
        "add_accept_handler",
        "current",
        "start",
        "install",
        "websocket_connect"
      ]
    },
    "file": {
      "file_name": "ioloop.py",
      "file_nloc": 482,
      "file_complexity": 132,
      "file_token_count": 2876,
      "file_before": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"An I/O event loop for non-blocking sockets.\n\nTypical applications will use a single `IOLoop` object, in the\n`IOLoop.instance` singleton.  The `IOLoop.start` method should usually\nbe called at the end of the ``main()`` function.  Atypical applications may\nuse more than one `IOLoop`, such as one `IOLoop` per thread, or per `unittest`\ncase.\n\nIn addition to I/O events, the `IOLoop` can also schedule time-based events.\n`IOLoop.add_timeout` is a non-blocking alternative to `time.sleep`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\nimport datetime\nimport errno\nimport functools\nimport heapq\nimport itertools\nimport logging\nimport numbers\nimport os\nimport select\nimport sys\nimport threading\nimport time\nimport traceback\n\nfrom tornado.concurrent import TracebackFuture, is_future\nfrom tornado.log import app_log, gen_log\nfrom tornado import stack_context\nfrom tornado.util import Configurable, errno_from_exception, timedelta_to_seconds\n\ntry:\n    import signal\nexcept ImportError:\n    signal = None\n\ntry:\n    import thread  # py2\nexcept ImportError:\n    import _thread as thread  # py3\n\nfrom tornado.platform.auto import set_close_exec, Waker\n\n\n_POLL_TIMEOUT = 3600.0\n\n\nclass TimeoutError(Exception):\n    pass\n\n\nclass IOLoop(Configurable):\n    \"\"\"A level-triggered I/O loop.\n\n    We use ``epoll`` (Linux) or ``kqueue`` (BSD and Mac OS X) if they\n    are available, or else we fall back on select(). If you are\n    implementing a system that needs to handle thousands of\n    simultaneous connections, you should use a system that supports\n    either ``epoll`` or ``kqueue``.\n\n    Example usage for a simple TCP server::\n\n        import errno\n        import functools\n        import ioloop\n        import socket\n\n        def connection_ready(sock, fd, events):\n            while True:\n                try:\n                    connection, address = sock.accept()\n                except socket.error, e:\n                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):\n                        raise\n                    return\n                connection.setblocking(0)\n                handle_connection(connection, address)\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setblocking(0)\n        sock.bind((\"\", port))\n        sock.listen(128)\n\n        io_loop = ioloop.IOLoop.instance()\n        callback = functools.partial(connection_ready, sock)\n        io_loop.add_handler(sock.fileno(), callback, io_loop.READ)\n        io_loop.start()\n\n    \"\"\"\n    # Constants from the epoll module\n    _EPOLLIN = 0x001\n    _EPOLLPRI = 0x002\n    _EPOLLOUT = 0x004\n    _EPOLLERR = 0x008\n    _EPOLLHUP = 0x010\n    _EPOLLRDHUP = 0x2000\n    _EPOLLONESHOT = (1 << 30)\n    _EPOLLET = (1 << 31)\n\n    # Our events map exactly to the epoll events\n    NONE = 0\n    READ = _EPOLLIN\n    WRITE = _EPOLLOUT\n    ERROR = _EPOLLERR | _EPOLLHUP\n\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n\n    _current = threading.local()\n\n    @staticmethod\n    def instance():\n        \"\"\"Returns a global `IOLoop` instance.\n\n        Most applications have a single, global `IOLoop` running on the\n        main thread.  Use this method to get this instance from\n        another thread.  To get the current thread's `IOLoop`, use `current()`.\n        \"\"\"\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n\n    @staticmethod\n    def initialized():\n        \"\"\"Returns true if the singleton instance has been created.\"\"\"\n        return hasattr(IOLoop, \"_instance\")\n\n    def install(self):\n        \"\"\"Installs this `IOLoop` object as the singleton instance.\n\n        This is normally not necessary as `instance()` will create\n        an `IOLoop` on demand, but you may want to call `install` to use\n        a custom subclass of `IOLoop`.\n        \"\"\"\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def clear_instance():\n        \"\"\"Clear the global `IOLoop` instance.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        if hasattr(IOLoop, \"_instance\"):\n            del IOLoop._instance\n\n    @staticmethod\n    def current():\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as current\n        by `make_current`, returns that instance.  Otherwise returns\n        `IOLoop.instance()`, i.e. the main thread's `IOLoop`.\n\n        A common pattern for classes that depend on ``IOLoops`` is to use\n        a default argument to enable programs with multiple ``IOLoops``\n        but not require the argument for simpler applications::\n\n            class MyClass(object):\n                def __init__(self, io_loop=None):\n                    self.io_loop = io_loop or IOLoop.current()\n\n        In general you should use `IOLoop.current` as the default when\n        constructing an asynchronous object, and use `IOLoop.instance`\n        when you mean to communicate to the main thread from a different\n        one.\n        \"\"\"\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None:\n            return IOLoop.instance()\n        return current\n\n    def make_current(self):\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n        \"\"\"\n        IOLoop._current.instance = self\n\n    @staticmethod\n    def clear_current():\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self):\n        pass\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for \"file descriptors\", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` method (and optionally a\n        ``close()`` method, which may be called when the `IOLoop` is shut\n        down).\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n\n        When an event occurs, ``handler(fd, events)`` will be run.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def update_handler(self, fd, events):\n        \"\"\"Changes the events we listen for ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def remove_handler(self, fd):\n        \"\"\"Stop listening for events on ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        \"\"\"Sends a signal if the `IOLoop` is blocked for more than\n        ``s`` seconds.\n\n        Pass ``seconds=None`` to disable.  Requires Python 2.6 on a unixy\n        platform.\n\n        The action parameter is a Python signal handler.  Read the\n        documentation for the `signal` module for more information.\n        If ``action`` is None, the process will be killed if it is\n        blocked for too long.\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_log_threshold(self, seconds):\n        \"\"\"Logs a stack trace if the `IOLoop` is blocked for more than\n        ``s`` seconds.\n\n        Equivalent to ``set_blocking_signal_threshold(seconds,\n        self.log_stack)``\n        \"\"\"\n        self.set_blocking_signal_threshold(seconds, self.log_stack)\n\n    def log_stack(self, signal, frame):\n        \"\"\"Signal handler to log the stack trace of the current thread.\n\n        For use with `set_blocking_signal_threshold`.\n        \"\"\"\n        gen_log.warning('IOLoop blocked for %f seconds in\\n%s',\n                        self._blocking_signal_threshold,\n                        ''.join(traceback.format_stack(frame)))\n\n    def start(self):\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the callbacks calls `stop()`, which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n        raise NotImplementedError()\n\n    def _setup_logging(self):\n        \"\"\"The IOLoop catches and logs exceptions, so it's\n        important that log output be visible.  However, python's\n        default behavior for non-root loggers (prior to python\n        3.2) is to print an unhelpful \"no handlers could be\n        found\" message rather than the actual log entry, so we\n        must explicitly configure logging if we've made it this\n        far without anything.\n\n        This method should be called from start() in subclasses.\n        \"\"\"\n        if not any([logging.getLogger().handlers,\n                    logging.getLogger('tornado').handlers,\n                    logging.getLogger('tornado.application').handlers]):\n            logging.basicConfig()\n\n    def stop(self):\n        \"\"\"Stop the I/O loop.\n\n        If the event loop is not currently running, the next call to `start()`\n        will return immediately.\n\n        To use asynchronous methods from otherwise-synchronous code (such as\n        unit tests), you can start and stop the event loop like this::\n\n          ioloop = IOLoop()\n          async_method(ioloop=ioloop, callback=ioloop.stop)\n          ioloop.start()\n\n        ``ioloop.start()`` will return after ``async_method`` has run\n        its callback, whether that callback was invoked before or\n        after ``ioloop.start``.\n\n        Note that even after `stop` has been called, the `IOLoop` is not\n        completely stopped until `IOLoop.start` has also returned.\n        Some work that was scheduled before the call to `stop` may still\n        be run before the `IOLoop` shuts down.\n        \"\"\"\n        raise NotImplementedError()\n\n    def run_sync(self, func, timeout=None):\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n\n        If the function returns a `.Future`, the `IOLoop` will run\n        until the future is resolved.  If it raises an exception, the\n        `IOLoop` will stop and the exception will be re-raised to the\n        caller.\n\n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `TimeoutError` is raised.\n\n        This method is useful in conjunction with `tornado.gen.coroutine`\n        to allow asynchronous calls in a ``main()`` function::\n\n            @gen.coroutine\n            def main():\n                # do stuff...\n\n            if __name__ == '__main__':\n                IOLoop.instance().run_sync(main)\n        \"\"\"\n        future_cell = [None]\n\n        def run():\n            try:\n                result = func()\n            except Exception:\n                future_cell[0] = TracebackFuture()\n                future_cell[0].set_exc_info(sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    future_cell[0] = TracebackFuture()\n                    future_cell[0].set_result(result)\n            self.add_future(future_cell[0], lambda future: self.stop())\n        self.add_callback(run)\n        if timeout is not None:\n            timeout_handle = self.add_timeout(self.time() + timeout, self.stop)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        if not future_cell[0].done():\n            raise TimeoutError('Operation timed out after %s seconds' % timeout)\n        return future_cell[0].result()\n\n    def time(self):\n        \"\"\"Returns the current time according to the `IOLoop`'s clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the `IOLoop`'s time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return time.time()\n\n    def add_timeout(self, deadline, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n\n        Returns an opaque handle that may be passed to\n        `remove_timeout` to cancel.\n\n        ``deadline`` may be a number denoting a time (on the same\n        scale as `IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.  Since Tornado 4.0, `call_later` is a more\n        convenient alternative for the relative case since it does not\n        require a timedelta object.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        `IOLoop`'s thread, and then call `add_timeout` from there.\n\n        Subclasses of IOLoop must implement either `add_timeout` or\n        `call_at`; the default implementations of each will call\n        the other.  `call_at` is usually easier to implement, but\n        subclasses that wish to maintain compatibility with Tornado\n        versions prior to 4.0 must use `add_timeout` instead.\n\n        .. versionchanged:: 4.0\n           Now passes through ``*args`` and ``**kwargs`` to the callback.\n        \"\"\"\n        if isinstance(deadline, numbers.Real):\n            return self.call_at(deadline, callback, *args, **kwargs)\n        elif isinstance(deadline, datetime.timedelta):\n            return self.call_at(self.time() + timedelta_to_seconds(deadline),\n                                callback, *args, **kwargs)\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n\n    def call_later(self, delay, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` after ``delay`` seconds have passed.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.call_at(self.time() + delay, callback, *args, **kwargs)\n\n    def call_at(self, when, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` at the absolute time designated by ``when``.\n\n        ``when`` must be a number using the same reference point as\n        `IOLoop.time`.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.add_timeout(when, callback, *args, **kwargs)\n\n    def remove_timeout(self, timeout):\n        \"\"\"Cancels a pending timeout.\n\n        The argument is a handle as returned by `add_timeout`.  It is\n        safe to call `remove_timeout` even if the callback has already\n        been run.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the **only**\n        method in `IOLoop` that makes this thread-safety guarantee; all\n        other interaction with the `IOLoop` must be done from that\n        `IOLoop`'s thread.  `add_callback()` may be used to transfer\n        control from other threads to the `IOLoop`'s thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback_from_signal(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n\n        Callbacks added with this method will be run without any\n        `.stack_context`, to avoid picking up the context of the function\n        that was interrupted by the signal.\n        \"\"\"\n        raise NotImplementedError()\n\n    def spawn_callback(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next IOLoop iteration.\n\n        Unlike all other callback-related methods on IOLoop,\n        ``spawn_callback`` does not associate the callback with its caller's\n        ``stack_context``, so it is suitable for fire-and-forget callbacks\n        that should not interfere with the caller.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        with stack_context.NullContext():\n            self.add_callback(callback, *args, **kwargs)\n\n    def add_future(self, future, callback):\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n        \"\"\"\n        assert is_future(future)\n        callback = stack_context.wrap(callback)\n        future.add_done_callback(\n            lambda future: self.add_callback(callback, future))\n\n    def _run_callback(self, callback):\n        \"\"\"Runs a callback with error handling.\n\n        For use in subclasses.\n        \"\"\"\n        try:\n            ret = callback()\n            if ret is not None and is_future(ret):\n                # Functions that return Futures typically swallow all\n                # exceptions and store them in the Future.  If a Future\n                # makes it out to the IOLoop, ensure its exception (if any)\n                # gets logged too.\n                self.add_future(ret, lambda f: f.result())\n        except Exception:\n            self.handle_callback_exception(callback)\n\n    def handle_callback_exception(self, callback):\n        \"\"\"This method is called whenever a callback run by the `IOLoop`\n        throws an exception.\n\n        By default simply logs the exception as an error.  Subclasses\n        may override this method to customize reporting of exceptions.\n\n        The exception itself is not passed explicitly, but is available\n        in `sys.exc_info`.\n        \"\"\"\n        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n\n    def split_fd(self, fd):\n        \"\"\"Returns an (fd, obj) pair from an ``fd`` parameter.\n\n        We accept both raw file descriptors and file-like objects as\n        input to `add_handler` and related methods.  When a file-like\n        object is passed, we must retain the object itself so we can\n        close it correctly when the `IOLoop` shuts down, but the\n        poller interfaces favor file descriptors (they will accept\n        file-like objects and call ``fileno()`` for you, but they\n        always return the descriptor itself).\n\n        This method is provided for use by `IOLoop` subclasses and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            return fd.fileno(), fd\n        except AttributeError:\n            return fd, fd\n\n    def close_fd(self, fd):\n        \"\"\"Utility method to close an ``fd``.\n\n        If ``fd`` is a file-like object, we close it directly; otherwise\n        we use `os.close`.\n\n        This method is provided for use by `IOLoop` subclasses (in\n        implementations of ``IOLoop.close(all_fds=True)`` and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            try:\n                fd.close()\n            except AttributeError:\n                os.close(fd)\n        except OSError:\n            pass\n\n\nclass PollIOLoop(IOLoop):\n    \"\"\"Base class for IOLoops built around a select-like function.\n\n    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`\n    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or\n    `tornado.platform.select.SelectIOLoop` (all platforms).\n    \"\"\"\n    def initialize(self, impl, time_func=None):\n        super(PollIOLoop, self).initialize()\n        self._impl = impl\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())\n        self.time_func = time_func or time.time\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._callback_lock = threading.Lock()\n        self._timeouts = []\n        self._cancellations = 0\n        self._running = False\n        self._stopped = False\n        self._closing = False\n        self._thread_ident = None\n        self._blocking_signal_threshold = None\n        self._timeout_counter = itertools.count()\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = Waker()\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)\n\n    def close(self, all_fds=False):\n        with self._callback_lock:\n            self._closing = True\n        self.remove_handler(self._waker.fileno())\n        if all_fds:\n            for fd, handler in self._handlers.values():\n                self.close_fd(fd)\n        self._waker.close()\n        self._impl.close()\n        self._callbacks = None\n        self._timeouts = None\n\n    def add_handler(self, fd, handler, events):\n        fd, obj = self.split_fd(fd)\n        self._handlers[fd] = (obj, stack_context.wrap(handler))\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        fd, obj = self.split_fd(fd)\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        fd, obj = self.split_fd(fd)\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except Exception:\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        if not hasattr(signal, \"setitimer\"):\n            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n                          \"with the setitimer method\")\n            return\n        self._blocking_signal_threshold = seconds\n        if seconds is not None:\n            signal.signal(signal.SIGALRM,\n                          action if action is not None else signal.SIG_DFL)\n\n    def start(self):\n        if self._running:\n            raise RuntimeError(\"IOLoop is already running\")\n        self._setup_logging()\n        if self._stopped:\n            self._stopped = False\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()\n        self._running = True\n\n        # signal.set_wakeup_fd closes a race condition in event loops:\n        # a signal may arrive at the beginning of select/poll/etc\n        # before it goes into its interruptible sleep, so the signal\n        # will be consumed without waking the select.  The solution is\n        # for the (C, synchronous) signal handler to write to a pipe,\n        # which will then be seen by select.\n        #\n        # In python's signal handling semantics, this only matters on the\n        # main thread (fortunately, set_wakeup_fd only works on the main\n        # thread and will raise a ValueError otherwise).\n        #\n        # If someone has already set a wakeup fd, we don't want to\n        # disturb it.  This is an issue for twisted, which does its\n        # SIGCHLD processing in response to its own wakeup fd being\n        # written to.  As long as the wakeup fd is registered on the IOLoop,\n        # the loop will still wake up and everything should work.\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n            # requires python 2.6+, unix.  set_wakeup_fd exists but crashes\n            # the python process on windows.\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n                    # Already set, restore previous value.  This is a little racy,\n                    # but there's no clean get_wakeup_fd and in real use the\n                    # IOLoop is just started once at the beginning.\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:  # non-main thread\n                pass\n\n        try:\n            while True:\n                # Prevent IO event starvation by delaying new callbacks\n                # to the next iteration of the event loop.\n                with self._callback_lock:\n                    callbacks = self._callbacks\n                    self._callbacks = []\n\n                # Add any timeouts that have come due to the callback list.\n                # Do not run anything until we have determined which ones\n                # are ready, so timeouts that call add_timeout cannot\n                # schedule anything in this iteration.\n                due_timeouts = []\n                if self._timeouts:\n                    now = self.time()\n                    while self._timeouts:\n                        if self._timeouts[0].callback is None:\n                            # The timeout was cancelled.  Note that the\n                            # cancellation check is repeated below for timeouts\n                            # that are cancelled by another timeout or callback.\n                            heapq.heappop(self._timeouts)\n                            self._cancellations -= 1\n                        elif self._timeouts[0].deadline <= now:\n                            due_timeouts.append(heapq.heappop(self._timeouts))\n                        else:\n                            break\n                    if (self._cancellations > 512\n                            and self._cancellations > (len(self._timeouts) >> 1)):\n                        # Clean up the timeout queue when it gets large and it's\n                        # more than half cancellations.\n                        self._cancellations = 0\n                        self._timeouts = [x for x in self._timeouts\n                                          if x.callback is not None]\n                        heapq.heapify(self._timeouts)\n\n                for callback in callbacks:\n                    self._run_callback(callback)\n                for timeout in due_timeouts:\n                    if timeout.callback is not None:\n                        self._run_callback(timeout.callback)\n                # Closures may be holding on to a lot of memory, so allow\n                # them to be freed before we go into our poll wait.\n                callbacks = callback = due_timeouts = timeout = None\n\n                if self._callbacks:\n                    # If any callbacks or timeouts called add_callback,\n                    # we don't want to wait in poll() before we run them.\n                    poll_timeout = 0.0\n                elif self._timeouts:\n                    # If there are any timeouts, schedule the first one.\n                    # Use self.time() instead of 'now' to account for time\n                    # spent running callbacks.\n                    poll_timeout = self._timeouts[0].deadline - self.time()\n                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))\n                else:\n                    # No timeouts and no callbacks, so use the default.\n                    poll_timeout = _POLL_TIMEOUT\n\n                if not self._running:\n                    break\n\n                if self._blocking_signal_threshold is not None:\n                    # clear alarm so it doesn't fire while poll is waiting for\n                    # events.\n                    signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n                try:\n                    event_pairs = self._impl.poll(poll_timeout)\n                except Exception as e:\n                    # Depending on python version and IOLoop implementation,\n                    # different exception types may be thrown and there are\n                    # two ways EINTR might be signaled:\n                    # * e.errno == errno.EINTR\n                    # * e.args is like (errno.EINTR, 'Interrupted system call')\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    else:\n                        raise\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL,\n                                     self._blocking_signal_threshold, 0)\n\n                # Pop one fd at a time from the set of pending fds and run\n                # its handler. Since that handler may perform actions on\n                # other file descriptors, there may be reentrant calls to\n                # this IOLoop that update self._events\n                self._events.update(event_pairs)\n                while self._events:\n                    fd, events = self._events.popitem()\n                    try:\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            # Happens when the client closes the connection\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\n                fd_obj = handler_func = None\n\n        finally:\n            # reset the stopped flag so another start/stop pair can be issued\n            self._stopped = False\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n            IOLoop._current.instance = old_current\n            if old_wakeup_fd is not None:\n                signal.set_wakeup_fd(old_wakeup_fd)\n\n    def stop(self):\n        self._running = False\n        self._stopped = True\n        self._waker.wake()\n\n    def time(self):\n        return self.time_func()\n\n    def call_at(self, deadline, callback, *args, **kwargs):\n        timeout = _Timeout(\n            deadline,\n            functools.partial(stack_context.wrap(callback), *args, **kwargs),\n            self)\n        heapq.heappush(self._timeouts, timeout)\n        return timeout\n\n    def remove_timeout(self, timeout):\n        # Removing from a heap is complicated, so just leave the defunct\n        # timeout object in the queue (see discussion in\n        # http://docs.python.org/library/heapq.html).\n        # If this turns out to be a problem, we could add a garbage\n        # collection pass whenever there are too many dead timeouts.\n        timeout.callback = None\n        self._cancellations += 1\n\n    def add_callback(self, callback, *args, **kwargs):\n        with self._callback_lock:\n            if self._closing:\n                raise RuntimeError(\"IOLoop is closing\")\n            list_empty = not self._callbacks\n            self._callbacks.append(functools.partial(\n                stack_context.wrap(callback), *args, **kwargs))\n            if list_empty and thread.get_ident() != self._thread_ident:\n                # If we're in the IOLoop's thread, we know it's not currently\n                # polling.  If we're not, and we added the first callback to an\n                # empty list, we may need to wake it up (it may wake up on its\n                # own, but an occasional extra wake is harmless).  Waking\n                # up a polling IOLoop is relatively expensive, so we try to\n                # avoid it when we can.\n                self._waker.wake()\n\n    def add_callback_from_signal(self, callback, *args, **kwargs):\n        with stack_context.NullContext():\n            if thread.get_ident() != self._thread_ident:\n                # if the signal is handled on another thread, we can add\n                # it normally (modulo the NullContext)\n                self.add_callback(callback, *args, **kwargs)\n            else:\n                # If we're on the IOLoop's thread, we cannot use\n                # the regular add_callback because it may deadlock on\n                # _callback_lock.  Blindly insert into self._callbacks.\n                # This is safe because the GIL makes list.append atomic.\n                # One subtlety is that if the signal interrupted the\n                # _callback_lock block in IOLoop.start, we may modify\n                # either the old or new version of self._callbacks,\n                # but either way will work.\n                self._callbacks.append(functools.partial(\n                    stack_context.wrap(callback), *args, **kwargs))\n\n\nclass _Timeout(object):\n    \"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\n\n    # Reduce memory overhead when there are lots of pending callbacks\n    __slots__ = ['deadline', 'callback', 'tiebreaker']\n\n    def __init__(self, deadline, callback, io_loop):\n        if not isinstance(deadline, numbers.Real):\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n        self.deadline = deadline\n        self.callback = callback\n        self.tiebreaker = next(io_loop._timeout_counter)\n\n    # Comparison methods to sort by deadline, with object id as a tiebreaker\n    # to guarantee a consistent ordering.  The heapq module uses __le__\n    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons\n    # use __lt__).\n    def __lt__(self, other):\n        return ((self.deadline, self.tiebreaker) <\n                (other.deadline, other.tiebreaker))\n\n    def __le__(self, other):\n        return ((self.deadline, self.tiebreaker) <=\n                (other.deadline, other.tiebreaker))\n\n\nclass PeriodicCallback(object):\n    \"\"\"Schedules the given callback to be called periodically.\n\n    The callback is called every ``callback_time`` milliseconds.\n\n    `start` must be called after the `PeriodicCallback` is created.\n    \"\"\"\n    def __init__(self, callback, callback_time, io_loop=None):\n        self.callback = callback\n        if callback_time <= 0:\n            raise ValueError(\"Periodic callback must have a positive callback_time\")\n        self.callback_time = callback_time\n        self.io_loop = io_loop or IOLoop.current()\n        self._running = False\n        self._timeout = None\n\n    def start(self):\n        \"\"\"Starts the timer.\"\"\"\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()\n\n    def stop(self):\n        \"\"\"Stops the timer.\"\"\"\n        self._running = False\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n    def is_running(self):\n        \"\"\"Return True if this `.PeriodicCallback` has been started.\n\n        .. versionadded:: 4.1\n        \"\"\"\n        return self._running\n\n    def _run(self):\n        if not self._running:\n            return\n        try:\n            return self.callback()\n        except Exception:\n            self.io_loop.handle_callback_exception(self.callback)\n        finally:\n            self._schedule_next()\n\n    def _schedule_next(self):\n        if self._running:\n            current_time = self.io_loop.time()\n            while self._next_timeout <= current_time:\n                self._next_timeout += self.callback_time / 1000.0\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\n",
      "file_after": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"An I/O event loop for non-blocking sockets.\n\nTypical applications will use a single `IOLoop` object, in the\n`IOLoop.instance` singleton.  The `IOLoop.start` method should usually\nbe called at the end of the ``main()`` function.  Atypical applications may\nuse more than one `IOLoop`, such as one `IOLoop` per thread, or per `unittest`\ncase.\n\nIn addition to I/O events, the `IOLoop` can also schedule time-based events.\n`IOLoop.add_timeout` is a non-blocking alternative to `time.sleep`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\nimport datetime\nimport errno\nimport functools\nimport heapq\nimport itertools\nimport logging\nimport numbers\nimport os\nimport select\nimport sys\nimport threading\nimport time\nimport traceback\n\nfrom tornado.concurrent import TracebackFuture, is_future\nfrom tornado.log import app_log, gen_log\nfrom tornado import stack_context\nfrom tornado.util import Configurable, errno_from_exception, timedelta_to_seconds\n\ntry:\n    import signal\nexcept ImportError:\n    signal = None\n\ntry:\n    import thread  # py2\nexcept ImportError:\n    import _thread as thread  # py3\n\nfrom tornado.platform.auto import set_close_exec, Waker\n\n\n_POLL_TIMEOUT = 3600.0\n\n\nclass TimeoutError(Exception):\n    pass\n\n\nclass IOLoop(Configurable):\n    \"\"\"A level-triggered I/O loop.\n\n    We use ``epoll`` (Linux) or ``kqueue`` (BSD and Mac OS X) if they\n    are available, or else we fall back on select(). If you are\n    implementing a system that needs to handle thousands of\n    simultaneous connections, you should use a system that supports\n    either ``epoll`` or ``kqueue``.\n\n    Example usage for a simple TCP server::\n\n        import errno\n        import functools\n        import ioloop\n        import socket\n\n        def connection_ready(sock, fd, events):\n            while True:\n                try:\n                    connection, address = sock.accept()\n                except socket.error, e:\n                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):\n                        raise\n                    return\n                connection.setblocking(0)\n                handle_connection(connection, address)\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setblocking(0)\n        sock.bind((\"\", port))\n        sock.listen(128)\n\n        io_loop = ioloop.IOLoop.instance()\n        callback = functools.partial(connection_ready, sock)\n        io_loop.add_handler(sock.fileno(), callback, io_loop.READ)\n        io_loop.start()\n\n    \"\"\"\n    # Constants from the epoll module\n    _EPOLLIN = 0x001\n    _EPOLLPRI = 0x002\n    _EPOLLOUT = 0x004\n    _EPOLLERR = 0x008\n    _EPOLLHUP = 0x010\n    _EPOLLRDHUP = 0x2000\n    _EPOLLONESHOT = (1 << 30)\n    _EPOLLET = (1 << 31)\n\n    # Our events map exactly to the epoll events\n    NONE = 0\n    READ = _EPOLLIN\n    WRITE = _EPOLLOUT\n    ERROR = _EPOLLERR | _EPOLLHUP\n\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n\n    _current = threading.local()\n\n    @staticmethod\n    def instance():\n        \"\"\"Returns a global `IOLoop` instance.\n\n        Most applications have a single, global `IOLoop` running on the\n        main thread.  Use this method to get this instance from\n        another thread.  To get the current thread's `IOLoop`, use `current()`.\n        \"\"\"\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n\n    @staticmethod\n    def initialized():\n        \"\"\"Returns true if the singleton instance has been created.\"\"\"\n        return hasattr(IOLoop, \"_instance\")\n\n    def install(self):\n        \"\"\"Installs this `IOLoop` object as the singleton instance.\n\n        This is normally not necessary as `instance()` will create\n        an `IOLoop` on demand, but you may want to call `install` to use\n        a custom subclass of `IOLoop`.\n        \"\"\"\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def clear_instance():\n        \"\"\"Clear the global `IOLoop` instance.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        if hasattr(IOLoop, \"_instance\"):\n            del IOLoop._instance\n\n    @staticmethod\n    def current(instance=True):\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as\n        current by `make_current`, returns that instance.  If there is\n        no current `IOLoop`, returns `IOLoop.instance()` (i.e. the\n        main thread's `IOLoop`, creating one if necessary) if ``instance``\n        is true.\n\n        In general you should use `IOLoop.current` as the default when\n        constructing an asynchronous object, and use `IOLoop.instance`\n        when you mean to communicate to the main thread from a different\n        one.\n\n        .. versionchanged:: 4.1\n           Added ``instance`` argument to control the\n\n        \"\"\"\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None and instance:\n            return IOLoop.instance()\n        return current\n\n    def make_current(self):\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n\n        .. versionchanged:: 4.1\n           An `IOLoop` created while there is no current `IOLoop`\n           will automatically become current.\n        \"\"\"\n        IOLoop._current.instance = self\n\n    @staticmethod\n    def clear_current():\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self):\n        if IOLoop.current(instance=False) is None:\n            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for \"file descriptors\", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` method (and optionally a\n        ``close()`` method, which may be called when the `IOLoop` is shut\n        down).\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n\n        When an event occurs, ``handler(fd, events)`` will be run.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def update_handler(self, fd, events):\n        \"\"\"Changes the events we listen for ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def remove_handler(self, fd):\n        \"\"\"Stop listening for events on ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        \"\"\"Sends a signal if the `IOLoop` is blocked for more than\n        ``s`` seconds.\n\n        Pass ``seconds=None`` to disable.  Requires Python 2.6 on a unixy\n        platform.\n\n        The action parameter is a Python signal handler.  Read the\n        documentation for the `signal` module for more information.\n        If ``action`` is None, the process will be killed if it is\n        blocked for too long.\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_log_threshold(self, seconds):\n        \"\"\"Logs a stack trace if the `IOLoop` is blocked for more than\n        ``s`` seconds.\n\n        Equivalent to ``set_blocking_signal_threshold(seconds,\n        self.log_stack)``\n        \"\"\"\n        self.set_blocking_signal_threshold(seconds, self.log_stack)\n\n    def log_stack(self, signal, frame):\n        \"\"\"Signal handler to log the stack trace of the current thread.\n\n        For use with `set_blocking_signal_threshold`.\n        \"\"\"\n        gen_log.warning('IOLoop blocked for %f seconds in\\n%s',\n                        self._blocking_signal_threshold,\n                        ''.join(traceback.format_stack(frame)))\n\n    def start(self):\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the callbacks calls `stop()`, which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n        raise NotImplementedError()\n\n    def _setup_logging(self):\n        \"\"\"The IOLoop catches and logs exceptions, so it's\n        important that log output be visible.  However, python's\n        default behavior for non-root loggers (prior to python\n        3.2) is to print an unhelpful \"no handlers could be\n        found\" message rather than the actual log entry, so we\n        must explicitly configure logging if we've made it this\n        far without anything.\n\n        This method should be called from start() in subclasses.\n        \"\"\"\n        if not any([logging.getLogger().handlers,\n                    logging.getLogger('tornado').handlers,\n                    logging.getLogger('tornado.application').handlers]):\n            logging.basicConfig()\n\n    def stop(self):\n        \"\"\"Stop the I/O loop.\n\n        If the event loop is not currently running, the next call to `start()`\n        will return immediately.\n\n        To use asynchronous methods from otherwise-synchronous code (such as\n        unit tests), you can start and stop the event loop like this::\n\n          ioloop = IOLoop()\n          async_method(ioloop=ioloop, callback=ioloop.stop)\n          ioloop.start()\n\n        ``ioloop.start()`` will return after ``async_method`` has run\n        its callback, whether that callback was invoked before or\n        after ``ioloop.start``.\n\n        Note that even after `stop` has been called, the `IOLoop` is not\n        completely stopped until `IOLoop.start` has also returned.\n        Some work that was scheduled before the call to `stop` may still\n        be run before the `IOLoop` shuts down.\n        \"\"\"\n        raise NotImplementedError()\n\n    def run_sync(self, func, timeout=None):\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n\n        If the function returns a `.Future`, the `IOLoop` will run\n        until the future is resolved.  If it raises an exception, the\n        `IOLoop` will stop and the exception will be re-raised to the\n        caller.\n\n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `TimeoutError` is raised.\n\n        This method is useful in conjunction with `tornado.gen.coroutine`\n        to allow asynchronous calls in a ``main()`` function::\n\n            @gen.coroutine\n            def main():\n                # do stuff...\n\n            if __name__ == '__main__':\n                IOLoop.instance().run_sync(main)\n        \"\"\"\n        future_cell = [None]\n\n        def run():\n            try:\n                result = func()\n            except Exception:\n                future_cell[0] = TracebackFuture()\n                future_cell[0].set_exc_info(sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    future_cell[0] = TracebackFuture()\n                    future_cell[0].set_result(result)\n            self.add_future(future_cell[0], lambda future: self.stop())\n        self.add_callback(run)\n        if timeout is not None:\n            timeout_handle = self.add_timeout(self.time() + timeout, self.stop)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        if not future_cell[0].done():\n            raise TimeoutError('Operation timed out after %s seconds' % timeout)\n        return future_cell[0].result()\n\n    def time(self):\n        \"\"\"Returns the current time according to the `IOLoop`'s clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the `IOLoop`'s time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return time.time()\n\n    def add_timeout(self, deadline, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n\n        Returns an opaque handle that may be passed to\n        `remove_timeout` to cancel.\n\n        ``deadline`` may be a number denoting a time (on the same\n        scale as `IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.  Since Tornado 4.0, `call_later` is a more\n        convenient alternative for the relative case since it does not\n        require a timedelta object.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        `IOLoop`'s thread, and then call `add_timeout` from there.\n\n        Subclasses of IOLoop must implement either `add_timeout` or\n        `call_at`; the default implementations of each will call\n        the other.  `call_at` is usually easier to implement, but\n        subclasses that wish to maintain compatibility with Tornado\n        versions prior to 4.0 must use `add_timeout` instead.\n\n        .. versionchanged:: 4.0\n           Now passes through ``*args`` and ``**kwargs`` to the callback.\n        \"\"\"\n        if isinstance(deadline, numbers.Real):\n            return self.call_at(deadline, callback, *args, **kwargs)\n        elif isinstance(deadline, datetime.timedelta):\n            return self.call_at(self.time() + timedelta_to_seconds(deadline),\n                                callback, *args, **kwargs)\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n\n    def call_later(self, delay, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` after ``delay`` seconds have passed.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.call_at(self.time() + delay, callback, *args, **kwargs)\n\n    def call_at(self, when, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` at the absolute time designated by ``when``.\n\n        ``when`` must be a number using the same reference point as\n        `IOLoop.time`.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.add_timeout(when, callback, *args, **kwargs)\n\n    def remove_timeout(self, timeout):\n        \"\"\"Cancels a pending timeout.\n\n        The argument is a handle as returned by `add_timeout`.  It is\n        safe to call `remove_timeout` even if the callback has already\n        been run.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the **only**\n        method in `IOLoop` that makes this thread-safety guarantee; all\n        other interaction with the `IOLoop` must be done from that\n        `IOLoop`'s thread.  `add_callback()` may be used to transfer\n        control from other threads to the `IOLoop`'s thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback_from_signal(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n\n        Callbacks added with this method will be run without any\n        `.stack_context`, to avoid picking up the context of the function\n        that was interrupted by the signal.\n        \"\"\"\n        raise NotImplementedError()\n\n    def spawn_callback(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next IOLoop iteration.\n\n        Unlike all other callback-related methods on IOLoop,\n        ``spawn_callback`` does not associate the callback with its caller's\n        ``stack_context``, so it is suitable for fire-and-forget callbacks\n        that should not interfere with the caller.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        with stack_context.NullContext():\n            self.add_callback(callback, *args, **kwargs)\n\n    def add_future(self, future, callback):\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n        \"\"\"\n        assert is_future(future)\n        callback = stack_context.wrap(callback)\n        future.add_done_callback(\n            lambda future: self.add_callback(callback, future))\n\n    def _run_callback(self, callback):\n        \"\"\"Runs a callback with error handling.\n\n        For use in subclasses.\n        \"\"\"\n        try:\n            ret = callback()\n            if ret is not None and is_future(ret):\n                # Functions that return Futures typically swallow all\n                # exceptions and store them in the Future.  If a Future\n                # makes it out to the IOLoop, ensure its exception (if any)\n                # gets logged too.\n                self.add_future(ret, lambda f: f.result())\n        except Exception:\n            self.handle_callback_exception(callback)\n\n    def handle_callback_exception(self, callback):\n        \"\"\"This method is called whenever a callback run by the `IOLoop`\n        throws an exception.\n\n        By default simply logs the exception as an error.  Subclasses\n        may override this method to customize reporting of exceptions.\n\n        The exception itself is not passed explicitly, but is available\n        in `sys.exc_info`.\n        \"\"\"\n        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n\n    def split_fd(self, fd):\n        \"\"\"Returns an (fd, obj) pair from an ``fd`` parameter.\n\n        We accept both raw file descriptors and file-like objects as\n        input to `add_handler` and related methods.  When a file-like\n        object is passed, we must retain the object itself so we can\n        close it correctly when the `IOLoop` shuts down, but the\n        poller interfaces favor file descriptors (they will accept\n        file-like objects and call ``fileno()`` for you, but they\n        always return the descriptor itself).\n\n        This method is provided for use by `IOLoop` subclasses and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            return fd.fileno(), fd\n        except AttributeError:\n            return fd, fd\n\n    def close_fd(self, fd):\n        \"\"\"Utility method to close an ``fd``.\n\n        If ``fd`` is a file-like object, we close it directly; otherwise\n        we use `os.close`.\n\n        This method is provided for use by `IOLoop` subclasses (in\n        implementations of ``IOLoop.close(all_fds=True)`` and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            try:\n                fd.close()\n            except AttributeError:\n                os.close(fd)\n        except OSError:\n            pass\n\n\nclass PollIOLoop(IOLoop):\n    \"\"\"Base class for IOLoops built around a select-like function.\n\n    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`\n    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or\n    `tornado.platform.select.SelectIOLoop` (all platforms).\n    \"\"\"\n    def initialize(self, impl, time_func=None):\n        super(PollIOLoop, self).initialize()\n        self._impl = impl\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())\n        self.time_func = time_func or time.time\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._callback_lock = threading.Lock()\n        self._timeouts = []\n        self._cancellations = 0\n        self._running = False\n        self._stopped = False\n        self._closing = False\n        self._thread_ident = None\n        self._blocking_signal_threshold = None\n        self._timeout_counter = itertools.count()\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = Waker()\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)\n\n    def close(self, all_fds=False):\n        with self._callback_lock:\n            self._closing = True\n        self.remove_handler(self._waker.fileno())\n        if all_fds:\n            for fd, handler in self._handlers.values():\n                self.close_fd(fd)\n        self._waker.close()\n        self._impl.close()\n        self._callbacks = None\n        self._timeouts = None\n\n    def add_handler(self, fd, handler, events):\n        fd, obj = self.split_fd(fd)\n        self._handlers[fd] = (obj, stack_context.wrap(handler))\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        fd, obj = self.split_fd(fd)\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        fd, obj = self.split_fd(fd)\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except Exception:\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        if not hasattr(signal, \"setitimer\"):\n            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n                          \"with the setitimer method\")\n            return\n        self._blocking_signal_threshold = seconds\n        if seconds is not None:\n            signal.signal(signal.SIGALRM,\n                          action if action is not None else signal.SIG_DFL)\n\n    def start(self):\n        if self._running:\n            raise RuntimeError(\"IOLoop is already running\")\n        self._setup_logging()\n        if self._stopped:\n            self._stopped = False\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()\n        self._running = True\n\n        # signal.set_wakeup_fd closes a race condition in event loops:\n        # a signal may arrive at the beginning of select/poll/etc\n        # before it goes into its interruptible sleep, so the signal\n        # will be consumed without waking the select.  The solution is\n        # for the (C, synchronous) signal handler to write to a pipe,\n        # which will then be seen by select.\n        #\n        # In python's signal handling semantics, this only matters on the\n        # main thread (fortunately, set_wakeup_fd only works on the main\n        # thread and will raise a ValueError otherwise).\n        #\n        # If someone has already set a wakeup fd, we don't want to\n        # disturb it.  This is an issue for twisted, which does its\n        # SIGCHLD processing in response to its own wakeup fd being\n        # written to.  As long as the wakeup fd is registered on the IOLoop,\n        # the loop will still wake up and everything should work.\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n            # requires python 2.6+, unix.  set_wakeup_fd exists but crashes\n            # the python process on windows.\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n                    # Already set, restore previous value.  This is a little racy,\n                    # but there's no clean get_wakeup_fd and in real use the\n                    # IOLoop is just started once at the beginning.\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:  # non-main thread\n                pass\n\n        try:\n            while True:\n                # Prevent IO event starvation by delaying new callbacks\n                # to the next iteration of the event loop.\n                with self._callback_lock:\n                    callbacks = self._callbacks\n                    self._callbacks = []\n\n                # Add any timeouts that have come due to the callback list.\n                # Do not run anything until we have determined which ones\n                # are ready, so timeouts that call add_timeout cannot\n                # schedule anything in this iteration.\n                due_timeouts = []\n                if self._timeouts:\n                    now = self.time()\n                    while self._timeouts:\n                        if self._timeouts[0].callback is None:\n                            # The timeout was cancelled.  Note that the\n                            # cancellation check is repeated below for timeouts\n                            # that are cancelled by another timeout or callback.\n                            heapq.heappop(self._timeouts)\n                            self._cancellations -= 1\n                        elif self._timeouts[0].deadline <= now:\n                            due_timeouts.append(heapq.heappop(self._timeouts))\n                        else:\n                            break\n                    if (self._cancellations > 512\n                            and self._cancellations > (len(self._timeouts) >> 1)):\n                        # Clean up the timeout queue when it gets large and it's\n                        # more than half cancellations.\n                        self._cancellations = 0\n                        self._timeouts = [x for x in self._timeouts\n                                          if x.callback is not None]\n                        heapq.heapify(self._timeouts)\n\n                for callback in callbacks:\n                    self._run_callback(callback)\n                for timeout in due_timeouts:\n                    if timeout.callback is not None:\n                        self._run_callback(timeout.callback)\n                # Closures may be holding on to a lot of memory, so allow\n                # them to be freed before we go into our poll wait.\n                callbacks = callback = due_timeouts = timeout = None\n\n                if self._callbacks:\n                    # If any callbacks or timeouts called add_callback,\n                    # we don't want to wait in poll() before we run them.\n                    poll_timeout = 0.0\n                elif self._timeouts:\n                    # If there are any timeouts, schedule the first one.\n                    # Use self.time() instead of 'now' to account for time\n                    # spent running callbacks.\n                    poll_timeout = self._timeouts[0].deadline - self.time()\n                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))\n                else:\n                    # No timeouts and no callbacks, so use the default.\n                    poll_timeout = _POLL_TIMEOUT\n\n                if not self._running:\n                    break\n\n                if self._blocking_signal_threshold is not None:\n                    # clear alarm so it doesn't fire while poll is waiting for\n                    # events.\n                    signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n                try:\n                    event_pairs = self._impl.poll(poll_timeout)\n                except Exception as e:\n                    # Depending on python version and IOLoop implementation,\n                    # different exception types may be thrown and there are\n                    # two ways EINTR might be signaled:\n                    # * e.errno == errno.EINTR\n                    # * e.args is like (errno.EINTR, 'Interrupted system call')\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    else:\n                        raise\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL,\n                                     self._blocking_signal_threshold, 0)\n\n                # Pop one fd at a time from the set of pending fds and run\n                # its handler. Since that handler may perform actions on\n                # other file descriptors, there may be reentrant calls to\n                # this IOLoop that update self._events\n                self._events.update(event_pairs)\n                while self._events:\n                    fd, events = self._events.popitem()\n                    try:\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            # Happens when the client closes the connection\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\n                fd_obj = handler_func = None\n\n        finally:\n            # reset the stopped flag so another start/stop pair can be issued\n            self._stopped = False\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n            IOLoop._current.instance = old_current\n            if old_wakeup_fd is not None:\n                signal.set_wakeup_fd(old_wakeup_fd)\n\n    def stop(self):\n        self._running = False\n        self._stopped = True\n        self._waker.wake()\n\n    def time(self):\n        return self.time_func()\n\n    def call_at(self, deadline, callback, *args, **kwargs):\n        timeout = _Timeout(\n            deadline,\n            functools.partial(stack_context.wrap(callback), *args, **kwargs),\n            self)\n        heapq.heappush(self._timeouts, timeout)\n        return timeout\n\n    def remove_timeout(self, timeout):\n        # Removing from a heap is complicated, so just leave the defunct\n        # timeout object in the queue (see discussion in\n        # http://docs.python.org/library/heapq.html).\n        # If this turns out to be a problem, we could add a garbage\n        # collection pass whenever there are too many dead timeouts.\n        timeout.callback = None\n        self._cancellations += 1\n\n    def add_callback(self, callback, *args, **kwargs):\n        with self._callback_lock:\n            if self._closing:\n                raise RuntimeError(\"IOLoop is closing\")\n            list_empty = not self._callbacks\n            self._callbacks.append(functools.partial(\n                stack_context.wrap(callback), *args, **kwargs))\n            if list_empty and thread.get_ident() != self._thread_ident:\n                # If we're in the IOLoop's thread, we know it's not currently\n                # polling.  If we're not, and we added the first callback to an\n                # empty list, we may need to wake it up (it may wake up on its\n                # own, but an occasional extra wake is harmless).  Waking\n                # up a polling IOLoop is relatively expensive, so we try to\n                # avoid it when we can.\n                self._waker.wake()\n\n    def add_callback_from_signal(self, callback, *args, **kwargs):\n        with stack_context.NullContext():\n            if thread.get_ident() != self._thread_ident:\n                # if the signal is handled on another thread, we can add\n                # it normally (modulo the NullContext)\n                self.add_callback(callback, *args, **kwargs)\n            else:\n                # If we're on the IOLoop's thread, we cannot use\n                # the regular add_callback because it may deadlock on\n                # _callback_lock.  Blindly insert into self._callbacks.\n                # This is safe because the GIL makes list.append atomic.\n                # One subtlety is that if the signal interrupted the\n                # _callback_lock block in IOLoop.start, we may modify\n                # either the old or new version of self._callbacks,\n                # but either way will work.\n                self._callbacks.append(functools.partial(\n                    stack_context.wrap(callback), *args, **kwargs))\n\n\nclass _Timeout(object):\n    \"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\n\n    # Reduce memory overhead when there are lots of pending callbacks\n    __slots__ = ['deadline', 'callback', 'tiebreaker']\n\n    def __init__(self, deadline, callback, io_loop):\n        if not isinstance(deadline, numbers.Real):\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n        self.deadline = deadline\n        self.callback = callback\n        self.tiebreaker = next(io_loop._timeout_counter)\n\n    # Comparison methods to sort by deadline, with object id as a tiebreaker\n    # to guarantee a consistent ordering.  The heapq module uses __le__\n    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons\n    # use __lt__).\n    def __lt__(self, other):\n        return ((self.deadline, self.tiebreaker) <\n                (other.deadline, other.tiebreaker))\n\n    def __le__(self, other):\n        return ((self.deadline, self.tiebreaker) <=\n                (other.deadline, other.tiebreaker))\n\n\nclass PeriodicCallback(object):\n    \"\"\"Schedules the given callback to be called periodically.\n\n    The callback is called every ``callback_time`` milliseconds.\n\n    `start` must be called after the `PeriodicCallback` is created.\n\n    .. versionchanged:: 4.1\n       The ``io_loop`` argument is deprecated.\n    \"\"\"\n    def __init__(self, callback, callback_time, io_loop=None):\n        self.callback = callback\n        if callback_time <= 0:\n            raise ValueError(\"Periodic callback must have a positive callback_time\")\n        self.callback_time = callback_time\n        self.io_loop = io_loop or IOLoop.current()\n        self._running = False\n        self._timeout = None\n\n    def start(self):\n        \"\"\"Starts the timer.\"\"\"\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()\n\n    def stop(self):\n        \"\"\"Stops the timer.\"\"\"\n        self._running = False\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n    def is_running(self):\n        \"\"\"Return True if this `.PeriodicCallback` has been started.\n\n        .. versionadded:: 4.1\n        \"\"\"\n        return self._running\n\n    def _run(self):\n        if not self._running:\n            return\n        try:\n            return self.callback()\n        except Exception:\n            self.io_loop.handle_callback_exception(self.callback)\n        finally:\n            self._schedule_next()\n\n    def _schedule_next(self):\n        if self._running:\n            current_time = self.io_loop.time()\n            while self._next_timeout <= current_time:\n                self._next_timeout += self.callback_time / 1000.0\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\n",
      "file_patch": "@@ -167,28 +167,26 @@ class IOLoop(Configurable):\n             del IOLoop._instance\n \n     @staticmethod\n-    def current():\n+    def current(instance=True):\n         \"\"\"Returns the current thread's `IOLoop`.\n \n-        If an `IOLoop` is currently running or has been marked as current\n-        by `make_current`, returns that instance.  Otherwise returns\n-        `IOLoop.instance()`, i.e. the main thread's `IOLoop`.\n-\n-        A common pattern for classes that depend on ``IOLoops`` is to use\n-        a default argument to enable programs with multiple ``IOLoops``\n-        but not require the argument for simpler applications::\n-\n-            class MyClass(object):\n-                def __init__(self, io_loop=None):\n-                    self.io_loop = io_loop or IOLoop.current()\n+        If an `IOLoop` is currently running or has been marked as\n+        current by `make_current`, returns that instance.  If there is\n+        no current `IOLoop`, returns `IOLoop.instance()` (i.e. the\n+        main thread's `IOLoop`, creating one if necessary) if ``instance``\n+        is true.\n \n         In general you should use `IOLoop.current` as the default when\n         constructing an asynchronous object, and use `IOLoop.instance`\n         when you mean to communicate to the main thread from a different\n         one.\n+\n+        .. versionchanged:: 4.1\n+           Added ``instance`` argument to control the\n+\n         \"\"\"\n         current = getattr(IOLoop._current, \"instance\", None)\n-        if current is None:\n+        if current is None and instance:\n             return IOLoop.instance()\n         return current\n \n@@ -200,6 +198,10 @@ class IOLoop(Configurable):\n         `make_current` explicitly before starting the `IOLoop`,\n         so that code run at startup time can find the right\n         instance.\n+\n+        .. versionchanged:: 4.1\n+           An `IOLoop` created while there is no current `IOLoop`\n+           will automatically become current.\n         \"\"\"\n         IOLoop._current.instance = self\n \n@@ -224,7 +226,8 @@ class IOLoop(Configurable):\n         return SelectIOLoop\n \n     def initialize(self):\n-        pass\n+        if IOLoop.current(instance=False) is None:\n+            self.make_current()\n \n     def close(self, all_fds=False):\n         \"\"\"Closes the `IOLoop`, freeing any resources used.\n@@ -946,6 +949,9 @@ class PeriodicCallback(object):\n     The callback is called every ``callback_time`` milliseconds.\n \n     `start` must be called after the `PeriodicCallback` is created.\n+\n+    .. versionchanged:: 4.1\n+       The ``io_loop`` argument is deprecated.\n     \"\"\"\n     def __init__(self, callback, callback_time, io_loop=None):\n         self.callback = callback\n",
      "files_name_in_blame_commit": [
        "autoreload.py",
        "tcpclient.py",
        "netutil.py",
        "ioloop.py",
        "iostream.py",
        "httpclient.py",
        "twisted.py",
        "websocket.py",
        "gen.py",
        "process.py",
        "caresresolver.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 167
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "226": {
        "commit_id": "1a66183f19ccc61d344771c46b591c239513a254",
        "line_code": "    def initialize(self):",
        "commit_date": "2012-10-07 11:16:41",
        "valid": 1
      },
      "227": {
        "commit_id": "1a66183f19ccc61d344771c46b591c239513a254",
        "line_code": "        pass",
        "commit_date": "2012-10-07 11:16:41",
        "valid": 1
      }
    },
    "commits": {
      "1a66183f19ccc61d344771c46b591c239513a254": {
        "commit": {
          "commit_id": "1a66183f19ccc61d344771c46b591c239513a254",
          "commit_message": "Split IOLoop into a base class and poll-based implementation.\n\nThe base class has all the methods with docstrings; nearly all the\nimplementation is in a new subclass PollIOLoop.",
          "commit_author": "Ben Darnell",
          "commit_date": "2012-10-07 11:16:41",
          "commit_parent": "8b32830d73e34b09137310c69c1ece2714975af4"
        },
        "function": {
          "function_name": "initialize",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "clear_current",
            "instance",
            "_run_callback",
            "log_stack",
            "time",
            "configurable_default",
            "remove_handler",
            "start",
            "add_future",
            "add_timeout",
            "running",
            "make_current",
            "_run",
            "initialize",
            "install",
            "handle_callback_exception",
            "__le__",
            "add_callback",
            "set_blocking_signal_threshold",
            "close",
            "initialized",
            "__lt__",
            "_schedule_next",
            "add_callback_from_signal",
            "update_handler",
            "__init__",
            "remove_timeout",
            "current",
            "add_handler",
            "stop",
            "configurable_base",
            "set_blocking_log_threshold",
            "timedelta_to_seconds"
          ],
          "functions_name_all_files": [
            "clear_current",
            "poll",
            "instance",
            "_control",
            "_run_callback",
            "log_stack",
            "time",
            "configurable_default",
            "remove_handler",
            "start",
            "register",
            "add_future",
            "add_timeout",
            "running",
            "make_current",
            "_run",
            "initialize",
            "install",
            "handle_callback_exception",
            "__le__",
            "add_callback",
            "set_blocking_signal_threshold",
            "close",
            "initialized",
            "modify",
            "__lt__",
            "_schedule_next",
            "fileno",
            "add_callback_from_signal",
            "update_handler",
            "__init__",
            "remove_timeout",
            "current",
            "add_handler",
            "stop",
            "unregister",
            "configurable_base",
            "set_blocking_log_threshold",
            "timedelta_to_seconds"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "update_handler",
            "remove_timeout",
            "add_handler",
            "_run_callback",
            "time",
            "start",
            "configurable_default",
            "remove_handler",
            "stop",
            "handle_callback_exception",
            "add_future",
            "configurable_base",
            "add_callback_from_signal",
            "add_timeout",
            "set_blocking_signal_threshold",
            "add_callback",
            "running"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "update_handler",
            "remove_timeout",
            "add_handler",
            "_run_callback",
            "time",
            "start",
            "configurable_default",
            "remove_handler",
            "stop",
            "handle_callback_exception",
            "add_future",
            "configurable_base",
            "add_callback_from_signal",
            "add_timeout",
            "set_blocking_signal_threshold",
            "add_callback",
            "running"
          ]
        },
        "file": {
          "file_name": "ioloop.py",
          "file_nloc": 397,
          "file_complexity": 105,
          "file_token_count": 2232,
          "file_before": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"An I/O event loop for non-blocking sockets.\n\nTypical applications will use a single `IOLoop` object, in the\n`IOLoop.instance` singleton.  The `IOLoop.start` method should usually\nbe called at the end of the ``main()`` function.  Atypical applications may\nuse more than one `IOLoop`, such as one `IOLoop` per thread, or per `unittest`\ncase.\n\nIn addition to I/O events, the `IOLoop` can also schedule time-based events.\n`IOLoop.add_timeout` is a non-blocking alternative to `time.sleep`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, with_statement\n\nimport datetime\nimport errno\nimport functools\nimport heapq\nimport logging\nimport os\nimport select\nimport sys\nimport thread\nimport threading\nimport time\nimport traceback\n\nfrom tornado.concurrent import DummyFuture\nfrom tornado.log import app_log, gen_log\nfrom tornado import stack_context\nfrom tornado.util import Configurable\n\ntry:\n    import signal\nexcept ImportError:\n    signal = None\n\ntry:\n    from concurrent import futures\nexcept ImportError:\n    futures = None\n\nfrom tornado.platform.auto import set_close_exec, Waker\n\n\nclass IOLoop(Configurable):\n    \"\"\"A level-triggered I/O loop.\n\n    We use epoll (Linux) or kqueue (BSD and Mac OS X; requires python\n    2.6+) if they are available, or else we fall back on select(). If\n    you are implementing a system that needs to handle thousands of\n    simultaneous connections, you should use a system that supports either\n    epoll or queue.\n\n    Example usage for a simple TCP server::\n\n        import errno\n        import functools\n        import ioloop\n        import socket\n\n        def connection_ready(sock, fd, events):\n            while True:\n                try:\n                    connection, address = sock.accept()\n                except socket.error, e:\n                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):\n                        raise\n                    return\n                connection.setblocking(0)\n                handle_connection(connection, address)\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setblocking(0)\n        sock.bind((\"\", port))\n        sock.listen(128)\n\n        io_loop = ioloop.IOLoop.instance()\n        callback = functools.partial(connection_ready, sock)\n        io_loop.add_handler(sock.fileno(), callback, io_loop.READ)\n        io_loop.start()\n\n    \"\"\"\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\") or sys.platform.startswith('linux'):\n            try:\n                from tornado.platform.epoll import EPollIOLoop\n                return EPollIOLoop\n            except ImportError:\n                gen_log.warning(\"unable to import EPollIOLoop, falling back to SelectIOLoop\")\n                pass\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    # Constants from the epoll module\n    _EPOLLIN = 0x001\n    _EPOLLPRI = 0x002\n    _EPOLLOUT = 0x004\n    _EPOLLERR = 0x008\n    _EPOLLHUP = 0x010\n    _EPOLLRDHUP = 0x2000\n    _EPOLLONESHOT = (1 << 30)\n    _EPOLLET = (1 << 31)\n\n    # Our events map exactly to the epoll events\n    NONE = 0\n    READ = _EPOLLIN\n    WRITE = _EPOLLOUT\n    ERROR = _EPOLLERR | _EPOLLHUP\n\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n\n    _current = threading.local()\n\n    def initialize(self, impl, time_func=None):\n        self._impl = impl\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())\n        self.time_func = time_func or time.time\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._callback_lock = threading.Lock()\n        self._timeouts = []\n        self._running = False\n        self._stopped = False\n        self._thread_ident = None\n        self._blocking_signal_threshold = None\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = Waker()\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)\n\n    @staticmethod\n    def instance():\n        \"\"\"Returns a global IOLoop instance.\n\n        Most single-threaded applications have a single, global IOLoop.\n        Use this method instead of passing around IOLoop instances\n        throughout your code.\n\n        A common pattern for classes that depend on IOLoops is to use\n        a default argument to enable programs with multiple IOLoops\n        but not require the argument for simpler applications::\n\n            class MyClass(object):\n                def __init__(self, io_loop=None):\n                    self.io_loop = io_loop or IOLoop.instance()\n        \"\"\"\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n\n    @staticmethod\n    def initialized():\n        \"\"\"Returns true if the singleton instance has been created.\"\"\"\n        return hasattr(IOLoop, \"_instance\")\n\n    def install(self):\n        \"\"\"Installs this IOloop object as the singleton instance.\n\n        This is normally not necessary as `instance()` will create\n        an IOLoop on demand, but you may want to call `install` to use\n        a custom subclass of IOLoop.\n        \"\"\"\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def current():\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None:\n            raise ValueError(\"no current IOLoop\")\n        return current\n\n    def make_current(self):\n        IOLoop._current.instance = self\n\n    def clear_current(self):\n        assert IOLoop._current.instance is self\n        IOLoop._current.instance = None\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the IOLoop, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the IOLoop itself).\n\n        Many applications will only use a single IOLoop that runs for the\n        entire lifetime of the process.  In that case closing the IOLoop\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        IOLoops.\n\n        An IOLoop must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n        \"\"\"\n        self.remove_handler(self._waker.fileno())\n        if all_fds:\n            for fd in self._handlers.keys()[:]:\n                try:\n                    os.close(fd)\n                except Exception:\n                    gen_log.debug(\"error closing fd %s\", fd, exc_info=True)\n        self._waker.close()\n        self._impl.close()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for fd.\"\"\"\n        self._handlers[fd] = stack_context.wrap(handler)\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        \"\"\"Changes the events we listen for fd.\"\"\"\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        \"\"\"Stop listening for events on fd.\"\"\"\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except (OSError, IOError):\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        \"\"\"Sends a signal if the ioloop is blocked for more than s seconds.\n\n        Pass seconds=None to disable.  Requires python 2.6 on a unixy\n        platform.\n\n        The action parameter is a python signal handler.  Read the\n        documentation for the python 'signal' module for more information.\n        If action is None, the process will be killed if it is blocked for\n        too long.\n        \"\"\"\n        if not hasattr(signal, \"setitimer\"):\n            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n                           \"with the setitimer method\")\n            return\n        self._blocking_signal_threshold = seconds\n        if seconds is not None:\n            signal.signal(signal.SIGALRM,\n                          action if action is not None else signal.SIG_DFL)\n\n    def set_blocking_log_threshold(self, seconds):\n        \"\"\"Logs a stack trace if the ioloop is blocked for more than s seconds.\n        Equivalent to set_blocking_signal_threshold(seconds, self.log_stack)\n        \"\"\"\n        self.set_blocking_signal_threshold(seconds, self.log_stack)\n\n    def log_stack(self, signal, frame):\n        \"\"\"Signal handler to log the stack trace of the current thread.\n\n        For use with set_blocking_signal_threshold.\n        \"\"\"\n        gen_log.warning('IOLoop blocked for %f seconds in\\n%s',\n                         self._blocking_signal_threshold,\n                         ''.join(traceback.format_stack(frame)))\n\n    def start(self):\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the I/O handlers calls stop(), which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n        if not logging.getLogger().handlers:\n            # The IOLoop catches and logs exceptions, so it's\n            # important that log output be visible.  However, python's\n            # default behavior for non-root loggers (prior to python\n            # 3.2) is to print an unhelpful \"no handlers could be\n            # found\" message rather than the actual log entry, so we\n            # must explicitly configure logging if we've made it this\n            # far without anything.\n            logging.basicConfig()\n        if self._stopped:\n            self._stopped = False\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()\n        self._running = True\n\n        # signal.set_wakeup_fd closes a race condition in event loops:\n        # a signal may arrive at the beginning of select/poll/etc\n        # before it goes into its interruptible sleep, so the signal\n        # will be consumed without waking the select.  The solution is\n        # for the (C, synchronous) signal handler to write to a pipe,\n        # which will then be seen by select.\n        #\n        # In python's signal handling semantics, this only matters on the\n        # main thread (fortunately, set_wakeup_fd only works on the main\n        # thread and will raise a ValueError otherwise).\n        #\n        # If someone has already set a wakeup fd, we don't want to\n        # disturb it.  This is an issue for twisted, which does its\n        # SIGCHILD processing in response to its own wakeup fd being\n        # written to.  As long as the wakeup fd is registered on the IOLoop,\n        # the loop will still wake up and everything should work.\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n            # requires python 2.6+, unix.  set_wakeup_fd exists but crashes\n            # the python process on windows.\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n                    # Already set, restore previous value.  This is a little racy,\n                    # but there's no clean get_wakeup_fd and in real use the\n                    # IOLoop is just started once at the beginning.\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:  # non-main thread\n                pass\n\n        while True:\n            poll_timeout = 3600.0\n\n            # Prevent IO event starvation by delaying new callbacks\n            # to the next iteration of the event loop.\n            with self._callback_lock:\n                callbacks = self._callbacks\n                self._callbacks = []\n            for callback in callbacks:\n                self._run_callback(callback)\n\n            if self._timeouts:\n                now = self.time()\n                while self._timeouts:\n                    if self._timeouts[0].callback is None:\n                        # the timeout was cancelled\n                        heapq.heappop(self._timeouts)\n                    elif self._timeouts[0].deadline <= now:\n                        timeout = heapq.heappop(self._timeouts)\n                        self._run_callback(timeout.callback)\n                    else:\n                        seconds = self._timeouts[0].deadline - now\n                        poll_timeout = min(seconds, poll_timeout)\n                        break\n\n            if self._callbacks:\n                # If any callbacks or timeouts called add_callback,\n                # we don't want to wait in poll() before we run them.\n                poll_timeout = 0.0\n\n            if not self._running:\n                break\n\n            if self._blocking_signal_threshold is not None:\n                # clear alarm so it doesn't fire while poll is waiting for\n                # events.\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n            try:\n                event_pairs = self._impl.poll(poll_timeout)\n            except Exception, e:\n                # Depending on python version and IOLoop implementation,\n                # different exception types may be thrown and there are\n                # two ways EINTR might be signaled:\n                # * e.errno == errno.EINTR\n                # * e.args is like (errno.EINTR, 'Interrupted system call')\n                if (getattr(e, 'errno', None) == errno.EINTR or\n                    (isinstance(getattr(e, 'args', None), tuple) and\n                     len(e.args) == 2 and e.args[0] == errno.EINTR)):\n                    continue\n                else:\n                    raise\n\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL,\n                                 self._blocking_signal_threshold, 0)\n\n            # Pop one fd at a time from the set of pending fds and run\n            # its handler. Since that handler may perform actions on\n            # other file descriptors, there may be reentrant calls to\n            # this IOLoop that update self._events\n            self._events.update(event_pairs)\n            while self._events:\n                fd, events = self._events.popitem()\n                try:\n                    self._handlers[fd](fd, events)\n                except (OSError, IOError), e:\n                    if e.args[0] == errno.EPIPE:\n                        # Happens when the client closes the connection\n                        pass\n                    else:\n                        app_log.error(\"Exception in I/O handler for fd %s\",\n                                      fd, exc_info=True)\n                except Exception:\n                    app_log.error(\"Exception in I/O handler for fd %s\",\n                                  fd, exc_info=True)\n        # reset the stopped flag so another start/stop pair can be issued\n        self._stopped = False\n        if self._blocking_signal_threshold is not None:\n            signal.setitimer(signal.ITIMER_REAL, 0, 0)\n        IOLoop._current.instance = old_current\n        if old_wakeup_fd is not None:\n            signal.set_wakeup_fd(old_wakeup_fd)\n\n    def stop(self):\n        \"\"\"Stop the loop after the current event loop iteration is complete.\n        If the event loop is not currently running, the next call to start()\n        will return immediately.\n\n        To use asynchronous methods from otherwise-synchronous code (such as\n        unit tests), you can start and stop the event loop like this::\n\n          ioloop = IOLoop()\n          async_method(ioloop=ioloop, callback=ioloop.stop)\n          ioloop.start()\n\n        ioloop.start() will return after async_method has run its callback,\n        whether that callback was invoked before or after ioloop.start.\n\n        Note that even after `stop` has been called, the IOLoop is not\n        completely stopped until `IOLoop.start` has also returned.\n        \"\"\"\n        self._running = False\n        self._stopped = True\n        self._waker.wake()\n\n    def running(self):\n        \"\"\"Returns true if this IOLoop is currently running.\"\"\"\n        return self._running\n\n    def time(self):\n        \"\"\"Returns the current time according to the IOLoop's clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the IOLoop's time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return self.time_func()\n\n    def add_timeout(self, deadline, callback):\n        \"\"\"Calls the given callback at the time deadline from the I/O loop.\n\n        Returns a handle that may be passed to remove_timeout to cancel.\n\n        ``deadline`` may be a number denoting a time relative to\n        `IOLoop.time`, or a ``datetime.timedelta`` object for a\n        deadline relative to the current time.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        IOLoop's thread, and then call `add_timeout` from there.\n        \"\"\"\n        timeout = _Timeout(deadline, stack_context.wrap(callback), self)\n        heapq.heappush(self._timeouts, timeout)\n        return timeout\n\n    def remove_timeout(self, timeout):\n        \"\"\"Cancels a pending timeout.\n\n        The argument is a handle as returned by add_timeout.\n        \"\"\"\n        # Removing from a heap is complicated, so just leave the defunct\n        # timeout object in the queue (see discussion in\n        # http://docs.python.org/library/heapq.html).\n        # If this turns out to be a problem, we could add a garbage\n        # collection pass whenever there are too many dead timeouts.\n        timeout.callback = None\n\n    def add_callback(self, callback):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the *only*\n        method in IOLoop that makes this thread-safety guarantee; all\n        other interaction with the IOLoop must be done from that\n        IOLoop's thread.  add_callback() may be used to transfer\n        control from other threads to the IOLoop's thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n        with self._callback_lock:\n            list_empty = not self._callbacks\n            self._callbacks.append(stack_context.wrap(callback))\n        if list_empty and thread.get_ident() != self._thread_ident:\n            # If we're in the IOLoop's thread, we know it's not currently\n            # polling.  If we're not, and we added the first callback to an\n            # empty list, we may need to wake it up (it may wake up on its\n            # own, but an occasional extra wake is harmless).  Waking\n            # up a polling IOLoop is relatively expensive, so we try to\n            # avoid it when we can.\n            self._waker.wake()\n\n    def add_callback_from_signal(self, callback):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n\n        Callbacks added with this method will be run without any\n        stack_context, to avoid picking up the context of the function\n        that was interrupted by the signal.\n        \"\"\"\n        with stack_context.NullContext():\n            if thread.get_ident() != self._thread_ident:\n                # if the signal is handled on another thread, we can add\n                # it normally (modulo the NullContext)\n                self.add_callback(callback)\n            else:\n                # If we're on the IOLoop's thread, we cannot use\n                # the regular add_callback because it may deadlock on\n                # _callback_lock.  Blindly insert into self._callbacks.\n                # This is safe because the GIL makes list.append atomic.\n                # One subtlety is that if the signal interrupted the\n                # _callback_lock block in IOLoop.start, we may modify\n                # either the old or new version of self._callbacks,\n                # but either way will work.\n                self._callbacks.append(stack_context.wrap(callback))\n\n    if futures is not None:\n        _FUTURE_TYPES = (futures.Future, DummyFuture)\n    else:\n        _FUTURE_TYPES = DummyFuture\n    def add_future(self, future, callback):\n        \"\"\"Schedules a callback on the IOLoop when the given future is finished.\n\n        The callback is invoked with one argument, the future.\n        \"\"\"\n        assert isinstance(future, IOLoop._FUTURE_TYPES)\n        callback = stack_context.wrap(callback)\n        future.add_done_callback(\n            lambda future: self.add_callback(\n                functools.partial(callback, future)))\n\n    def _run_callback(self, callback):\n        try:\n            callback()\n        except Exception:\n            self.handle_callback_exception(callback)\n\n    def handle_callback_exception(self, callback):\n        \"\"\"This method is called whenever a callback run by the IOLoop\n        throws an exception.\n\n        By default simply logs the exception as an error.  Subclasses\n        may override this method to customize reporting of exceptions.\n\n        The exception itself is not passed explicitly, but is available\n        in sys.exc_info.\n        \"\"\"\n        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n\n\nclass _Timeout(object):\n    \"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\n\n    # Reduce memory overhead when there are lots of pending callbacks\n    __slots__ = ['deadline', 'callback']\n\n    def __init__(self, deadline, callback, io_loop):\n        if isinstance(deadline, (int, long, float)):\n            self.deadline = deadline\n        elif isinstance(deadline, datetime.timedelta):\n            self.deadline = io_loop.time() + _Timeout.timedelta_to_seconds(deadline)\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n        self.callback = callback\n\n    @staticmethod\n    def timedelta_to_seconds(td):\n        \"\"\"Equivalent to td.total_seconds() (introduced in python 2.7).\"\"\"\n        return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10 ** 6) / float(10 ** 6)\n\n    # Comparison methods to sort by deadline, with object id as a tiebreaker\n    # to guarantee a consistent ordering.  The heapq module uses __le__\n    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons\n    # use __lt__).\n    def __lt__(self, other):\n        return ((self.deadline, id(self)) <\n                (other.deadline, id(other)))\n\n    def __le__(self, other):\n        return ((self.deadline, id(self)) <=\n                (other.deadline, id(other)))\n\n\nclass PeriodicCallback(object):\n    \"\"\"Schedules the given callback to be called periodically.\n\n    The callback is called every callback_time milliseconds.\n\n    `start` must be called after the PeriodicCallback is created.\n    \"\"\"\n    def __init__(self, callback, callback_time, io_loop=None):\n        self.callback = callback\n        self.callback_time = callback_time\n        self.io_loop = io_loop or IOLoop.instance()\n        self._running = False\n        self._timeout = None\n\n    def start(self):\n        \"\"\"Starts the timer.\"\"\"\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()\n\n    def stop(self):\n        \"\"\"Stops the timer.\"\"\"\n        self._running = False\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n    def _run(self):\n        if not self._running:\n            return\n        try:\n            self.callback()\n        except Exception:\n            app_log.error(\"Error in periodic callback\", exc_info=True)\n        self._schedule_next()\n\n    def _schedule_next(self):\n        if self._running:\n            current_time = self.io_loop.time()\n            while self._next_timeout <= current_time:\n                self._next_timeout += self.callback_time / 1000.0\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\n",
          "file_after": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"An I/O event loop for non-blocking sockets.\n\nTypical applications will use a single `IOLoop` object, in the\n`IOLoop.instance` singleton.  The `IOLoop.start` method should usually\nbe called at the end of the ``main()`` function.  Atypical applications may\nuse more than one `IOLoop`, such as one `IOLoop` per thread, or per `unittest`\ncase.\n\nIn addition to I/O events, the `IOLoop` can also schedule time-based events.\n`IOLoop.add_timeout` is a non-blocking alternative to `time.sleep`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, with_statement\n\nimport datetime\nimport errno\nimport functools\nimport heapq\nimport logging\nimport os\nimport select\nimport sys\nimport thread\nimport threading\nimport time\nimport traceback\n\nfrom tornado.concurrent import DummyFuture\nfrom tornado.log import app_log, gen_log\nfrom tornado import stack_context\nfrom tornado.util import Configurable\n\ntry:\n    import signal\nexcept ImportError:\n    signal = None\n\ntry:\n    from concurrent import futures\nexcept ImportError:\n    futures = None\n\nfrom tornado.platform.auto import set_close_exec, Waker\n\n\nclass IOLoop(Configurable):\n    \"\"\"A level-triggered I/O loop.\n\n    We use epoll (Linux) or kqueue (BSD and Mac OS X; requires python\n    2.6+) if they are available, or else we fall back on select(). If\n    you are implementing a system that needs to handle thousands of\n    simultaneous connections, you should use a system that supports either\n    epoll or queue.\n\n    Example usage for a simple TCP server::\n\n        import errno\n        import functools\n        import ioloop\n        import socket\n\n        def connection_ready(sock, fd, events):\n            while True:\n                try:\n                    connection, address = sock.accept()\n                except socket.error, e:\n                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):\n                        raise\n                    return\n                connection.setblocking(0)\n                handle_connection(connection, address)\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setblocking(0)\n        sock.bind((\"\", port))\n        sock.listen(128)\n\n        io_loop = ioloop.IOLoop.instance()\n        callback = functools.partial(connection_ready, sock)\n        io_loop.add_handler(sock.fileno(), callback, io_loop.READ)\n        io_loop.start()\n\n    \"\"\"\n    # Constants from the epoll module\n    _EPOLLIN = 0x001\n    _EPOLLPRI = 0x002\n    _EPOLLOUT = 0x004\n    _EPOLLERR = 0x008\n    _EPOLLHUP = 0x010\n    _EPOLLRDHUP = 0x2000\n    _EPOLLONESHOT = (1 << 30)\n    _EPOLLET = (1 << 31)\n\n    # Our events map exactly to the epoll events\n    NONE = 0\n    READ = _EPOLLIN\n    WRITE = _EPOLLOUT\n    ERROR = _EPOLLERR | _EPOLLHUP\n\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n\n    _current = threading.local()\n\n    @staticmethod\n    def instance():\n        \"\"\"Returns a global IOLoop instance.\n\n        Most single-threaded applications have a single, global IOLoop.\n        Use this method instead of passing around IOLoop instances\n        throughout your code.\n\n        A common pattern for classes that depend on IOLoops is to use\n        a default argument to enable programs with multiple IOLoops\n        but not require the argument for simpler applications::\n\n            class MyClass(object):\n                def __init__(self, io_loop=None):\n                    self.io_loop = io_loop or IOLoop.instance()\n        \"\"\"\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n\n    @staticmethod\n    def initialized():\n        \"\"\"Returns true if the singleton instance has been created.\"\"\"\n        return hasattr(IOLoop, \"_instance\")\n\n    def install(self):\n        \"\"\"Installs this IOloop object as the singleton instance.\n\n        This is normally not necessary as `instance()` will create\n        an IOLoop on demand, but you may want to call `install` to use\n        a custom subclass of IOLoop.\n        \"\"\"\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def current():\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None:\n            raise ValueError(\"no current IOLoop\")\n        return current\n\n    def make_current(self):\n        IOLoop._current.instance = self\n\n    def clear_current(self):\n        assert IOLoop._current.instance is self\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\") or sys.platform.startswith('linux'):\n            try:\n                from tornado.platform.epoll import EPollIOLoop\n                return EPollIOLoop\n            except ImportError:\n                gen_log.warning(\"unable to import EPollIOLoop, falling back to SelectIOLoop\")\n                pass\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self):\n        pass\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the IOLoop, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the IOLoop itself).\n\n        Many applications will only use a single IOLoop that runs for the\n        entire lifetime of the process.  In that case closing the IOLoop\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        IOLoops.\n\n        An IOLoop must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for fd.\"\"\"\n        raise NotImplementedError()\n\n    def update_handler(self, fd, events):\n        \"\"\"Changes the events we listen for fd.\"\"\"\n        raise NotImplementedError()\n\n    def remove_handler(self, fd):\n        \"\"\"Stop listening for events on fd.\"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        \"\"\"Sends a signal if the ioloop is blocked for more than s seconds.\n\n        Pass seconds=None to disable.  Requires python 2.6 on a unixy\n        platform.\n\n        The action parameter is a python signal handler.  Read the\n        documentation for the python 'signal' module for more information.\n        If action is None, the process will be killed if it is blocked for\n        too long.\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_blocking_log_threshold(self, seconds):\n        \"\"\"Logs a stack trace if the ioloop is blocked for more than s seconds.\n        Equivalent to set_blocking_signal_threshold(seconds, self.log_stack)\n        \"\"\"\n        self.set_blocking_signal_threshold(seconds, self.log_stack)\n\n    def log_stack(self, signal, frame):\n        \"\"\"Signal handler to log the stack trace of the current thread.\n\n        For use with set_blocking_signal_threshold.\n        \"\"\"\n        gen_log.warning('IOLoop blocked for %f seconds in\\n%s',\n                         self._blocking_signal_threshold,\n                         ''.join(traceback.format_stack(frame)))\n\n    def start(self):\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the I/O handlers calls stop(), which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n        raise NotImplementedError()\n\n    def stop(self):\n        \"\"\"Stop the loop after the current event loop iteration is complete.\n        If the event loop is not currently running, the next call to start()\n        will return immediately.\n\n        To use asynchronous methods from otherwise-synchronous code (such as\n        unit tests), you can start and stop the event loop like this::\n\n          ioloop = IOLoop()\n          async_method(ioloop=ioloop, callback=ioloop.stop)\n          ioloop.start()\n\n        ioloop.start() will return after async_method has run its callback,\n        whether that callback was invoked before or after ioloop.start.\n\n        Note that even after `stop` has been called, the IOLoop is not\n        completely stopped until `IOLoop.start` has also returned.\n        \"\"\"\n        raise NotImplementedError()\n\n    def running(self):\n        \"\"\"Returns true if this IOLoop is currently running.\"\"\"\n        raise NotImplementedError()\n\n    def time(self):\n        \"\"\"Returns the current time according to the IOLoop's clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the IOLoop's time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return time.time()\n\n    def add_timeout(self, deadline, callback):\n        \"\"\"Calls the given callback at the time deadline from the I/O loop.\n\n        Returns a handle that may be passed to remove_timeout to cancel.\n\n        ``deadline`` may be a number denoting a time relative to\n        `IOLoop.time`, or a ``datetime.timedelta`` object for a\n        deadline relative to the current time.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        IOLoop's thread, and then call `add_timeout` from there.\n        \"\"\"\n        raise NotImplementedError()\n\n    def remove_timeout(self, timeout):\n        \"\"\"Cancels a pending timeout.\n\n        The argument is a handle as returned by add_timeout.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback(self, callback):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the *only*\n        method in IOLoop that makes this thread-safety guarantee; all\n        other interaction with the IOLoop must be done from that\n        IOLoop's thread.  add_callback() may be used to transfer\n        control from other threads to the IOLoop's thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_callback_from_signal(self, callback):\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n\n        Callbacks added with this method will be run without any\n        stack_context, to avoid picking up the context of the function\n        that was interrupted by the signal.\n        \"\"\"\n        raise NotImplementedError()\n\n    if futures is not None:\n        _FUTURE_TYPES = (futures.Future, DummyFuture)\n    else:\n        _FUTURE_TYPES = DummyFuture\n    def add_future(self, future, callback):\n        \"\"\"Schedules a callback on the IOLoop when the given future is finished.\n\n        The callback is invoked with one argument, the future.\n        \"\"\"\n        assert isinstance(future, IOLoop._FUTURE_TYPES)\n        callback = stack_context.wrap(callback)\n        future.add_done_callback(\n            lambda future: self.add_callback(\n                functools.partial(callback, future)))\n\n    def _run_callback(self, callback):\n        \"\"\"Runs a callback with error handling.\n\n        For use in subclasses.\n        \"\"\"\n        try:\n            callback()\n        except Exception:\n            self.handle_callback_exception(callback)\n\n    def handle_callback_exception(self, callback):\n        \"\"\"This method is called whenever a callback run by the IOLoop\n        throws an exception.\n\n        By default simply logs the exception as an error.  Subclasses\n        may override this method to customize reporting of exceptions.\n\n        The exception itself is not passed explicitly, but is available\n        in sys.exc_info.\n        \"\"\"\n        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n\n\n\nclass PollIOLoop(IOLoop):\n    \"\"\"Base class for IOLoops built around a select-like function.\n\n    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`\n    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or\n    `tornado.platform.select.SelectIOLoop` (all platforms).\n    \"\"\"\n    def initialize(self, impl, time_func=None):\n        super(PollIOLoop, self).initialize()\n        self._impl = impl\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())\n        self.time_func = time_func or time.time\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._callback_lock = threading.Lock()\n        self._timeouts = []\n        self._running = False\n        self._stopped = False\n        self._thread_ident = None\n        self._blocking_signal_threshold = None\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = Waker()\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)\n\n    def close(self, all_fds=False):\n        self.remove_handler(self._waker.fileno())\n        if all_fds:\n            for fd in self._handlers.keys()[:]:\n                try:\n                    os.close(fd)\n                except Exception:\n                    gen_log.debug(\"error closing fd %s\", fd, exc_info=True)\n        self._waker.close()\n        self._impl.close()\n\n    def add_handler(self, fd, handler, events):\n        self._handlers[fd] = stack_context.wrap(handler)\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except (OSError, IOError):\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        if not hasattr(signal, \"setitimer\"):\n            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n                           \"with the setitimer method\")\n            return\n        self._blocking_signal_threshold = seconds\n        if seconds is not None:\n            signal.signal(signal.SIGALRM,\n                          action if action is not None else signal.SIG_DFL)\n\n    def start(self):\n        if not logging.getLogger().handlers:\n            # The IOLoop catches and logs exceptions, so it's\n            # important that log output be visible.  However, python's\n            # default behavior for non-root loggers (prior to python\n            # 3.2) is to print an unhelpful \"no handlers could be\n            # found\" message rather than the actual log entry, so we\n            # must explicitly configure logging if we've made it this\n            # far without anything.\n            logging.basicConfig()\n        if self._stopped:\n            self._stopped = False\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()\n        self._running = True\n\n        # signal.set_wakeup_fd closes a race condition in event loops:\n        # a signal may arrive at the beginning of select/poll/etc\n        # before it goes into its interruptible sleep, so the signal\n        # will be consumed without waking the select.  The solution is\n        # for the (C, synchronous) signal handler to write to a pipe,\n        # which will then be seen by select.\n        #\n        # In python's signal handling semantics, this only matters on the\n        # main thread (fortunately, set_wakeup_fd only works on the main\n        # thread and will raise a ValueError otherwise).\n        #\n        # If someone has already set a wakeup fd, we don't want to\n        # disturb it.  This is an issue for twisted, which does its\n        # SIGCHILD processing in response to its own wakeup fd being\n        # written to.  As long as the wakeup fd is registered on the IOLoop,\n        # the loop will still wake up and everything should work.\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n            # requires python 2.6+, unix.  set_wakeup_fd exists but crashes\n            # the python process on windows.\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n                    # Already set, restore previous value.  This is a little racy,\n                    # but there's no clean get_wakeup_fd and in real use the\n                    # IOLoop is just started once at the beginning.\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:  # non-main thread\n                pass\n\n        while True:\n            poll_timeout = 3600.0\n\n            # Prevent IO event starvation by delaying new callbacks\n            # to the next iteration of the event loop.\n            with self._callback_lock:\n                callbacks = self._callbacks\n                self._callbacks = []\n            for callback in callbacks:\n                self._run_callback(callback)\n\n            if self._timeouts:\n                now = self.time()\n                while self._timeouts:\n                    if self._timeouts[0].callback is None:\n                        # the timeout was cancelled\n                        heapq.heappop(self._timeouts)\n                    elif self._timeouts[0].deadline <= now:\n                        timeout = heapq.heappop(self._timeouts)\n                        self._run_callback(timeout.callback)\n                    else:\n                        seconds = self._timeouts[0].deadline - now\n                        poll_timeout = min(seconds, poll_timeout)\n                        break\n\n            if self._callbacks:\n                # If any callbacks or timeouts called add_callback,\n                # we don't want to wait in poll() before we run them.\n                poll_timeout = 0.0\n\n            if not self._running:\n                break\n\n            if self._blocking_signal_threshold is not None:\n                # clear alarm so it doesn't fire while poll is waiting for\n                # events.\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n            try:\n                event_pairs = self._impl.poll(poll_timeout)\n            except Exception, e:\n                # Depending on python version and IOLoop implementation,\n                # different exception types may be thrown and there are\n                # two ways EINTR might be signaled:\n                # * e.errno == errno.EINTR\n                # * e.args is like (errno.EINTR, 'Interrupted system call')\n                if (getattr(e, 'errno', None) == errno.EINTR or\n                    (isinstance(getattr(e, 'args', None), tuple) and\n                     len(e.args) == 2 and e.args[0] == errno.EINTR)):\n                    continue\n                else:\n                    raise\n\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL,\n                                 self._blocking_signal_threshold, 0)\n\n            # Pop one fd at a time from the set of pending fds and run\n            # its handler. Since that handler may perform actions on\n            # other file descriptors, there may be reentrant calls to\n            # this IOLoop that update self._events\n            self._events.update(event_pairs)\n            while self._events:\n                fd, events = self._events.popitem()\n                try:\n                    self._handlers[fd](fd, events)\n                except (OSError, IOError), e:\n                    if e.args[0] == errno.EPIPE:\n                        # Happens when the client closes the connection\n                        pass\n                    else:\n                        app_log.error(\"Exception in I/O handler for fd %s\",\n                                      fd, exc_info=True)\n                except Exception:\n                    app_log.error(\"Exception in I/O handler for fd %s\",\n                                  fd, exc_info=True)\n        # reset the stopped flag so another start/stop pair can be issued\n        self._stopped = False\n        if self._blocking_signal_threshold is not None:\n            signal.setitimer(signal.ITIMER_REAL, 0, 0)\n        IOLoop._current.instance = old_current\n        if old_wakeup_fd is not None:\n            signal.set_wakeup_fd(old_wakeup_fd)\n\n    def stop(self):\n        self._running = False\n        self._stopped = True\n        self._waker.wake()\n\n    def running(self):\n        return self._running\n\n    def time(self):\n        return self.time_func()\n\n    def add_timeout(self, deadline, callback):\n        timeout = _Timeout(deadline, stack_context.wrap(callback), self)\n        heapq.heappush(self._timeouts, timeout)\n        return timeout\n\n    def remove_timeout(self, timeout):\n        # Removing from a heap is complicated, so just leave the defunct\n        # timeout object in the queue (see discussion in\n        # http://docs.python.org/library/heapq.html).\n        # If this turns out to be a problem, we could add a garbage\n        # collection pass whenever there are too many dead timeouts.\n        timeout.callback = None\n\n    def add_callback(self, callback):\n        with self._callback_lock:\n            list_empty = not self._callbacks\n            self._callbacks.append(stack_context.wrap(callback))\n        if list_empty and thread.get_ident() != self._thread_ident:\n            # If we're in the IOLoop's thread, we know it's not currently\n            # polling.  If we're not, and we added the first callback to an\n            # empty list, we may need to wake it up (it may wake up on its\n            # own, but an occasional extra wake is harmless).  Waking\n            # up a polling IOLoop is relatively expensive, so we try to\n            # avoid it when we can.\n            self._waker.wake()\n\n    def add_callback_from_signal(self, callback):\n        with stack_context.NullContext():\n            if thread.get_ident() != self._thread_ident:\n                # if the signal is handled on another thread, we can add\n                # it normally (modulo the NullContext)\n                self.add_callback(callback)\n            else:\n                # If we're on the IOLoop's thread, we cannot use\n                # the regular add_callback because it may deadlock on\n                # _callback_lock.  Blindly insert into self._callbacks.\n                # This is safe because the GIL makes list.append atomic.\n                # One subtlety is that if the signal interrupted the\n                # _callback_lock block in IOLoop.start, we may modify\n                # either the old or new version of self._callbacks,\n                # but either way will work.\n                self._callbacks.append(stack_context.wrap(callback))\n\n\nclass _Timeout(object):\n    \"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\n\n    # Reduce memory overhead when there are lots of pending callbacks\n    __slots__ = ['deadline', 'callback']\n\n    def __init__(self, deadline, callback, io_loop):\n        if isinstance(deadline, (int, long, float)):\n            self.deadline = deadline\n        elif isinstance(deadline, datetime.timedelta):\n            self.deadline = io_loop.time() + _Timeout.timedelta_to_seconds(deadline)\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)\n        self.callback = callback\n\n    @staticmethod\n    def timedelta_to_seconds(td):\n        \"\"\"Equivalent to td.total_seconds() (introduced in python 2.7).\"\"\"\n        return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10 ** 6) / float(10 ** 6)\n\n    # Comparison methods to sort by deadline, with object id as a tiebreaker\n    # to guarantee a consistent ordering.  The heapq module uses __le__\n    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons\n    # use __lt__).\n    def __lt__(self, other):\n        return ((self.deadline, id(self)) <\n                (other.deadline, id(other)))\n\n    def __le__(self, other):\n        return ((self.deadline, id(self)) <=\n                (other.deadline, id(other)))\n\n\nclass PeriodicCallback(object):\n    \"\"\"Schedules the given callback to be called periodically.\n\n    The callback is called every callback_time milliseconds.\n\n    `start` must be called after the PeriodicCallback is created.\n    \"\"\"\n    def __init__(self, callback, callback_time, io_loop=None):\n        self.callback = callback\n        self.callback_time = callback_time\n        self.io_loop = io_loop or IOLoop.instance()\n        self._running = False\n        self._timeout = None\n\n    def start(self):\n        \"\"\"Starts the timer.\"\"\"\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()\n\n    def stop(self):\n        \"\"\"Stops the timer.\"\"\"\n        self._running = False\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n    def _run(self):\n        if not self._running:\n            return\n        try:\n            self.callback()\n        except Exception:\n            app_log.error(\"Error in periodic callback\", exc_info=True)\n        self._schedule_next()\n\n    def _schedule_next(self):\n        if self._running:\n            current_time = self.io_loop.time()\n            while self._next_timeout <= current_time:\n                self._next_timeout += self.callback_time / 1000.0\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\n",
          "file_patch": "@@ -98,26 +98,6 @@ class IOLoop(Configurable):\n         io_loop.start()\n \n     \"\"\"\n-    @classmethod\n-    def configurable_base(cls):\n-        return IOLoop\n-\n-    @classmethod\n-    def configurable_default(cls):\n-        if hasattr(select, \"epoll\") or sys.platform.startswith('linux'):\n-            try:\n-                from tornado.platform.epoll import EPollIOLoop\n-                return EPollIOLoop\n-            except ImportError:\n-                gen_log.warning(\"unable to import EPollIOLoop, falling back to SelectIOLoop\")\n-                pass\n-        if hasattr(select, \"kqueue\"):\n-            # Python 2.6+ on BSD or Mac\n-            from tornado.platform.kqueue import KQueueIOLoop\n-            return KQueueIOLoop\n-        from tornado.platform.select import SelectIOLoop\n-        return SelectIOLoop\n-\n     # Constants from the epoll module\n     _EPOLLIN = 0x001\n     _EPOLLPRI = 0x002\n@@ -139,28 +119,6 @@ class IOLoop(Configurable):\n \n     _current = threading.local()\n \n-    def initialize(self, impl, time_func=None):\n-        self._impl = impl\n-        if hasattr(self._impl, 'fileno'):\n-            set_close_exec(self._impl.fileno())\n-        self.time_func = time_func or time.time\n-        self._handlers = {}\n-        self._events = {}\n-        self._callbacks = []\n-        self._callback_lock = threading.Lock()\n-        self._timeouts = []\n-        self._running = False\n-        self._stopped = False\n-        self._thread_ident = None\n-        self._blocking_signal_threshold = None\n-\n-        # Create a pipe that we send bogus data to when we want to wake\n-        # the I/O loop when it is idle\n-        self._waker = Waker()\n-        self.add_handler(self._waker.fileno(),\n-                         lambda fd, events: self._waker.consume(),\n-                         self.READ)\n-\n     @staticmethod\n     def instance():\n         \"\"\"Returns a global IOLoop instance.\n@@ -213,6 +171,29 @@ class IOLoop(Configurable):\n         assert IOLoop._current.instance is self\n         IOLoop._current.instance = None\n \n+    @classmethod\n+    def configurable_base(cls):\n+        return IOLoop\n+\n+    @classmethod\n+    def configurable_default(cls):\n+        if hasattr(select, \"epoll\") or sys.platform.startswith('linux'):\n+            try:\n+                from tornado.platform.epoll import EPollIOLoop\n+                return EPollIOLoop\n+            except ImportError:\n+                gen_log.warning(\"unable to import EPollIOLoop, falling back to SelectIOLoop\")\n+                pass\n+        if hasattr(select, \"kqueue\"):\n+            # Python 2.6+ on BSD or Mac\n+            from tornado.platform.kqueue import KQueueIOLoop\n+            return KQueueIOLoop\n+        from tornado.platform.select import SelectIOLoop\n+        return SelectIOLoop\n+\n+    def initialize(self):\n+        pass\n+\n     def close(self, all_fds=False):\n         \"\"\"Closes the IOLoop, freeing any resources used.\n \n@@ -232,33 +213,19 @@ class IOLoop(Configurable):\n         Therefore the call to `close` will usually appear just after\n         the call to `start` rather than near the call to `stop`.\n         \"\"\"\n-        self.remove_handler(self._waker.fileno())\n-        if all_fds:\n-            for fd in self._handlers.keys()[:]:\n-                try:\n-                    os.close(fd)\n-                except Exception:\n-                    gen_log.debug(\"error closing fd %s\", fd, exc_info=True)\n-        self._waker.close()\n-        self._impl.close()\n+        raise NotImplementedError()\n \n     def add_handler(self, fd, handler, events):\n         \"\"\"Registers the given handler to receive the given events for fd.\"\"\"\n-        self._handlers[fd] = stack_context.wrap(handler)\n-        self._impl.register(fd, events | self.ERROR)\n+        raise NotImplementedError()\n \n     def update_handler(self, fd, events):\n         \"\"\"Changes the events we listen for fd.\"\"\"\n-        self._impl.modify(fd, events | self.ERROR)\n+        raise NotImplementedError()\n \n     def remove_handler(self, fd):\n         \"\"\"Stop listening for events on fd.\"\"\"\n-        self._handlers.pop(fd, None)\n-        self._events.pop(fd, None)\n-        try:\n-            self._impl.unregister(fd)\n-        except (OSError, IOError):\n-            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n+        raise NotImplementedError()\n \n     def set_blocking_signal_threshold(self, seconds, action):\n         \"\"\"Sends a signal if the ioloop is blocked for more than s seconds.\n@@ -271,14 +238,7 @@ class IOLoop(Configurable):\n         If action is None, the process will be killed if it is blocked for\n         too long.\n         \"\"\"\n-        if not hasattr(signal, \"setitimer\"):\n-            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n-                           \"with the setitimer method\")\n-            return\n-        self._blocking_signal_threshold = seconds\n-        if seconds is not None:\n-            signal.signal(signal.SIGALRM,\n-                          action if action is not None else signal.SIG_DFL)\n+        raise NotImplementedError()\n \n     def set_blocking_log_threshold(self, seconds):\n         \"\"\"Logs a stack trace if the ioloop is blocked for more than s seconds.\n@@ -301,6 +261,202 @@ class IOLoop(Configurable):\n         The loop will run until one of the I/O handlers calls stop(), which\n         will make the loop stop after the current event iteration completes.\n         \"\"\"\n+        raise NotImplementedError()\n+\n+    def stop(self):\n+        \"\"\"Stop the loop after the current event loop iteration is complete.\n+        If the event loop is not currently running, the next call to start()\n+        will return immediately.\n+\n+        To use asynchronous methods from otherwise-synchronous code (such as\n+        unit tests), you can start and stop the event loop like this::\n+\n+          ioloop = IOLoop()\n+          async_method(ioloop=ioloop, callback=ioloop.stop)\n+          ioloop.start()\n+\n+        ioloop.start() will return after async_method has run its callback,\n+        whether that callback was invoked before or after ioloop.start.\n+\n+        Note that even after `stop` has been called, the IOLoop is not\n+        completely stopped until `IOLoop.start` has also returned.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def running(self):\n+        \"\"\"Returns true if this IOLoop is currently running.\"\"\"\n+        raise NotImplementedError()\n+\n+    def time(self):\n+        \"\"\"Returns the current time according to the IOLoop's clock.\n+\n+        The return value is a floating-point number relative to an\n+        unspecified time in the past.\n+\n+        By default, the IOLoop's time function is `time.time`.  However,\n+        it may be configured to use e.g. `time.monotonic` instead.\n+        Calls to `add_timeout` that pass a number instead of a\n+        `datetime.timedelta` should use this function to compute the\n+        appropriate time, so they can work no matter what time function\n+        is chosen.\n+        \"\"\"\n+        return time.time()\n+\n+    def add_timeout(self, deadline, callback):\n+        \"\"\"Calls the given callback at the time deadline from the I/O loop.\n+\n+        Returns a handle that may be passed to remove_timeout to cancel.\n+\n+        ``deadline`` may be a number denoting a time relative to\n+        `IOLoop.time`, or a ``datetime.timedelta`` object for a\n+        deadline relative to the current time.\n+\n+        Note that it is not safe to call `add_timeout` from other threads.\n+        Instead, you must use `add_callback` to transfer control to the\n+        IOLoop's thread, and then call `add_timeout` from there.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def remove_timeout(self, timeout):\n+        \"\"\"Cancels a pending timeout.\n+\n+        The argument is a handle as returned by add_timeout.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def add_callback(self, callback):\n+        \"\"\"Calls the given callback on the next I/O loop iteration.\n+\n+        It is safe to call this method from any thread at any time,\n+        except from a signal handler.  Note that this is the *only*\n+        method in IOLoop that makes this thread-safety guarantee; all\n+        other interaction with the IOLoop must be done from that\n+        IOLoop's thread.  add_callback() may be used to transfer\n+        control from other threads to the IOLoop's thread.\n+\n+        To add a callback from a signal handler, see\n+        `add_callback_from_signal`.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def add_callback_from_signal(self, callback):\n+        \"\"\"Calls the given callback on the next I/O loop iteration.\n+\n+        Safe for use from a Python signal handler; should not be used\n+        otherwise.\n+\n+        Callbacks added with this method will be run without any\n+        stack_context, to avoid picking up the context of the function\n+        that was interrupted by the signal.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    if futures is not None:\n+        _FUTURE_TYPES = (futures.Future, DummyFuture)\n+    else:\n+        _FUTURE_TYPES = DummyFuture\n+    def add_future(self, future, callback):\n+        \"\"\"Schedules a callback on the IOLoop when the given future is finished.\n+\n+        The callback is invoked with one argument, the future.\n+        \"\"\"\n+        assert isinstance(future, IOLoop._FUTURE_TYPES)\n+        callback = stack_context.wrap(callback)\n+        future.add_done_callback(\n+            lambda future: self.add_callback(\n+                functools.partial(callback, future)))\n+\n+    def _run_callback(self, callback):\n+        \"\"\"Runs a callback with error handling.\n+\n+        For use in subclasses.\n+        \"\"\"\n+        try:\n+            callback()\n+        except Exception:\n+            self.handle_callback_exception(callback)\n+\n+    def handle_callback_exception(self, callback):\n+        \"\"\"This method is called whenever a callback run by the IOLoop\n+        throws an exception.\n+\n+        By default simply logs the exception as an error.  Subclasses\n+        may override this method to customize reporting of exceptions.\n+\n+        The exception itself is not passed explicitly, but is available\n+        in sys.exc_info.\n+        \"\"\"\n+        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n+\n+\n+\n+class PollIOLoop(IOLoop):\n+    \"\"\"Base class for IOLoops built around a select-like function.\n+\n+    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`\n+    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or\n+    `tornado.platform.select.SelectIOLoop` (all platforms).\n+    \"\"\"\n+    def initialize(self, impl, time_func=None):\n+        super(PollIOLoop, self).initialize()\n+        self._impl = impl\n+        if hasattr(self._impl, 'fileno'):\n+            set_close_exec(self._impl.fileno())\n+        self.time_func = time_func or time.time\n+        self._handlers = {}\n+        self._events = {}\n+        self._callbacks = []\n+        self._callback_lock = threading.Lock()\n+        self._timeouts = []\n+        self._running = False\n+        self._stopped = False\n+        self._thread_ident = None\n+        self._blocking_signal_threshold = None\n+\n+        # Create a pipe that we send bogus data to when we want to wake\n+        # the I/O loop when it is idle\n+        self._waker = Waker()\n+        self.add_handler(self._waker.fileno(),\n+                         lambda fd, events: self._waker.consume(),\n+                         self.READ)\n+\n+    def close(self, all_fds=False):\n+        self.remove_handler(self._waker.fileno())\n+        if all_fds:\n+            for fd in self._handlers.keys()[:]:\n+                try:\n+                    os.close(fd)\n+                except Exception:\n+                    gen_log.debug(\"error closing fd %s\", fd, exc_info=True)\n+        self._waker.close()\n+        self._impl.close()\n+\n+    def add_handler(self, fd, handler, events):\n+        self._handlers[fd] = stack_context.wrap(handler)\n+        self._impl.register(fd, events | self.ERROR)\n+\n+    def update_handler(self, fd, events):\n+        self._impl.modify(fd, events | self.ERROR)\n+\n+    def remove_handler(self, fd):\n+        self._handlers.pop(fd, None)\n+        self._events.pop(fd, None)\n+        try:\n+            self._impl.unregister(fd)\n+        except (OSError, IOError):\n+            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n+\n+    def set_blocking_signal_threshold(self, seconds, action):\n+        if not hasattr(signal, \"setitimer\"):\n+            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n+                           \"with the setitimer method\")\n+            return\n+        self._blocking_signal_threshold = seconds\n+        if seconds is not None:\n+            signal.signal(signal.SIGALRM,\n+                          action if action is not None else signal.SIG_DFL)\n+\n+    def start(self):\n         if not logging.getLogger().handlers:\n             # The IOLoop catches and logs exceptions, so it's\n             # important that log output be visible.  However, python's\n@@ -434,68 +590,22 @@ class IOLoop(Configurable):\n             signal.set_wakeup_fd(old_wakeup_fd)\n \n     def stop(self):\n-        \"\"\"Stop the loop after the current event loop iteration is complete.\n-        If the event loop is not currently running, the next call to start()\n-        will return immediately.\n-\n-        To use asynchronous methods from otherwise-synchronous code (such as\n-        unit tests), you can start and stop the event loop like this::\n-\n-          ioloop = IOLoop()\n-          async_method(ioloop=ioloop, callback=ioloop.stop)\n-          ioloop.start()\n-\n-        ioloop.start() will return after async_method has run its callback,\n-        whether that callback was invoked before or after ioloop.start.\n-\n-        Note that even after `stop` has been called, the IOLoop is not\n-        completely stopped until `IOLoop.start` has also returned.\n-        \"\"\"\n         self._running = False\n         self._stopped = True\n         self._waker.wake()\n \n     def running(self):\n-        \"\"\"Returns true if this IOLoop is currently running.\"\"\"\n         return self._running\n \n     def time(self):\n-        \"\"\"Returns the current time according to the IOLoop's clock.\n-\n-        The return value is a floating-point number relative to an\n-        unspecified time in the past.\n-\n-        By default, the IOLoop's time function is `time.time`.  However,\n-        it may be configured to use e.g. `time.monotonic` instead.\n-        Calls to `add_timeout` that pass a number instead of a\n-        `datetime.timedelta` should use this function to compute the\n-        appropriate time, so they can work no matter what time function\n-        is chosen.\n-        \"\"\"\n         return self.time_func()\n \n     def add_timeout(self, deadline, callback):\n-        \"\"\"Calls the given callback at the time deadline from the I/O loop.\n-\n-        Returns a handle that may be passed to remove_timeout to cancel.\n-\n-        ``deadline`` may be a number denoting a time relative to\n-        `IOLoop.time`, or a ``datetime.timedelta`` object for a\n-        deadline relative to the current time.\n-\n-        Note that it is not safe to call `add_timeout` from other threads.\n-        Instead, you must use `add_callback` to transfer control to the\n-        IOLoop's thread, and then call `add_timeout` from there.\n-        \"\"\"\n         timeout = _Timeout(deadline, stack_context.wrap(callback), self)\n         heapq.heappush(self._timeouts, timeout)\n         return timeout\n \n     def remove_timeout(self, timeout):\n-        \"\"\"Cancels a pending timeout.\n-\n-        The argument is a handle as returned by add_timeout.\n-        \"\"\"\n         # Removing from a heap is complicated, so just leave the defunct\n         # timeout object in the queue (see discussion in\n         # http://docs.python.org/library/heapq.html).\n@@ -504,18 +614,6 @@ class IOLoop(Configurable):\n         timeout.callback = None\n \n     def add_callback(self, callback):\n-        \"\"\"Calls the given callback on the next I/O loop iteration.\n-\n-        It is safe to call this method from any thread at any time,\n-        except from a signal handler.  Note that this is the *only*\n-        method in IOLoop that makes this thread-safety guarantee; all\n-        other interaction with the IOLoop must be done from that\n-        IOLoop's thread.  add_callback() may be used to transfer\n-        control from other threads to the IOLoop's thread.\n-\n-        To add a callback from a signal handler, see\n-        `add_callback_from_signal`.\n-        \"\"\"\n         with self._callback_lock:\n             list_empty = not self._callbacks\n             self._callbacks.append(stack_context.wrap(callback))\n@@ -529,15 +627,6 @@ class IOLoop(Configurable):\n             self._waker.wake()\n \n     def add_callback_from_signal(self, callback):\n-        \"\"\"Calls the given callback on the next I/O loop iteration.\n-\n-        Safe for use from a Python signal handler; should not be used\n-        otherwise.\n-\n-        Callbacks added with this method will be run without any\n-        stack_context, to avoid picking up the context of the function\n-        that was interrupted by the signal.\n-        \"\"\"\n         with stack_context.NullContext():\n             if thread.get_ident() != self._thread_ident:\n                 # if the signal is handled on another thread, we can add\n@@ -554,39 +643,6 @@ class IOLoop(Configurable):\n                 # but either way will work.\n                 self._callbacks.append(stack_context.wrap(callback))\n \n-    if futures is not None:\n-        _FUTURE_TYPES = (futures.Future, DummyFuture)\n-    else:\n-        _FUTURE_TYPES = DummyFuture\n-    def add_future(self, future, callback):\n-        \"\"\"Schedules a callback on the IOLoop when the given future is finished.\n-\n-        The callback is invoked with one argument, the future.\n-        \"\"\"\n-        assert isinstance(future, IOLoop._FUTURE_TYPES)\n-        callback = stack_context.wrap(callback)\n-        future.add_done_callback(\n-            lambda future: self.add_callback(\n-                functools.partial(callback, future)))\n-\n-    def _run_callback(self, callback):\n-        try:\n-            callback()\n-        except Exception:\n-            self.handle_callback_exception(callback)\n-\n-    def handle_callback_exception(self, callback):\n-        \"\"\"This method is called whenever a callback run by the IOLoop\n-        throws an exception.\n-\n-        By default simply logs the exception as an error.  Subclasses\n-        may override this method to customize reporting of exceptions.\n-\n-        The exception itself is not passed explicitly, but is available\n-        in sys.exc_info.\n-        \"\"\"\n-        app_log.error(\"Exception in callback %r\", callback, exc_info=True)\n-\n \n class _Timeout(object):\n     \"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\n",
          "files_name_in_blame_commit": [
            "select.py",
            "epoll.py",
            "kqueue.py",
            "ioloop.py"
          ]
        }
      }
    }
  }
}
{
  "id": "2",
  "blame_commit": {
    "commit": {
      "commit_id": "a6077a179067812766293f9ab4391b5e1499a9c6",
      "commit_message": "GIT-37: fix blueprint middleware application (#1690)\n\n* GIT-37: fix blueprint middleware application\r\n\r\n1. If you register a middleware via `@blueprint.middleware` then it will apply only to the routes defined by the blueprint.\r\n2. If you register a middleware via `@blueprint_group.middleware` then it will apply to all blueprint based routes that are part of the group.\r\n3. If you define a middleware via `@app.middleware` then it will be applied on all available routes\r\n\r\nFixes #37\r\n\r\nSigned-off-by: Harsha Narayana <harsha2k4@gmail.com>\r\n\r\n* GIT-37: add changelog\r\n\r\nSigned-off-by: Harsha Narayana <harsha2k4@gmail.com>",
      "commit_author": "Harsha Narayana",
      "commit_date": "2019-12-20 10:01:04",
      "commit_parent": "179a07942eddba0e3196b345aa361a3460137ebf"
    },
    "function": {
      "function_name": "register_named_middleware",
      "function_code_before": "",
      "function_code_after": "def register_named_middleware(self, middleware, route_names, attach_to='request'):\n    if attach_to == 'request':\n        for _rn in route_names:\n            if _rn not in self.named_request_middleware:\n                self.named_request_middleware[_rn] = deque()\n            if middleware not in self.named_request_middleware[_rn]:\n                self.named_request_middleware[_rn].append(middleware)\n    if attach_to == 'response':\n        for _rn in route_names:\n            if _rn not in self.named_response_middleware:\n                self.named_response_middleware[_rn] = deque()\n            if middleware not in self.named_response_middleware[_rn]:\n                self.named_response_middleware[_rn].append(middleware)",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 650,
      "function_after_end_line": 664,
      "function_before_token_count": 0,
      "function_after_token_count": 113,
      "functions_name_modified_file": [
        "_run_response_middleware",
        "test_client",
        "trigger_events",
        "url_for",
        "post",
        "_helper",
        "add_websocket_route",
        "add_task",
        "static",
        "websocket",
        "run",
        "options",
        "listener",
        "blueprint",
        "_run_request_middleware",
        "add_route",
        "register_blueprint",
        "route",
        "register_listener",
        "put",
        "converted_response_type",
        "asgi_client",
        "get",
        "patch",
        "_build_endpoint_name",
        "middleware",
        "delete",
        "remove_route",
        "__init__",
        "register_middleware",
        "exception",
        "__call__",
        "create_server",
        "register_named_middleware",
        "handle_request",
        "loop",
        "stop",
        "head",
        "enable_websocket"
      ],
      "functions_name_all_files": [
        "test_app_route_raise_value_error",
        "test_create_asyncio_server",
        "_helper",
        "parse_parameter_string",
        "add_websocket_route",
        "add_task",
        "test_route_handler_add",
        "test_bp_with_host",
        "test_bp",
        "test_bp_strict_slash_default_value",
        "test_bp_static_content_type",
        "_run_request_middleware",
        "route",
        "test_websocket_route",
        "register_listener",
        "test_handle_request_with_nested_exception",
        "__init__",
        "stop",
        "test_handle_request_with_nested_exception_debug",
        "test_bp_exception_handler",
        "test_bp_static",
        "test_app_enable_websocket",
        "test_bp_group_with_additional_route_params",
        "test_register_blueprint",
        "run",
        "group",
        "test_asyncio_server_start_serving",
        "register_blueprint",
        "converted_response_type",
        "asgi_client",
        "test_bp_middleware",
        "patch",
        "_build_endpoint_name",
        "test_app_handle_request_handler_is_none",
        "test_duplicate_blueprint",
        "exception",
        "loop",
        "test_bp_strict_slash_default_value_can_be_overwritten",
        "is_stream_handler",
        "test_bp_with_url_prefix",
        "_get",
        "url_for",
        "find_route_by_view_name",
        "test_bp_shorthand",
        "post",
        "get_file_content",
        "url_hash",
        "test_bp_listeners",
        "websocket",
        "listener",
        "get_file_path",
        "middleware",
        "__call__",
        "register_named_middleware",
        "handle_request",
        "test_static_blueprint_name",
        "enable_websocket",
        "static_file_directory",
        "test_bp_strict_slash",
        "_run_response_middleware",
        "test_client",
        "test_app_loop_running",
        "trigger_events",
        "test_several_bp_with_url_prefix",
        "register",
        "test_bp_group_with_default_url_prefix",
        "test_app_loop_not_running",
        "remove",
        "test_blueprint_middleware_with_args",
        "static",
        "uvloop_installed",
        "add",
        "options",
        "blueprint",
        "test_versioned_routes_get",
        "add_route",
        "test_bp_group_indexing",
        "test_handle_request_with_nested_sanic_exception",
        "test_bp_group",
        "put",
        "test_bp_strict_slash_without_passing_default_value",
        "get",
        "test_bp_group_list_operations",
        "test_app_run_raise_type_error",
        "delete",
        "remove_route",
        "register_middleware",
        "check_dynamic_route_exists",
        "test_strict_slashes_behavior_adoption",
        "create_server",
        "_add",
        "get_supported_methods",
        "head",
        "test_several_bp_with_host"
      ],
      "functions_name_co_evolved_modified_file": [
        "__init__",
        "_run_request_middleware",
        "route",
        "_run_response_middleware",
        "add_websocket_route",
        "websocket",
        "handle_request"
      ],
      "functions_name_co_evolved_all_files": [
        "__init__",
        "_run_request_middleware",
        "test_bp_group_with_additional_route_params",
        "route",
        "_run_response_middleware",
        "test_bp_group",
        "add_websocket_route",
        "websocket",
        "handle_request",
        "test_bp_middleware",
        "register",
        "_add",
        "add",
        "test_app_handle_request_handler_is_none",
        "_get"
      ]
    },
    "file": {
      "file_name": "app.py",
      "file_nloc": 1004,
      "file_complexity": 201,
      "file_token_count": 4602,
      "file_before": "import logging\nimport logging.config\nimport os\nimport re\nimport warnings\n\nfrom asyncio import CancelledError, Protocol, ensure_future, get_event_loop\nfrom collections import defaultdict, deque\nfrom functools import partial\nfrom inspect import getmodulename, isawaitable, signature, stack\nfrom socket import socket\nfrom ssl import Purpose, SSLContext, create_default_context\nfrom traceback import format_exc\nfrom typing import Any, Dict, Optional, Type, Union\nfrom urllib.parse import urlencode, urlunparse\n\nfrom sanic import reloader_helpers\nfrom sanic.asgi import ASGIApp\nfrom sanic.blueprint_group import BlueprintGroup\nfrom sanic.config import BASE_LOGO, Config\nfrom sanic.constants import HTTP_METHODS\nfrom sanic.exceptions import SanicException, ServerError, URLBuildError\nfrom sanic.handlers import ErrorHandler\nfrom sanic.log import LOGGING_CONFIG_DEFAULTS, error_logger, logger\nfrom sanic.response import HTTPResponse, StreamingHTTPResponse\nfrom sanic.router import Router\nfrom sanic.server import (\n    AsyncioServer,\n    HttpProtocol,\n    Signal,\n    serve,\n    serve_multiple,\n)\nfrom sanic.static import register as static_register\nfrom sanic.testing import SanicASGITestClient, SanicTestClient\nfrom sanic.views import CompositionView\nfrom sanic.websocket import ConnectionClosed, WebSocketProtocol\n\n\nclass Sanic:\n    def __init__(\n        self,\n        name=None,\n        router=None,\n        error_handler=None,\n        load_env=True,\n        request_class=None,\n        strict_slashes=False,\n        log_config=None,\n        configure_logging=True,\n    ):\n\n        # Get name from previous stack frame\n        if name is None:\n            warnings.warn(\n                \"Sanic(name=None) is deprecated and None value support \"\n                \"for `name` will be removed in the next release. \"\n                \"Please use Sanic(name='your_application_name') instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            frame_records = stack()[1]\n            name = getmodulename(frame_records[1])\n\n        # logging\n        if configure_logging:\n            logging.config.dictConfig(log_config or LOGGING_CONFIG_DEFAULTS)\n\n        self.name = name\n        self.asgi = False\n        self.router = router or Router()\n        self.request_class = request_class\n        self.error_handler = error_handler or ErrorHandler()\n        self.config = Config(load_env=load_env)\n        self.request_middleware = deque()\n        self.response_middleware = deque()\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.configure_logging = configure_logging\n        self.debug = None\n        self.sock = None\n        self.strict_slashes = strict_slashes\n        self.listeners = defaultdict(list)\n        self.is_running = False\n        self.is_request_stream = False\n        self.websocket_enabled = False\n        self.websocket_tasks = set()\n\n        # Register alternative method names\n        self.go_fast = self.run\n\n    @property\n    def loop(self):\n        \"\"\"Synonymous with asyncio.get_event_loop().\n\n        Only supported when using the `app.run` method.\n        \"\"\"\n        if not self.is_running and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        return get_event_loop()\n\n    # -------------------------------------------------------------------- #\n    # Registration\n    # -------------------------------------------------------------------- #\n\n    def add_task(self, task):\n        \"\"\"Schedule a task to run later, after the loop has started.\n        Different from asyncio.ensure_future in that it does not\n        also return a future, and the actual ensure_future call\n        is delayed until before server start.\n\n        :param task: future, couroutine or awaitable\n        \"\"\"\n        try:\n            if callable(task):\n                try:\n                    self.loop.create_task(task(self))\n                except TypeError:\n                    self.loop.create_task(task())\n            else:\n                self.loop.create_task(task)\n        except SanicException:\n\n            @self.listener(\"before_server_start\")\n            def run(app, loop):\n                if callable(task):\n                    try:\n                        loop.create_task(task(self))\n                    except TypeError:\n                        loop.create_task(task())\n                else:\n                    loop.create_task(task)\n\n    # Decorator\n    def listener(self, event):\n        \"\"\"Create a listener from a decorated function.\n\n        :param event: event to listen to\n        \"\"\"\n\n        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener\n\n        return decorator\n\n    def register_listener(self, listener, event):\n        \"\"\"\n        Register the listener for a given event.\n\n        :param listener: callable i.e. setup_db(app, loop)\n        :param event: when to register listener i.e. 'before_server_start'\n        :return: listener\n        \"\"\"\n\n        return self.listener(event)(listener)\n\n    # Decorator\n    def route(\n        self,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"Decorate a function to be registered as a route\n\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed\n        :param host:\n        :param strict_slashes:\n        :param stream:\n        :param version:\n        :param name: user defined route name for url_for\n        :return: decorated function\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if stream:\n            self.is_request_stream = True\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            args = list(signature(handler).parameters.keys())\n\n            if not args:\n                raise ValueError(\n                    \"Required parameter `request` missing \"\n                    \"in the {0}() route?\".format(handler.__name__)\n                )\n\n            if stream:\n                handler.is_stream = stream\n\n            self.router.add(\n                uri=uri,\n                methods=methods,\n                handler=handler,\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n            )\n            return handler\n\n        return response\n\n    # Shorthand method decorators\n    def get(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def post(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def put(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def head(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def options(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def patch(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def delete(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def add_route(\n        self,\n        handler,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        version=None,\n        name=None,\n        stream=False,\n    ):\n        \"\"\"A helper method to register class instance or\n        functions as a handler to the application url\n        routes.\n\n        :param handler: function or class instance\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed, these are overridden\n                        if using a HTTPMethodView\n        :param host:\n        :param strict_slashes:\n        :param version:\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                _handler = getattr(handler.view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n            for _handler in handler.handlers.values():\n                if hasattr(_handler, \"is_stream\"):\n                    stream = True\n                    break\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler\n\n    # Decorator\n    def websocket(\n        self, uri, host=None, strict_slashes=None, subprotocols=None, name=None\n    ):\n        \"\"\"\n        Decorate a function to be registered as a websocket route\n\n        :param uri: path of the URL\n        :param host: Host IP or FQDN details\n        :param strict_slashes: If the API endpoint needs to terminate\n                               with a \"/\" or not\n        :param subprotocols: optional list of str with supported subprotocols\n        :param name: A unique name assigned to the URL so that it can\n                     be used with :func:`url_for`\n        :return: decorated function\n        \"\"\"\n        self.enable_websocket()\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            async def websocket_handler(request, *args, **kwargs):\n                request.app = self\n                if not getattr(handler, \"__blueprintname__\", False):\n                    request.endpoint = handler.__name__\n                else:\n                    request.endpoint = (\n                        getattr(handler, \"__blueprintname__\", \"\")\n                        + handler.__name__\n                    )\n\n                    pass\n\n                if self.asgi:\n                    ws = request.transport.get_websocket_connection()\n                else:\n                    try:\n                        protocol = request.transport.get_protocol()\n                    except AttributeError:\n                        # On Python3.5 the Transport classes in asyncio do not\n                        # have a get_protocol() method as in uvloop\n                        protocol = request.transport._protocol\n                    protocol.app = self\n\n                    ws = await protocol.websocket_handshake(\n                        request, subprotocols\n                    )\n\n                # schedule the application handler\n                # its future is kept in self.websocket_tasks in case it\n                # needs to be cancelled due to the server being stopped\n                fut = ensure_future(handler(request, ws, *args, **kwargs))\n                self.websocket_tasks.add(fut)\n                try:\n                    await fut\n                except (CancelledError, ConnectionClosed):\n                    pass\n                finally:\n                    self.websocket_tasks.remove(fut)\n                await ws.close()\n\n            self.router.add(\n                uri=uri,\n                handler=websocket_handler,\n                methods=frozenset({\"GET\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                name=name,\n            )\n            return handler\n\n        return response\n\n    def add_websocket_route(\n        self,\n        handler,\n        uri,\n        host=None,\n        strict_slashes=None,\n        subprotocols=None,\n        name=None,\n    ):\n        \"\"\"\n        A helper method to register a function as a websocket route.\n\n        :param handler: a callable function or instance of a class\n                        that can handle the websocket request\n        :param host: Host IP or FQDN details\n        :param uri: URL path that will be mapped to the websocket\n                    handler\n        :param strict_slashes: If the API endpoint needs to terminate\n                with a \"/\" or not\n        :param subprotocols: Subprotocols to be used with websocket\n                handshake\n        :param name: A unique name assigned to the URL so that it can\n                be used with :func:`url_for`\n        :return: Objected decorated by :func:`websocket`\n        \"\"\"\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        return self.websocket(\n            uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            name=name,\n        )(handler)\n\n    def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            @self.listener(\"before_server_stop\")\n            def cancel_websocket_tasks(app, loop):\n                for task in self.websocket_tasks:\n                    task.cancel()\n\n        self.websocket_enabled = enable\n\n    def remove_route(self, uri, clean_cache=True, host=None):\n        \"\"\"\n        This method provides the app user a mechanism by which an already\n        existing route can be removed from the :class:`Sanic` object\n\n        .. warning::\n            remove_route is deprecated in v19.06 and will be removed\n            from future versions.\n\n        :param uri: URL Path to be removed from the app\n        :param clean_cache: Instruct sanic if it needs to clean up the LRU\n            route cache\n        :param host: IP address or FQDN specific to the host\n        :return: None\n        \"\"\"\n        warnings.warn(\n            \"remove_route is deprecated and will be removed \"\n            \"from future versions.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.router.remove(uri, clean_cache, host)\n\n    # Decorator\n    def exception(self, *exceptions):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        def response(handler):\n            for exception in exceptions:\n                if isinstance(exception, (tuple, list)):\n                    for e in exception:\n                        self.error_handler.add(e, handler)\n                else:\n                    self.error_handler.add(exception, handler)\n            return handler\n\n        return response\n\n    def register_middleware(self, middleware, attach_to=\"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware\n\n    # Decorator\n    def middleware(self, middleware_or_request):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return self.register_middleware(middleware_or_request)\n\n        else:\n            return partial(\n                self.register_middleware, attach_to=middleware_or_request\n            )\n\n    # Static Files\n    def static(\n        self,\n        uri,\n        file_or_directory,\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n        :param file_or_directory: Path for the Static file/directory with\n            static files\n        :param pattern: Regex Pattern identifying the valid static files\n        :param use_modified_since: If true, send file modified time, and return\n            not modified if the browser's matches the server's\n        :param use_content_range: If true, process header for range requests\n            and sends the file part that is requested\n        :param stream_large_files: If true, use the\n            :func:`StreamingHTTPResponse.file_stream` handler rather\n            than the :func:`HTTPResponse.file` handler to send the file.\n            If this is an integer, this represents the threshold size to\n            switch to :func:`StreamingHTTPResponse.file_stream`\n        :param name: user defined name used for url_for\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param content_type: user defined content type for header\n        :return: None\n        \"\"\"\n        static_register(\n            self,\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n        )\n\n    def blueprint(self, blueprint, **options):\n        \"\"\"Register a blueprint on the application.\n\n        :param blueprint: Blueprint object or (list, tuple) thereof\n        :param options: option dictionary with blueprint defaults\n        :return: Nothing\n        \"\"\"\n        if isinstance(blueprint, (list, tuple, BlueprintGroup)):\n            for item in blueprint:\n                self.blueprint(item, **options)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n        blueprint.register(self, options)\n\n    def register_blueprint(self, *args, **kwargs):\n        \"\"\"\n        Proxy method provided for invoking the :func:`blueprint` method\n\n        .. note::\n            To be deprecated in 1.0. Use :func:`blueprint` instead.\n\n        :param args: Blueprint object or (list, tuple) thereof\n        :param kwargs: option dictionary with blueprint defaults\n        :return: None\n        \"\"\"\n\n        if self.debug:\n            warnings.simplefilter(\"default\")\n        warnings.warn(\n            \"Use of register_blueprint will be deprecated in \"\n            \"version 1.0.  Please use the blueprint method\"\n            \" instead\",\n            DeprecationWarning,\n        )\n        return self.blueprint(*args, **kwargs)\n\n    def url_for(self, view_name: str, **kwargs):\n        r\"\"\"Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        `URLBuildError` will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        :param view_name: string referencing the view name\n        :param \\**kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n        # find the route by the supplied view name\n        kw: Dict[str, str] = {}\n        # special static files url_for\n        if view_name == \"static\":\n            kw.update(name=kwargs.pop(\"name\", \"static\"))\n        elif view_name.endswith(\".static\"):  # blueprint.static\n            kwargs.pop(\"name\", None)\n            kw.update(name=view_name)\n\n        uri, route = self.router.find_route_by_view_name(view_name, **kw)\n        if not (uri and route):\n            raise URLBuildError(\n                \"Endpoint with name `{}` was not found\".format(view_name)\n            )\n\n        if view_name == \"static\" or view_name.endswith(\".static\"):\n            filename = kwargs.pop(\"filename\", None)\n            # it's static folder\n            if \"<file_uri:\" in uri:\n                folder_ = uri.split(\"<file_uri:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                uri = \"{}/{}\".format(folder_, filename)\n\n        if uri != \"/\" and uri.endswith(\"/\"):\n            uri = uri[:-1]\n\n        out = uri\n\n        # find all the parameters we will need to build in the URL\n        matched_params = re.findall(self.router.parameter_pattern, uri)\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        external = kwargs.pop(\"_external\", False)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        for match in matched_params:\n            name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n            specific_pattern = \"^{}$\".format(pattern)\n            supplied_param = None\n\n            if name in kwargs:\n                supplied_param = kwargs.get(name)\n                del kwargs[name]\n            else:\n                raise URLBuildError(\n                    \"Required parameter `{}` was not passed to url_for\".format(\n                        name\n                    )\n                )\n\n            supplied_param = str(supplied_param)\n            # determine if the parameter supplied by the caller passes the test\n            # in the URL\n            passes_pattern = re.match(specific_pattern, supplied_param)\n\n            if not passes_pattern:\n                if _type != str:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` does not '\n                        \"match pattern for type `{}`: {}\".format(\n                            supplied_param, name, _type.__name__, pattern\n                        )\n                    )\n                else:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` '\n                        \"does not satisfy pattern {}\".format(\n                            supplied_param, name, pattern\n                        )\n                    )\n                raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = \"(<{}.*?>)\".format(name)\n\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out\n\n    # -------------------------------------------------------------------- #\n    # Request Handling\n    # -------------------------------------------------------------------- #\n\n    def converted_response_type(self, response):\n        \"\"\"\n        No implementation provided.\n        \"\"\"\n        pass\n\n    async def handle_request(self, request, write_callback, stream_callback):\n        \"\"\"Take a request from the HTTP Server and return a response object\n        to be sent back The HTTP Server only expects a response object, so\n        exception handling must be done here\n\n        :param request: HTTP Request object\n        :param write_callback: Synchronous response function to be\n            called with the response as the only argument\n        :param stream_callback: Coroutine that handles streaming a\n            StreamingHTTPResponse if produced by the handler.\n\n        :return: Nothing\n        \"\"\"\n        # Define `response` var here to remove warnings about\n        # allocation before assignment below.\n        response = None\n        cancelled = False\n        try:\n            # -------------------------------------------- #\n            # Request Middleware\n            # -------------------------------------------- #\n            response = await self._run_request_middleware(request)\n            # No middleware results\n            if not response:\n                # -------------------------------------------- #\n                # Execute Handler\n                # -------------------------------------------- #\n\n                # Fetch handler from router\n                handler, args, kwargs, uri = self.router.get(request)\n\n                request.uri_template = uri\n                if handler is None:\n                    raise ServerError(\n                        (\n                            \"'None' was returned while requesting a \"\n                            \"handler from the router\"\n                        )\n                    )\n                else:\n                    if not getattr(handler, \"__blueprintname__\", False):\n                        request.endpoint = self._build_endpoint_name(\n                            handler.__name__\n                        )\n                    else:\n                        request.endpoint = self._build_endpoint_name(\n                            getattr(handler, \"__blueprintname__\", \"\"),\n                            handler.__name__,\n                        )\n\n                # Run response handler\n                response = handler(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n        except CancelledError:\n            # If response handler times out, the server handles the error\n            # and cancels the handle_request job.\n            # In this case, the transport is already closed and we cannot\n            # issue a response.\n            response = None\n            cancelled = True\n        except Exception as e:\n            # -------------------------------------------- #\n            # Response Generation Failed\n            # -------------------------------------------- #\n\n            try:\n                response = self.error_handler.response(request, e)\n                if isawaitable(response):\n                    response = await response\n            except Exception as e:\n                if isinstance(e, SanicException):\n                    response = self.error_handler.default(\n                        request=request, exception=e\n                    )\n                elif self.debug:\n                    response = HTTPResponse(\n                        \"Error while handling error: {}\\nStack: {}\".format(\n                            e, format_exc()\n                        ),\n                        status=500,\n                    )\n                else:\n                    response = HTTPResponse(\n                        \"An error occurred while handling an error\", status=500\n                    )\n        finally:\n            # -------------------------------------------- #\n            # Response Middleware\n            # -------------------------------------------- #\n            # Don't run response middleware if response is None\n            if response is not None:\n                try:\n                    response = await self._run_response_middleware(\n                        request, response\n                    )\n                except CancelledError:\n                    # Response middleware can timeout too, as above.\n                    response = None\n                    cancelled = True\n                except BaseException:\n                    error_logger.exception(\n                        \"Exception occurred in one of response \"\n                        \"middleware handlers\"\n                    )\n            if cancelled:\n                raise CancelledError()\n\n        # pass the response to the correct callback\n        if write_callback is None or isinstance(\n            response, StreamingHTTPResponse\n        ):\n            if stream_callback:\n                await stream_callback(response)\n            else:\n                # Should only end here IF it is an ASGI websocket.\n                # TODO:\n                # - Add exception handling\n                pass\n        else:\n            write_callback(response)\n\n    # -------------------------------------------------------------------- #\n    # Testing\n    # -------------------------------------------------------------------- #\n\n    @property\n    def test_client(self):\n        return SanicTestClient(self)\n\n    @property\n    def asgi_client(self):\n        return SanicASGITestClient(self)\n\n    # -------------------------------------------------------------------- #\n    # Execution\n    # -------------------------------------------------------------------- #\n\n    def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Run the HTTP Server and listen until keyboard interrupt or term\n        signal. On termination, drain connections before closing.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param workers: Number of processes received before it is respected\n        :type workers: int\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param register_sys_signals: Register SIG* events\n        :type register_sys_signals: bool\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :return: Nothing\n        \"\"\"\n        if \"loop\" in kwargs:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        # Default auto_reload to false\n        auto_reload = False\n        # If debug is set, default it to true (unless on windows)\n        if debug and os.name == \"posix\":\n            auto_reload = True\n        # Allow for overriding either of the defaults\n        auto_reload = kwargs.get(\"auto_reload\", auto_reload)\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_reload=auto_reload,\n        )\n\n        try:\n            self.is_running = True\n            if workers == 1:\n                if auto_reload and os.name != \"posix\":\n                    # This condition must be removed after implementing\n                    # auto reloader for other operating systems.\n                    raise NotImplementedError\n\n                if (\n                    auto_reload\n                    and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n                ):\n                    reloader_helpers.watchdog(2)\n                else:\n                    serve(**server_settings)\n            else:\n                serve_multiple(server_settings, workers)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            self.is_running = False\n        logger.info(\"Server Stopped\")\n\n    def stop(self):\n        \"\"\"This kills the Sanic\"\"\"\n        get_event_loop().stop()\n\n    async def create_server(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        access_log: Optional[bool] = None,\n        return_asyncio_server=False,\n        asyncio_server_kwargs=None,\n    ) -> Optional[AsyncioServer]:\n        \"\"\"\n        Asynchronous version of :func:`run`.\n\n        This method will take care of the operations necessary to invoke\n        the *before_start* events via :func:`trigger_events` method invocation\n        before starting the *sanic* app in Async mode.\n\n        .. note::\n            This does not support multiprocessing and is not the preferred\n            way to run a :class:`Sanic` application.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :param return_asyncio_server: flag that defines whether there's a need\n                                      to return asyncio.Server or\n                                      start it serving right away\n        :type return_asyncio_server: bool\n        :param asyncio_server_kwargs: key-value arguments for\n                                      asyncio/uvloop create_server method\n        :type asyncio_server_kwargs: dict\n        :return: AsyncioServer if return_asyncio_server is true, else Nothing\n        \"\"\"\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            loop=get_event_loop(),\n            protocol=protocol,\n            backlog=backlog,\n            run_async=return_asyncio_server,\n        )\n\n        # Trigger before_start events\n        await self.trigger_events(\n            server_settings.get(\"before_start\", []),\n            server_settings.get(\"loop\"),\n        )\n\n        return await serve(\n            asyncio_server_kwargs=asyncio_server_kwargs, **server_settings\n        )\n\n    async def trigger_events(self, events, loop):\n        \"\"\"Trigger events (functions or async)\n        :param events: one or more sync or async functions to execute\n        :param loop: event loop\n        \"\"\"\n        for event in events:\n            result = event(loop)\n            if isawaitable(result):\n                await result\n\n    async def _run_request_middleware(self, request):\n        # The if improves speed.  I don't know why\n        if self.request_middleware:\n            for middleware in self.request_middleware:\n                response = middleware(request)\n                if isawaitable(response):\n                    response = await response\n                if response:\n                    return response\n        return None\n\n    async def _run_response_middleware(self, request, response):\n        if self.response_middleware:\n            for middleware in self.response_middleware:\n                _response = middleware(request, response)\n                if isawaitable(_response):\n                    _response = await _response\n                if _response:\n                    response = _response\n                    break\n        return response\n\n    def _helper(\n        self,\n        host=None,\n        port=None,\n        debug=False,\n        ssl=None,\n        sock=None,\n        workers=1,\n        loop=None,\n        protocol=HttpProtocol,\n        backlog=100,\n        stop_event=None,\n        register_sys_signals=True,\n        run_async=False,\n        auto_reload=False,\n    ):\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n        if isinstance(ssl, dict):\n            # try common aliaseses\n            cert = ssl.get(\"cert\") or ssl.get(\"certificate\")\n            key = ssl.get(\"key\") or ssl.get(\"keyfile\")\n            if cert is None or key is None:\n                raise ValueError(\"SSLContext or certificate and key required.\")\n            context = create_default_context(purpose=Purpose.CLIENT_AUTH)\n            context.load_cert_chain(cert, keyfile=key)\n            ssl = context\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        self.error_handler.debug = debug\n        self.debug = debug\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"request_class\": self.request_class,\n            \"is_request_stream\": self.is_request_stream,\n            \"router\": self.router,\n            \"host\": host,\n            \"port\": port,\n            \"sock\": sock,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": Signal(),\n            \"debug\": debug,\n            \"request_handler\": self.handle_request,\n            \"error_handler\": self.error_handler,\n            \"request_timeout\": self.config.REQUEST_TIMEOUT,\n            \"response_timeout\": self.config.RESPONSE_TIMEOUT,\n            \"keep_alive_timeout\": self.config.KEEP_ALIVE_TIMEOUT,\n            \"request_max_size\": self.config.REQUEST_MAX_SIZE,\n            \"request_buffer_queue_size\": self.config.REQUEST_BUFFER_QUEUE_SIZE,\n            \"keep_alive\": self.config.KEEP_ALIVE,\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n            \"access_log\": self.config.ACCESS_LOG,\n            \"websocket_max_size\": self.config.WEBSOCKET_MAX_SIZE,\n            \"websocket_max_queue\": self.config.WEBSOCKET_MAX_QUEUE,\n            \"websocket_read_limit\": self.config.WEBSOCKET_READ_LIMIT,\n            \"websocket_write_limit\": self.config.WEBSOCKET_WRITE_LIMIT,\n            \"graceful_shutdown_timeout\": self.config.GRACEFUL_SHUTDOWN_TIMEOUT,\n        }\n\n        # -------------------------------------------- #\n        # Register start/stop events\n        # -------------------------------------------- #\n\n        for event_name, settings_name, reverse in (\n            (\"before_server_start\", \"before_start\", False),\n            (\"after_server_start\", \"after_start\", False),\n            (\"before_server_stop\", \"before_stop\", True),\n            (\"after_server_stop\", \"after_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners\n\n        if self.configure_logging and debug:\n            logger.setLevel(logging.DEBUG)\n\n        if (\n            self.config.LOGO\n            and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n        ):\n            logger.debug(\n                self.config.LOGO\n                if isinstance(self.config.LOGO, str)\n                else BASE_LOGO\n            )\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        # Serve\n        if host and port and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\":\n            proto = \"http\"\n            if ssl is not None:\n                proto = \"https\"\n            logger.info(\"Goin' Fast @ {}://{}:{}\".format(proto, host, port))\n\n        return server_settings\n\n    def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)\n\n    # -------------------------------------------------------------------- #\n    # ASGI\n    # -------------------------------------------------------------------- #\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"To be ASGI compliant, our instance must be a callable that accepts\n        three arguments: scope, receive, send. See the ASGI reference for more\n        details: https://asgi.readthedocs.io/en/latest/\"\"\"\n        self.asgi = True\n        asgi_app = await ASGIApp.create(self, scope, receive, send)\n        await asgi_app()\n",
      "file_after": "import logging\nimport logging.config\nimport os\nimport re\nimport warnings\n\nfrom asyncio import CancelledError, Protocol, ensure_future, get_event_loop\nfrom collections import defaultdict, deque\nfrom functools import partial\nfrom inspect import getmodulename, isawaitable, signature, stack\nfrom socket import socket\nfrom ssl import Purpose, SSLContext, create_default_context\nfrom traceback import format_exc\nfrom typing import Any, Dict, Optional, Type, Union\nfrom urllib.parse import urlencode, urlunparse\n\nfrom sanic import reloader_helpers\nfrom sanic.asgi import ASGIApp\nfrom sanic.blueprint_group import BlueprintGroup\nfrom sanic.config import BASE_LOGO, Config\nfrom sanic.constants import HTTP_METHODS\nfrom sanic.exceptions import SanicException, ServerError, URLBuildError\nfrom sanic.handlers import ErrorHandler\nfrom sanic.log import LOGGING_CONFIG_DEFAULTS, error_logger, logger\nfrom sanic.response import HTTPResponse, StreamingHTTPResponse\nfrom sanic.router import Router\nfrom sanic.server import (\n    AsyncioServer,\n    HttpProtocol,\n    Signal,\n    serve,\n    serve_multiple,\n)\nfrom sanic.static import register as static_register\nfrom sanic.testing import SanicASGITestClient, SanicTestClient\nfrom sanic.views import CompositionView\nfrom sanic.websocket import ConnectionClosed, WebSocketProtocol\n\n\nclass Sanic:\n    def __init__(\n        self,\n        name=None,\n        router=None,\n        error_handler=None,\n        load_env=True,\n        request_class=None,\n        strict_slashes=False,\n        log_config=None,\n        configure_logging=True,\n    ):\n\n        # Get name from previous stack frame\n        if name is None:\n            warnings.warn(\n                \"Sanic(name=None) is deprecated and None value support \"\n                \"for `name` will be removed in the next release. \"\n                \"Please use Sanic(name='your_application_name') instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            frame_records = stack()[1]\n            name = getmodulename(frame_records[1])\n\n        # logging\n        if configure_logging:\n            logging.config.dictConfig(log_config or LOGGING_CONFIG_DEFAULTS)\n\n        self.name = name\n        self.asgi = False\n        self.router = router or Router()\n        self.request_class = request_class\n        self.error_handler = error_handler or ErrorHandler()\n        self.config = Config(load_env=load_env)\n        self.request_middleware = deque()\n        self.response_middleware = deque()\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.configure_logging = configure_logging\n        self.debug = None\n        self.sock = None\n        self.strict_slashes = strict_slashes\n        self.listeners = defaultdict(list)\n        self.is_running = False\n        self.is_request_stream = False\n        self.websocket_enabled = False\n        self.websocket_tasks = set()\n        self.named_request_middleware = {}\n        self.named_response_middleware = {}\n        # Register alternative method names\n        self.go_fast = self.run\n\n    @property\n    def loop(self):\n        \"\"\"Synonymous with asyncio.get_event_loop().\n\n        Only supported when using the `app.run` method.\n        \"\"\"\n        if not self.is_running and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        return get_event_loop()\n\n    # -------------------------------------------------------------------- #\n    # Registration\n    # -------------------------------------------------------------------- #\n\n    def add_task(self, task):\n        \"\"\"Schedule a task to run later, after the loop has started.\n        Different from asyncio.ensure_future in that it does not\n        also return a future, and the actual ensure_future call\n        is delayed until before server start.\n\n        :param task: future, couroutine or awaitable\n        \"\"\"\n        try:\n            if callable(task):\n                try:\n                    self.loop.create_task(task(self))\n                except TypeError:\n                    self.loop.create_task(task())\n            else:\n                self.loop.create_task(task)\n        except SanicException:\n\n            @self.listener(\"before_server_start\")\n            def run(app, loop):\n                if callable(task):\n                    try:\n                        loop.create_task(task(self))\n                    except TypeError:\n                        loop.create_task(task())\n                else:\n                    loop.create_task(task)\n\n    # Decorator\n    def listener(self, event):\n        \"\"\"Create a listener from a decorated function.\n\n        :param event: event to listen to\n        \"\"\"\n\n        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener\n\n        return decorator\n\n    def register_listener(self, listener, event):\n        \"\"\"\n        Register the listener for a given event.\n\n        :param listener: callable i.e. setup_db(app, loop)\n        :param event: when to register listener i.e. 'before_server_start'\n        :return: listener\n        \"\"\"\n\n        return self.listener(event)(listener)\n\n    # Decorator\n    def route(\n        self,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"Decorate a function to be registered as a route\n\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed\n        :param host:\n        :param strict_slashes:\n        :param stream:\n        :param version:\n        :param name: user defined route name for url_for\n        :return: tuple of routes, decorated function\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if stream:\n            self.is_request_stream = True\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            args = list(signature(handler).parameters.keys())\n\n            if not args:\n                raise ValueError(\n                    \"Required parameter `request` missing \"\n                    \"in the {0}() route?\".format(handler.__name__)\n                )\n\n            if stream:\n                handler.is_stream = stream\n\n            routes = self.router.add(\n                uri=uri,\n                methods=methods,\n                handler=handler,\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n            )\n            return routes, handler\n\n        return response\n\n    # Shorthand method decorators\n    def get(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def post(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def put(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def head(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def options(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def patch(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )\n\n    def delete(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )\n\n    def add_route(\n        self,\n        handler,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        version=None,\n        name=None,\n        stream=False,\n    ):\n        \"\"\"A helper method to register class instance or\n        functions as a handler to the application url\n        routes.\n\n        :param handler: function or class instance\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed, these are overridden\n                        if using a HTTPMethodView\n        :param host:\n        :param strict_slashes:\n        :param version:\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                _handler = getattr(handler.view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n            for _handler in handler.handlers.values():\n                if hasattr(_handler, \"is_stream\"):\n                    stream = True\n                    break\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler\n\n    # Decorator\n    def websocket(\n        self, uri, host=None, strict_slashes=None, subprotocols=None, name=None\n    ):\n        \"\"\"\n        Decorate a function to be registered as a websocket route\n\n        :param uri: path of the URL\n        :param host: Host IP or FQDN details\n        :param strict_slashes: If the API endpoint needs to terminate\n                               with a \"/\" or not\n        :param subprotocols: optional list of str with supported subprotocols\n        :param name: A unique name assigned to the URL so that it can\n                     be used with :func:`url_for`\n        :return: tuple of routes, decorated function\n        \"\"\"\n        self.enable_websocket()\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            async def websocket_handler(request, *args, **kwargs):\n                request.app = self\n                if not getattr(handler, \"__blueprintname__\", False):\n                    request.endpoint = handler.__name__\n                else:\n                    request.endpoint = (\n                        getattr(handler, \"__blueprintname__\", \"\")\n                        + handler.__name__\n                    )\n\n                    pass\n\n                if self.asgi:\n                    ws = request.transport.get_websocket_connection()\n                else:\n                    try:\n                        protocol = request.transport.get_protocol()\n                    except AttributeError:\n                        # On Python3.5 the Transport classes in asyncio do not\n                        # have a get_protocol() method as in uvloop\n                        protocol = request.transport._protocol\n                    protocol.app = self\n\n                    ws = await protocol.websocket_handshake(\n                        request, subprotocols\n                    )\n\n                # schedule the application handler\n                # its future is kept in self.websocket_tasks in case it\n                # needs to be cancelled due to the server being stopped\n                fut = ensure_future(handler(request, ws, *args, **kwargs))\n                self.websocket_tasks.add(fut)\n                try:\n                    await fut\n                except (CancelledError, ConnectionClosed):\n                    pass\n                finally:\n                    self.websocket_tasks.remove(fut)\n                await ws.close()\n\n            routes = self.router.add(\n                uri=uri,\n                handler=websocket_handler,\n                methods=frozenset({\"GET\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                name=name,\n            )\n            return routes, handler\n\n        return response\n\n    def add_websocket_route(\n        self,\n        handler,\n        uri,\n        host=None,\n        strict_slashes=None,\n        subprotocols=None,\n        name=None,\n    ):\n        \"\"\"\n        A helper method to register a function as a websocket route.\n\n        :param handler: a callable function or instance of a class\n                        that can handle the websocket request\n        :param host: Host IP or FQDN details\n        :param uri: URL path that will be mapped to the websocket\n                    handler\n                    handler\n        :param strict_slashes: If the API endpoint needs to terminate\n                with a \"/\" or not\n        :param subprotocols: Subprotocols to be used with websocket\n                handshake\n        :param name: A unique name assigned to the URL so that it can\n                be used with :func:`url_for`\n        :return: Objected decorated by :func:`websocket`\n        \"\"\"\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        return self.websocket(\n            uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            name=name,\n        )(handler)\n\n    def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            @self.listener(\"before_server_stop\")\n            def cancel_websocket_tasks(app, loop):\n                for task in self.websocket_tasks:\n                    task.cancel()\n\n        self.websocket_enabled = enable\n\n    def remove_route(self, uri, clean_cache=True, host=None):\n        \"\"\"\n        This method provides the app user a mechanism by which an already\n        existing route can be removed from the :class:`Sanic` object\n\n        .. warning::\n            remove_route is deprecated in v19.06 and will be removed\n            from future versions.\n\n        :param uri: URL Path to be removed from the app\n        :param clean_cache: Instruct sanic if it needs to clean up the LRU\n            route cache\n        :param host: IP address or FQDN specific to the host\n        :return: None\n        \"\"\"\n        warnings.warn(\n            \"remove_route is deprecated and will be removed \"\n            \"from future versions.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.router.remove(uri, clean_cache, host)\n\n    # Decorator\n    def exception(self, *exceptions):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        def response(handler):\n            for exception in exceptions:\n                if isinstance(exception, (tuple, list)):\n                    for e in exception:\n                        self.error_handler.add(e, handler)\n                else:\n                    self.error_handler.add(exception, handler)\n            return handler\n\n        return response\n\n    def register_middleware(self, middleware, attach_to=\"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware\n\n    def register_named_middleware(\n        self, middleware, route_names, attach_to=\"request\"\n    ):\n        if attach_to == \"request\":\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if attach_to == \"response\":\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n                    self.named_response_middleware[_rn].append(middleware)\n\n    # Decorator\n    def middleware(self, middleware_or_request):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return self.register_middleware(middleware_or_request)\n\n        else:\n            return partial(\n                self.register_middleware, attach_to=middleware_or_request\n            )\n\n    # Static Files\n    def static(\n        self,\n        uri,\n        file_or_directory,\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n        :param file_or_directory: Path for the Static file/directory with\n            static files\n        :param pattern: Regex Pattern identifying the valid static files\n        :param use_modified_since: If true, send file modified time, and return\n            not modified if the browser's matches the server's\n        :param use_content_range: If true, process header for range requests\n            and sends the file part that is requested\n        :param stream_large_files: If true, use the\n            :func:`StreamingHTTPResponse.file_stream` handler rather\n            than the :func:`HTTPResponse.file` handler to send the file.\n            If this is an integer, this represents the threshold size to\n            switch to :func:`StreamingHTTPResponse.file_stream`\n        :param name: user defined name used for url_for\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param content_type: user defined content type for header\n        :return: None\n        \"\"\"\n        static_register(\n            self,\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n        )\n\n    def blueprint(self, blueprint, **options):\n        \"\"\"Register a blueprint on the application.\n\n        :param blueprint: Blueprint object or (list, tuple) thereof\n        :param options: option dictionary with blueprint defaults\n        :return: Nothing\n        \"\"\"\n        if isinstance(blueprint, (list, tuple, BlueprintGroup)):\n            for item in blueprint:\n                self.blueprint(item, **options)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n        blueprint.register(self, options)\n\n    def register_blueprint(self, *args, **kwargs):\n        \"\"\"\n        Proxy method provided for invoking the :func:`blueprint` method\n\n        .. note::\n            To be deprecated in 1.0. Use :func:`blueprint` instead.\n\n        :param args: Blueprint object or (list, tuple) thereof\n        :param kwargs: option dictionary with blueprint defaults\n        :return: None\n        \"\"\"\n\n        if self.debug:\n            warnings.simplefilter(\"default\")\n        warnings.warn(\n            \"Use of register_blueprint will be deprecated in \"\n            \"version 1.0.  Please use the blueprint method\"\n            \" instead\",\n            DeprecationWarning,\n        )\n        return self.blueprint(*args, **kwargs)\n\n    def url_for(self, view_name: str, **kwargs):\n        r\"\"\"Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        `URLBuildError` will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        :param view_name: string referencing the view name\n        :param \\**kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n        # find the route by the supplied view name\n        kw: Dict[str, str] = {}\n        # special static files url_for\n        if view_name == \"static\":\n            kw.update(name=kwargs.pop(\"name\", \"static\"))\n        elif view_name.endswith(\".static\"):  # blueprint.static\n            kwargs.pop(\"name\", None)\n            kw.update(name=view_name)\n\n        uri, route = self.router.find_route_by_view_name(view_name, **kw)\n        if not (uri and route):\n            raise URLBuildError(\n                \"Endpoint with name `{}` was not found\".format(view_name)\n            )\n\n        if view_name == \"static\" or view_name.endswith(\".static\"):\n            filename = kwargs.pop(\"filename\", None)\n            # it's static folder\n            if \"<file_uri:\" in uri:\n                folder_ = uri.split(\"<file_uri:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                uri = \"{}/{}\".format(folder_, filename)\n\n        if uri != \"/\" and uri.endswith(\"/\"):\n            uri = uri[:-1]\n\n        out = uri\n\n        # find all the parameters we will need to build in the URL\n        matched_params = re.findall(self.router.parameter_pattern, uri)\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        external = kwargs.pop(\"_external\", False)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        for match in matched_params:\n            name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n            specific_pattern = \"^{}$\".format(pattern)\n            supplied_param = None\n\n            if name in kwargs:\n                supplied_param = kwargs.get(name)\n                del kwargs[name]\n            else:\n                raise URLBuildError(\n                    \"Required parameter `{}` was not passed to url_for\".format(\n                        name\n                    )\n                )\n\n            supplied_param = str(supplied_param)\n            # determine if the parameter supplied by the caller passes the test\n            # in the URL\n            passes_pattern = re.match(specific_pattern, supplied_param)\n\n            if not passes_pattern:\n                if _type != str:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` does not '\n                        \"match pattern for type `{}`: {}\".format(\n                            supplied_param, name, _type.__name__, pattern\n                        )\n                    )\n                else:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` '\n                        \"does not satisfy pattern {}\".format(\n                            supplied_param, name, pattern\n                        )\n                    )\n                raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = \"(<{}.*?>)\".format(name)\n\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out\n\n    # -------------------------------------------------------------------- #\n    # Request Handling\n    # -------------------------------------------------------------------- #\n\n    def converted_response_type(self, response):\n        \"\"\"\n        No implementation provided.\n        \"\"\"\n        pass\n\n    async def handle_request(self, request, write_callback, stream_callback):\n        \"\"\"Take a request from the HTTP Server and return a response object\n        to be sent back The HTTP Server only expects a response object, so\n        exception handling must be done here\n\n        :param request: HTTP Request object\n        :param write_callback: Synchronous response function to be\n            called with the response as the only argument\n        :param stream_callback: Coroutine that handles streaming a\n            StreamingHTTPResponse if produced by the handler.\n\n        :return: Nothing\n        \"\"\"\n        # Define `response` var here to remove warnings about\n        # allocation before assignment below.\n        response = None\n        cancelled = False\n        name = None\n        try:\n            # Fetch handler from router\n            handler, args, kwargs, uri, name = self.router.get(request)\n\n            # -------------------------------------------- #\n            # Request Middleware\n            # -------------------------------------------- #\n            response = await self._run_request_middleware(\n                request, request_name=name\n            )\n            # No middleware results\n            if not response:\n                # -------------------------------------------- #\n                # Execute Handler\n                # -------------------------------------------- #\n\n                request.uri_template = uri\n                if handler is None:\n                    raise ServerError(\n                        (\n                            \"'None' was returned while requesting a \"\n                            \"handler from the router\"\n                        )\n                    )\n                else:\n                    if not getattr(handler, \"__blueprintname__\", False):\n                        request.endpoint = self._build_endpoint_name(\n                            handler.__name__\n                        )\n                    else:\n                        request.endpoint = self._build_endpoint_name(\n                            getattr(handler, \"__blueprintname__\", \"\"),\n                            handler.__name__,\n                        )\n\n                # Run response handler\n                response = handler(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n        except CancelledError:\n            # If response handler times out, the server handles the error\n            # and cancels the handle_request job.\n            # In this case, the transport is already closed and we cannot\n            # issue a response.\n            response = None\n            cancelled = True\n        except Exception as e:\n            # -------------------------------------------- #\n            # Response Generation Failed\n            # -------------------------------------------- #\n\n            try:\n                response = self.error_handler.response(request, e)\n                if isawaitable(response):\n                    response = await response\n            except Exception as e:\n                if isinstance(e, SanicException):\n                    response = self.error_handler.default(\n                        request=request, exception=e\n                    )\n                elif self.debug:\n                    response = HTTPResponse(\n                        \"Error while handling error: {}\\nStack: {}\".format(\n                            e, format_exc()\n                        ),\n                        status=500,\n                    )\n                else:\n                    response = HTTPResponse(\n                        \"An error occurred while handling an error\", status=500\n                    )\n        finally:\n            # -------------------------------------------- #\n            # Response Middleware\n            # -------------------------------------------- #\n            # Don't run response middleware if response is None\n            if response is not None:\n                try:\n                    response = await self._run_response_middleware(\n                        request, response, request_name=name\n                    )\n                except CancelledError:\n                    # Response middleware can timeout too, as above.\n                    response = None\n                    cancelled = True\n                except BaseException:\n                    error_logger.exception(\n                        \"Exception occurred in one of response \"\n                        \"middleware handlers\"\n                    )\n            if cancelled:\n                raise CancelledError()\n\n        # pass the response to the correct callback\n        if write_callback is None or isinstance(\n            response, StreamingHTTPResponse\n        ):\n            if stream_callback:\n                await stream_callback(response)\n            else:\n                # Should only end here IF it is an ASGI websocket.\n                # TODO:\n                # - Add exception handling\n                pass\n        else:\n            write_callback(response)\n\n    # -------------------------------------------------------------------- #\n    # Testing\n    # -------------------------------------------------------------------- #\n\n    @property\n    def test_client(self):\n        return SanicTestClient(self)\n\n    @property\n    def asgi_client(self):\n        return SanicASGITestClient(self)\n\n    # -------------------------------------------------------------------- #\n    # Execution\n    # -------------------------------------------------------------------- #\n\n    def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Run the HTTP Server and listen until keyboard interrupt or term\n        signal. On termination, drain connections before closing.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param workers: Number of processes received before it is respected\n        :type workers: int\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param register_sys_signals: Register SIG* events\n        :type register_sys_signals: bool\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :return: Nothing\n        \"\"\"\n        if \"loop\" in kwargs:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        # Default auto_reload to false\n        auto_reload = False\n        # If debug is set, default it to true (unless on windows)\n        if debug and os.name == \"posix\":\n            auto_reload = True\n        # Allow for overriding either of the defaults\n        auto_reload = kwargs.get(\"auto_reload\", auto_reload)\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_reload=auto_reload,\n        )\n\n        try:\n            self.is_running = True\n            if workers == 1:\n                if auto_reload and os.name != \"posix\":\n                    # This condition must be removed after implementing\n                    # auto reloader for other operating systems.\n                    raise NotImplementedError\n\n                if (\n                    auto_reload\n                    and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n                ):\n                    reloader_helpers.watchdog(2)\n                else:\n                    serve(**server_settings)\n            else:\n                serve_multiple(server_settings, workers)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            self.is_running = False\n        logger.info(\"Server Stopped\")\n\n    def stop(self):\n        \"\"\"This kills the Sanic\"\"\"\n        get_event_loop().stop()\n\n    async def create_server(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        access_log: Optional[bool] = None,\n        return_asyncio_server=False,\n        asyncio_server_kwargs=None,\n    ) -> Optional[AsyncioServer]:\n        \"\"\"\n        Asynchronous version of :func:`run`.\n\n        This method will take care of the operations necessary to invoke\n        the *before_start* events via :func:`trigger_events` method invocation\n        before starting the *sanic* app in Async mode.\n\n        .. note::\n            This does not support multiprocessing and is not the preferred\n            way to run a :class:`Sanic` application.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :param return_asyncio_server: flag that defines whether there's a need\n                                      to return asyncio.Server or\n                                      start it serving right away\n        :type return_asyncio_server: bool\n        :param asyncio_server_kwargs: key-value arguments for\n                                      asyncio/uvloop create_server method\n        :type asyncio_server_kwargs: dict\n        :return: AsyncioServer if return_asyncio_server is true, else Nothing\n        \"\"\"\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            loop=get_event_loop(),\n            protocol=protocol,\n            backlog=backlog,\n            run_async=return_asyncio_server,\n        )\n\n        # Trigger before_start events\n        await self.trigger_events(\n            server_settings.get(\"before_start\", []),\n            server_settings.get(\"loop\"),\n        )\n\n        return await serve(\n            asyncio_server_kwargs=asyncio_server_kwargs, **server_settings\n        )\n\n    async def trigger_events(self, events, loop):\n        \"\"\"Trigger events (functions or async)\n        :param events: one or more sync or async functions to execute\n        :param loop: event loop\n        \"\"\"\n        for event in events:\n            result = event(loop)\n            if isawaitable(result):\n                await result\n\n    async def _run_request_middleware(self, request, request_name=None):\n        # The if improves speed.  I don't know why\n        named_middleware = self.named_request_middleware.get(\n            request_name, deque()\n        )\n        applicable_middleware = self.request_middleware + named_middleware\n        if applicable_middleware:\n            for middleware in applicable_middleware:\n                response = middleware(request)\n                if isawaitable(response):\n                    response = await response\n                if response:\n                    return response\n        return None\n\n    async def _run_response_middleware(\n        self, request, response, request_name=None\n    ):\n        named_middleware = self.named_response_middleware.get(\n            request_name, deque()\n        )\n        applicable_middleware = self.response_middleware + named_middleware\n        if applicable_middleware:\n            for middleware in applicable_middleware:\n                _response = middleware(request, response)\n                if isawaitable(_response):\n                    _response = await _response\n                if _response:\n                    response = _response\n                    break\n        return response\n\n    def _helper(\n        self,\n        host=None,\n        port=None,\n        debug=False,\n        ssl=None,\n        sock=None,\n        workers=1,\n        loop=None,\n        protocol=HttpProtocol,\n        backlog=100,\n        stop_event=None,\n        register_sys_signals=True,\n        run_async=False,\n        auto_reload=False,\n    ):\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n        if isinstance(ssl, dict):\n            # try common aliaseses\n            cert = ssl.get(\"cert\") or ssl.get(\"certificate\")\n            key = ssl.get(\"key\") or ssl.get(\"keyfile\")\n            if cert is None or key is None:\n                raise ValueError(\"SSLContext or certificate and key required.\")\n            context = create_default_context(purpose=Purpose.CLIENT_AUTH)\n            context.load_cert_chain(cert, keyfile=key)\n            ssl = context\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        self.error_handler.debug = debug\n        self.debug = debug\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"request_class\": self.request_class,\n            \"is_request_stream\": self.is_request_stream,\n            \"router\": self.router,\n            \"host\": host,\n            \"port\": port,\n            \"sock\": sock,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": Signal(),\n            \"debug\": debug,\n            \"request_handler\": self.handle_request,\n            \"error_handler\": self.error_handler,\n            \"request_timeout\": self.config.REQUEST_TIMEOUT,\n            \"response_timeout\": self.config.RESPONSE_TIMEOUT,\n            \"keep_alive_timeout\": self.config.KEEP_ALIVE_TIMEOUT,\n            \"request_max_size\": self.config.REQUEST_MAX_SIZE,\n            \"request_buffer_queue_size\": self.config.REQUEST_BUFFER_QUEUE_SIZE,\n            \"keep_alive\": self.config.KEEP_ALIVE,\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n            \"access_log\": self.config.ACCESS_LOG,\n            \"websocket_max_size\": self.config.WEBSOCKET_MAX_SIZE,\n            \"websocket_max_queue\": self.config.WEBSOCKET_MAX_QUEUE,\n            \"websocket_read_limit\": self.config.WEBSOCKET_READ_LIMIT,\n            \"websocket_write_limit\": self.config.WEBSOCKET_WRITE_LIMIT,\n            \"graceful_shutdown_timeout\": self.config.GRACEFUL_SHUTDOWN_TIMEOUT,\n        }\n\n        # -------------------------------------------- #\n        # Register start/stop events\n        # -------------------------------------------- #\n\n        for event_name, settings_name, reverse in (\n            (\"before_server_start\", \"before_start\", False),\n            (\"after_server_start\", \"after_start\", False),\n            (\"before_server_stop\", \"before_stop\", True),\n            (\"after_server_stop\", \"after_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners\n\n        if self.configure_logging and debug:\n            logger.setLevel(logging.DEBUG)\n\n        if (\n            self.config.LOGO\n            and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n        ):\n            logger.debug(\n                self.config.LOGO\n                if isinstance(self.config.LOGO, str)\n                else BASE_LOGO\n            )\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        # Serve\n        if host and port and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\":\n            proto = \"http\"\n            if ssl is not None:\n                proto = \"https\"\n            logger.info(\"Goin' Fast @ {}://{}:{}\".format(proto, host, port))\n\n        return server_settings\n\n    def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)\n\n    # -------------------------------------------------------------------- #\n    # ASGI\n    # -------------------------------------------------------------------- #\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"To be ASGI compliant, our instance must be a callable that accepts\n        three arguments: scope, receive, send. See the ASGI reference for more\n        details: https://asgi.readthedocs.io/en/latest/\"\"\"\n        self.asgi = True\n        asgi_app = await ASGIApp.create(self, scope, receive, send)\n        await asgi_app()\n",
      "file_patch": "@@ -85,7 +85,8 @@ class Sanic:\n         self.is_request_stream = False\n         self.websocket_enabled = False\n         self.websocket_tasks = set()\n-\n+        self.named_request_middleware = {}\n+        self.named_response_middleware = {}\n         # Register alternative method names\n         self.go_fast = self.run\n \n@@ -178,7 +179,7 @@ class Sanic:\n         :param stream:\n         :param version:\n         :param name: user defined route name for url_for\n-        :return: decorated function\n+        :return: tuple of routes, decorated function\n         \"\"\"\n \n         # Fix case where the user did not prefix the URL with a /\n@@ -204,7 +205,7 @@ class Sanic:\n             if stream:\n                 handler.is_stream = stream\n \n-            self.router.add(\n+            routes = self.router.add(\n                 uri=uri,\n                 methods=methods,\n                 handler=handler,\n@@ -213,7 +214,7 @@ class Sanic:\n                 version=version,\n                 name=name,\n             )\n-            return handler\n+            return routes, handler\n \n         return response\n \n@@ -462,7 +463,7 @@ class Sanic:\n         :param subprotocols: optional list of str with supported subprotocols\n         :param name: A unique name assigned to the URL so that it can\n                      be used with :func:`url_for`\n-        :return: decorated function\n+        :return: tuple of routes, decorated function\n         \"\"\"\n         self.enable_websocket()\n \n@@ -515,7 +516,7 @@ class Sanic:\n                     self.websocket_tasks.remove(fut)\n                 await ws.close()\n \n-            self.router.add(\n+            routes = self.router.add(\n                 uri=uri,\n                 handler=websocket_handler,\n                 methods=frozenset({\"GET\"}),\n@@ -523,7 +524,7 @@ class Sanic:\n                 strict_slashes=strict_slashes,\n                 name=name,\n             )\n-            return handler\n+            return routes, handler\n \n         return response\n \n@@ -544,6 +545,7 @@ class Sanic:\n         :param host: Host IP or FQDN details\n         :param uri: URL path that will be mapped to the websocket\n                     handler\n+                    handler\n         :param strict_slashes: If the API endpoint needs to terminate\n                 with a \"/\" or not\n         :param subprotocols: Subprotocols to be used with websocket\n@@ -645,6 +647,22 @@ class Sanic:\n                 self.response_middleware.appendleft(middleware)\n         return middleware\n \n+    def register_named_middleware(\n+        self, middleware, route_names, attach_to=\"request\"\n+    ):\n+        if attach_to == \"request\":\n+            for _rn in route_names:\n+                if _rn not in self.named_request_middleware:\n+                    self.named_request_middleware[_rn] = deque()\n+                if middleware not in self.named_request_middleware[_rn]:\n+                    self.named_request_middleware[_rn].append(middleware)\n+        if attach_to == \"response\":\n+            for _rn in route_names:\n+                if _rn not in self.named_response_middleware:\n+                    self.named_response_middleware[_rn] = deque()\n+                if middleware not in self.named_response_middleware[_rn]:\n+                    self.named_response_middleware[_rn].append(middleware)\n+\n     # Decorator\n     def middleware(self, middleware_or_request):\n         \"\"\"\n@@ -916,20 +934,23 @@ class Sanic:\n         # allocation before assignment below.\n         response = None\n         cancelled = False\n+        name = None\n         try:\n+            # Fetch handler from router\n+            handler, args, kwargs, uri, name = self.router.get(request)\n+\n             # -------------------------------------------- #\n             # Request Middleware\n             # -------------------------------------------- #\n-            response = await self._run_request_middleware(request)\n+            response = await self._run_request_middleware(\n+                request, request_name=name\n+            )\n             # No middleware results\n             if not response:\n                 # -------------------------------------------- #\n                 # Execute Handler\n                 # -------------------------------------------- #\n \n-                # Fetch handler from router\n-                handler, args, kwargs, uri = self.router.get(request)\n-\n                 request.uri_template = uri\n                 if handler is None:\n                     raise ServerError(\n@@ -993,7 +1014,7 @@ class Sanic:\n             if response is not None:\n                 try:\n                     response = await self._run_response_middleware(\n-                        request, response\n+                        request, response, request_name=name\n                     )\n                 except CancelledError:\n                     # Response middleware can timeout too, as above.\n@@ -1265,10 +1286,14 @@ class Sanic:\n             if isawaitable(result):\n                 await result\n \n-    async def _run_request_middleware(self, request):\n+    async def _run_request_middleware(self, request, request_name=None):\n         # The if improves speed.  I don't know why\n-        if self.request_middleware:\n-            for middleware in self.request_middleware:\n+        named_middleware = self.named_request_middleware.get(\n+            request_name, deque()\n+        )\n+        applicable_middleware = self.request_middleware + named_middleware\n+        if applicable_middleware:\n+            for middleware in applicable_middleware:\n                 response = middleware(request)\n                 if isawaitable(response):\n                     response = await response\n@@ -1276,9 +1301,15 @@ class Sanic:\n                     return response\n         return None\n \n-    async def _run_response_middleware(self, request, response):\n-        if self.response_middleware:\n-            for middleware in self.response_middleware:\n+    async def _run_response_middleware(\n+        self, request, response, request_name=None\n+    ):\n+        named_middleware = self.named_response_middleware.get(\n+            request_name, deque()\n+        )\n+        applicable_middleware = self.response_middleware + named_middleware\n+        if applicable_middleware:\n+            for middleware in applicable_middleware:\n                 _response = middleware(request, response)\n                 if isawaitable(_response):\n                     _response = await _response\n",
      "files_name_in_blame_commit": [
        "test_app.py",
        "app.py",
        "test_blueprints.py",
        "blueprints.py",
        "test_blueprint_group.py",
        "router.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 255
  },
  "recursive_blame_commits": {}
}
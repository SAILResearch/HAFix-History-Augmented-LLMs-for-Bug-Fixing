{
  "id": "23",
  "blame_commit": {
    "commit": {
      "commit_id": "43a44e6f3533170557cb971df6b3272e8bb7fa6b",
      "commit_message": "Move utility functions out of basic.py (#51715)\n\nMove the following methods to lib/anisble/module_utils/common/validation.py:\r\n\r\n- _count_terms()\r\n- _check_mutually_exclusive()\r\n- _check_required_one_of()\r\n- _check_required_together()\r\n- _check_required_by()\r\n- _check_required_arguments()\r\n- _check_required_if\r\n- fail_on_missing_params() --> create check_missing_parameters()",
      "commit_author": "Sam Doran",
      "commit_date": "2019-03-14 21:29:55",
      "commit_parent": "34b928d28376696fd3a62bf5b7bc5316713574d6"
    },
    "function": {
      "function_name": "check_required_arguments",
      "function_code_before": "",
      "function_code_after": "def check_required_arguments(argument_spec, module_parameters):\n    \"\"\"Check all paramaters in argument_spec and return a list of parameters\n    that are required by not present in module_parameters.\n\n    Raises AnsibleModuleParameterException if the check fails.\n\n    :arg argument_spec: Argument spec dicitionary containing all parameters\n        and their specification\n    :arg module_paramaters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n    missing = []\n    if argument_spec is None:\n        return missing\n    for (k, v) in argument_spec.items():\n        required = v.get('required', False)\n        if required and k not in module_parameters:\n            missing.append(k)\n    if missing:\n        msg = 'missing required arguments: %s' % ', '.join(missing)\n        raise TypeError(to_native(msg))\n    return missing",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 150,
      "function_after_end_line": 176,
      "function_before_token_count": 0,
      "function_after_token_count": 79,
      "functions_name_modified_file": [
        "check_mutually_exclusive",
        "check_required_together",
        "check_required_if",
        "count_terms",
        "check_required_by",
        "check_required_arguments",
        "check_required_one_of",
        "check_missing_parameters"
      ],
      "functions_name_all_files": [
        "append_to_file",
        "test_nxos_bgp_af_vrf_exists",
        "_json_encode_fallback",
        "check_required_arguments",
        "_get_wanted_type",
        "find_package_foo",
        "test_module_utils_with_identation_error",
        "test_fail_required_together_and_fallback",
        "_apply_operation_to_mode",
        "_check_mutually_exclusive",
        "mutually_exclusive_terms",
        "check_required_if",
        "test_validator_fail",
        "set_owner_if_different",
        "test_subspec_not_required_defaults",
        "_check_type_bits",
        "selinux_default_context",
        "find_mount_point",
        "check_required_one_of",
        "selinux_initial_context",
        "_count_terms",
        "_remove_values_conditions",
        "fail_on_missing_params",
        "_symbolic_mode_to_octal",
        "heuristic_log_sanitize",
        "_check_type_str",
        "test_fail_required_together",
        "test_nxos_bgp_af_dampening_mix",
        "_check_required_by",
        "__init__",
        "_restore_signal_handlers",
        "md5",
        "test_validator_basic_types",
        "get_all_subclasses",
        "selinux_enabled",
        "_set_defaults",
        "test_import_six_from_many_submodules",
        "test_fallback_in_option",
        "test_check_mutually_exclusive_found",
        "check_required_together",
        "finder_containers",
        "_check_type_path",
        "_check_argument_values",
        "tmpdir",
        "test_module_utils_with_syntax_error",
        "test_nxos_bgp_af_client",
        "tearDown",
        "test_fail_validate_options_dict",
        "set_context_if_different",
        "_check_type_bytes",
        "test_validator_function",
        "count_terms",
        "preserved_copy",
        "exit_json",
        "test_load_file_common_args",
        "sha256",
        "load_file_common_arguments",
        "_check_type_jsonarg",
        "get_timestamp",
        "add_path_info",
        "test_elements_path_in_option",
        "digest_from_file",
        "test_count_terms_list_input",
        "missing_required_lib",
        "test_list_with_choices",
        "_handle_aliases",
        "add_cleanup_file",
        "test_count_terms_tuple_input",
        "options_argspec_list",
        "do_cleanup_files",
        "_handle_elements",
        "env_fallback",
        "_check_type_float",
        "_read_from_pipes",
        "bytes_to_human",
        "check_required_by",
        "set_file_attributes_if_different",
        "get_buffer_size",
        "_check_type_dict",
        "test_import_six",
        "set_default_selinux_context",
        "_lenient_lowercase",
        "find_module_foo",
        "set_fs_attributes_if_different",
        "test_options_type_dict",
        "_load_params",
        "log",
        "_return_formatted",
        "cleanup",
        "get_file_attributes",
        "deprecate",
        "_check_type_raw",
        "sha1",
        "check_file_absent_if_check_mode",
        "check_mutually_exclusive",
        "test_from_import_six",
        "get_module_path",
        "_check_required_if",
        "test_no_module_utils",
        "complex_argspec",
        "setUp",
        "get_platform",
        "test_fail_validate_options_list",
        "selinux_context",
        "_log_to_syslog",
        "test_count_terms_str_input",
        "options_argspec_dict",
        "load_fixtures",
        "params",
        "remove_values",
        "jsonify",
        "load_platform_subclass",
        "json_dict_unicode_to_bytes",
        "test_complex_required",
        "is_special_selinux_path",
        "_unsafe_writes",
        "from_json",
        "check_missing_parameters",
        "test_complex_type_fallback",
        "test_options_type_list",
        "_log_invocation",
        "test_fail_list_with_choices",
        "debug",
        "human_to_bytes",
        "test_check_mutually_exclusive_no_params",
        "test_list_with_elements_path",
        "test_fail_required_together_and_default",
        "set_attributes_if_different",
        "set_mode_if_different",
        "set_directory_attributes_if_different",
        "test_check_mutually_exclusive_none",
        "test_smoketest_load_file_common_args",
        "_set_fallbacks",
        "_check_type_bool",
        "atomic_move",
        "_clean_args",
        "get_bin_path",
        "run_command",
        "json_dict_bytes_to_unicode",
        "_handle_no_log_values",
        "set_group_if_different",
        "test_from_import_toplevel_package",
        "test_nxos_bgp_af",
        "_check_required_together",
        "fail_json",
        "backup_local",
        "safe_eval",
        "_check_required_arguments",
        "_handle_options",
        "user_and_group",
        "test_nxos_bgp_af_dampening_routemap",
        "test_from_import_toplevel_module",
        "test_nxos_bgp_af_dampening_manual",
        "selinux_mls_enabled",
        "_check_locale",
        "_set_cwd",
        "test_nxos_bgp_af_vrf",
        "test_fail_mutually_exclusive",
        "_get_octal_mode_from_symbolic_perms",
        "_check_required_one_of",
        "_check_arguments",
        "boolean",
        "_check_type_list",
        "_check_type_int",
        "test_count_terms",
        "_check_argument_types",
        "test_check_mutually_exclusive",
        "warn"
      ],
      "functions_name_co_evolved_modified_file": [
        "check_mutually_exclusive",
        "check_required_together",
        "check_required_if",
        "count_terms",
        "check_required_by",
        "check_required_one_of",
        "check_missing_parameters"
      ],
      "functions_name_co_evolved_all_files": [
        "check_mutually_exclusive",
        "_check_required_together",
        "count_terms",
        "_check_required_if",
        "complex_argspec",
        "_check_mutually_exclusive",
        "test_count_terms_list_input",
        "mutually_exclusive_terms",
        "test_count_terms_str_input",
        "_check_required_arguments",
        "check_required_if",
        "params",
        "check_missing_parameters",
        "test_count_terms_tuple_input",
        "options_argspec_list",
        "_count_terms",
        "fail_on_missing_params",
        "test_check_mutually_exclusive_no_params",
        "test_fail_mutually_exclusive",
        "check_required_by",
        "test_nxos_bgp_af_dampening_mix",
        "test_check_mutually_exclusive_none",
        "_check_required_by",
        "_check_required_one_of",
        "test_check_mutually_exclusive_found",
        "check_required_together",
        "test_count_terms",
        "test_check_mutually_exclusive",
        "check_required_one_of"
      ]
    },
    "file": {
      "file_name": "validation.py",
      "file_nloc": 126,
      "file_complexity": 60,
      "file_token_count": 829,
      "file_before": null,
      "file_after": "# -*- coding: utf-8 -*-\n# Copyright (c) 2018 Ansible Project\n# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nfrom ansible.module_utils._text import to_native\nfrom ansible.module_utils.common.collections import is_iterable\nfrom ansible.module_utils.six import string_types\n\n\ndef count_terms(terms, module_parameters):\n    \"\"\"Count the number of occurrences of a key in a given dictionary\n\n    :arg terms: String or iterable of values to check\n    :arg module_parameters: Dictionary of module parameters\n\n    :returns: An integer that is the number of occurrences of the terms values\n        in the provided dictionary.\n    \"\"\"\n\n    if not is_iterable(terms):\n        terms = [terms]\n\n    return len(set(terms).intersection(module_parameters))\n\n\ndef check_mutually_exclusive(terms, module_parameters):\n    \"\"\"Check mutually exclusive terms against argument parameters. Accepts\n    a single list or list of lists that are groups of terms that should be\n    mutually exclusive with one another\n\n    :arg terms: List of mutually exclusive module parameters\n    :arg module_parameters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n\n    results = []\n    if terms is None:\n        return results\n\n    for check in terms:\n        count = count_terms(check, module_parameters)\n        if count > 1:\n            results.append(check)\n\n    if results:\n        full_list = ['|'.join(check) for check in results]\n        msg = \"parameters are mutually exclusive: %s\" % ', '.join(full_list)\n        raise TypeError(to_native(msg))\n\n    return results\n\n\ndef check_required_one_of(terms, module_parameters):\n    \"\"\"Check each list of terms to ensure at least one exists in the given module\n    parameters. Accepts a list of lists or tuples.\n\n    :arg terms: List of lists of terms to check. For each list of terms, at\n        least one is required.\n    :arg module_parameters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n\n    results = []\n    if terms is None:\n        return results\n\n    for term in terms:\n        count = count_terms(term, module_parameters)\n        if count == 0:\n            results.append(term)\n\n    if results:\n        for term in results:\n            msg = \"one of the following is required: %s\" % ', '.join(term)\n            raise TypeError(to_native(msg))\n\n    return results\n\n\ndef check_required_together(terms, module_parameters):\n    \"\"\"Check each list of terms to ensure every parameter in each list exists\n    in the given module parameters. Accepts a list of lists or tuples.\n\n    :arg terms: List of lists of terms to check. Each list should include\n        parameters that are all required when at least one is specified\n        in the module_parameters.\n    :arg module_parameters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n\n    results = []\n    if terms is None:\n        return results\n\n    for term in terms:\n        counts = [count_terms(field, module_parameters) for field in term]\n        non_zero = [c for c in counts if c > 0]\n        if len(non_zero) > 0:\n            if 0 in counts:\n                results.append(term)\n    if results:\n        for term in results:\n            msg = \"parameters are required together: %s\" % ', '.join(term)\n            raise TypeError(to_native(msg))\n\n    return results\n\n\ndef check_required_by(requirements, module_parameters):\n    \"\"\"For each key in requirements, check the corresponding list to see if they\n    exist in module_parameters. Accepts a single string or list of values for\n    each key.\n\n    :arg requirements: Dictionary of requirements\n    :arg module_parameters: Dictionary of module parameters\n\n    :returns: Empty dictionary or raises TypeError if the\n    \"\"\"\n\n    result = {}\n    if requirements is None:\n        return result\n\n    for (key, value) in requirements.items():\n        if key not in module_parameters or module_parameters[key] is None:\n            continue\n        result[key] = []\n        # Support strings (single-item lists)\n        if isinstance(value, string_types):\n            value = [value]\n        for required in value:\n            if required not in module_parameters or module_parameters[required] is None:\n                result[key].append(required)\n\n    if result:\n        for key, missing in result.items():\n            if len(missing) > 0:\n                msg = \"missing parameter(s) required by '%s': %s\" % (key, ', '.join(missing))\n                raise TypeError(to_native(msg))\n\n    return result\n\n\ndef check_required_arguments(argument_spec, module_parameters):\n    \"\"\"Check all paramaters in argument_spec and return a list of parameters\n    that are required by not present in module_parameters.\n\n    Raises AnsibleModuleParameterException if the check fails.\n\n    :arg argument_spec: Argument spec dicitionary containing all parameters\n        and their specification\n    :arg module_paramaters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n\n    missing = []\n    if argument_spec is None:\n        return missing\n\n    for (k, v) in argument_spec.items():\n        required = v.get('required', False)\n        if required and k not in module_parameters:\n            missing.append(k)\n\n    if missing:\n        msg = \"missing required arguments: %s\" % \", \".join(missing)\n        raise TypeError(to_native(msg))\n\n    return missing\n\n\ndef check_required_if(requirements, module_parameters):\n    \"\"\"Check parameters that are conditionally required.\n\n    Raises TypeError if the check fails.\n\n    :arg requirements: List of lists specifying a parameter, value, parameters\n        required when the given parameter is the specified value, and optionally\n        a boolean indicating any or all parameters are required.\n\n        Example:\n            required_if=[\n                ['state', 'present', ('path',), True],\n                ['someint', 99, ('bool_param', 'string_param')],\n            ]\n\n    :arg module_paramaters: Dictionary of module parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n        The results attribute of the exception contains a list of dictionaries.\n        Each dictionary is the result of evaluting each item in requirements.\n        Each return dictionary contains the following keys:\n\n            :key missing: List of parameters that are required but missing\n            :key requires: 'any' or 'all'\n            :key paramater: Parameter name that has the requirement\n            :key value: Original value of the paramater\n            :key requirements: Original required parameters\n\n        Example:\n            [\n                {\n                    'parameter': 'someint',\n                    'value': 99\n                    'requirements': ('bool_param', 'string_param'),\n                    'missing': ['string_param'],\n                    'requires': 'all',\n                }\n            ]\n\n    \"\"\"\n    results = []\n    if requirements is None:\n        return results\n\n    for req in requirements:\n        missing = {}\n        missing['missing'] = []\n        max_missing_count = 0\n        is_one_of = False\n        if len(req) == 4:\n            key, val, requirements, is_one_of = req\n        else:\n            key, val, requirements = req\n\n        # is_one_of is True at least one requirement should be\n        # present, else all requirements should be present.\n        if is_one_of:\n            max_missing_count = len(requirements)\n            missing['requires'] = 'any'\n        else:\n            missing['requires'] = 'all'\n\n        if key in module_parameters and module_parameters[key] == val:\n            for check in requirements:\n                count = count_terms(check, module_parameters)\n                if count == 0:\n                    missing['missing'].append(check)\n        if len(missing['missing']) and len(missing['missing']) >= max_missing_count:\n            missing['parameter'] = key\n            missing['value'] = val\n            missing['requirements'] = requirements\n            results.append(missing)\n\n    if results:\n        for missing in results:\n            msg = \"%s is %s but %s of the following are missing: %s\" % (\n                missing['parameter'], missing['value'], missing['requires'], ', '.join(missing['missing']))\n            raise TypeError(to_native(msg))\n\n    return results\n\n\ndef check_missing_parameters(module_parameters, required_parameters=None):\n    \"\"\"This is for checking for required params when we can not check via\n    argspec because we need more information than is simply given in the argspec.\n\n    :arg module_paramaters: Dictionary of module parameters\n    :arg required_parameters: List of parameters to look for in the given module\n        parameters\n\n    :returns: Empty list or raises TypeError if the check fails.\n    \"\"\"\n    missing_params = []\n    if required_parameters is None:\n        return missing_params\n\n    for param in required_parameters:\n        if not module_parameters.get(param):\n            missing_params.append(param)\n\n    if missing_params:\n        msg = \"missing required arguments: %s\" % ', '.join(missing_params)\n        raise TypeError(to_native(msg))\n\n    return missing_params\n",
      "file_patch": "@@ -0,0 +1,283 @@\n+# -*- coding: utf-8 -*-\n+# Copyright (c) 2018 Ansible Project\n+# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)\n+\n+from __future__ import absolute_import, division, print_function\n+__metaclass__ = type\n+\n+from ansible.module_utils._text import to_native\n+from ansible.module_utils.common.collections import is_iterable\n+from ansible.module_utils.six import string_types\n+\n+\n+def count_terms(terms, module_parameters):\n+    \"\"\"Count the number of occurrences of a key in a given dictionary\n+\n+    :arg terms: String or iterable of values to check\n+    :arg module_parameters: Dictionary of module parameters\n+\n+    :returns: An integer that is the number of occurrences of the terms values\n+        in the provided dictionary.\n+    \"\"\"\n+\n+    if not is_iterable(terms):\n+        terms = [terms]\n+\n+    return len(set(terms).intersection(module_parameters))\n+\n+\n+def check_mutually_exclusive(terms, module_parameters):\n+    \"\"\"Check mutually exclusive terms against argument parameters. Accepts\n+    a single list or list of lists that are groups of terms that should be\n+    mutually exclusive with one another\n+\n+    :arg terms: List of mutually exclusive module parameters\n+    :arg module_parameters: Dictionary of module parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+    \"\"\"\n+\n+    results = []\n+    if terms is None:\n+        return results\n+\n+    for check in terms:\n+        count = count_terms(check, module_parameters)\n+        if count > 1:\n+            results.append(check)\n+\n+    if results:\n+        full_list = ['|'.join(check) for check in results]\n+        msg = \"parameters are mutually exclusive: %s\" % ', '.join(full_list)\n+        raise TypeError(to_native(msg))\n+\n+    return results\n+\n+\n+def check_required_one_of(terms, module_parameters):\n+    \"\"\"Check each list of terms to ensure at least one exists in the given module\n+    parameters. Accepts a list of lists or tuples.\n+\n+    :arg terms: List of lists of terms to check. For each list of terms, at\n+        least one is required.\n+    :arg module_parameters: Dictionary of module parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+    \"\"\"\n+\n+    results = []\n+    if terms is None:\n+        return results\n+\n+    for term in terms:\n+        count = count_terms(term, module_parameters)\n+        if count == 0:\n+            results.append(term)\n+\n+    if results:\n+        for term in results:\n+            msg = \"one of the following is required: %s\" % ', '.join(term)\n+            raise TypeError(to_native(msg))\n+\n+    return results\n+\n+\n+def check_required_together(terms, module_parameters):\n+    \"\"\"Check each list of terms to ensure every parameter in each list exists\n+    in the given module parameters. Accepts a list of lists or tuples.\n+\n+    :arg terms: List of lists of terms to check. Each list should include\n+        parameters that are all required when at least one is specified\n+        in the module_parameters.\n+    :arg module_parameters: Dictionary of module parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+    \"\"\"\n+\n+    results = []\n+    if terms is None:\n+        return results\n+\n+    for term in terms:\n+        counts = [count_terms(field, module_parameters) for field in term]\n+        non_zero = [c for c in counts if c > 0]\n+        if len(non_zero) > 0:\n+            if 0 in counts:\n+                results.append(term)\n+    if results:\n+        for term in results:\n+            msg = \"parameters are required together: %s\" % ', '.join(term)\n+            raise TypeError(to_native(msg))\n+\n+    return results\n+\n+\n+def check_required_by(requirements, module_parameters):\n+    \"\"\"For each key in requirements, check the corresponding list to see if they\n+    exist in module_parameters. Accepts a single string or list of values for\n+    each key.\n+\n+    :arg requirements: Dictionary of requirements\n+    :arg module_parameters: Dictionary of module parameters\n+\n+    :returns: Empty dictionary or raises TypeError if the\n+    \"\"\"\n+\n+    result = {}\n+    if requirements is None:\n+        return result\n+\n+    for (key, value) in requirements.items():\n+        if key not in module_parameters or module_parameters[key] is None:\n+            continue\n+        result[key] = []\n+        # Support strings (single-item lists)\n+        if isinstance(value, string_types):\n+            value = [value]\n+        for required in value:\n+            if required not in module_parameters or module_parameters[required] is None:\n+                result[key].append(required)\n+\n+    if result:\n+        for key, missing in result.items():\n+            if len(missing) > 0:\n+                msg = \"missing parameter(s) required by '%s': %s\" % (key, ', '.join(missing))\n+                raise TypeError(to_native(msg))\n+\n+    return result\n+\n+\n+def check_required_arguments(argument_spec, module_parameters):\n+    \"\"\"Check all paramaters in argument_spec and return a list of parameters\n+    that are required by not present in module_parameters.\n+\n+    Raises AnsibleModuleParameterException if the check fails.\n+\n+    :arg argument_spec: Argument spec dicitionary containing all parameters\n+        and their specification\n+    :arg module_paramaters: Dictionary of module parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+    \"\"\"\n+\n+    missing = []\n+    if argument_spec is None:\n+        return missing\n+\n+    for (k, v) in argument_spec.items():\n+        required = v.get('required', False)\n+        if required and k not in module_parameters:\n+            missing.append(k)\n+\n+    if missing:\n+        msg = \"missing required arguments: %s\" % \", \".join(missing)\n+        raise TypeError(to_native(msg))\n+\n+    return missing\n+\n+\n+def check_required_if(requirements, module_parameters):\n+    \"\"\"Check parameters that are conditionally required.\n+\n+    Raises TypeError if the check fails.\n+\n+    :arg requirements: List of lists specifying a parameter, value, parameters\n+        required when the given parameter is the specified value, and optionally\n+        a boolean indicating any or all parameters are required.\n+\n+        Example:\n+            required_if=[\n+                ['state', 'present', ('path',), True],\n+                ['someint', 99, ('bool_param', 'string_param')],\n+            ]\n+\n+    :arg module_paramaters: Dictionary of module parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+        The results attribute of the exception contains a list of dictionaries.\n+        Each dictionary is the result of evaluting each item in requirements.\n+        Each return dictionary contains the following keys:\n+\n+            :key missing: List of parameters that are required but missing\n+            :key requires: 'any' or 'all'\n+            :key paramater: Parameter name that has the requirement\n+            :key value: Original value of the paramater\n+            :key requirements: Original required parameters\n+\n+        Example:\n+            [\n+                {\n+                    'parameter': 'someint',\n+                    'value': 99\n+                    'requirements': ('bool_param', 'string_param'),\n+                    'missing': ['string_param'],\n+                    'requires': 'all',\n+                }\n+            ]\n+\n+    \"\"\"\n+    results = []\n+    if requirements is None:\n+        return results\n+\n+    for req in requirements:\n+        missing = {}\n+        missing['missing'] = []\n+        max_missing_count = 0\n+        is_one_of = False\n+        if len(req) == 4:\n+            key, val, requirements, is_one_of = req\n+        else:\n+            key, val, requirements = req\n+\n+        # is_one_of is True at least one requirement should be\n+        # present, else all requirements should be present.\n+        if is_one_of:\n+            max_missing_count = len(requirements)\n+            missing['requires'] = 'any'\n+        else:\n+            missing['requires'] = 'all'\n+\n+        if key in module_parameters and module_parameters[key] == val:\n+            for check in requirements:\n+                count = count_terms(check, module_parameters)\n+                if count == 0:\n+                    missing['missing'].append(check)\n+        if len(missing['missing']) and len(missing['missing']) >= max_missing_count:\n+            missing['parameter'] = key\n+            missing['value'] = val\n+            missing['requirements'] = requirements\n+            results.append(missing)\n+\n+    if results:\n+        for missing in results:\n+            msg = \"%s is %s but %s of the following are missing: %s\" % (\n+                missing['parameter'], missing['value'], missing['requires'], ', '.join(missing['missing']))\n+            raise TypeError(to_native(msg))\n+\n+    return results\n+\n+\n+def check_missing_parameters(module_parameters, required_parameters=None):\n+    \"\"\"This is for checking for required params when we can not check via\n+    argspec because we need more information than is simply given in the argspec.\n+\n+    :arg module_paramaters: Dictionary of module parameters\n+    :arg required_parameters: List of parameters to look for in the given module\n+        parameters\n+\n+    :returns: Empty list or raises TypeError if the check fails.\n+    \"\"\"\n+    missing_params = []\n+    if required_parameters is None:\n+        return missing_params\n+\n+    for param in required_parameters:\n+        if not module_parameters.get(param):\n+            missing_params.append(param)\n+\n+    if missing_params:\n+        msg = \"missing required arguments: %s\" % ', '.join(missing_params)\n+        raise TypeError(to_native(msg))\n+\n+    return missing_params\n",
      "files_name_in_blame_commit": [
        "test_check_mutually_exclusive.py",
        "test_argument_spec.py",
        "validation.py",
        "basic.py",
        "test_recursive_finder.py",
        "test_count_terms.py",
        "test_nxos_bgp_af.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 5
  },
  "recursive_blame_commits": {}
}
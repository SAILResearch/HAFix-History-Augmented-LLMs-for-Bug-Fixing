{
  "id": "20",
  "blame_commit": {
    "commit": {
      "commit_id": "b286f201a8424e00cc91d27adcf53a5249b8a3b9",
      "commit_message": "[YoutubeDL] Do not override ie_key in url_transparent",
      "commit_author": "Yen Chi Hsuan",
      "commit_date": "2016-02-01 17:05:48",
      "commit_parent": "bd93a12e852f34a1c9d8c86023972c6812dc80d5"
    },
    "function": {
      "function_name": "process_ie_result",
      "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
      "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url', 'ie_key'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
      "function_before_start_line": 702,
      "function_before_end_line": 865,
      "function_after_start_line": 702,
      "function_after_end_line": 864,
      "function_before_token_count": 817,
      "function_after_token_count": 819,
      "functions_name_modified_file": [
        "list_formats",
        "to_stderr",
        "record_download_archive",
        "add_extra_info",
        "extract_info",
        "in_download_archive",
        "_setup_opener",
        "restore_console_title",
        "report_warning",
        "list_subtitles",
        "_make_archive_id",
        "add_default_info_extractors",
        "urlopen",
        "__enter__",
        "trouble",
        "get_encoding",
        "process_info",
        "process_ie_result",
        "post_process",
        "add_post_processor",
        "_format_note",
        "_write_thumbnails",
        "prepare_filename",
        "add_progress_hook",
        "encode",
        "to_console_title",
        "warn_if_short_id",
        "to_screen",
        "save_console_title",
        "_match_entry",
        "filter_requested_info",
        "__init__",
        "download_with_info_file",
        "report_error",
        "format_resolution",
        "download",
        "_build_format_filter",
        "get_info_extractor",
        "_calc_headers",
        "add_info_extractor",
        "process_subtitles",
        "print_debug_header",
        "_bidi_workaround",
        "add_default_extra_info",
        "process_video_result",
        "list_thumbnails",
        "report_file_already_downloaded",
        "_calc_cookies",
        "build_format_selector",
        "__exit__",
        "to_stdout",
        "_write_string"
      ],
      "functions_name_all_files": [
        "list_formats",
        "to_stderr",
        "record_download_archive",
        "test_format_selection_audio",
        "add_extra_info",
        "test_format_note",
        "extract_info",
        "in_download_archive",
        "_setup_opener",
        "restore_console_title",
        "report_warning",
        "test_add_extra_info",
        "list_subtitles",
        "_make_archive_id",
        "test_match_filter",
        "test_format_selection",
        "add_default_info_extractors",
        "urlopen",
        "test_format_selection_audio_exts",
        "test_do_not_override_ie_key_in_url_transparent",
        "__enter__",
        "trouble",
        "get_encoding",
        "test_prefer_free_formats",
        "process_info",
        "test_invalid_format_specs",
        "process_ie_result",
        "post_process",
        "test_youtube_format_selection",
        "add_post_processor",
        "_format_note",
        "test_urlopen_no_file_protocol",
        "test_playlist_items_selection",
        "_write_thumbnails",
        "prepare_filename",
        "add_progress_hook",
        "test_prepare_filename",
        "test_postprocessors",
        "encode",
        "to_console_title",
        "warn_if_short_id",
        "to_screen",
        "test_format_selection_video",
        "test_subtitles",
        "save_console_title",
        "_match_entry",
        "_make_result",
        "__init__",
        "download_with_info_file",
        "filter_requested_info",
        "report_error",
        "format_resolution",
        "download",
        "_build_format_filter",
        "test_format_filtering",
        "get_info_extractor",
        "add_info_extractor",
        "_calc_headers",
        "process_subtitles",
        "_bidi_workaround",
        "print_debug_header",
        "add_default_extra_info",
        "process_video_result",
        "list_thumbnails",
        "report_file_already_downloaded",
        "_calc_cookies",
        "build_format_selector",
        "__exit__",
        "to_stdout",
        "_write_string"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_do_not_override_ie_key_in_url_transparent"
      ]
    },
    "file": {
      "file_name": "YoutubeDL.py",
      "file_nloc": 1757,
      "file_complexity": 561,
      "file_token_count": 11417,
      "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport tokenize\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_tokenize_tokenize,\n    compat_urllib_error,\n    compat_urllib_request,\n    compat_urllib_request_DataHandler,\n)\nfrom .utils import (\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    determine_protocol,\n    DownloadError,\n    encode_compat_str,\n    encodeFilename,\n    error_to_compat_str,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    sanitized_Request,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLCookieProcessor,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for accessing a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    force_generic_extractor: Force downloader to use the generic extractor\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatically generated subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args, hls_use_mpegts.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    postprocessor_args: A list of additional command-line arguments for the\n                        postprocessor.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {\n            # Default parameters\n            'nocheckcertificate': False,\n        }\n        self.params.update(params)\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += encode_compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return sanitize_path(filename)\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True, force_generic_extractor=False):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if not ie_key and force_generic_extractor:\n            ie_key = 'Generic'\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as e:  # An error we somewhat expected\n                self.report_error(compat_str(e), e.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(error_to_compat_str(e), tb=encode_compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [\n                        ie_entries[i - 1] for i in playlistitems\n                        if -n_all_entries <= i - 1 < n_all_entries]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _build_format_filter(self, filter_spec):\n        \" Returns a function to filter the formats according to the filter_spec \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            $\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(filter_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), filter_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n                '^=': lambda attr, value: attr.startswith(value),\n                '$=': lambda attr, value: attr.endswith(value),\n                '*=': lambda attr, value: value in attr,\n            }\n            str_operator_rex = re.compile(r'''(?x)\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9._-]+)\n                \\s*$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(filter_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid filter specification %r' % filter_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        return _filter\n\n    def build_format_selector(self, format_spec):\n        def syntax_error(note, start):\n            message = (\n                'Invalid format specification: '\n                '{0}\\n\\t{1}\\n\\t{2}^'.format(note, format_spec, ' ' * start[1]))\n            return SyntaxError(message)\n\n        PICKFIRST = 'PICKFIRST'\n        MERGE = 'MERGE'\n        SINGLE = 'SINGLE'\n        GROUP = 'GROUP'\n        FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])\n\n        def _parse_filter(tokens):\n            filter_parts = []\n            for type, string, start, _, _ in tokens:\n                if type == tokenize.OP and string == ']':\n                    return ''.join(filter_parts)\n                else:\n                    filter_parts.append(string)\n\n        def _remove_unused_ops(tokens):\n            # Remove operators that we don't use and join them with the surrounding strings\n            # for example: 'mp4' '-' 'baseline' '-' '16x9' is converted to 'mp4-baseline-16x9'\n            ALLOWED_OPS = ('/', '+', ',', '(', ')')\n            last_string, last_start, last_end, last_line = None, None, None, None\n            for type, string, start, end, line in tokens:\n                if type == tokenize.OP and string == '[':\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                    # everything inside brackets will be handled by _parse_filter\n                    for type, string, start, end, line in tokens:\n                        yield type, string, start, end, line\n                        if type == tokenize.OP and string == ']':\n                            break\n                elif type == tokenize.OP and string in ALLOWED_OPS:\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                elif type in [tokenize.NAME, tokenize.NUMBER, tokenize.OP]:\n                    if not last_string:\n                        last_string = string\n                        last_start = start\n                        last_end = end\n                    else:\n                        last_string += string\n            if last_string:\n                yield tokenize.NAME, last_string, last_start, last_end, last_line\n\n        def _parse_format_selection(tokens, inside_merge=False, inside_choice=False, inside_group=False):\n            selectors = []\n            current_selector = None\n            for type, string, start, _, _ in tokens:\n                # ENCODING is only defined in python 3.x\n                if type == getattr(tokenize, 'ENCODING', None):\n                    continue\n                elif type in [tokenize.NAME, tokenize.NUMBER]:\n                    current_selector = FormatSelector(SINGLE, string, [])\n                elif type == tokenize.OP:\n                    if string == ')':\n                        if not inside_group:\n                            # ')' will be handled by the parentheses group\n                            tokens.restore_last_token()\n                        break\n                    elif inside_merge and string in ['/', ',']:\n                        tokens.restore_last_token()\n                        break\n                    elif inside_choice and string == ',':\n                        tokens.restore_last_token()\n                        break\n                    elif string == ',':\n                        if not current_selector:\n                            raise syntax_error('\",\" must follow a format selector', start)\n                        selectors.append(current_selector)\n                        current_selector = None\n                    elif string == '/':\n                        if not current_selector:\n                            raise syntax_error('\"/\" must follow a format selector', start)\n                        first_choice = current_selector\n                        second_choice = _parse_format_selection(tokens, inside_choice=True)\n                        current_selector = FormatSelector(PICKFIRST, (first_choice, second_choice), [])\n                    elif string == '[':\n                        if not current_selector:\n                            current_selector = FormatSelector(SINGLE, 'best', [])\n                        format_filter = _parse_filter(tokens)\n                        current_selector.filters.append(format_filter)\n                    elif string == '(':\n                        if current_selector:\n                            raise syntax_error('Unexpected \"(\"', start)\n                        group = _parse_format_selection(tokens, inside_group=True)\n                        current_selector = FormatSelector(GROUP, group, [])\n                    elif string == '+':\n                        video_selector = current_selector\n                        audio_selector = _parse_format_selection(tokens, inside_merge=True)\n                        if not video_selector or not audio_selector:\n                            raise syntax_error('\"+\" must be between two format selectors', start)\n                        current_selector = FormatSelector(MERGE, (video_selector, audio_selector), [])\n                    else:\n                        raise syntax_error('Operator not recognized: \"{0}\"'.format(string), start)\n                elif type == tokenize.ENDMARKER:\n                    break\n            if current_selector:\n                selectors.append(current_selector)\n            return selectors\n\n        def _build_selector_function(selector):\n            if isinstance(selector, list):\n                fs = [_build_selector_function(s) for s in selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        for format in f(formats):\n                            yield format\n                return selector_function\n            elif selector.type == GROUP:\n                selector_function = _build_selector_function(selector.selector)\n            elif selector.type == PICKFIRST:\n                fs = [_build_selector_function(s) for s in selector.selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        picked_formats = list(f(formats))\n                        if picked_formats:\n                            return picked_formats\n                    return []\n            elif selector.type == SINGLE:\n                format_spec = selector.selector\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    if not formats:\n                        return\n                    if format_spec == 'all':\n                        for f in formats:\n                            yield f\n                    elif format_spec in ['best', 'worst', None]:\n                        format_idx = 0 if format_spec == 'worst' else -1\n                        audiovideo_formats = [\n                            f for f in formats\n                            if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n                        if audiovideo_formats:\n                            yield audiovideo_formats[format_idx]\n                        # for audio only (soundcloud) or video only (imgur) urls, select the best/worst audio format\n                        elif (all(f.get('acodec') != 'none' for f in formats) or\n                              all(f.get('vcodec') != 'none' for f in formats)):\n                            yield formats[format_idx]\n                    elif format_spec == 'bestaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[-1]\n                    elif format_spec == 'worstaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[0]\n                    elif format_spec == 'bestvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[-1]\n                    elif format_spec == 'worstvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[0]\n                    else:\n                        extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n                        if format_spec in extensions:\n                            filter_f = lambda f: f['ext'] == format_spec\n                        else:\n                            filter_f = lambda f: f['format_id'] == format_spec\n                        matches = list(filter(filter_f, formats))\n                        if matches:\n                            yield matches[-1]\n            elif selector.type == MERGE:\n                def _merge(formats_info):\n                    format_1, format_2 = [f['format_id'] for f in formats_info]\n                    # The first format must contain the video and the\n                    # second the audio\n                    if formats_info[0].get('vcodec') == 'none':\n                        self.report_error('The first format must '\n                                          'contain the video, try using '\n                                          '\"-f %s+%s\"' % (format_2, format_1))\n                        return\n                    # Formats must be opposite (video+audio)\n                    if formats_info[0].get('acodec') == 'none' and formats_info[1].get('acodec') == 'none':\n                        self.report_error(\n                            'Both formats %s and %s are video-only, you must specify \"-f video+audio\"'\n                            % (format_1, format_2))\n                        return\n                    output_ext = (\n                        formats_info[0]['ext']\n                        if self.params.get('merge_output_format') is None\n                        else self.params['merge_output_format'])\n                    return {\n                        'requested_formats': formats_info,\n                        'format': '%s+%s' % (formats_info[0].get('format'),\n                                             formats_info[1].get('format')),\n                        'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                formats_info[1].get('format_id')),\n                        'width': formats_info[0].get('width'),\n                        'height': formats_info[0].get('height'),\n                        'resolution': formats_info[0].get('resolution'),\n                        'fps': formats_info[0].get('fps'),\n                        'vcodec': formats_info[0].get('vcodec'),\n                        'vbr': formats_info[0].get('vbr'),\n                        'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                        'acodec': formats_info[1].get('acodec'),\n                        'abr': formats_info[1].get('abr'),\n                        'ext': output_ext,\n                    }\n                video_selector, audio_selector = map(_build_selector_function, selector.selector)\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    for pair in itertools.product(video_selector(formats), audio_selector(formats)):\n                        yield _merge(pair)\n\n            filters = [self._build_format_filter(f) for f in selector.filters]\n\n            def final_selector(formats):\n                for _filter in filters:\n                    formats = list(filter(_filter, formats))\n                return selector_function(formats)\n            return final_selector\n\n        stream = io.BytesIO(format_spec.encode('utf-8'))\n        try:\n            tokens = list(_remove_unused_ops(compat_tokenize_tokenize(stream.readline)))\n        except tokenize.TokenError:\n            raise syntax_error('Missing closing/opening brackets or parenthesis', (0, len(format_spec)))\n\n        class TokenIterator(object):\n            def __init__(self, tokens):\n                self.tokens = tokens\n                self.counter = 0\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                if self.counter >= len(self.tokens):\n                    raise StopIteration()\n                value = self.tokens[self.counter]\n                self.counter += 1\n                return value\n\n            next = __next__\n\n            def restore_last_token(self):\n                self.counter -= 1\n\n        parsed_selector = _parse_format_selection(iter(TokenIterator(tokens)))\n        return _build_selector_function(parsed_selector)\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = sanitized_Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if t.get('width') and t.get('height'):\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around out-of-range timestamp values (e.g. negative ones on Windows,\n            # see http://bugs.python.org/issue1646728)\n            try:\n                upload_date = datetime.datetime.utcfromtimestamp(info_dict['timestamp'])\n                info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n            except (ValueError, OverflowError, OSError):\n                pass\n\n        # Auto generate title fields corresponding to the *_number fields when missing\n        # in order to always have clean titles. This is very common for TV series.\n        for field in ('chapter', 'season', 'episode'):\n            if info_dict.get('%s_number' % field) is not None and not info_dict.get(field):\n                info_dict[field] = '%s %d' % (field.capitalize(), info_dict['%s_number' % field])\n\n        subtitles = info_dict.get('subtitles')\n        if subtitles:\n            for _, subtitle in subtitles.items():\n                for subtitle_format in subtitle:\n                    if 'ext' not in subtitle_format:\n                        subtitle_format['ext'] = determine_ext(subtitle_format['url']).lower()\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], subtitles, 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], subtitles,\n            info_dict.get('automatic_captions'))\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        formats_dict = {}\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            format_id = format['format_id']\n            if format_id not in formats_dict:\n                formats_dict[format_id] = []\n            formats_dict[format_id].append(format)\n\n        # Make sure all formats have unique format_id\n        for format_id, ambiguous_formats in formats_dict.items():\n            if len(ambiguous_formats) > 1:\n                for i, format in enumerate(ambiguous_formats):\n                    format['format_id'] = '%s-%d' % (format_id, i)\n\n        for i, format in enumerate(formats):\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Automatically determine protocol if missing (useful for format\n            # selection purposes)\n            if 'protocol' not in format:\n                format['protocol'] = determine_protocol(format)\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # which can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted'] and\n                    not info_dict.get('is_live')):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        format_selector = self.build_format_selector(req_format)\n        formats_to_download = list(format_selector(formats))\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + error_to_compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, error_to_compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged.')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning(\n                            'Requested formats are incompatible for merge and will be merged into mkv.')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(\n                    url, force_generic_extractor=self.params.get('force_generic_extractor', False))\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            files_to_delete = []\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('language'):\n            if res:\n                res += ' '\n            res += '[%s]' % fdict['language']\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        if isinstance(req, compat_basestring):\n            req = sanitized_Request(req)\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = YoutubeDLCookieProcessor(self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        data_handler = compat_urllib_request_DataHandler()\n\n        # When passing our own FileHandler instance, build_opener won't add the\n        # default FileHandler and allows us to disable the file protocol, which\n        # can be used for malicious purposes (see\n        # https://github.com/rg3/youtube-dl/issues/8227)\n        file_handler = compat_urllib_request.FileHandler()\n\n        def file_open(*args, **kwargs):\n            raise compat_urllib_error.URLError('file:// scheme is explicitly disabled in youtube-dl for security reasons')\n        file_handler.file_open = file_open\n\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh, data_handler, file_handler)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(encodeFilename(thumb_filename), 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], error_to_compat_str(err)))\n",
      "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport tokenize\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_tokenize_tokenize,\n    compat_urllib_error,\n    compat_urllib_request,\n    compat_urllib_request_DataHandler,\n)\nfrom .utils import (\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    determine_protocol,\n    DownloadError,\n    encode_compat_str,\n    encodeFilename,\n    error_to_compat_str,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    sanitized_Request,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLCookieProcessor,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for accessing a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    force_generic_extractor: Force downloader to use the generic extractor\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatically generated subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args, hls_use_mpegts.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    postprocessor_args: A list of additional command-line arguments for the\n                        postprocessor.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {\n            # Default parameters\n            'nocheckcertificate': False,\n        }\n        self.params.update(params)\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += encode_compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return sanitize_path(filename)\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True, force_generic_extractor=False):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if not ie_key and force_generic_extractor:\n            ie_key = 'Generic'\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as e:  # An error we somewhat expected\n                self.report_error(compat_str(e), e.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(error_to_compat_str(e), tb=encode_compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url', 'ie_key'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [\n                        ie_entries[i - 1] for i in playlistitems\n                        if -n_all_entries <= i - 1 < n_all_entries]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _build_format_filter(self, filter_spec):\n        \" Returns a function to filter the formats according to the filter_spec \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            $\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(filter_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), filter_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n                '^=': lambda attr, value: attr.startswith(value),\n                '$=': lambda attr, value: attr.endswith(value),\n                '*=': lambda attr, value: value in attr,\n            }\n            str_operator_rex = re.compile(r'''(?x)\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9._-]+)\n                \\s*$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(filter_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid filter specification %r' % filter_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        return _filter\n\n    def build_format_selector(self, format_spec):\n        def syntax_error(note, start):\n            message = (\n                'Invalid format specification: '\n                '{0}\\n\\t{1}\\n\\t{2}^'.format(note, format_spec, ' ' * start[1]))\n            return SyntaxError(message)\n\n        PICKFIRST = 'PICKFIRST'\n        MERGE = 'MERGE'\n        SINGLE = 'SINGLE'\n        GROUP = 'GROUP'\n        FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])\n\n        def _parse_filter(tokens):\n            filter_parts = []\n            for type, string, start, _, _ in tokens:\n                if type == tokenize.OP and string == ']':\n                    return ''.join(filter_parts)\n                else:\n                    filter_parts.append(string)\n\n        def _remove_unused_ops(tokens):\n            # Remove operators that we don't use and join them with the surrounding strings\n            # for example: 'mp4' '-' 'baseline' '-' '16x9' is converted to 'mp4-baseline-16x9'\n            ALLOWED_OPS = ('/', '+', ',', '(', ')')\n            last_string, last_start, last_end, last_line = None, None, None, None\n            for type, string, start, end, line in tokens:\n                if type == tokenize.OP and string == '[':\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                    # everything inside brackets will be handled by _parse_filter\n                    for type, string, start, end, line in tokens:\n                        yield type, string, start, end, line\n                        if type == tokenize.OP and string == ']':\n                            break\n                elif type == tokenize.OP and string in ALLOWED_OPS:\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                elif type in [tokenize.NAME, tokenize.NUMBER, tokenize.OP]:\n                    if not last_string:\n                        last_string = string\n                        last_start = start\n                        last_end = end\n                    else:\n                        last_string += string\n            if last_string:\n                yield tokenize.NAME, last_string, last_start, last_end, last_line\n\n        def _parse_format_selection(tokens, inside_merge=False, inside_choice=False, inside_group=False):\n            selectors = []\n            current_selector = None\n            for type, string, start, _, _ in tokens:\n                # ENCODING is only defined in python 3.x\n                if type == getattr(tokenize, 'ENCODING', None):\n                    continue\n                elif type in [tokenize.NAME, tokenize.NUMBER]:\n                    current_selector = FormatSelector(SINGLE, string, [])\n                elif type == tokenize.OP:\n                    if string == ')':\n                        if not inside_group:\n                            # ')' will be handled by the parentheses group\n                            tokens.restore_last_token()\n                        break\n                    elif inside_merge and string in ['/', ',']:\n                        tokens.restore_last_token()\n                        break\n                    elif inside_choice and string == ',':\n                        tokens.restore_last_token()\n                        break\n                    elif string == ',':\n                        if not current_selector:\n                            raise syntax_error('\",\" must follow a format selector', start)\n                        selectors.append(current_selector)\n                        current_selector = None\n                    elif string == '/':\n                        if not current_selector:\n                            raise syntax_error('\"/\" must follow a format selector', start)\n                        first_choice = current_selector\n                        second_choice = _parse_format_selection(tokens, inside_choice=True)\n                        current_selector = FormatSelector(PICKFIRST, (first_choice, second_choice), [])\n                    elif string == '[':\n                        if not current_selector:\n                            current_selector = FormatSelector(SINGLE, 'best', [])\n                        format_filter = _parse_filter(tokens)\n                        current_selector.filters.append(format_filter)\n                    elif string == '(':\n                        if current_selector:\n                            raise syntax_error('Unexpected \"(\"', start)\n                        group = _parse_format_selection(tokens, inside_group=True)\n                        current_selector = FormatSelector(GROUP, group, [])\n                    elif string == '+':\n                        video_selector = current_selector\n                        audio_selector = _parse_format_selection(tokens, inside_merge=True)\n                        if not video_selector or not audio_selector:\n                            raise syntax_error('\"+\" must be between two format selectors', start)\n                        current_selector = FormatSelector(MERGE, (video_selector, audio_selector), [])\n                    else:\n                        raise syntax_error('Operator not recognized: \"{0}\"'.format(string), start)\n                elif type == tokenize.ENDMARKER:\n                    break\n            if current_selector:\n                selectors.append(current_selector)\n            return selectors\n\n        def _build_selector_function(selector):\n            if isinstance(selector, list):\n                fs = [_build_selector_function(s) for s in selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        for format in f(formats):\n                            yield format\n                return selector_function\n            elif selector.type == GROUP:\n                selector_function = _build_selector_function(selector.selector)\n            elif selector.type == PICKFIRST:\n                fs = [_build_selector_function(s) for s in selector.selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        picked_formats = list(f(formats))\n                        if picked_formats:\n                            return picked_formats\n                    return []\n            elif selector.type == SINGLE:\n                format_spec = selector.selector\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    if not formats:\n                        return\n                    if format_spec == 'all':\n                        for f in formats:\n                            yield f\n                    elif format_spec in ['best', 'worst', None]:\n                        format_idx = 0 if format_spec == 'worst' else -1\n                        audiovideo_formats = [\n                            f for f in formats\n                            if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n                        if audiovideo_formats:\n                            yield audiovideo_formats[format_idx]\n                        # for audio only (soundcloud) or video only (imgur) urls, select the best/worst audio format\n                        elif (all(f.get('acodec') != 'none' for f in formats) or\n                              all(f.get('vcodec') != 'none' for f in formats)):\n                            yield formats[format_idx]\n                    elif format_spec == 'bestaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[-1]\n                    elif format_spec == 'worstaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[0]\n                    elif format_spec == 'bestvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[-1]\n                    elif format_spec == 'worstvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[0]\n                    else:\n                        extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n                        if format_spec in extensions:\n                            filter_f = lambda f: f['ext'] == format_spec\n                        else:\n                            filter_f = lambda f: f['format_id'] == format_spec\n                        matches = list(filter(filter_f, formats))\n                        if matches:\n                            yield matches[-1]\n            elif selector.type == MERGE:\n                def _merge(formats_info):\n                    format_1, format_2 = [f['format_id'] for f in formats_info]\n                    # The first format must contain the video and the\n                    # second the audio\n                    if formats_info[0].get('vcodec') == 'none':\n                        self.report_error('The first format must '\n                                          'contain the video, try using '\n                                          '\"-f %s+%s\"' % (format_2, format_1))\n                        return\n                    # Formats must be opposite (video+audio)\n                    if formats_info[0].get('acodec') == 'none' and formats_info[1].get('acodec') == 'none':\n                        self.report_error(\n                            'Both formats %s and %s are video-only, you must specify \"-f video+audio\"'\n                            % (format_1, format_2))\n                        return\n                    output_ext = (\n                        formats_info[0]['ext']\n                        if self.params.get('merge_output_format') is None\n                        else self.params['merge_output_format'])\n                    return {\n                        'requested_formats': formats_info,\n                        'format': '%s+%s' % (formats_info[0].get('format'),\n                                             formats_info[1].get('format')),\n                        'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                formats_info[1].get('format_id')),\n                        'width': formats_info[0].get('width'),\n                        'height': formats_info[0].get('height'),\n                        'resolution': formats_info[0].get('resolution'),\n                        'fps': formats_info[0].get('fps'),\n                        'vcodec': formats_info[0].get('vcodec'),\n                        'vbr': formats_info[0].get('vbr'),\n                        'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                        'acodec': formats_info[1].get('acodec'),\n                        'abr': formats_info[1].get('abr'),\n                        'ext': output_ext,\n                    }\n                video_selector, audio_selector = map(_build_selector_function, selector.selector)\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    for pair in itertools.product(video_selector(formats), audio_selector(formats)):\n                        yield _merge(pair)\n\n            filters = [self._build_format_filter(f) for f in selector.filters]\n\n            def final_selector(formats):\n                for _filter in filters:\n                    formats = list(filter(_filter, formats))\n                return selector_function(formats)\n            return final_selector\n\n        stream = io.BytesIO(format_spec.encode('utf-8'))\n        try:\n            tokens = list(_remove_unused_ops(compat_tokenize_tokenize(stream.readline)))\n        except tokenize.TokenError:\n            raise syntax_error('Missing closing/opening brackets or parenthesis', (0, len(format_spec)))\n\n        class TokenIterator(object):\n            def __init__(self, tokens):\n                self.tokens = tokens\n                self.counter = 0\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                if self.counter >= len(self.tokens):\n                    raise StopIteration()\n                value = self.tokens[self.counter]\n                self.counter += 1\n                return value\n\n            next = __next__\n\n            def restore_last_token(self):\n                self.counter -= 1\n\n        parsed_selector = _parse_format_selection(iter(TokenIterator(tokens)))\n        return _build_selector_function(parsed_selector)\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = sanitized_Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if t.get('width') and t.get('height'):\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around out-of-range timestamp values (e.g. negative ones on Windows,\n            # see http://bugs.python.org/issue1646728)\n            try:\n                upload_date = datetime.datetime.utcfromtimestamp(info_dict['timestamp'])\n                info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n            except (ValueError, OverflowError, OSError):\n                pass\n\n        # Auto generate title fields corresponding to the *_number fields when missing\n        # in order to always have clean titles. This is very common for TV series.\n        for field in ('chapter', 'season', 'episode'):\n            if info_dict.get('%s_number' % field) is not None and not info_dict.get(field):\n                info_dict[field] = '%s %d' % (field.capitalize(), info_dict['%s_number' % field])\n\n        subtitles = info_dict.get('subtitles')\n        if subtitles:\n            for _, subtitle in subtitles.items():\n                for subtitle_format in subtitle:\n                    if 'ext' not in subtitle_format:\n                        subtitle_format['ext'] = determine_ext(subtitle_format['url']).lower()\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], subtitles, 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], subtitles,\n            info_dict.get('automatic_captions'))\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        formats_dict = {}\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            format_id = format['format_id']\n            if format_id not in formats_dict:\n                formats_dict[format_id] = []\n            formats_dict[format_id].append(format)\n\n        # Make sure all formats have unique format_id\n        for format_id, ambiguous_formats in formats_dict.items():\n            if len(ambiguous_formats) > 1:\n                for i, format in enumerate(ambiguous_formats):\n                    format['format_id'] = '%s-%d' % (format_id, i)\n\n        for i, format in enumerate(formats):\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Automatically determine protocol if missing (useful for format\n            # selection purposes)\n            if 'protocol' not in format:\n                format['protocol'] = determine_protocol(format)\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # which can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted'] and\n                    not info_dict.get('is_live')):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        format_selector = self.build_format_selector(req_format)\n        formats_to_download = list(format_selector(formats))\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + error_to_compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, error_to_compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged.')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning(\n                            'Requested formats are incompatible for merge and will be merged into mkv.')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(\n                    url, force_generic_extractor=self.params.get('force_generic_extractor', False))\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            files_to_delete = []\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('language'):\n            if res:\n                res += ' '\n            res += '[%s]' % fdict['language']\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        if isinstance(req, compat_basestring):\n            req = sanitized_Request(req)\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = YoutubeDLCookieProcessor(self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        data_handler = compat_urllib_request_DataHandler()\n\n        # When passing our own FileHandler instance, build_opener won't add the\n        # default FileHandler and allows us to disable the file protocol, which\n        # can be used for malicious purposes (see\n        # https://github.com/rg3/youtube-dl/issues/8227)\n        file_handler = compat_urllib_request.FileHandler()\n\n        def file_open(*args, **kwargs):\n            raise compat_urllib_error.URLError('file:// scheme is explicitly disabled in youtube-dl for security reasons')\n        file_handler.file_open = file_open\n\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh, data_handler, file_handler)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(encodeFilename(thumb_filename), 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], error_to_compat_str(err)))\n",
      "file_patch": "@@ -707,7 +707,6 @@ class YoutubeDL(object):\n         It will also download the videos if 'download'.\n         Returns the resolved ie_result.\n         \"\"\"\n-\n         result_type = ie_result.get('_type', 'video')\n \n         if result_type in ('url', 'url_transparent'):\n@@ -736,7 +735,7 @@ class YoutubeDL(object):\n \n             force_properties = dict(\n                 (k, v) for k, v in ie_result.items() if v is not None)\n-            for f in ('_type', 'url'):\n+            for f in ('_type', 'url', 'ie_key'):\n                 if f in force_properties:\n                     del force_properties[f]\n             new_result = info.copy()\n",
      "files_name_in_blame_commit": [
        "test_YoutubeDL.py",
        "YoutubeDL.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 581
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "702": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "    def process_ie_result(self, ie_result, download=True, extra_info={}):",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "703": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        \"\"\"",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "704": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        Take the result of the ie(may be modified) and resolve all unresolved",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "705": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        references (URLs, playlist items).",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "706": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "707": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        It will also download the videos if 'download'.",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "708": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        Returns the resolved ie_result.",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "709": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        \"\"\"",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "710": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "711": {
        "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
        "line_code": "        result_type = ie_result.get('_type', 'video')",
        "commit_date": "2014-08-21 11:52:07",
        "valid": 1
      },
      "712": {
        "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
        "line_code": "",
        "commit_date": "2014-08-21 11:52:07",
        "valid": 0
      },
      "713": {
        "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
        "line_code": "        if result_type in ('url', 'url_transparent'):",
        "commit_date": "2014-08-21 11:52:07",
        "valid": 1
      },
      "714": {
        "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
        "line_code": "            extract_flat = self.params.get('extract_flat', False)",
        "commit_date": "2014-10-24 14:48:12",
        "valid": 1
      },
      "715": {
        "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
        "line_code": "            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or",
        "commit_date": "2014-10-24 14:48:12",
        "valid": 1
      },
      "716": {
        "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
        "line_code": "                    extract_flat is True):",
        "commit_date": "2014-10-24 14:48:12",
        "valid": 1
      },
      "717": {
        "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
        "line_code": "                if self.params.get('forcejson', False):",
        "commit_date": "2014-10-24 14:48:12",
        "valid": 1
      },
      "718": {
        "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
        "line_code": "                    self.to_stdout(json.dumps(ie_result))",
        "commit_date": "2014-10-24 14:48:12",
        "valid": 1
      },
      "719": {
        "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
        "line_code": "                return ie_result",
        "commit_date": "2014-08-21 11:52:07",
        "valid": 1
      },
      "720": {
        "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
        "line_code": "",
        "commit_date": "2014-08-21 11:52:07",
        "valid": 0
      },
      "721": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        if result_type == 'video':",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "722": {
        "commit_id": "b6c45014aed4b3176be1142958be98d7cb9dbaff",
        "line_code": "            self.add_extra_info(ie_result, extra_info)",
        "commit_date": "2013-11-03 11:57:04",
        "valid": 1
      },
      "723": {
        "commit_id": "feee2ecfa9fbc6fd34246c7e167ac9542ae7def2",
        "line_code": "            return self.process_video_result(ie_result, download=download)",
        "commit_date": "2013-11-15 11:04:26",
        "valid": 1
      },
      "724": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        elif result_type == 'url':",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "725": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            # We have to add extra_info to the results because it may be",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "726": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            # contained in a playlist",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "727": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            return self.extract_info(ie_result['url'],",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "728": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                                     download,",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "729": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                                     ie_key=ie_result.get('ie_key'),",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "730": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                                     extra_info=extra_info)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "731": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "        elif result_type == 'url_transparent':",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "732": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "            # Use the information from the embedding page",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "733": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "            info = self.extract_info(",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "734": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "                ie_result['url'], ie_key=ie_result.get('ie_key'),",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "735": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "                extra_info=extra_info, download=False, process=False)",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "736": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 0
      },
      "737": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "            force_properties = dict(",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "738": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "                (k, v) for k, v in ie_result.items() if v is not None)",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "739": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "            for f in ('_type', 'url'):",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "740": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "                if f in force_properties:",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "741": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "                    del force_properties[f]",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "742": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "            new_result = info.copy()",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "743": {
        "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
        "line_code": "            new_result.update(force_properties)",
        "commit_date": "2014-12-12 15:55:55",
        "valid": 1
      },
      "744": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 0
      },
      "745": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "            assert new_result.get('_type') != 'url_transparent'",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "746": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 0
      },
      "747": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "            return self.process_ie_result(",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "748": {
        "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
        "line_code": "                new_result, download=download, extra_info=extra_info)",
        "commit_date": "2013-12-05 14:29:08",
        "valid": 1
      },
      "749": {
        "commit_id": "42e12102a979a03f156e71fc86006f61c905f7dd",
        "line_code": "        elif result_type == 'playlist' or result_type == 'multi_video':",
        "commit_date": "2014-11-21 22:39:57",
        "valid": 1
      },
      "750": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            # We process each entry in the playlist",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "751": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            playlist = ie_result.get('title', None) or ie_result.get('id', None)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "752": {
        "commit_id": "6febd1c1df02870bf8b529ca758d7155cf65ab35",
        "line_code": "            self.to_screen('[download] Downloading playlist: %s' % playlist)",
        "commit_date": "2014-01-05 01:52:03",
        "valid": 1
      },
      "753": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "754": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            playlist_results = []",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "755": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "756": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            playliststart = self.params.get('playliststart', 1) - 1",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "757": {
        "commit_id": "a19fd00cc4f799215a942c92fd5c722b3ea499cd",
        "line_code": "            playlistend = self.params.get('playlistend', None)",
        "commit_date": "2013-12-16 13:16:20",
        "valid": 1
      },
      "758": {
        "commit_id": "a19fd00cc4f799215a942c92fd5c722b3ea499cd",
        "line_code": "            # For backwards compatibility, interpret -1 as whole list",
        "commit_date": "2013-12-16 13:16:20",
        "valid": 1
      },
      "759": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            if playlistend == -1:",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "760": {
        "commit_id": "a19fd00cc4f799215a942c92fd5c722b3ea499cd",
        "line_code": "                playlistend = None",
        "commit_date": "2013-12-16 13:16:20",
        "valid": 1
      },
      "761": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "762": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "            playlistitems_str = self.params.get('playlist_items', None)",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "763": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "            playlistitems = None",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "764": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "            if playlistitems_str is not None:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "765": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                def iter_playlistitems(format):",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "766": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                    for string_segment in format.split(','):",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "767": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                        if '-' in string_segment:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "768": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                            start, end = string_segment.split('-')",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "769": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                            for item in range(int(start), int(end) + 1):",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "770": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                                yield int(item)",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "771": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                        else:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "772": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                            yield int(string_segment)",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "773": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                playlistitems = iter_playlistitems(playlistitems_str)",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "774": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 0
      },
      "775": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "            ie_entries = ie_result['entries']",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "776": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "            if isinstance(ie_entries, list):",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "777": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                n_all_entries = len(ie_entries)",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "778": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                if playlistitems:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "779": {
        "commit_id": "3884dcf313223040049e4153e0c398fbc36b5117",
        "line_code": "                    entries = [",
        "commit_date": "2015-05-15 14:08:26",
        "valid": 1
      },
      "780": {
        "commit_id": "3884dcf313223040049e4153e0c398fbc36b5117",
        "line_code": "                        ie_entries[i - 1] for i in playlistitems",
        "commit_date": "2015-05-15 14:08:26",
        "valid": 1
      },
      "781": {
        "commit_id": "3884dcf313223040049e4153e0c398fbc36b5117",
        "line_code": "                        if -n_all_entries <= i - 1 < n_all_entries]",
        "commit_date": "2015-05-15 14:08:26",
        "valid": 1
      },
      "782": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                else:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "783": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                    entries = ie_entries[playliststart:playlistend]",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "784": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                n_entries = len(entries)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "785": {
        "commit_id": "a19fd00cc4f799215a942c92fd5c722b3ea499cd",
        "line_code": "                self.to_screen(",
        "commit_date": "2013-12-16 13:16:20",
        "valid": 1
      },
      "786": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "787": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                    (ie_result['extractor'], playlist, n_all_entries, n_entries))",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "788": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "            elif isinstance(ie_entries, PagedList):",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "789": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                if playlistitems:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "790": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                    entries = []",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "791": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                    for item in playlistitems:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "792": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                        entries.extend(ie_entries.getslice(",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "793": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                            item - 1, item",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "794": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                        ))",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "795": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                else:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "796": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                    entries = ie_entries.getslice(",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "797": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                        playliststart, playlistend)",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "798": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                n_entries = len(entries)",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "799": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                self.to_screen(",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "800": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                    \"[%s] playlist %s: Downloading %d videos\" %",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "801": {
        "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
        "line_code": "                    (ie_result['extractor'], playlist, n_entries))",
        "commit_date": "2014-01-20 11:36:47",
        "valid": 1
      },
      "802": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "            else:  # iterable",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "803": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                if playlistitems:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "804": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                    entry_list = list(ie_entries)",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "805": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                    entries = [entry_list[i - 1] for i in playlistitems]",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "806": {
        "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
        "line_code": "                else:",
        "commit_date": "2015-01-25 04:24:55",
        "valid": 1
      },
      "807": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                    entries = list(itertools.islice(",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "808": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                        ie_entries, playliststart, playlistend))",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "809": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                n_entries = len(entries)",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "810": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                self.to_screen(",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "811": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                    \"[%s] playlist %s: Downloading %d videos\" %",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "812": {
        "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
        "line_code": "                    (ie_result['extractor'], playlist, n_entries))",
        "commit_date": "2014-12-06 14:02:19",
        "valid": 1
      },
      "813": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 0
      },
      "814": {
        "commit_id": "ff815fe65aab83db7e11251db5eafc76504adf05",
        "line_code": "            if self.params.get('playlistreverse', False):",
        "commit_date": "2014-12-12 16:56:29",
        "valid": 1
      },
      "815": {
        "commit_id": "ff815fe65aab83db7e11251db5eafc76504adf05",
        "line_code": "                entries = entries[::-1]",
        "commit_date": "2014-12-12 16:56:29",
        "valid": 1
      },
      "816": {
        "commit_id": "ff815fe65aab83db7e11251db5eafc76504adf05",
        "line_code": "",
        "commit_date": "2014-12-12 16:56:29",
        "valid": 0
      },
      "817": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            for i, entry in enumerate(entries, 1):",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "818": {
        "commit_id": "734ea11e3c57ca4df7d9cfc475b1b99b56c18034",
        "line_code": "                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))",
        "commit_date": "2014-12-16 00:37:42",
        "valid": 1
      },
      "819": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                extra = {",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "820": {
        "commit_id": "c6b4132a0ad568b8383dfb64689b7d45182f275a",
        "line_code": "                    'n_entries': n_entries,",
        "commit_date": "2014-08-24 18:49:04",
        "valid": 1
      },
      "821": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                    'playlist': playlist,",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "822": {
        "commit_id": "a1cf99d03a6a842aa4e53c211c9f38dd27db5971",
        "line_code": "                    'playlist_id': ie_result.get('id'),",
        "commit_date": "2014-11-09 22:32:35",
        "valid": 1
      },
      "823": {
        "commit_id": "a1cf99d03a6a842aa4e53c211c9f38dd27db5971",
        "line_code": "                    'playlist_title': ie_result.get('title'),",
        "commit_date": "2014-11-09 22:32:35",
        "valid": 1
      },
      "824": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                    'playlist_index': i + playliststart,",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "825": {
        "commit_id": "b6c45014aed4b3176be1142958be98d7cb9dbaff",
        "line_code": "                    'extractor': ie_result['extractor'],",
        "commit_date": "2013-11-03 11:57:04",
        "valid": 1
      },
      "826": {
        "commit_id": "9103bbc5cd11957de2e906e4401dcf4df9511d28",
        "line_code": "                    'webpage_url': ie_result['webpage_url'],",
        "commit_date": "2013-11-03 12:11:13",
        "valid": 1
      },
      "827": {
        "commit_id": "29eb5174031cfc0b5de556da3da7761ac377de4e",
        "line_code": "                    'webpage_url_basename': url_basename(ie_result['webpage_url']),",
        "commit_date": "2013-12-17 04:13:36",
        "valid": 1
      },
      "828": {
        "commit_id": "be97abc247d26bc36d1ef8cad5c17fc2a99d9101",
        "line_code": "                    'extractor_key': ie_result['extractor_key'],",
        "commit_date": "2013-11-03 12:14:44",
        "valid": 1
      },
      "829": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                }",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "830": {
        "commit_id": "7012b23c947fc1ed146e314a30d3c70a5fde70e7",
        "line_code": "",
        "commit_date": "2013-11-22 22:46:46",
        "valid": 0
      },
      "831": {
        "commit_id": "442c37b7a9a912cf3b0eb972335b7d24407f4537",
        "line_code": "                reason = self._match_entry(entry, incomplete=True)",
        "commit_date": "2015-02-10 11:28:28",
        "valid": 1
      },
      "832": {
        "commit_id": "7012b23c947fc1ed146e314a30d3c70a5fde70e7",
        "line_code": "                if reason is not None:",
        "commit_date": "2013-11-22 22:46:46",
        "valid": 1
      },
      "833": {
        "commit_id": "6febd1c1df02870bf8b529ca758d7155cf65ab35",
        "line_code": "                    self.to_screen('[download] ' + reason)",
        "commit_date": "2014-01-05 01:52:03",
        "valid": 1
      },
      "834": {
        "commit_id": "7012b23c947fc1ed146e314a30d3c70a5fde70e7",
        "line_code": "                    continue",
        "commit_date": "2013-11-22 22:46:46",
        "valid": 1
      },
      "835": {
        "commit_id": "7012b23c947fc1ed146e314a30d3c70a5fde70e7",
        "line_code": "",
        "commit_date": "2013-11-22 22:46:46",
        "valid": 0
      },
      "836": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                entry_result = self.process_ie_result(entry,",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "837": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                                                      download=download,",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "838": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                                                      extra_info=extra)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "839": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                playlist_results.append(entry_result)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "840": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            ie_result['entries'] = playlist_results",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "841": {
        "commit_id": "371c3b796cb4168dbb2cb1ad48e3cf12745a8601",
        "line_code": "            self.to_screen('[download] Finished downloading playlist: %s' % playlist)",
        "commit_date": "2015-11-19 22:39:02",
        "valid": 1
      },
      "842": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            return ie_result",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "843": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        elif result_type == 'compat_list':",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "844": {
        "commit_id": "c9bf41145fc7c722eb9b5ae528642976177c1b14",
        "line_code": "            self.report_warning(",
        "commit_date": "2014-11-20 16:29:31",
        "valid": 1
      },
      "845": {
        "commit_id": "c9bf41145fc7c722eb9b5ae528642976177c1b14",
        "line_code": "                'Extractor %s returned a compat_list result. '",
        "commit_date": "2014-11-20 16:29:31",
        "valid": 1
      },
      "846": {
        "commit_id": "c9bf41145fc7c722eb9b5ae528642976177c1b14",
        "line_code": "                'It needs to be updated.' % ie_result.get('extractor'))",
        "commit_date": "2014-11-20 16:29:31",
        "valid": 1
      },
      "847": {
        "commit_id": "5f6a1245ffa9276c1af59b0835afeef67e2fb5b1",
        "line_code": "",
        "commit_date": "2014-11-23 20:41:03",
        "valid": 0
      },
      "848": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            def _fixup(r):",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "849": {
        "commit_id": "9e1a5b845586a0a5431fb72467142046d8571e6f",
        "line_code": "                self.add_extra_info(",
        "commit_date": "2014-11-23 21:39:15",
        "valid": 1
      },
      "850": {
        "commit_id": "9e1a5b845586a0a5431fb72467142046d8571e6f",
        "line_code": "                    r,",
        "commit_date": "2014-11-23 21:39:15",
        "valid": 1
      },
      "851": {
        "commit_id": "9103bbc5cd11957de2e906e4401dcf4df9511d28",
        "line_code": "                    {",
        "commit_date": "2013-11-03 12:11:13",
        "valid": 1
      },
      "852": {
        "commit_id": "9103bbc5cd11957de2e906e4401dcf4df9511d28",
        "line_code": "                        'extractor': ie_result['extractor'],",
        "commit_date": "2013-11-03 12:11:13",
        "valid": 1
      },
      "853": {
        "commit_id": "9103bbc5cd11957de2e906e4401dcf4df9511d28",
        "line_code": "                        'webpage_url': ie_result['webpage_url'],",
        "commit_date": "2013-11-03 12:11:13",
        "valid": 1
      },
      "854": {
        "commit_id": "29eb5174031cfc0b5de556da3da7761ac377de4e",
        "line_code": "                        'webpage_url_basename': url_basename(ie_result['webpage_url']),",
        "commit_date": "2013-12-17 04:13:36",
        "valid": 1
      },
      "855": {
        "commit_id": "be97abc247d26bc36d1ef8cad5c17fc2a99d9101",
        "line_code": "                        'extractor_key': ie_result['extractor_key'],",
        "commit_date": "2013-11-03 12:14:44",
        "valid": 1
      },
      "856": {
        "commit_id": "9e1a5b845586a0a5431fb72467142046d8571e6f",
        "line_code": "                    }",
        "commit_date": "2014-11-23 21:39:15",
        "valid": 1
      },
      "857": {
        "commit_id": "9e1a5b845586a0a5431fb72467142046d8571e6f",
        "line_code": "                )",
        "commit_date": "2014-11-23 21:39:15",
        "valid": 1
      },
      "858": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                return r",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "859": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            ie_result['entries'] = [",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "860": {
        "commit_id": "b6c45014aed4b3176be1142958be98d7cb9dbaff",
        "line_code": "                self.process_ie_result(_fixup(r), download, extra_info)",
        "commit_date": "2013-11-03 11:57:04",
        "valid": 1
      },
      "861": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "                for r in ie_result['entries']",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "862": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            ]",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "863": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            return ie_result",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "864": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "        else:",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      },
      "865": {
        "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
        "line_code": "            raise Exception('Invalid result type: %s' % result_type)",
        "commit_date": "2013-06-24 10:21:43",
        "valid": 1
      }
    },
    "commits": {
      "371c3b796cb4168dbb2cb1ad48e3cf12745a8601": {
        "commit": {
          "commit_id": "371c3b796cb4168dbb2cb1ad48e3cf12745a8601",
          "commit_message": "[YoutubeDL] Add playlist finished downloading message (Closes #7517)\n\nConflicts:\n\tyoutube_dl/YoutubeDL.py",
          "commit_author": "hedii",
          "commit_date": "2015-11-19 22:39:02",
          "commit_parent": "6b7ceee1b9124521d2f583fb0d0717999747fdcf"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 697,
          "function_before_end_line": 859,
          "function_after_start_line": 697,
          "function_after_end_line": 860,
          "function_before_token_count": 809,
          "function_after_token_count": 817,
          "functions_name_modified_file": [
            "list_formats",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "list_subtitles",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "filter_requested_info",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_build_format_filter",
            "get_info_extractor",
            "_calc_headers",
            "add_info_extractor",
            "process_subtitles",
            "print_debug_header",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "build_format_selector",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "list_subtitles",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "filter_requested_info",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_build_format_filter",
            "get_info_extractor",
            "_calc_headers",
            "add_info_extractor",
            "process_subtitles",
            "print_debug_header",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "build_format_selector",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1729,
          "file_complexity": 551,
          "file_token_count": 11195,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport tokenize\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_tokenize_tokenize,\n    compat_urllib_error,\n    compat_urllib_request,\n    compat_urllib_request_DataHandler,\n)\nfrom .utils import (\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLCookieProcessor,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for accessing a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    force_generic_extractor: Force downloader to use the generic extractor\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    postprocessor_args: A list of additional command-line arguments for the\n                        postprocessor.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {\n            # Default parameters\n            'nocheckcertificate': False,\n        }\n        self.params.update(params)\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return sanitize_path(filename)\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True, force_generic_extractor=False):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if not ie_key and force_generic_extractor:\n            ie_key = 'Generic'\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [\n                        ie_entries[i - 1] for i in playlistitems\n                        if -n_all_entries <= i - 1 < n_all_entries]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _build_format_filter(self, filter_spec):\n        \" Returns a function to filter the formats according to the filter_spec \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            $\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(filter_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), filter_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(filter_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid filter specification %r' % filter_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        return _filter\n\n    def build_format_selector(self, format_spec):\n        def syntax_error(note, start):\n            message = (\n                'Invalid format specification: '\n                '{0}\\n\\t{1}\\n\\t{2}^'.format(note, format_spec, ' ' * start[1]))\n            return SyntaxError(message)\n\n        PICKFIRST = 'PICKFIRST'\n        MERGE = 'MERGE'\n        SINGLE = 'SINGLE'\n        GROUP = 'GROUP'\n        FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])\n\n        def _parse_filter(tokens):\n            filter_parts = []\n            for type, string, start, _, _ in tokens:\n                if type == tokenize.OP and string == ']':\n                    return ''.join(filter_parts)\n                else:\n                    filter_parts.append(string)\n\n        def _remove_unused_ops(tokens):\n            # Remove operators that we don't use and join them with the sourrounding strings\n            # for example: 'mp4' '-' 'baseline' '-' '16x9' is converted to 'mp4-baseline-16x9'\n            ALLOWED_OPS = ('/', '+', ',', '(', ')')\n            last_string, last_start, last_end, last_line = None, None, None, None\n            for type, string, start, end, line in tokens:\n                if type == tokenize.OP and string == '[':\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                    # everything inside brackets will be handled by _parse_filter\n                    for type, string, start, end, line in tokens:\n                        yield type, string, start, end, line\n                        if type == tokenize.OP and string == ']':\n                            break\n                elif type == tokenize.OP and string in ALLOWED_OPS:\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                elif type in [tokenize.NAME, tokenize.NUMBER, tokenize.OP]:\n                    if not last_string:\n                        last_string = string\n                        last_start = start\n                        last_end = end\n                    else:\n                        last_string += string\n            if last_string:\n                yield tokenize.NAME, last_string, last_start, last_end, last_line\n\n        def _parse_format_selection(tokens, inside_merge=False, inside_choice=False, inside_group=False):\n            selectors = []\n            current_selector = None\n            for type, string, start, _, _ in tokens:\n                # ENCODING is only defined in python 3.x\n                if type == getattr(tokenize, 'ENCODING', None):\n                    continue\n                elif type in [tokenize.NAME, tokenize.NUMBER]:\n                    current_selector = FormatSelector(SINGLE, string, [])\n                elif type == tokenize.OP:\n                    if string == ')':\n                        if not inside_group:\n                            # ')' will be handled by the parentheses group\n                            tokens.restore_last_token()\n                        break\n                    elif inside_merge and string in ['/', ',']:\n                        tokens.restore_last_token()\n                        break\n                    elif inside_choice and string == ',':\n                        tokens.restore_last_token()\n                        break\n                    elif string == ',':\n                        if not current_selector:\n                            raise syntax_error('\",\" must follow a format selector', start)\n                        selectors.append(current_selector)\n                        current_selector = None\n                    elif string == '/':\n                        if not current_selector:\n                            raise syntax_error('\"/\" must follow a format selector', start)\n                        first_choice = current_selector\n                        second_choice = _parse_format_selection(tokens, inside_choice=True)\n                        current_selector = FormatSelector(PICKFIRST, (first_choice, second_choice), [])\n                    elif string == '[':\n                        if not current_selector:\n                            current_selector = FormatSelector(SINGLE, 'best', [])\n                        format_filter = _parse_filter(tokens)\n                        current_selector.filters.append(format_filter)\n                    elif string == '(':\n                        if current_selector:\n                            raise syntax_error('Unexpected \"(\"', start)\n                        group = _parse_format_selection(tokens, inside_group=True)\n                        current_selector = FormatSelector(GROUP, group, [])\n                    elif string == '+':\n                        video_selector = current_selector\n                        audio_selector = _parse_format_selection(tokens, inside_merge=True)\n                        if not video_selector or not audio_selector:\n                            raise syntax_error('\"+\" must be between two format selectors', start)\n                        current_selector = FormatSelector(MERGE, (video_selector, audio_selector), [])\n                    else:\n                        raise syntax_error('Operator not recognized: \"{0}\"'.format(string), start)\n                elif type == tokenize.ENDMARKER:\n                    break\n            if current_selector:\n                selectors.append(current_selector)\n            return selectors\n\n        def _build_selector_function(selector):\n            if isinstance(selector, list):\n                fs = [_build_selector_function(s) for s in selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        for format in f(formats):\n                            yield format\n                return selector_function\n            elif selector.type == GROUP:\n                selector_function = _build_selector_function(selector.selector)\n            elif selector.type == PICKFIRST:\n                fs = [_build_selector_function(s) for s in selector.selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        picked_formats = list(f(formats))\n                        if picked_formats:\n                            return picked_formats\n                    return []\n            elif selector.type == SINGLE:\n                format_spec = selector.selector\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    if not formats:\n                        return\n                    if format_spec == 'all':\n                        for f in formats:\n                            yield f\n                    elif format_spec in ['best', 'worst', None]:\n                        format_idx = 0 if format_spec == 'worst' else -1\n                        audiovideo_formats = [\n                            f for f in formats\n                            if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n                        if audiovideo_formats:\n                            yield audiovideo_formats[format_idx]\n                        # for audio only (soundcloud) or video only (imgur) urls, select the best/worst audio format\n                        elif (all(f.get('acodec') != 'none' for f in formats) or\n                              all(f.get('vcodec') != 'none' for f in formats)):\n                            yield formats[format_idx]\n                    elif format_spec == 'bestaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[-1]\n                    elif format_spec == 'worstaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[0]\n                    elif format_spec == 'bestvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[-1]\n                    elif format_spec == 'worstvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[0]\n                    else:\n                        extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n                        if format_spec in extensions:\n                            filter_f = lambda f: f['ext'] == format_spec\n                        else:\n                            filter_f = lambda f: f['format_id'] == format_spec\n                        matches = list(filter(filter_f, formats))\n                        if matches:\n                            yield matches[-1]\n            elif selector.type == MERGE:\n                def _merge(formats_info):\n                    format_1, format_2 = [f['format_id'] for f in formats_info]\n                    # The first format must contain the video and the\n                    # second the audio\n                    if formats_info[0].get('vcodec') == 'none':\n                        self.report_error('The first format must '\n                                          'contain the video, try using '\n                                          '\"-f %s+%s\"' % (format_2, format_1))\n                        return\n                    output_ext = (\n                        formats_info[0]['ext']\n                        if self.params.get('merge_output_format') is None\n                        else self.params['merge_output_format'])\n                    return {\n                        'requested_formats': formats_info,\n                        'format': '%s+%s' % (formats_info[0].get('format'),\n                                             formats_info[1].get('format')),\n                        'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                formats_info[1].get('format_id')),\n                        'width': formats_info[0].get('width'),\n                        'height': formats_info[0].get('height'),\n                        'resolution': formats_info[0].get('resolution'),\n                        'fps': formats_info[0].get('fps'),\n                        'vcodec': formats_info[0].get('vcodec'),\n                        'vbr': formats_info[0].get('vbr'),\n                        'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                        'acodec': formats_info[1].get('acodec'),\n                        'abr': formats_info[1].get('abr'),\n                        'ext': output_ext,\n                    }\n                video_selector, audio_selector = map(_build_selector_function, selector.selector)\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    for pair in itertools.product(video_selector(formats), audio_selector(formats)):\n                        yield _merge(pair)\n\n            filters = [self._build_format_filter(f) for f in selector.filters]\n\n            def final_selector(formats):\n                for _filter in filters:\n                    formats = list(filter(_filter, formats))\n                return selector_function(formats)\n            return final_selector\n\n        stream = io.BytesIO(format_spec.encode('utf-8'))\n        try:\n            tokens = list(_remove_unused_ops(compat_tokenize_tokenize(stream.readline)))\n        except tokenize.TokenError:\n            raise syntax_error('Missing closing/opening brackets or parenthesis', (0, len(format_spec)))\n\n        class TokenIterator(object):\n            def __init__(self, tokens):\n                self.tokens = tokens\n                self.counter = 0\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                if self.counter >= len(self.tokens):\n                    raise StopIteration()\n                value = self.tokens[self.counter]\n                self.counter += 1\n                return value\n\n            next = __next__\n\n            def restore_last_token(self):\n                self.counter -= 1\n\n        parsed_selector = _parse_format_selection(iter(TokenIterator(tokens)))\n        return _build_selector_function(parsed_selector)\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = compat_urllib_request.Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if t.get('width') and t.get('height'):\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around out-of-range timestamp values (e.g. negative ones on Windows,\n            # see http://bugs.python.org/issue1646728)\n            try:\n                upload_date = datetime.datetime.utcfromtimestamp(info_dict['timestamp'])\n                info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n            except (ValueError, OverflowError, OSError):\n                pass\n\n        subtitles = info_dict.get('subtitles')\n        if subtitles:\n            for _, subtitle in subtitles.items():\n                for subtitle_format in subtitle:\n                    if 'ext' not in subtitle_format:\n                        subtitle_format['ext'] = determine_ext(subtitle_format['url']).lower()\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], subtitles, 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], subtitles,\n            info_dict.get('automatic_captions'))\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        formats_dict = {}\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            format_id = format['format_id']\n            if format_id not in formats_dict:\n                formats_dict[format_id] = []\n            formats_dict[format_id].append(format)\n\n        # Make sure all formats have unique format_id\n        for format_id, ambiguous_formats in formats_dict.items():\n            if len(ambiguous_formats) > 1:\n                for i, format in enumerate(ambiguous_formats):\n                    format['format_id'] = '%s-%d' % (format_id, i)\n\n        for i, format in enumerate(formats):\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted'] and\n                    not info_dict.get('is_live')):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        format_selector = self.build_format_selector(req_format)\n        formats_to_download = list(format_selector(formats))\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged.')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning(\n                            'Requested formats are incompatible for merge and will be merged into mkv.')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(\n                    url, force_generic_extractor=self.params.get('force_generic_extractor', False))\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            files_to_delete = []\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = YoutubeDLCookieProcessor(self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        data_handler = compat_urllib_request_DataHandler()\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh, data_handler)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(encodeFilename(thumb_filename), 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport tokenize\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_tokenize_tokenize,\n    compat_urllib_error,\n    compat_urllib_request,\n    compat_urllib_request_DataHandler,\n)\nfrom .utils import (\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLCookieProcessor,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for accessing a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    force_generic_extractor: Force downloader to use the generic extractor\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    postprocessor_args: A list of additional command-line arguments for the\n                        postprocessor.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {\n            # Default parameters\n            'nocheckcertificate': False,\n        }\n        self.params.update(params)\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return sanitize_path(filename)\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True, force_generic_extractor=False):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if not ie_key and force_generic_extractor:\n            ie_key = 'Generic'\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [\n                        ie_entries[i - 1] for i in playlistitems\n                        if -n_all_entries <= i - 1 < n_all_entries]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _build_format_filter(self, filter_spec):\n        \" Returns a function to filter the formats according to the filter_spec \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            $\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(filter_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), filter_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(filter_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid filter specification %r' % filter_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        return _filter\n\n    def build_format_selector(self, format_spec):\n        def syntax_error(note, start):\n            message = (\n                'Invalid format specification: '\n                '{0}\\n\\t{1}\\n\\t{2}^'.format(note, format_spec, ' ' * start[1]))\n            return SyntaxError(message)\n\n        PICKFIRST = 'PICKFIRST'\n        MERGE = 'MERGE'\n        SINGLE = 'SINGLE'\n        GROUP = 'GROUP'\n        FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])\n\n        def _parse_filter(tokens):\n            filter_parts = []\n            for type, string, start, _, _ in tokens:\n                if type == tokenize.OP and string == ']':\n                    return ''.join(filter_parts)\n                else:\n                    filter_parts.append(string)\n\n        def _remove_unused_ops(tokens):\n            # Remove operators that we don't use and join them with the sourrounding strings\n            # for example: 'mp4' '-' 'baseline' '-' '16x9' is converted to 'mp4-baseline-16x9'\n            ALLOWED_OPS = ('/', '+', ',', '(', ')')\n            last_string, last_start, last_end, last_line = None, None, None, None\n            for type, string, start, end, line in tokens:\n                if type == tokenize.OP and string == '[':\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                    # everything inside brackets will be handled by _parse_filter\n                    for type, string, start, end, line in tokens:\n                        yield type, string, start, end, line\n                        if type == tokenize.OP and string == ']':\n                            break\n                elif type == tokenize.OP and string in ALLOWED_OPS:\n                    if last_string:\n                        yield tokenize.NAME, last_string, last_start, last_end, last_line\n                        last_string = None\n                    yield type, string, start, end, line\n                elif type in [tokenize.NAME, tokenize.NUMBER, tokenize.OP]:\n                    if not last_string:\n                        last_string = string\n                        last_start = start\n                        last_end = end\n                    else:\n                        last_string += string\n            if last_string:\n                yield tokenize.NAME, last_string, last_start, last_end, last_line\n\n        def _parse_format_selection(tokens, inside_merge=False, inside_choice=False, inside_group=False):\n            selectors = []\n            current_selector = None\n            for type, string, start, _, _ in tokens:\n                # ENCODING is only defined in python 3.x\n                if type == getattr(tokenize, 'ENCODING', None):\n                    continue\n                elif type in [tokenize.NAME, tokenize.NUMBER]:\n                    current_selector = FormatSelector(SINGLE, string, [])\n                elif type == tokenize.OP:\n                    if string == ')':\n                        if not inside_group:\n                            # ')' will be handled by the parentheses group\n                            tokens.restore_last_token()\n                        break\n                    elif inside_merge and string in ['/', ',']:\n                        tokens.restore_last_token()\n                        break\n                    elif inside_choice and string == ',':\n                        tokens.restore_last_token()\n                        break\n                    elif string == ',':\n                        if not current_selector:\n                            raise syntax_error('\",\" must follow a format selector', start)\n                        selectors.append(current_selector)\n                        current_selector = None\n                    elif string == '/':\n                        if not current_selector:\n                            raise syntax_error('\"/\" must follow a format selector', start)\n                        first_choice = current_selector\n                        second_choice = _parse_format_selection(tokens, inside_choice=True)\n                        current_selector = FormatSelector(PICKFIRST, (first_choice, second_choice), [])\n                    elif string == '[':\n                        if not current_selector:\n                            current_selector = FormatSelector(SINGLE, 'best', [])\n                        format_filter = _parse_filter(tokens)\n                        current_selector.filters.append(format_filter)\n                    elif string == '(':\n                        if current_selector:\n                            raise syntax_error('Unexpected \"(\"', start)\n                        group = _parse_format_selection(tokens, inside_group=True)\n                        current_selector = FormatSelector(GROUP, group, [])\n                    elif string == '+':\n                        video_selector = current_selector\n                        audio_selector = _parse_format_selection(tokens, inside_merge=True)\n                        if not video_selector or not audio_selector:\n                            raise syntax_error('\"+\" must be between two format selectors', start)\n                        current_selector = FormatSelector(MERGE, (video_selector, audio_selector), [])\n                    else:\n                        raise syntax_error('Operator not recognized: \"{0}\"'.format(string), start)\n                elif type == tokenize.ENDMARKER:\n                    break\n            if current_selector:\n                selectors.append(current_selector)\n            return selectors\n\n        def _build_selector_function(selector):\n            if isinstance(selector, list):\n                fs = [_build_selector_function(s) for s in selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        for format in f(formats):\n                            yield format\n                return selector_function\n            elif selector.type == GROUP:\n                selector_function = _build_selector_function(selector.selector)\n            elif selector.type == PICKFIRST:\n                fs = [_build_selector_function(s) for s in selector.selector]\n\n                def selector_function(formats):\n                    for f in fs:\n                        picked_formats = list(f(formats))\n                        if picked_formats:\n                            return picked_formats\n                    return []\n            elif selector.type == SINGLE:\n                format_spec = selector.selector\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    if not formats:\n                        return\n                    if format_spec == 'all':\n                        for f in formats:\n                            yield f\n                    elif format_spec in ['best', 'worst', None]:\n                        format_idx = 0 if format_spec == 'worst' else -1\n                        audiovideo_formats = [\n                            f for f in formats\n                            if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n                        if audiovideo_formats:\n                            yield audiovideo_formats[format_idx]\n                        # for audio only (soundcloud) or video only (imgur) urls, select the best/worst audio format\n                        elif (all(f.get('acodec') != 'none' for f in formats) or\n                              all(f.get('vcodec') != 'none' for f in formats)):\n                            yield formats[format_idx]\n                    elif format_spec == 'bestaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[-1]\n                    elif format_spec == 'worstaudio':\n                        audio_formats = [\n                            f for f in formats\n                            if f.get('vcodec') == 'none']\n                        if audio_formats:\n                            yield audio_formats[0]\n                    elif format_spec == 'bestvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[-1]\n                    elif format_spec == 'worstvideo':\n                        video_formats = [\n                            f for f in formats\n                            if f.get('acodec') == 'none']\n                        if video_formats:\n                            yield video_formats[0]\n                    else:\n                        extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n                        if format_spec in extensions:\n                            filter_f = lambda f: f['ext'] == format_spec\n                        else:\n                            filter_f = lambda f: f['format_id'] == format_spec\n                        matches = list(filter(filter_f, formats))\n                        if matches:\n                            yield matches[-1]\n            elif selector.type == MERGE:\n                def _merge(formats_info):\n                    format_1, format_2 = [f['format_id'] for f in formats_info]\n                    # The first format must contain the video and the\n                    # second the audio\n                    if formats_info[0].get('vcodec') == 'none':\n                        self.report_error('The first format must '\n                                          'contain the video, try using '\n                                          '\"-f %s+%s\"' % (format_2, format_1))\n                        return\n                    output_ext = (\n                        formats_info[0]['ext']\n                        if self.params.get('merge_output_format') is None\n                        else self.params['merge_output_format'])\n                    return {\n                        'requested_formats': formats_info,\n                        'format': '%s+%s' % (formats_info[0].get('format'),\n                                             formats_info[1].get('format')),\n                        'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                formats_info[1].get('format_id')),\n                        'width': formats_info[0].get('width'),\n                        'height': formats_info[0].get('height'),\n                        'resolution': formats_info[0].get('resolution'),\n                        'fps': formats_info[0].get('fps'),\n                        'vcodec': formats_info[0].get('vcodec'),\n                        'vbr': formats_info[0].get('vbr'),\n                        'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                        'acodec': formats_info[1].get('acodec'),\n                        'abr': formats_info[1].get('abr'),\n                        'ext': output_ext,\n                    }\n                video_selector, audio_selector = map(_build_selector_function, selector.selector)\n\n                def selector_function(formats):\n                    formats = list(formats)\n                    for pair in itertools.product(video_selector(formats), audio_selector(formats)):\n                        yield _merge(pair)\n\n            filters = [self._build_format_filter(f) for f in selector.filters]\n\n            def final_selector(formats):\n                for _filter in filters:\n                    formats = list(filter(_filter, formats))\n                return selector_function(formats)\n            return final_selector\n\n        stream = io.BytesIO(format_spec.encode('utf-8'))\n        try:\n            tokens = list(_remove_unused_ops(compat_tokenize_tokenize(stream.readline)))\n        except tokenize.TokenError:\n            raise syntax_error('Missing closing/opening brackets or parenthesis', (0, len(format_spec)))\n\n        class TokenIterator(object):\n            def __init__(self, tokens):\n                self.tokens = tokens\n                self.counter = 0\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                if self.counter >= len(self.tokens):\n                    raise StopIteration()\n                value = self.tokens[self.counter]\n                self.counter += 1\n                return value\n\n            next = __next__\n\n            def restore_last_token(self):\n                self.counter -= 1\n\n        parsed_selector = _parse_format_selection(iter(TokenIterator(tokens)))\n        return _build_selector_function(parsed_selector)\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = compat_urllib_request.Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if t.get('width') and t.get('height'):\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around out-of-range timestamp values (e.g. negative ones on Windows,\n            # see http://bugs.python.org/issue1646728)\n            try:\n                upload_date = datetime.datetime.utcfromtimestamp(info_dict['timestamp'])\n                info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n            except (ValueError, OverflowError, OSError):\n                pass\n\n        subtitles = info_dict.get('subtitles')\n        if subtitles:\n            for _, subtitle in subtitles.items():\n                for subtitle_format in subtitle:\n                    if 'ext' not in subtitle_format:\n                        subtitle_format['ext'] = determine_ext(subtitle_format['url']).lower()\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], subtitles, 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], subtitles,\n            info_dict.get('automatic_captions'))\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        formats_dict = {}\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            format_id = format['format_id']\n            if format_id not in formats_dict:\n                formats_dict[format_id] = []\n            formats_dict[format_id].append(format)\n\n        # Make sure all formats have unique format_id\n        for format_id, ambiguous_formats in formats_dict.items():\n            if len(ambiguous_formats) > 1:\n                for i, format in enumerate(ambiguous_formats):\n                    format['format_id'] = '%s-%d' % (format_id, i)\n\n        for i, format in enumerate(formats):\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted'] and\n                    not info_dict.get('is_live')):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        format_selector = self.build_format_selector(req_format)\n        formats_to_download = list(format_selector(formats))\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged.')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning(\n                            'Requested formats are incompatible for merge and will be merged into mkv.')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(\n                    url, force_generic_extractor=self.params.get('force_generic_extractor', False))\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            files_to_delete = []\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = YoutubeDLCookieProcessor(self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        data_handler = compat_urllib_request_DataHandler()\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh, data_handler)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(encodeFilename(thumb_filename), 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_patch": "@@ -833,6 +833,7 @@ class YoutubeDL(object):\n                                                       extra_info=extra)\n                 playlist_results.append(entry_result)\n             ie_result['entries'] = playlist_results\n+            self.to_screen('[download] Finished downloading playlist: %s' % playlist)\n             return ie_result\n         elif result_type == 'compat_list':\n             self.report_warning(\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "3884dcf313223040049e4153e0c398fbc36b5117": {
        "commit": {
          "commit_id": "3884dcf313223040049e4153e0c398fbc36b5117",
          "commit_message": "YoutubeDL: ignore indexes from 'playlist_items' that are not in the list (fixes #5706)\n\nWe ignore them instead of failing to match the behaviour of the 'playliststart' parameter.",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2015-05-15 14:08:26",
          "commit_parent": "c4fc559f45ea5c40409eab44867ff2b4f08976c2"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 685,
          "function_before_end_line": 845,
          "function_after_start_line": 685,
          "function_after_end_line": 847,
          "function_before_token_count": 800,
          "function_after_token_count": 809,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "list_subtitles",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "filter_requested_info",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "process_subtitles",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "list_subtitles",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "filter_requested_info",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "process_subtitles",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1579,
          "file_complexity": 480,
          "file_token_count": 10164,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = sanitize_path(self.params.get('outtmpl', DEFAULT_OUTTMPL))\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [ie_entries[i - 1] for i in playlistitems]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), format_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\\s*\\[\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*\\]$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(format_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec in ['best', 'worst', None]:\n            format_idx = 0 if format_spec == 'worst' else -1\n            audiovideo_formats = [\n                f for f in available_formats\n                if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n            if audiovideo_formats:\n                return audiovideo_formats[format_idx]\n            # for audio only urls, select the best/worst audio format\n            elif all(f.get('acodec') != 'none' for f in available_formats):\n                return available_formats[format_idx]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = compat_urllib_request.Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], info_dict.get('subtitles'), 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], info_dict.get('subtitles'),\n            info_dict.get('automatic_captions'))\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted']):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        formats_to_download = []\n        if req_format == 'all':\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': '%s+%s' % (formats_info[0].get('format'),\n                                                     formats_info[1].get('format')),\n                                'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                        formats_info[1].get('format_id')),\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning('You have requested formats incompatible for merge. '\n                                            'The formats will be merged into mkv')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, compat_basestring)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport contextlib\nimport datetime\nimport errno\nimport fileinput\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_get_terminal_size,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PerRequestProxyHandler,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    sanitize_path,\n    std_headers,\n    subtitles_filename,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    replace_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   The format code for subtitles\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    cn_verification_proxy:  URL of the proxy to use for IP address verification\n                       on Chinese sites. (Experimental)\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\", \"error\", or \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\", or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * tmpfilename: The filename we're currently writing to\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * total_bytes_estimate: Guess of the eventual file size,\n                                               None if unavailable.\n                       * elapsed: The number of seconds since download started.\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n                       * fragment_index: The counter of the currently\n                                         downloaded video fragment.\n                       * fragment_count: The number of fragments (= individual\n                                         files that will be merged)\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n    The following options determine which downloader is picked:\n    external_downloader: Executable of the external downloader to call.\n                       None or unset for standard (built-in) downloader.\n    hls_prefer_native: Use the native HLS downloader instead of ffmpeg/avconv.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the downloader (see youtube_dl/downloader/common.py):\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize, external_downloader_args.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = compat_get_terminal_size().columns\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968'] and\n                not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if isinstance(params.get('outtmpl'), bytes):\n            self.report_warning(\n                'Parameter outtmpl is bytes, but should be a unicode string. '\n                'Put  from __future__ import unicode_literals  at the top of your code file or consider switching to Python 3.x.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = sanitize_path(self.params.get('outtmpl', DEFAULT_OUTTMPL))\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n        '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [\n                        ie_entries[i - 1] for i in playlistitems\n                        if -n_all_entries <= i - 1 < n_all_entries]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), format_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\\s*\\[\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*\\]$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(format_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec in ['best', 'worst', None]:\n            format_idx = 0 if format_spec == 'worst' else -1\n            audiovideo_formats = [\n                f for f in available_formats\n                if f.get('vcodec') != 'none' and f.get('acodec') != 'none']\n            if audiovideo_formats:\n                return audiovideo_formats[format_idx]\n            # for audio only urls, select the best/worst audio format\n            elif all(f.get('acodec') != 'none' for f in available_formats):\n                return available_formats[format_idx]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        pr = compat_urllib_request.Request(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.get_header('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(info_dict['id'], info_dict.get('automatic_captions'), 'automatic captions')\n            self.list_subtitles(info_dict['id'], info_dict.get('subtitles'), 'subtitles')\n            return\n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], info_dict.get('subtitles'),\n            info_dict.get('automatic_captions'))\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format_list = []\n            if (self.params.get('outtmpl', DEFAULT_OUTTMPL) != '-' and\n                    info_dict['extractor'] in ['youtube', 'ted']):\n                merger = FFmpegMergerPP(self)\n                if merger.available and merger.can_merge():\n                    req_format_list.append('bestvideo+bestaudio')\n            req_format_list.append('best')\n            req_format = '/'.join(req_format_list)\n        formats_to_download = []\n        if req_format == 'all':\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': '%s+%s' % (formats_info[0].get('format'),\n                                                     formats_info[1].get('format')),\n                                'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                        formats_info[1].get('format_id')),\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_subtitles(self, video_id, normal_subtitles, automatic_captions):\n        \"\"\"Select the requested subtitles and their format\"\"\"\n        available_subs = {}\n        if normal_subtitles and self.params.get('writesubtitles'):\n            available_subs.update(normal_subtitles)\n        if automatic_captions and self.params.get('writeautomaticsub'):\n            for lang, cap_info in automatic_captions.items():\n                if lang not in available_subs:\n                    available_subs[lang] = cap_info\n\n        if (not self.params.get('writesubtitles') and not\n                self.params.get('writeautomaticsub') or not\n                available_subs):\n            return None\n\n        if self.params.get('allsubtitles', False):\n            requested_langs = available_subs.keys()\n        else:\n            if self.params.get('subtitleslangs', False):\n                requested_langs = self.params.get('subtitleslangs')\n            elif 'en' in available_subs:\n                requested_langs = ['en']\n            else:\n                requested_langs = [list(available_subs.keys())[0]]\n\n        formats_query = self.params.get('subtitlesformat', 'best')\n        formats_preference = formats_query.split('/') if formats_query else []\n        subs = {}\n        for lang in requested_langs:\n            formats = available_subs.get(lang)\n            if formats is None:\n                self.report_warning('%s subtitles not available for %s' % (lang, video_id))\n                continue\n            for ext in formats_preference:\n                if ext == 'best':\n                    f = formats[-1]\n                    break\n                matches = list(filter(lambda f: f['ext'] == ext, formats))\n                if matches:\n                    f = matches[-1]\n                    break\n            else:\n                f = formats[-1]\n                self.report_warning(\n                    'No subtitle format found matching \"%s\" for language %s, '\n                    'using %s' % (formats_query, lang, f['ext']))\n            subs[lang] = f\n        return subs\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(sanitize_path(encodeFilename(filename)))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = replace_extension(filename, 'description', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = replace_extension(filename, 'annotations.xml', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and info_dict.get('requested_subtitles'):\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['requested_subtitles']\n            ie = self.get_info_extractor(info_dict['extractor_key'])\n            for sub_lang, sub_info in subtitles.items():\n                sub_format = sub_info['ext']\n                if sub_info.get('data') is not None:\n                    sub_data = sub_info['data']\n                else:\n                    try:\n                        sub_data = ie._download_webpage(\n                            sub_info['url'], info_dict['id'], note=False)\n                    except ExtractorError as err:\n                        self.report_warning('Unable to download subtitle for \"%s\": %s' %\n                                            (sub_lang, compat_str(err.cause)))\n                        continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub_data)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = replace_extension(filename, 'info.json', info_dict.get('ext'))\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(self.filter_requested_info(info_dict), infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self)\n                    if not merger.available:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n\n                    def compatible_formats(formats):\n                        video, audio = formats\n                        # Check extension\n                        video_ext, audio_ext = audio.get('ext'), video.get('ext')\n                        if video_ext and audio_ext:\n                            COMPATIBLE_EXTS = (\n                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v'),\n                                ('webm')\n                            )\n                            for exts in COMPATIBLE_EXTS:\n                                if video_ext in exts and audio_ext in exts:\n                                    return True\n                        # TODO: Check acodec/vcodec\n                        return False\n\n                    filename_real_ext = os.path.splitext(filename)[1][1:]\n                    filename_wo_ext = (\n                        os.path.splitext(filename)[0]\n                        if filename_real_ext == info_dict['ext']\n                        else filename)\n                    requested_formats = info_dict['requested_formats']\n                    if self.params.get('merge_output_format') is None and not compatible_formats(requested_formats):\n                        info_dict['ext'] = 'mkv'\n                        self.report_warning('You have requested formats incompatible for merge. '\n                                            'The formats will be merged into mkv')\n                    # Ensure filename always has a correct extension for successful merge\n                    filename = '%s.%s' % (filename_wo_ext, info_dict['ext'])\n                    if os.path.exists(encodeFilename(filename)):\n                        self.to_screen(\n                            '[download] %s has already been downloaded and '\n                            'merged' % filename)\n                    else:\n                        for f in requested_formats:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'], new_info['ext'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl and\n                self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with contextlib.closing(fileinput.FileInput(\n                [info_filename], mode='r',\n                openhook=fileinput.hook_encoded('utf-8'))) as f:\n            # FileInput doesn't have a read method, we can't call json.load\n            info = self.filter_requested_info(json.loads('\\n'.join(f)))\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    @staticmethod\n    def filter_requested_info(info_dict):\n        return dict(\n            (k, v) for k, v in info_dict.items()\n            if k not in ['requested_formats', 'requested_subtitles'])\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                files_to_delete, info = pp.run(info)\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if files_to_delete and not self.params.get('keepvideo', False):\n                for old_filename in files_to_delete:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    try:\n                        os.remove(encodeFilename(old_filename))\n                    except (IOError, OSError):\n                        self.report_warning('Unable to remove downloaded original file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        formats = info_dict.get('formats', [info_dict])\n        table = [\n            [f['format_id'], f['ext'], self.format_resolution(f), self._format_note(f)]\n            for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            table[-1][-1] += (' ' if table[-1][-1] else '') + '(best)'\n\n        header_line = ['format code', 'extension', 'resolution', 'note']\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s' %\n            (info_dict['id'], render_table(header_line, table)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def list_subtitles(self, video_id, subtitles, name='subtitles'):\n        if not subtitles:\n            self.to_screen('%s has no %s' % (video_id, name))\n            return\n        self.to_screen(\n            'Available %s for %s:' % (name, video_id))\n        self.to_screen(render_table(\n            ['Language', 'formats'],\n            [[lang, ', '.join(f['ext'] for f in reversed(formats))]\n                for lang, formats in subtitles.items()]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, compat_basestring)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except Exception:\n            try:\n                sys.exc_clear()\n            except Exception:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions(self)\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = PerRequestProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            proxy_handler, https_handler, cookie_processor, ydlh)\n\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            t['filename'] = thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_patch": "@@ -759,7 +759,9 @@ class YoutubeDL(object):\n             if isinstance(ie_entries, list):\n                 n_all_entries = len(ie_entries)\n                 if playlistitems:\n-                    entries = [ie_entries[i - 1] for i in playlistitems]\n+                    entries = [\n+                        ie_entries[i - 1] for i in playlistitems\n+                        if -n_all_entries <= i - 1 < n_all_entries]\n                 else:\n                     entries = ie_entries[playliststart:playlistend]\n                 n_entries = len(entries)\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "442c37b7a9a912cf3b0eb972335b7d24407f4537": {
        "commit": {
          "commit_id": "442c37b7a9a912cf3b0eb972335b7d24407f4537",
          "commit_message": "[YoutubeDL] Do not perform filter matching on partial results (Fixes #4921)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2015-02-10 11:28:28",
          "commit_parent": "04bbe41330a4c8619e6fa3228d47c4e7b0396899"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry, incomplete=True)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 668,
          "function_before_end_line": 828,
          "function_after_start_line": 669,
          "function_after_end_line": 829,
          "function_before_token_count": 796,
          "function_after_token_count": 800,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [
            "process_info",
            "_match_entry"
          ],
          "functions_name_co_evolved_all_files": [
            "process_info",
            "_match_entry"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1481,
          "file_complexity": 443,
          "file_token_count": 9460,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    std_headers,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\" and \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\" or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    external_downloader:  Executable of the external downloader to call.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        match_filter = self.params.get('match_filter')\n        if match_filter is not None:\n            ret = match_filter(info_dict)\n            if ret is not None:\n                return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [ie_entries[i - 1] for i in playlistitems]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), format_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\\s*\\[\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*\\]$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(format_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        class _PseudoRequest(object):\n            def __init__(self, url):\n                self.url = url\n                self.headers = {}\n                self.unverifiable = False\n\n            def add_unredirected_header(self, k, v):\n                self.headers[k] = v\n\n            def get_full_url(self):\n                return self.url\n\n            def is_unverifiable(self):\n                return self.unverifiable\n\n            def has_header(self, h):\n                return h in self.headers\n\n            def get_header(self, h, default=None):\n                return self.headers.get(h, default)\n\n        pr = _PseudoRequest(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.headers.get('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': '%s+%s' % (formats_info[0].get('format'),\n                                                     formats_info[1].get('format')),\n                                'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                        formats_info[1].get('format_id')),\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                    if not merger._executable:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n                    for f in info_dict['requested_formats']:\n                        new_info = dict(info_dict)\n                        new_info.update(f)\n                        fname = self.prepare_filename(new_info)\n                        fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                        downloaded.append(fname)\n                        partial_success = dl(fname, new_info)\n                        success = success and partial_success\n                    info_dict['__postprocessors'] = postprocessors\n                    info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            keep_video = None\n            old_filename = info['filepath']\n            try:\n                keep_video_wish, info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if keep_video is False and not self.params.get('keepvideo', False):\n                try:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    os.remove(encodeFilename(old_filename))\n                except (IOError, OSError):\n                    self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [\n            line(f, idlen) for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s\\n%s' %\n            (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, compat_basestring)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_basestring,\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    std_headers,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * status: One of \"downloading\" and \"finished\".\n                                 Check this first and ignore unknown values.\n\n                       If status is one of \"downloading\" or \"finished\", the\n                       following properties may also be present:\n                       * filename: The final filename (always present)\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    external_downloader:  Executable of the external downloader to call.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n    match_filter:      A function that gets called with the info_dict of\n                       every video.\n                       If it returns a message, the video is ignored.\n                       If it returns None, the video is downloaded.\n                       match_filter_func in utils.py is one example for this.\n    no_color:          Do not emit color codes in output.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle,\n    xattr_set_filesize.\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if not self.params.get('no_color') and self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            # Temporary fix for #4787\n            # 'Treat' all problem characters by passing filename through preferredencoding\n            # to workaround encoding issues with subprocess on python2 @ Windows\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict, incomplete):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % video_title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n\n        if not incomplete:\n            match_filter = self.params.get('match_filter')\n            if match_filter is not None:\n                ret = match_filter(info_dict)\n                if ret is not None:\n                    return ret\n\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [ie_entries[i - 1] for i in playlistitems]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry, incomplete=True)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|asr|filesize|fps)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if m:\n            try:\n                comparison_value = int(m.group('value'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('value'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('value') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid value %r in format specification %r' % (\n                            m.group('value'), format_spec))\n            op = OPERATORS[m.group('op')]\n\n        if not m:\n            STR_OPERATORS = {\n                '=': operator.eq,\n                '!=': operator.ne,\n            }\n            str_operator_rex = re.compile(r'''(?x)\\s*\\[\n                \\s*(?P<key>ext|acodec|vcodec|container|protocol)\n                \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\n                \\s*(?P<value>[a-zA-Z0-9_-]+)\n                \\s*\\]$\n                ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))\n            m = str_operator_rex.search(format_spec)\n            if m:\n                comparison_value = m.group('value')\n                op = STR_OPERATORS[m.group('op')]\n\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        class _PseudoRequest(object):\n            def __init__(self, url):\n                self.url = url\n                self.headers = {}\n                self.unverifiable = False\n\n            def add_unredirected_header(self, k, v):\n                self.headers[k] = v\n\n            def get_full_url(self):\n                return self.url\n\n            def is_unverifiable(self):\n                return self.unverifiable\n\n            def has_header(self, h):\n                return h in self.headers\n\n            def get_header(self, h, default=None):\n                return self.headers.get(h, default)\n\n        pr = _PseudoRequest(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.headers.get('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for i, t in enumerate(thumbnails):\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': '%s+%s' % (formats_info[0].get('format'),\n                                                     formats_info[1].get('format')),\n                                'format_id': '%s+%s' % (formats_info[0].get('format_id'),\n                                                        formats_info[1].get('format_id')),\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict, incomplete=False)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        info_dict['_filename'] = filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                    if not merger._executable:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n                    for f in info_dict['requested_formats']:\n                        new_info = dict(info_dict)\n                        new_info.update(f)\n                        fname = self.prepare_filename(new_info)\n                        fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                        downloaded.append(fname)\n                        partial_success = dl(fname, new_info)\n                        success = success and partial_success\n                    info_dict['__postprocessors'] = postprocessors\n                    info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            keep_video = None\n            old_filename = info['filepath']\n            try:\n                keep_video_wish, info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if keep_video is False and not self.params.get('keepvideo', False):\n                try:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    os.remove(encodeFilename(old_filename))\n                except (IOError, OSError):\n                    self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [\n            line(f, idlen) for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s\\n%s' %\n            (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, compat_basestring)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_patch": "@@ -560,7 +560,7 @@ class YoutubeDL(object):\n             self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n             return None\n \n-    def _match_entry(self, info_dict):\n+    def _match_entry(self, info_dict, incomplete):\n         \"\"\" Returns None iff the file should be downloaded \"\"\"\n \n         video_title = info_dict.get('title', info_dict.get('id', 'video'))\n@@ -593,11 +593,12 @@ class YoutubeDL(object):\n         if self.in_download_archive(info_dict):\n             return '%s has already been recorded in archive' % video_title\n \n-        match_filter = self.params.get('match_filter')\n-        if match_filter is not None:\n-            ret = match_filter(info_dict)\n-            if ret is not None:\n-                return ret\n+        if not incomplete:\n+            match_filter = self.params.get('match_filter')\n+            if match_filter is not None:\n+                ret = match_filter(info_dict)\n+                if ret is not None:\n+                    return ret\n \n         return None\n \n@@ -792,7 +793,7 @@ class YoutubeDL(object):\n                     'extractor_key': ie_result['extractor_key'],\n                 }\n \n-                reason = self._match_entry(entry)\n+                reason = self._match_entry(entry, incomplete=True)\n                 if reason is not None:\n                     self.to_screen('[download] ' + reason)\n                     continue\n@@ -1166,7 +1167,7 @@ class YoutubeDL(object):\n         if 'format' not in info_dict:\n             info_dict['format'] = info_dict['ext']\n \n-        reason = self._match_entry(info_dict)\n+        reason = self._match_entry(info_dict, incomplete=False)\n         if reason is not None:\n             self.to_screen('[download] ' + reason)\n             return\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca": {
        "commit": {
          "commit_id": "c14e88f0f561c5ac0a1cb9e6764fe4702bd9f7ca",
          "commit_message": "[YoutubeDL] Add --playlist-items option (Fixes #2662)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2015-01-25 04:24:55",
          "commit_parent": "8940b8608e567dba09b3ea146b89b297190ec6d6"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items', None)\n        playlistitems = None\n        if playlistitems_str is not None:\n\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        (start, end) = string_segment.split('-')\n                        for item in range(int(start), int(end) + 1):\n                            yield int(item)\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            if playlistitems:\n                entries = []\n                for item in playlistitems:\n                    entries.extend(ie_entries.getslice(item - 1, item))\n            else:\n                entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            if playlistitems:\n                entry_list = list(ie_entries)\n                entries = [entry_list[i - 1] for i in playlistitems]\n            else:\n                entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 646,
          "function_before_end_line": 779,
          "function_after_start_line": 647,
          "function_after_end_line": 807,
          "function_before_token_count": 694,
          "function_after_token_count": 796,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "main",
            "parseOpts",
            "__enter__",
            "trouble",
            "_real_main",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_write_thumbnails",
            "prepare_filename",
            "add_progress_hook",
            "_apply_format_filter",
            "to_console_title",
            "warn_if_short_id",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "_calc_headers",
            "get_info_extractor",
            "print_debug_header",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "list_thumbnails",
            "report_file_already_downloaded",
            "_calc_cookies",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "parseOpts",
            "_real_main"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1446,
          "file_complexity": 434,
          "file_token_count": 9246,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    std_headers,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * filename: The final filename\n                       * status: One of \"downloading\" and \"finished\"\n\n                       The dict may also have some of the following entries:\n\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    external_downloader:  Executable of the external downloader to call.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|filesize)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        try:\n            comparison_value = int(m.group('value'))\n        except ValueError:\n            comparison_value = parse_filesize(m.group('value'))\n            if comparison_value is None:\n                comparison_value = parse_filesize(m.group('value') + 'B')\n            if comparison_value is None:\n                raise ValueError(\n                    'Invalid value %r in format specification %r' % (\n                        m.group('value'), format_spec))\n        op = OPERATORS[m.group('op')]\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        class _PseudoRequest(object):\n            def __init__(self, url):\n                self.url = url\n                self.headers = {}\n                self.unverifiable = False\n\n            def add_unredirected_header(self, k, v):\n                self.headers[k] = v\n\n            def get_full_url(self):\n                return self.url\n\n            def is_unverifiable(self):\n                return self.unverifiable\n\n            def has_header(self, h):\n                return h in self.headers\n\n        pr = _PseudoRequest(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.headers.get('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                    if not merger._executable:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n                    for f in info_dict['requested_formats']:\n                        new_info = dict(info_dict)\n                        new_info.update(f)\n                        fname = self.prepare_filename(new_info)\n                        fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                        downloaded.append(fname)\n                        partial_success = dl(fname, new_info)\n                        success = success and partial_success\n                    info_dict['__postprocessors'] = postprocessors\n                    info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            keep_video = None\n            old_filename = info['filepath']\n            try:\n                keep_video_wish, info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if keep_video is False and not self.params.get('keepvideo', False):\n                try:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    os.remove(encodeFilename(old_filename))\n                except (IOError, OSError):\n                    self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [\n            line(f, idlen) for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s\\n%s' %\n            (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport operator\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    parse_filesize,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    render_table,\n    SameFileError,\n    sanitize_filename,\n    std_headers,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    version_tuple,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n    age_restricted,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegFixupM4aPP,\n    FFmpegFixupStretchedPP,\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlist_items:    Specific indices of playlist to download.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    write_all_thumbnails:  Write all thumbnail formats to files\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * filename: The final filename\n                       * status: One of \"downloading\" and \"finished\"\n\n                       The dict may also have some of the following entries:\n\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n    merge_output_format: Extension to use when merging formats.\n    fixup:             Automatically correct known faults of the file.\n                       One of:\n                       - \"never\": do nothing\n                       - \"warn\": only emit a warning\n                       - \"detect_or_warn\": check whether we can do anything\n                                           about it, warn otherwise (default)\n    source_address:    (Experimental) Client-side IP address to bind to.\n    call_home:         Boolean, true iff we are allowed to contact the\n                       youtube-dl servers for debugging.\n    sleep_interval:    Number of seconds to sleep before each download.\n    external_downloader:  Executable of the external downloader to call.\n    listformats:       Print an overview of available video formats and exit.\n    list_thumbnails:   Print a table of all thumbnails and exit.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        if age_restricted(info_dict.get('age_limit'), self.params.get('age_limit')):\n            return 'Skipping \"%s\" because it is age restricted' % title\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            playlistitems_str = self.params.get('playlist_items', None)\n            playlistitems = None\n            if playlistitems_str is not None:\n                def iter_playlistitems(format):\n                    for string_segment in format.split(','):\n                        if '-' in string_segment:\n                            start, end = string_segment.split('-')\n                            for item in range(int(start), int(end) + 1):\n                                yield int(item)\n                        else:\n                            yield int(string_segment)\n                playlistitems = iter_playlistitems(playlistitems_str)\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                if playlistitems:\n                    entries = [ie_entries[i - 1] for i in playlistitems]\n                else:\n                    entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                if playlistitems:\n                    entries = []\n                    for item in playlistitems:\n                        entries.extend(ie_entries.getslice(\n                            item - 1, item\n                        ))\n                else:\n                    entries = ie_entries.getslice(\n                        playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                if playlistitems:\n                    entry_list = list(ie_entries)\n                    entries = [entry_list[i - 1] for i in playlistitems]\n                else:\n                    entries = list(itertools.islice(\n                        ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def _apply_format_filter(self, format_spec, available_formats):\n        \" Returns a tuple of the remaining format_spec and filtered formats \"\n\n        OPERATORS = {\n            '<': operator.lt,\n            '<=': operator.le,\n            '>': operator.gt,\n            '>=': operator.ge,\n            '=': operator.eq,\n            '!=': operator.ne,\n        }\n        operator_rex = re.compile(r'''(?x)\\s*\\[\n            (?P<key>width|height|tbr|abr|vbr|filesize)\n            \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n            (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)\n            \\]$\n            ''' % '|'.join(map(re.escape, OPERATORS.keys())))\n        m = operator_rex.search(format_spec)\n        if not m:\n            raise ValueError('Invalid format specification %r' % format_spec)\n\n        try:\n            comparison_value = int(m.group('value'))\n        except ValueError:\n            comparison_value = parse_filesize(m.group('value'))\n            if comparison_value is None:\n                comparison_value = parse_filesize(m.group('value') + 'B')\n            if comparison_value is None:\n                raise ValueError(\n                    'Invalid value %r in format specification %r' % (\n                        m.group('value'), format_spec))\n        op = OPERATORS[m.group('op')]\n\n        def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)\n        new_formats = [f for f in available_formats if _filter(f)]\n\n        new_format_spec = format_spec[:-len(m.group(0))]\n        if not new_format_spec:\n            new_format_spec = 'best'\n\n        return (new_format_spec, new_formats)\n\n    def select_format(self, format_spec, available_formats):\n        while format_spec.endswith(']'):\n            format_spec, available_formats = self._apply_format_filter(\n                format_spec, available_formats)\n        if not available_formats:\n            return None\n\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a', 'mp3', 'ogg', 'aac', 'wav']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def _calc_headers(self, info_dict):\n        res = std_headers.copy()\n\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            res.update(add_headers)\n\n        cookies = self._calc_cookies(info_dict)\n        if cookies:\n            res['Cookie'] = cookies\n\n        return res\n\n    def _calc_cookies(self, info_dict):\n        class _PseudoRequest(object):\n            def __init__(self, url):\n                self.url = url\n                self.headers = {}\n                self.unverifiable = False\n\n            def add_unredirected_header(self, k, v):\n                self.headers[k] = v\n\n            def get_full_url(self):\n                return self.url\n\n            def is_unverifiable(self):\n                return self.unverifiable\n\n            def has_header(self, h):\n                return h in self.headers\n\n        pr = _PseudoRequest(info_dict['url'])\n        self.cookiejar.add_cookie_header(pr)\n        return pr.headers.get('Cookie')\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference'), t.get('width'), t.get('height'),\n                t.get('id'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            output_ext = (\n                                formats_info[0]['ext']\n                                if self.params.get('merge_output_format') is None\n                                else self.params['merge_output_format'])\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                                'width': formats_info[0].get('width'),\n                                'height': formats_info[0].get('height'),\n                                'resolution': formats_info[0].get('resolution'),\n                                'fps': formats_info[0].get('fps'),\n                                'vcodec': formats_info[0].get('vcodec'),\n                                'vbr': formats_info[0].get('vbr'),\n                                'stretched_ratio': formats_info[0].get('stretched_ratio'),\n                                'acodec': formats_info[1].get('acodec'),\n                                'abr': formats_info[1].get('abr'),\n                                'ext': output_ext,\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            elif info_dict.get('description') is None:\n                self.report_warning('There\\'s no description to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        self._write_thumbnails(info_dict, filename)\n\n        if not self.params.get('skip_download', False):\n            try:\n                def dl(name, info):\n                    fd = get_suitable_downloader(info, self.params)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    if self.params.get('verbose'):\n                        self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                    return fd.download(name, info)\n                if info_dict.get('requested_formats') is not None:\n                    downloaded = []\n                    success = True\n                    merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                    if not merger._executable:\n                        postprocessors = []\n                        self.report_warning('You have requested multiple '\n                                            'formats but ffmpeg or avconv are not installed.'\n                                            ' The formats won\\'t be merged')\n                    else:\n                        postprocessors = [merger]\n                    for f in info_dict['requested_formats']:\n                        new_info = dict(info_dict)\n                        new_info.update(f)\n                        fname = self.prepare_filename(new_info)\n                        fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                        downloaded.append(fname)\n                        partial_success = dl(fname, new_info)\n                        success = success and partial_success\n                    info_dict['__postprocessors'] = postprocessors\n                    info_dict['__files_to_merge'] = downloaded\n                else:\n                    # Just a single file\n                    success = dl(filename, info_dict)\n            except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                self.report_error('unable to download video data: %s' % str(err))\n                return\n            except (OSError, IOError) as err:\n                raise UnavailableVideoError(err)\n            except (ContentTooShortError, ) as err:\n                self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                return\n\n            if success:\n                # Fixup content\n                fixup_policy = self.params.get('fixup')\n                if fixup_policy is None:\n                    fixup_policy = 'detect_or_warn'\n\n                stretched_ratio = info_dict.get('stretched_ratio')\n                if stretched_ratio is not None and stretched_ratio != 1:\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: Non-uniform pixel ratio (%s)' % (\n                            info_dict['id'], stretched_ratio))\n                    elif fixup_policy == 'detect_or_warn':\n                        stretched_pp = FFmpegFixupStretchedPP(self)\n                        if stretched_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(stretched_pp)\n                        else:\n                            self.report_warning(\n                                '%s: Non-uniform pixel ratio (%s). Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id'], stretched_ratio))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                if info_dict.get('requested_formats') is None and info_dict.get('container') == 'm4a_dash':\n                    if fixup_policy == 'warn':\n                        self.report_warning('%s: writing DASH m4a. Only some players support this container.' % (\n                            info_dict['id']))\n                    elif fixup_policy == 'detect_or_warn':\n                        fixup_pp = FFmpegFixupM4aPP(self)\n                        if fixup_pp.available:\n                            info_dict.setdefault('__postprocessors', [])\n                            info_dict['__postprocessors'].append(fixup_pp)\n                        else:\n                            self.report_warning(\n                                '%s: writing DASH m4a. Only some players support this container. Install ffmpeg or avconv to fix this automatically.' % (\n                                    info_dict['id']))\n                    else:\n                        assert fixup_policy in ('ignore', 'never')\n\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n                self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            keep_video = None\n            old_filename = info['filepath']\n            try:\n                keep_video_wish, info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n            if keep_video is False and not self.params.get('keepvideo', False):\n                try:\n                    self.to_screen('Deleting original file %s (pass -k to keep)' % old_filename)\n                    os.remove(encodeFilename(old_filename))\n                except (IOError, OSError):\n                    self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [\n            line(f, idlen) for f in formats\n            if f.get('preference') is None or f['preference'] >= -1000]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen(\n            '[info] Available formats for %s:\\n%s\\n%s' %\n            (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def list_thumbnails(self, info_dict):\n        thumbnails = info_dict.get('thumbnails')\n        if not thumbnails:\n            tn_url = info_dict.get('thumbnail')\n            if tn_url:\n                thumbnails = [{'id': '0', 'url': tn_url}]\n            else:\n                self.to_screen(\n                    '[info] No thumbnails present for %s' % info_dict['id'])\n                return\n\n        self.to_screen(\n            '[info] Thumbnails for %s:' % info_dict['id'])\n        self.to_screen(render_table(\n            ['ID', 'width', 'height', 'URL'],\n            [[t['id'], t.get('width', 'unknown'), t.get('height', 'unknown'), t['url']] for t in thumbnails]))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n        if self.params.get('call_home', False):\n            ipaddr = self.urlopen('https://yt-dl.org/ip').read().decode('utf-8')\n            self._write_string('[debug] Public IP address: %s\\n' % ipaddr)\n            latest_version = self.urlopen(\n                'https://yt-dl.org/latest/version').read().decode('utf-8')\n            if version_tuple(latest_version) > version_tuple(__version__):\n                self.report_warning(\n                    'You are using an outdated version (newest version: %s)! '\n                    'See https://yt-dl.org/update if you need help updating.' %\n                    latest_version)\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(self.params, debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(self.params, debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n\n    def _write_thumbnails(self, info_dict, filename):\n        if self.params.get('writethumbnail', False):\n            thumbnails = info_dict.get('thumbnails')\n            if thumbnails:\n                thumbnails = [thumbnails[-1]]\n        elif self.params.get('write_all_thumbnails', False):\n            thumbnails = info_dict.get('thumbnails')\n        else:\n            return\n\n        if not thumbnails:\n            # No thumbnails present, so return immediately\n            return\n\n        for t in thumbnails:\n            thumb_ext = determine_ext(t['url'], 'jpg')\n            suffix = '_%s' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_display_id = '%s ' % t['id'] if len(thumbnails) > 1 else ''\n            thumb_filename = os.path.splitext(filename)[0] + suffix + '.' + thumb_ext\n\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                self.to_screen('[%s] %s: Thumbnail %sis already present' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n            else:\n                self.to_screen('[%s] %s: Downloading thumbnail %s...' %\n                               (info_dict['extractor'], info_dict['id'], thumb_display_id))\n                try:\n                    uf = self.urlopen(t['url'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen('[%s] %s: Writing thumbnail %sto: %s' %\n                                   (info_dict['extractor'], info_dict['id'], thumb_display_id, thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                        (t['url'], compat_str(err)))\n",
          "file_patch": "@@ -137,6 +137,7 @@ class YoutubeDL(object):\n     nooverwrites:      Prevent overwriting files.\n     playliststart:     Playlist item to start at.\n     playlistend:       Playlist item to end at.\n+    playlist_items:    Specific indices of playlist to download.\n     playlistreverse:   Download playlist items in reverse order.\n     matchtitle:        Download only matching titles.\n     rejecttitle:       Reject downloads for matching titles.\n@@ -703,24 +704,51 @@ class YoutubeDL(object):\n             if playlistend == -1:\n                 playlistend = None\n \n+            playlistitems_str = self.params.get('playlist_items', None)\n+            playlistitems = None\n+            if playlistitems_str is not None:\n+                def iter_playlistitems(format):\n+                    for string_segment in format.split(','):\n+                        if '-' in string_segment:\n+                            start, end = string_segment.split('-')\n+                            for item in range(int(start), int(end) + 1):\n+                                yield int(item)\n+                        else:\n+                            yield int(string_segment)\n+                playlistitems = iter_playlistitems(playlistitems_str)\n+\n             ie_entries = ie_result['entries']\n             if isinstance(ie_entries, list):\n                 n_all_entries = len(ie_entries)\n-                entries = ie_entries[playliststart:playlistend]\n+                if playlistitems:\n+                    entries = [ie_entries[i - 1] for i in playlistitems]\n+                else:\n+                    entries = ie_entries[playliststart:playlistend]\n                 n_entries = len(entries)\n                 self.to_screen(\n                     \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                     (ie_result['extractor'], playlist, n_all_entries, n_entries))\n             elif isinstance(ie_entries, PagedList):\n-                entries = ie_entries.getslice(\n-                    playliststart, playlistend)\n+                if playlistitems:\n+                    entries = []\n+                    for item in playlistitems:\n+                        entries.extend(ie_entries.getslice(\n+                            item - 1, item\n+                        ))\n+                else:\n+                    entries = ie_entries.getslice(\n+                        playliststart, playlistend)\n                 n_entries = len(entries)\n                 self.to_screen(\n                     \"[%s] playlist %s: Downloading %d videos\" %\n                     (ie_result['extractor'], playlist, n_entries))\n             else:  # iterable\n-                entries = list(itertools.islice(\n-                    ie_entries, playliststart, playlistend))\n+                if playlistitems:\n+                    entry_list = list(ie_entries)\n+                    entries = [entry_list[i - 1] for i in playlistitems]\n+                else:\n+                    entries = list(itertools.islice(\n+                        ie_entries, playliststart, playlistend))\n                 n_entries = len(entries)\n                 self.to_screen(\n                     \"[%s] playlist %s: Downloading %d videos\" %\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "options.py",
            "YoutubeDL.py"
          ]
        }
      },
      "734ea11e3c57ca4df7d9cfc475b1b99b56c18034": {
        "commit": {
          "commit_id": "734ea11e3c57ca4df7d9cfc475b1b99b56c18034",
          "commit_message": "Drop hash character in downloader output (#4484)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-12-16 00:37:42",
          "commit_parent": "3940450878480cf12a12072a03db2c641c63c250"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 628,
          "function_before_end_line": 761,
          "function_after_start_line": 628,
          "function_after_end_line": 761,
          "function_before_token_count": 694,
          "function_after_token_count": 694,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1233,
          "file_complexity": 377,
          "file_token_count": 7904,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * filename: The final filename\n                       * status: One of \"downloading\" and \"finished\"\n\n                       The dict may also have some of the following entries:\n\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import (\n    FFmpegMergerPP,\n    FFmpegPostProcessor,\n    get_postprocessor,\n)\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code. See options.py for more information.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n    postprocessors:    A list of dictionaries, each with an entry\n                       * key:  The name of the postprocessor. See\n                               youtube_dl/postprocessor/__init__.py for a list.\n                       as well as any further keyword arguments for the\n                       postprocessor.\n    progress_hooks:    A list of functions that get called on download\n                       progress, with a dictionary with the entries\n                       * filename: The final filename\n                       * status: One of \"downloading\" and \"finished\"\n\n                       The dict may also have some of the following entries:\n\n                       * downloaded_bytes: Bytes on disk\n                       * total_bytes: Size of the whole file, None if unknown\n                       * tmpfilename: The filename we're currently writing to\n                       * eta: The estimated time in seconds, None if unknown\n                       * speed: The download speed in bytes/second, None if\n                                unknown\n\n                       Progress hooks are guaranteed to be called at least once\n                       (with status \"finished\") if the download is successful.\n\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n        for pp_def_raw in self.params.get('postprocessors', []):\n            pp_class = get_postprocessor(pp_def_raw['key'])\n            pp_def = dict(pp_def_raw)\n            del pp_def['key']\n            pp = pp_class(self, **compat_kwargs(pp_def))\n            self.add_post_processor(pp)\n\n        for ph in self.params.get('progress_hooks', []):\n            self.add_progress_hook(ph)\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -712,7 +712,7 @@ class YoutubeDL(object):\n                 entries = entries[::-1]\n \n             for i, entry in enumerate(entries, 1):\n-                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n+                self.to_screen('[download] Downloading video %s of %s' % (i, n_entries))\n                 extra = {\n                     'n_entries': n_entries,\n                     'playlist': playlist,\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "ff815fe65aab83db7e11251db5eafc76504adf05": {
        "commit": {
          "commit_id": "ff815fe65aab83db7e11251db5eafc76504adf05",
          "commit_message": "Download playlist items in reverse order\n\nSeries of videos are typically uploaded to YouTube playlists in\nchronological order.  By default, these videos are downloaded\nlatest-to-earliest; this is great for seeing the latest videos in a\nseries, but prevents streaming video in the order that the videos were\nproduced.  Add an option to download videos in reverse order,\nearliest-to-latest.\n\nConflicts:\n\tyoutube_dl/YoutubeDL.py\n\tyoutube_dl/__init__.py",
          "commit_author": "Mark Schreiber",
          "commit_date": "2014-12-12 16:56:29",
          "commit_parent": "da3a2d8137fa89051b011d90875827504a9a9373"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        if self.params.get('playlistreverse', False):\n            entries = entries[::-1]\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 590,
          "function_before_end_line": 720,
          "function_after_start_line": 591,
          "function_after_end_line": 724,
          "function_before_token_count": 674,
          "function_after_token_count": 694,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "main",
            "parseOpts",
            "__enter__",
            "trouble",
            "_real_main",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "parseOpts",
            "_real_main"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1198,
          "file_complexity": 375,
          "file_token_count": 7823,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    playlistreverse:   Download playlist items in reverse order.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            if self.params.get('playlistreverse', False):\n                entries = entries[::-1]\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -124,6 +124,7 @@ class YoutubeDL(object):\n     nooverwrites:      Prevent overwriting files.\n     playliststart:     Playlist item to start at.\n     playlistend:       Playlist item to end at.\n+    playlistreverse:   Download playlist items in reverse order.\n     matchtitle:        Download only matching titles.\n     rejecttitle:       Reject downloads for matching titles.\n     logger:            Log messages to a logging.Logger instance.\n@@ -670,6 +671,9 @@ class YoutubeDL(object):\n                     \"[%s] playlist %s: Downloading %d videos\" %\n                     (ie_result['extractor'], playlist, n_entries))\n \n+            if self.params.get('playlistreverse', False):\n+                entries = entries[::-1]\n+\n             for i, entry in enumerate(entries, 1):\n                 self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                 extra = {\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "options.py",
            "YoutubeDL.py"
          ]
        }
      },
      "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f": {
        "commit": {
          "commit_id": "412c617d0f7d22e9b2f7c3b0252a76bcf8ffef2f",
          "commit_message": "[cnet] Update to new theplatform infrastructure (Fixes #2736)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-12-12 15:55:55",
          "commit_parent": "751536f5c80cdfdbf6ddfd9f9a673ffd3d8f5d55"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        new_result = ie_result.copy()\n        for f in ('_type', 'id', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n            if f in new_result:\n                del new_result[f]\n            if f in info:\n                new_result[f] = info[f]\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        force_properties = dict(((k, v) for (k, v) in ie_result.items() if v is not None))\n        for f in ('_type', 'url'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        assert new_result.get('_type') != 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 590,
          "function_before_end_line": 722,
          "function_after_start_line": 590,
          "function_after_end_line": 720,
          "function_before_token_count": 681,
          "function_after_token_count": 674,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "_real_extract",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "_real_extract"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1195,
          "file_complexity": 374,
          "file_token_count": 7803,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            new_result = ie_result.copy()\n            for f in ('_type', 'id', 'url', 'ext', 'player_url', 'formats',\n                      'entries', 'ie_key', 'duration',\n                      'subtitles', 'annotations', 'format',\n                      'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in info:\n                    new_result[f] = info[f]\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            force_properties = dict(\n                (k, v) for k, v in ie_result.items() if v is not None)\n            for f in ('_type', 'url'):\n                if f in force_properties:\n                    del force_properties[f]\n            new_result = info.copy()\n            new_result.update(force_properties)\n\n            assert new_result.get('_type') != 'url_transparent'\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            if info_dict.get('requested_formats') is not None:\n                for f in info_dict['requested_formats']:\n                    self.to_stdout(f['url'] + f.get('play_path', ''))\n            else:\n                # For RTMP URLs, also include the playpath\n                self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -622,15 +622,13 @@ class YoutubeDL(object):\n                 ie_result['url'], ie_key=ie_result.get('ie_key'),\n                 extra_info=extra_info, download=False, process=False)\n \n-            new_result = ie_result.copy()\n-            for f in ('_type', 'id', 'url', 'ext', 'player_url', 'formats',\n-                      'entries', 'ie_key', 'duration',\n-                      'subtitles', 'annotations', 'format',\n-                      'thumbnail', 'thumbnails'):\n-                if f in new_result:\n-                    del new_result[f]\n-                if f in info:\n-                    new_result[f] = info[f]\n+            force_properties = dict(\n+                (k, v) for k, v in ie_result.items() if v is not None)\n+            for f in ('_type', 'url'):\n+                if f in force_properties:\n+                    del force_properties[f]\n+            new_result = info.copy()\n+            new_result.update(force_properties)\n \n             assert new_result.get('_type') != 'url_transparent'\n \n",
          "files_name_in_blame_commit": [
            "cnet.py",
            "YoutubeDL.py"
          ]
        }
      },
      "b82f815f373818ba99ee43660e9255e8f4ecac62": {
        "commit": {
          "commit_id": "b82f815f373818ba99ee43660e9255e8f4ecac62",
          "commit_message": "Allow iterators for playlist result entries",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-12-06 14:02:19",
          "commit_parent": "158f8cadc0c29e9d43e1440a672a3f72f0e454c7"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        elif isinstance(ie_entries, PagedList):\n            entries = ie_entries.getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        else:\n            entries = list(itertools.islice(ie_entries, playliststart, playlistend))\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 589,
          "function_before_end_line": 720,
          "function_after_start_line": 590,
          "function_after_end_line": 728,
          "function_before_token_count": 623,
          "function_after_token_count": 653,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "_get_available_subtitles",
            "_extract_from_m3u8",
            "extract_videos_from_page",
            "to_stderr",
            "_sort_formats",
            "_print_sig_code",
            "_setup_opener",
            "playlist_result",
            "urlopen",
            "_media_rating_search",
            "_get_login_info",
            "_parse_sig_js",
            "add_post_processor",
            "_format_note",
            "_dc_search_uploader",
            "_parse_sig_swf",
            "_og_search_title",
            "prepare_filename",
            "_sleep",
            "_download_webpage_handle",
            "_html_search_meta",
            "warn_if_short_id",
            "_make_valid_url",
            "set_downloader",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download",
            "_write_string",
            "_rta_search",
            "_real_initialize",
            "select_format",
            "_real_extract",
            "record_download_archive",
            "extract_info",
            "in_download_archive",
            "report_login",
            "_extract_m3u8_formats",
            "_float",
            "report_extraction",
            "_request_webpage",
            "_download_json",
            "add_default_info_extractors",
            "report_rtmp_download",
            "report_unavailable_format",
            "_og_search_video_url",
            "_download_webpage",
            "process_ie_result",
            "post_process",
            "http_scheme",
            "_set_language",
            "to_console_title",
            "to_screen",
            "_og_search_thumbnail",
            "_ids_to_results",
            "_extract_signature_function",
            "_html_search_regex",
            "print_debug_header",
            "add_info_extractor",
            "_set_cookie",
            "add_default_extra_info",
            "_proto_relative_url",
            "working",
            "ie_key",
            "_int",
            "_make_archive_id",
            "initialize",
            "suitable",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "_extract_f4m_formats",
            "_twitter_search_player",
            "add_progress_hook",
            "report_information_extraction",
            "_FEED_TEMPLATE",
            "encode",
            "extract_id",
            "_og_search_url",
            "url_result",
            "_download_xml",
            "_live_title",
            "_og_regexes",
            "_login",
            "get_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "_search_regex",
            "extract",
            "report_video_info_webpage_download",
            "_extract_mix",
            "SEARCH_KEY",
            "IE_NAME",
            "_match_id",
            "add_extra_info",
            "report_age_confirmation",
            "restore_console_title",
            "report_warning",
            "_extract_annotations",
            "_webpage_read_content",
            "_get_tfa_info",
            "_get_n_results",
            "report_download_webpage",
            "_decrypt_signature",
            "_og_search_property",
            "download_with_info_file",
            "_get_available_automatic_caption",
            "report_error",
            "format_resolution",
            "_signature_cache_id",
            "report_file_already_downloaded",
            "_og_search_description",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "_real_extract"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1199,
          "file_complexity": 374,
          "file_token_count": 7811,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport itertools\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            ie_entries = ie_result['entries']\n            if isinstance(ie_entries, list):\n                n_all_entries = len(ie_entries)\n                entries = ie_entries[playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            elif isinstance(ie_entries, PagedList):\n                entries = ie_entries.getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n            else:  # iterable\n                entries = list(itertools.islice(\n                    ie_entries, playliststart, playlistend))\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around negative timestamps in Windows\n            # (see http://bugs.python.org/issue1646728)\n            if info_dict['timestamp'] < 0 and os.name == 'nt':\n                info_dict['timestamp'] = 0\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -7,6 +7,7 @@ import collections\n import datetime\n import errno\n import io\n+import itertools\n import json\n import locale\n import os\n@@ -654,21 +655,28 @@ class YoutubeDL(object):\n             if playlistend == -1:\n                 playlistend = None\n \n-            if isinstance(ie_result['entries'], list):\n-                n_all_entries = len(ie_result['entries'])\n-                entries = ie_result['entries'][playliststart:playlistend]\n+            ie_entries = ie_result['entries']\n+            if isinstance(ie_entries, list):\n+                n_all_entries = len(ie_entries)\n+                entries = ie_entries[playliststart:playlistend]\n                 n_entries = len(entries)\n                 self.to_screen(\n                     \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                     (ie_result['extractor'], playlist, n_all_entries, n_entries))\n-            else:\n-                assert isinstance(ie_result['entries'], PagedList)\n-                entries = ie_result['entries'].getslice(\n+            elif isinstance(ie_entries, PagedList):\n+                entries = ie_entries.getslice(\n                     playliststart, playlistend)\n                 n_entries = len(entries)\n                 self.to_screen(\n                     \"[%s] playlist %s: Downloading %d videos\" %\n                     (ie_result['extractor'], playlist, n_entries))\n+            else:  # iterable\n+                entries = list(itertools.islice(\n+                    ie_entries, playliststart, playlistend))\n+                n_entries = len(entries)\n+                self.to_screen(\n+                    \"[%s] playlist %s: Downloading %d videos\" %\n+                    (ie_result['extractor'], playlist, n_entries))\n \n             for i, entry in enumerate(entries, 1):\n                 self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n",
          "files_name_in_blame_commit": [
            "common.py",
            "youtube.py",
            "YoutubeDL.py"
          ]
        }
      },
      "9e1a5b845586a0a5431fb72467142046d8571e6f": {
        "commit": {
          "commit_id": "9e1a5b845586a0a5431fb72467142046d8571e6f",
          "commit_message": "PEP8: applied even more rules",
          "commit_author": "Jouke Waleson",
          "commit_date": "2014-11-23 21:39:15",
          "commit_parent": "2514d2635e0c8ff0fb72d00a093a849001df2bdd"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 589,
          "function_before_end_line": 718,
          "function_after_start_line": 589,
          "function_after_end_line": 720,
          "function_before_token_count": 623,
          "function_after_token_count": 623,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "warn_if_short_id",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "_verify_video_password",
            "shlex_quote",
            "list_formats",
            "_get_available_subtitles",
            "_extract_from_m3u8",
            "_confirm_age",
            "extract_videos_from_page",
            "get_params",
            "to_stderr",
            "win_service_start",
            "_sort_formats",
            "rmtree",
            "compat_getpass",
            "_get_info",
            "_print_sig_code",
            "_setup_opener",
            "_extract_video",
            "subprocess_check_output",
            "win_uninstall_service",
            "playlist_result",
            "win_service_report_event",
            "urlopen",
            "_media_rating_search",
            "_extract_video_formats",
            "_get_login_info",
            "assertRegexpMatches",
            "expect_warning",
            "_extract_entries",
            "_parse_sig_js",
            "_gen_sid",
            "read_unsigned_long_long",
            "add_post_processor",
            "_format_note",
            "_dc_search_uploader",
            "_parse_sig_swf",
            "_parse_qsl",
            "_extract_medias",
            "_og_search_title",
            "compat_expanduser",
            "expect_warnings",
            "prepare_filename",
            "_sleep",
            "_download_webpage_handle",
            "_html_search_meta",
            "warn_if_short_id",
            "_make_valid_url",
            "_watch_info",
            "set_downloader",
            "save_console_title",
            "_match_entry",
            "_fix_subtitles",
            "__init__",
            "download",
            "read_unsigned_char",
            "win_service_main",
            "_search_meta",
            "compat_print",
            "_build_url_result",
            "_write_string",
            "_extract_connections",
            "_rta_search",
            "read_asrt",
            "_real_initialize",
            "_extract_audio",
            "select_format",
            "_real_extract",
            "_extract_list_title",
            "read_string",
            "_extract_info_dict",
            "record_download_archive",
            "_get_video_info",
            "extract_info",
            "in_download_archive",
            "report_login",
            "_extract_m3u8_formats",
            "write_flv_header",
            "_ctypes_array",
            "report_extraction",
            "_float",
            "_build_result",
            "_get_thumbnail_url",
            "_request_webpage",
            "_extract_camtasia",
            "_download_json",
            "add_default_info_extractors",
            "read_box_info",
            "main",
            "_extract_captions",
            "report_rtmp_download",
            "_extract_videos",
            "compat_urllib_parse_unquote",
            "_transform_rtmp_url",
            "report_unavailable_format",
            "_og_search_video_url",
            "_download_webpage",
            "process_ie_result",
            "read_unsigned_int",
            "__md5",
            "post_process",
            "__rc4crypt",
            "_id_from_uri",
            "try_rm",
            "http_scheme",
            "build",
            "_page_url",
            "_set_language",
            "assertGreaterEqual",
            "to_console_title",
            "__str__",
            "to_screen",
            "_og_search_thumbnail",
            "_get_videos_info",
            "_extract_mobile_video_formats",
            "_ids_to_results",
            "read_afrt",
            "_extract_signature_function",
            "_html_search_regex",
            "print_debug_header",
            "win_service_handler",
            "add_info_extractor",
            "_verify_player_video_password",
            "add_default_extra_info",
            "do_GET",
            "_proto_relative_url",
            "_fix_json",
            "working",
            "_url_for_embed_code",
            "_media_xml_tag",
            "_extract_rss",
            "compat_ord",
            "ie_key",
            "_int",
            "expect_info_dict",
            "report_following_redirect",
            "build_fragments_list",
            "_make_archive_id",
            "initialize",
            "suitable",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "workaround_optparse_bug9161",
            "_extract_f4m_formats",
            "_twitter_search_player",
            "add_progress_hook",
            "build_completion",
            "report_information_extraction",
            "_FEED_TEMPLATE",
            "encode",
            "extract_id",
            "_resolv_url",
            "_build_url",
            "_og_search_url",
            "url_result",
            "_extract_asx_playlist",
            "_download_xml",
            "_live_title",
            "_add_ns",
            "win_service_set_status",
            "_og_regexes",
            "_login",
            "get_info_extractor",
            "report_disclaimer",
            "_bidi_workaround",
            "_find_video_id",
            "process_video_result",
            "_extract_result",
            "_search_regex",
            "extract",
            "report_video_info_webpage_download",
            "_extract_mix",
            "read_abst",
            "win_OpenSCManager",
            "SEARCH_KEY",
            "win_install_service",
            "IE_NAME",
            "_match_id",
            "start",
            "real_download",
            "_talk_info",
            "add_extra_info",
            "_playlist_videos_info",
            "_extract_url",
            "report_age_confirmation",
            "_extract_connection",
            "report_warning",
            "restore_console_title",
            "__exit__",
            "compat_kwargs",
            "_get_feed_url",
            "_extract_annotations",
            "_clean_query",
            "_webpage_read_content",
            "close",
            "_get_tfa_info",
            "_get_file_ID_mix_string",
            "gettestcases",
            "_get_n_results",
            "report_resolve",
            "_get_file_id",
            "report_download_webpage",
            "_decrypt_signature",
            "_og_search_property",
            "download_with_info_file",
            "_extract_info",
            "_get_available_automatic_caption",
            "report_error",
            "format_resolution",
            "_signature_cache_id",
            "_build_request",
            "_handle_error",
            "_extract_items",
            "compat_getenv",
            "report_file_already_downloaded",
            "_og_search_description",
            "read_bootstrap_info",
            "compat_parse_qs",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [
            "_bidi_workaround",
            "process_info",
            "process_video_result"
          ],
          "functions_name_co_evolved_all_files": [
            "_real_extract",
            "real_download",
            "_extract_info_dict",
            "expect_info_dict",
            "_playlist_videos_info",
            "_get_video_info",
            "_extract_video",
            "_get_feed_url",
            "_extract_video_formats",
            "process_info",
            "_extract_entries",
            "_twitter_search_player",
            "_parse_qsl",
            "build_completion",
            "_get_n_results",
            "_extract_mobile_video_formats",
            "_extract_info",
            "_login",
            "win_service_main",
            "_bidi_workaround",
            "process_video_result",
            "_search_regex",
            "_build_url_result",
            "compat_parse_qs"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1189,
          "file_complexity": 371,
          "file_token_count": 7759,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                    'contain the video, try using '\n                                    '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n    args_to_str,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def warn_if_short_id(self, argv):\n        # short YouTube ID starting with dash?\n        idxs = [\n            i for i, a in enumerate(argv)\n            if re.match(r'^-[0-9A-Za-z_-]{10}$', a)]\n        if idxs:\n            correct_argv = (\n                ['youtube-dl'] +\n                [a for i, a in enumerate(argv) if i not in idxs] +\n                ['--'] + [argv[i] for i in idxs]\n            )\n            self.report_warning(\n                'Long argument string detected. '\n                'Use -- to separate parameters and URLs, like this:\\n%s\\n' %\n                args_to_str(correct_argv))\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                      for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None:  # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de:  # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n\n            def _fixup(r):\n                self.add_extra_info(\n                    r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    }\n                )\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                                        self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                                  'contain the video, try using '\n                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                                'formats but ffmpeg or avconv are not installed.'\n                                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                # It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -314,7 +314,7 @@ class YoutubeDL(object):\n         self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n         self._output_process.stdin.flush()\n         res = ''.join(self._output_channel.readline().decode('utf-8')\n-                       for _ in range(line_count))\n+                      for _ in range(line_count))\n         return res[:-len('\\n')]\n \n     def to_screen(self, message, skip_eol=False):\n@@ -701,13 +701,15 @@ class YoutubeDL(object):\n                 'It needs to be updated.' % ie_result.get('extractor'))\n \n             def _fixup(r):\n-                self.add_extra_info(r,\n+                self.add_extra_info(\n+                    r,\n                     {\n                         'extractor': ie_result['extractor'],\n                         'webpage_url': ie_result['webpage_url'],\n                         'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                         'extractor_key': ie_result['extractor_key'],\n-                    })\n+                    }\n+                )\n                 return r\n             ie_result['entries'] = [\n                 self.process_ie_result(_fixup(r), download, extra_info)\n@@ -857,14 +859,14 @@ class YoutubeDL(object):\n                         # Two formats have been requested like '137+139'\n                         format_1, format_2 = rf.split('+')\n                         formats_info = (self.select_format(format_1, formats),\n-                            self.select_format(format_2, formats))\n+                                        self.select_format(format_2, formats))\n                         if all(formats_info):\n                             # The first format must contain the video and the\n                             # second the audio\n                             if formats_info[0].get('vcodec') == 'none':\n                                 self.report_error('The first format must '\n-                                    'contain the video, try using '\n-                                    '\"-f %s+%s\"' % (format_2, format_1))\n+                                                  'contain the video, try using '\n+                                                  '\"-f %s+%s\"' % (format_2, format_1))\n                                 return\n                             selected_format = {\n                                 'requested_formats': formats_info,\n@@ -1042,10 +1044,10 @@ class YoutubeDL(object):\n                         with open(thumb_filename, 'wb') as thumbf:\n                             shutil.copyfileobj(uf, thumbf)\n                         self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n-                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n+                                       (info_dict['extractor'], info_dict['id'], thumb_filename))\n                     except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                         self.report_warning('Unable to download thumbnail \"%s\": %s' %\n-                            (info_dict['thumbnail'], compat_str(err)))\n+                                            (info_dict['thumbnail'], compat_str(err)))\n \n         if not self.params.get('skip_download', False):\n             if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n@@ -1066,8 +1068,8 @@ class YoutubeDL(object):\n                         if not merger._executable:\n                             postprocessors = []\n                             self.report_warning('You have requested multiple '\n-                                'formats but ffmpeg or avconv are not installed.'\n-                                ' The formats won\\'t be merged')\n+                                                'formats but ffmpeg or avconv are not installed.'\n+                                                ' The formats won\\'t be merged')\n                         else:\n                             postprocessors = [merger]\n                         for f in info_dict['requested_formats']:\n",
          "files_name_in_blame_commit": [
            "f4m.py",
            "fivemin.py",
            "veehd.py",
            "jukebox.py",
            "photobucket.py",
            "generic.py",
            "collegehumor.py",
            "udemy.py",
            "francetv.py",
            "vimeo.py",
            "youku.py",
            "bbccouk.py",
            "ign.py",
            "rbmaradio.py",
            "internetvideoarchive.py",
            "nfb.py",
            "buildserver.py",
            "screencast.py",
            "metacritic.py",
            "defense.py",
            "fourtube.py",
            "metacafe.py",
            "slutload.py",
            "youporn.py",
            "discovery.py",
            "bambuser.py",
            "YoutubeDL.py",
            "lynda.py",
            "flickr.py",
            "tumblr.py",
            "ted.py",
            "teamcoco.py",
            "m6.py",
            "instagram.py",
            "weibo.py",
            "ninegag.py",
            "howcast.py",
            "myspace.py",
            "vbox7.py",
            "yahoo.py",
            "kickstarter.py",
            "myvideo.py",
            "setup.py",
            "dailymotion.py",
            "ehow.py",
            "vk.py",
            "traileraddict.py",
            "firsttv.py",
            "theplatform.py",
            "normalboots.py",
            "videofyme.py",
            "naver.py",
            "ustream.py",
            "youtube.py",
            "fktv.py",
            "appletrailers.py",
            "smotri.py",
            "cnn.py",
            "dropbox.py",
            "stanfordoc.py",
            "ooyala.py",
            "facebook.py",
            "vesti.py",
            "common.py",
            "tinypic.py",
            "xnxx.py",
            "compat.py",
            "nhl.py",
            "mtv.py",
            "sbs.py",
            "helper.py",
            "sina.py",
            "fish-completion.py",
            "niconico.py",
            "xhamster.py",
            "tf1.py",
            "soundcloud.py"
          ]
        }
      },
      "42e12102a979a03f156e71fc86006f61c905f7dd": {
        "commit": {
          "commit_id": "42e12102a979a03f156e71fc86006f61c905f7dd",
          "commit_message": "[YoutubeDL] Fix multi_video check",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-11-21 22:39:57",
          "commit_parent": "6127693ed9b7157bff55dd495a1da66e0f61c4d1"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or playlist == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist' or result_type == 'multi_video':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 572,
          "function_before_end_line": 700,
          "function_after_start_line": 572,
          "function_after_end_line": 700,
          "function_before_token_count": 623,
          "function_after_token_count": 623,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1172,
          "file_complexity": 364,
          "file_token_count": 7670,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or playlist == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                    'contain the video, try using '\n                                    '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist' or result_type == 'multi_video':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                    'contain the video, try using '\n                                    '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -624,7 +624,7 @@ class YoutubeDL(object):\n \n             return self.process_ie_result(\n                 new_result, download=download, extra_info=extra_info)\n-        elif result_type == 'playlist' or playlist == 'multi_video':\n+        elif result_type == 'playlist' or result_type == 'multi_video':\n             # We process each entry in the playlist\n             playlist = ie_result.get('title', None) or ie_result.get('id', None)\n             self.to_screen('[download] Downloading playlist: %s' % playlist)\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "c9bf41145fc7c722eb9b5ae528642976177c1b14": {
        "commit": {
          "commit_id": "c9bf41145fc7c722eb9b5ae528642976177c1b14",
          "commit_message": "[YoutubeDL] Warn if an extractor returns compat_list",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-11-20 16:29:31",
          "commit_parent": "5239075bb684bc2c19978dde70e3954bbe7a62de"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n        self.report_warning('Extractor %s returned a compat_list result. It needs to be updated.' % ie_result.get('extractor'))\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 572,
          "function_before_end_line": 697,
          "function_after_start_line": 572,
          "function_after_end_line": 700,
          "function_before_token_count": 605,
          "function_after_token_count": 619,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1172,
          "file_complexity": 363,
          "file_token_count": 7666,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                    'contain the video, try using '\n                                    '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            self.report_warning(\n                'Extractor %s returned a compat_list result. '\n                'It needs to be updated.' % ie_result.get('extractor'))\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            # The first format must contain the video and the\n                            # second the audio\n                            if formats_info[0].get('vcodec') == 'none':\n                                self.report_error('The first format must '\n                                    'contain the video, try using '\n                                    '\"-f %s+%s\"' % (format_2, format_1))\n                                return\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, infofn)\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        stdout_encoding = getattr(\n            sys.stdout, 'encoding', 'missing (%s)' % type(sys.stdout).__name__)\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                stdout_encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -679,6 +679,9 @@ class YoutubeDL(object):\n             ie_result['entries'] = playlist_results\n             return ie_result\n         elif result_type == 'compat_list':\n+            self.report_warning(\n+                'Extractor %s returned a compat_list result. '\n+                'It needs to be updated.' % ie_result.get('extractor'))\n             def _fixup(r):\n                 self.add_extra_info(r,\n                     {\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "a1cf99d03a6a842aa4e53c211c9f38dd27db5971": {
        "commit": {
          "commit_id": "a1cf99d03a6a842aa4e53c211c9f38dd27db5971",
          "commit_message": "[YoutubeDL] Add playlist_id and playlist_title fields (Fixes #4139)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-11-09 22:32:35",
          "commit_parent": "3c6af203cc615f835e8ff95508e04d908950249c"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_id': ie_result.get('id'), 'playlist_title': ie_result.get('title'), 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 572,
          "function_before_end_line": 695,
          "function_after_start_line": 572,
          "function_after_end_line": 697,
          "function_before_token_count": 587,
          "function_after_token_count": 605,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "_real_initialize",
            "_get_available_subtitles",
            "_extract_from_m3u8",
            "select_format",
            "_confirm_age",
            "_real_extract",
            "extract_videos_from_page",
            "IE_NAME",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "_print_sig_code",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "report_rtmp_download",
            "_extract_mix",
            "__enter__",
            "trouble",
            "_extract_annotations",
            "suitable",
            "parseOpts",
            "get_encoding",
            "report_unavailable_format",
            "process_info",
            "process_ie_result",
            "_parse_sig_js",
            "post_process",
            "add_post_processor",
            "_format_note",
            "_parse_sig_swf",
            "prepare_filename",
            "add_progress_hook",
            "_set_language",
            "report_information_extraction",
            "_get_n_results",
            "encode",
            "to_console_title",
            "extract_id",
            "_FEED_TEMPLATE",
            "to_screen",
            "_decrypt_signature",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "_get_available_automatic_caption",
            "report_error",
            "format_resolution",
            "_signature_cache_id",
            "download",
            "_login",
            "_extract_signature_function",
            "_ids_to_results",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "report_video_info_webpage_download",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "parseOpts"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1167,
          "file_complexity": 363,
          "file_token_count": 7637,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        # The first format must contain the video and the\n                        # second the audio\n                        if formats_info[0].get('vcodec') == 'none':\n                            self.report_error('The first format must contain '\n                                'the video, try using \"-f %s+%s\"' %\n                                (format_2, format_1))\n                            return\n                        if all(formats_info):\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .compat import (\n    compat_cookiejar,\n    compat_expanduser,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n)\nfrom .utils import (\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .downloader.rtmp import rtmpdump_version\nfrom .postprocessor import FFmpegMergerPP, FFmpegPostProcessor\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    dump_single_json:  Force printing the info_dict of the whole playlist\n                       (or video) as a single JSON line.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None, auto_init=True):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n        if auto_init:\n            self.print_debug_header()\n            self.add_default_info_extractors()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = compat_expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_id': ie_result.get('id'),\n                    'playlist_title': ie_result.get('title'),\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        # The first format must contain the video and the\n                        # second the audio\n                        if formats_info[0].get('vcodec') == 'none':\n                            self.report_error('The first format must contain '\n                                'the video, try using \"-f %s+%s\"' %\n                                (format_2, format_1))\n                            return\n                        if all(formats_info):\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n        if self.params.get('dump_single_json', False):\n            info_dict['_filename'] = filename\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._executable:\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                res = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n            else:\n                if self.params.get('dump_single_json', False):\n                    self.to_stdout(json.dumps(res))\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('fps') is not None:\n            res += ', %sfps' % fdict['fps']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s\\n' % (\n            platform.python_version(), platform_name()))\n\n        exe_versions = FFmpegPostProcessor.get_versions()\n        exe_versions['rtmpdump'] = rtmpdump_version()\n        exe_str = ', '.join(\n            '%s %s' % (exe, v)\n            for exe, v in sorted(exe_versions.items())\n            if v\n        )\n        if not exe_str:\n            exe_str = 'none'\n        self._write_string('[debug] exe versions: %s\\n' % exe_str)\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -658,6 +658,8 @@ class YoutubeDL(object):\n                 extra = {\n                     'n_entries': n_entries,\n                     'playlist': playlist,\n+                    'playlist_id': ie_result.get('id'),\n+                    'playlist_title': ie_result.get('title'),\n                     'playlist_index': i + playliststart,\n                     'extractor': ie_result['extractor'],\n                     'webpage_url': ie_result['webpage_url'],\n",
          "files_name_in_blame_commit": [
            "options.py",
            "youtube.py",
            "YoutubeDL.py"
          ]
        }
      },
      "057a5206cc602f2b6b4a622530df5244f1b41782": {
        "commit": {
          "commit_id": "057a5206cc602f2b6b4a622530df5244f1b41782",
          "commit_message": "Add --flat-playlist option (Closes #4003)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-10-24 14:48:12",
          "commit_parent": "b1edd7a48ace472f89cda7503f104a98fc67ee30"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if self.params.get('extract_flat', False):\n        if result_type in ('url', 'url_transparent'):\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type in ('url', 'url_transparent'):\n        extract_flat = self.params.get('extract_flat', False)\n        if extract_flat == 'in_playlist' and 'playlist' in extra_info or extract_flat is True:\n            self.add_extra_info(ie_result, extra_info)\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 560,
          "function_before_end_line": 679,
          "function_after_start_line": 562,
          "function_after_end_line": 686,
          "function_before_token_count": 547,
          "function_after_token_count": 595,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "main",
            "parseOpts",
            "__enter__",
            "trouble",
            "_real_main",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "parseOpts",
            "_real_main"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1135,
          "file_complexity": 355,
          "file_token_count": 7451,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if self.params.get('extract_flat', False):\n            if result_type in ('url', 'url_transparent'):\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    escape_url,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .cache import Cache\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       False to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n                       Pass in 'in_playlist' to only show this behavior for\n                       playlist items.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    exec_cmd:          Arbitrary command to run after downloading\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n        self.cache = Cache(self)\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params.get('restrictfilenames', False)):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all characters. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if result_type in ('url', 'url_transparent'):\n            extract_flat = self.params.get('extract_flat', False)\n            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n                    extract_flat is True):\n                self.add_extra_info(ie_result, extra_info)\n                if self.params.get('forcejson', False):\n                    self.to_stdout(json.dumps(ie_result))\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp', 'm4a']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            for rfstr in req_format.split(','):\n                # We can accept formats requested in the format: 34/5/best, we pick\n                # the first that is available, starting from left\n                req_formats = rfstr.split('/')\n                for rf in req_formats:\n                    if re.match(r'.+?\\+.+?', rf) is not None:\n                        # Two formats have been requested like '137+139'\n                        format_1, format_2 = rf.split('+')\n                        formats_info = (self.select_format(format_1, formats),\n                            self.select_format(format_2, formats))\n                        if all(formats_info):\n                            selected_format = {\n                                'requested_formats': formats_info,\n                                'format': rf,\n                                'ext': formats_info[0]['ext'],\n                            }\n                        else:\n                            selected_format = None\n                    else:\n                        selected_format = self.select_format(rf, formats)\n                    if selected_format is not None:\n                        formats_to_download.append(selected_format)\n                        break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        req_is_string = isinstance(req, basestring if sys.version_info < (3, 0) else compat_str)\n        url = req if req_is_string else req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            if req_is_string:\n                req = url_escaped\n            else:\n                req = compat_urllib_request.Request(\n                    url_escaped, data=req.data, headers=req.headers,\n                    origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -165,6 +165,8 @@ class YoutubeDL(object):\n                        'auto' for elaborate guessing\n     encoding:          Use this encoding instead of the system-specified.\n     extract_flat:      Do not resolve URLs, return the immediate result.\n+                       Pass in 'in_playlist' to only show this behavior for\n+                       playlist items.\n \n     The following parameters are not used by YoutubeDL itself, they are used by\n     the FileDownloader:\n@@ -568,8 +570,13 @@ class YoutubeDL(object):\n \n         result_type = ie_result.get('_type', 'video')\n \n-        if self.params.get('extract_flat', False):\n-            if result_type in ('url', 'url_transparent'):\n+        if result_type in ('url', 'url_transparent'):\n+            extract_flat = self.params.get('extract_flat', False)\n+            if ((extract_flat == 'in_playlist' and 'playlist' in extra_info) or\n+                    extract_flat is True):\n+                self.add_extra_info(ie_result, extra_info)\n+                if self.params.get('forcejson', False):\n+                    self.to_stdout(json.dumps(ie_result))\n                 return ie_result\n \n         if result_type == 'video':\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "options.py",
            "YoutubeDL.py"
          ]
        }
      },
      "c6b4132a0ad568b8383dfb64689b7d45182f275a": {
        "commit": {
          "commit_id": "c6b4132a0ad568b8383dfb64689b7d45182f275a",
          "commit_message": "renamed for consistency",
          "commit_author": "Gjorgji Jankovski",
          "commit_date": "2014-08-24 18:49:04",
          "commit_parent": "ad260c90abc6361051d7ae8f9226260f82d63c53"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if self.params.get('extract_flat', False):\n        if result_type in ('url', 'url_transparent'):\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_playlist': n_entries, 'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if self.params.get('extract_flat', False):\n        if result_type in ('url', 'url_transparent'):\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'n_entries': n_entries, 'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 556,
          "function_before_end_line": 675,
          "function_after_start_line": 556,
          "function_after_end_line": 675,
          "function_before_token_count": 547,
          "function_after_token_count": 547,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [
            "prepare_filename"
          ],
          "functions_name_co_evolved_all_files": [
            "prepare_filename"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1113,
          "file_complexity": 347,
          "file_token_count": 7289,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_playlist'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if self.params.get('extract_flat', False):\n            if result_type in ('url', 'url_transparent'):\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_playlist': n_entries,\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            actual_age_limit = info_dict.get('age_limit')\n            if actual_age_limit is None:\n                actual_age_limit = 0\n            if age_limit < actual_age_limit:\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if self.params.get('extract_flat', False):\n            if result_type in ('url', 'url_transparent'):\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'n_entries': n_entries,\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -424,7 +424,7 @@ class YoutubeDL(object):\n             autonumber_templ = '%0' + str(autonumber_size) + 'd'\n             template_dict['autonumber'] = autonumber_templ % self._num_downloads\n             if template_dict.get('playlist_index') is not None:\n-                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_playlist'])), template_dict['playlist_index'])\n+                template_dict['playlist_index'] = '%0*d' % (len(str(template_dict['n_entries'])), template_dict['playlist_index'])\n             if template_dict.get('resolution') is None:\n                 if template_dict.get('width') and template_dict.get('height'):\n                     template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n@@ -636,7 +636,7 @@ class YoutubeDL(object):\n             for i, entry in enumerate(entries, 1):\n                 self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                 extra = {\n-                    'n_playlist': n_entries,\n+                    'n_entries': n_entries,\n                     'playlist': playlist,\n                     'playlist_index': i + playliststart,\n                     'extractor': ie_result['extractor'],\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844": {
        "commit": {
          "commit_id": "e8ee972c6ea211a51275c8eb8bfc81b9ae3a9844",
          "commit_message": "Allow playlist test definitions in test_download.\n\nThis moves playlist tests where they belong, i.e. to the extractors themselves.\nAdditionally, all our network interaction configuration for tests in test_download now applies to playlist tests as well.",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-08-21 11:52:07",
          "commit_parent": "af8322d2f993653dbec5e6ad943f8cc632b901e4"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if self.params.get('extract_flat', False):\n        if result_type in ('url', 'url_transparent'):\n            return ie_result\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 552,
          "function_before_end_line": 665,
          "function_after_start_line": 553,
          "function_after_end_line": 671,
          "function_before_token_count": 520,
          "function_after_token_count": 543,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "_format_note",
            "prepare_filename",
            "add_progress_hook",
            "encode",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "get_params",
            "to_stderr",
            "record_download_archive",
            "generator",
            "add_extra_info",
            "expect_info_dict",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "report_warning",
            "restore_console_title",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "get_encoding",
            "process_info",
            "assertRegexpMatches",
            "process_ie_result",
            "expect_warning",
            "post_process",
            "add_post_processor",
            "try_rm",
            "_format_note",
            "gettestcases",
            "prepare_filename",
            "add_progress_hook",
            "assertGreaterEqual",
            "to_console_title",
            "_file_md5",
            "encode",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "setUp",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "add_default_extra_info",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout",
            "_write_string"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "generator",
            "expect_info_dict"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 1109,
          "file_complexity": 346,
          "file_token_count": 7263,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport datetime\nimport errno\nimport io\nimport json\nimport locale\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    DEFAULT_OUTTMPL,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    no_warnings:       Do not print out anything for warnings.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    prefer_insecure:   Use HTTP instead of HTTPS to retrieve information.\n                       At the moment, this is only supported by YouTube.\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n    include_ads:       Download ads as well\n    default_search:    Prepend this string if an input url is not valid.\n                       'auto' for elaborate guessing\n    encoding:          Use this encoding instead of the system-specified.\n    extract_flat:      Do not resolve URLs, return the immediate result.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert isinstance(message, compat_str)\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def _write_string(self, s, out=None):\n        write_string(s, out=out, encoding=self.params.get('encoding'))\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            self._write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert isinstance(message, compat_str)\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            self._write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            self._write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            self._write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            self._write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self.params.get('logger') is not None:\n            self.params['logger'].warning(message)\n        else:\n            if self.params.get('no_warnings'):\n                return\n            if self._err_file.isatty() and os.name != 'nt':\n                _msg_header = '\\033[0;33mWARNING:\\033[0m'\n            else:\n                _msg_header = 'WARNING:'\n            warning_message = '%s %s' % (_msg_header, message)\n            self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n            if template_dict.get('resolution') is None:\n                if template_dict.get('width') and template_dict.get('height'):\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif template_dict.get('height'):\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif template_dict.get('width'):\n                    template_dict['resolution'] = '?x%d' % template_dict['width']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n            tmpl = os.path.expanduser(outtmpl)\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_default_extra_info(ie_result, ie, url)\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except MaxDownloadsReached:\n                raise\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor for URL %s' % url)\n\n    def add_default_extra_info(self, ie_result, ie, url):\n        self.add_extra_info(ie_result, {\n            'extractor': ie.IE_NAME,\n            'webpage_url': url,\n            'webpage_url_basename': url_basename(url),\n            'extractor_key': ie.ie_key(),\n        })\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video')\n\n        if self.params.get('extract_flat', False):\n            if result_type in ('url', 'url_transparent'):\n                return ie_result\n\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        elif format_spec == 'bestaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[-1]\n        elif format_spec == 'worstaudio':\n            audio_formats = [\n                f for f in available_formats\n                if f.get('vcodec') == 'none']\n            if audio_formats:\n                return audio_formats[0]\n        elif format_spec == 'bestvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[-1]\n        elif format_spec == 'worstvideo':\n            video_formats = [\n                f for f in available_formats\n                if f.get('acodec') == 'none']\n            if video_formats:\n                return video_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('width'), t.get('height'), t.get('url')))\n            for t in thumbnails:\n                if 'width' in t and 'height' in t:\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n\n        if thumbnails and 'thumbnail' not in info_dict:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n\n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n\n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            upload_date = datetime.datetime.utcfromtimestamp(\n                info_dict['timestamp'])\n            info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        if not formats:\n            raise ExtractorError('No video formats found!')\n\n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            if 'url' not in format:\n                raise ExtractorError('Missing \"url\" key in result (index %d)' % i)\n\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url']).lower()\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads >= int(max_downloads):\n                raise MaxDownloadsReached()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if 'format' not in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        self._num_downloads += 1\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + sub_filename)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = self.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        if self.params.get('verbose'):\n                            self.to_stdout('[debug] Invoking downloader on %r' % info.get('url'))\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self, not self.params.get('keepvideo'))\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n        if (len(url_list) > 1 and\n                '%' not in outtmpl\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(outtmpl)\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def _format_note(self, fdict):\n        res = ''\n        if fdict.get('ext') in ['f4f', 'f4m']:\n            res += '(unsupported) '\n        if fdict.get('format_note') is not None:\n            res += fdict['format_note'] + ' '\n        if fdict.get('tbr') is not None:\n            res += '%4dk ' % fdict['tbr']\n        if fdict.get('container') is not None:\n            if res:\n                res += ', '\n            res += '%s container' % fdict['container']\n        if (fdict.get('vcodec') is not None and\n                fdict.get('vcodec') != 'none'):\n            if res:\n                res += ', '\n            res += fdict['vcodec']\n            if fdict.get('vbr') is not None:\n                res += '@'\n        elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n            res += 'video@'\n        if fdict.get('vbr') is not None:\n            res += '%4dk' % fdict['vbr']\n        if fdict.get('acodec') is not None:\n            if res:\n                res += ', '\n            if fdict['acodec'] == 'none':\n                res += 'video only'\n            else:\n                res += '%-5s' % fdict['acodec']\n        elif fdict.get('abr') is not None:\n            if res:\n                res += ', '\n            res += 'audio'\n        if fdict.get('abr') is not None:\n            res += '@%3dk' % fdict['abr']\n        if fdict.get('asr') is not None:\n            res += ' (%5dHz)' % fdict['asr']\n        if fdict.get('filesize') is not None:\n            if res:\n                res += ', '\n            res += format_bytes(fdict['filesize'])\n        elif fdict.get('filesize_approx') is not None:\n            if res:\n                res += ', '\n            res += '~' + format_bytes(fdict['filesize_approx'])\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                self._format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if self._format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if self._format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req, timeout=self._socket_timeout)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n\n        if type('') is not compat_str:\n            # Python 2.6 on SLES11 SP1 (https://github.com/rg3/youtube-dl/issues/3326)\n            self.report_warning(\n                'Your Python is broken! Update to a newer and supported version')\n\n        encoding_str = (\n            '[debug] Encodings: locale %s, fs %s, out %s, pref %s\\n' % (\n                locale.getpreferredencoding(),\n                sys.getfilesystemencoding(),\n                sys.stdout.encoding,\n                self.get_encoding()))\n        write_string(encoding_str, encoding=None)\n\n        self._write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                self._write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        self._write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        self._write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        self._socket_timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n    def encode(self, s):\n        if isinstance(s, bytes):\n            return s  # Already encoded\n\n        try:\n            return s.encode(self.get_encoding())\n        except UnicodeEncodeError as err:\n            err.reason = err.reason + '. Check your system encoding configuration or use the --encoding option.'\n            raise\n\n    def get_encoding(self):\n        encoding = self.params.get('encoding')\n        if encoding is None:\n            encoding = preferredencoding()\n        return encoding\n",
          "file_patch": "@@ -162,6 +162,7 @@ class YoutubeDL(object):\n     default_search:    Prepend this string if an input url is not valid.\n                        'auto' for elaborate guessing\n     encoding:          Use this encoding instead of the system-specified.\n+    extract_flat:      Do not resolve URLs, return the immediate result.\n \n     The following parameters are not used by YoutubeDL itself, they are used by\n     the FileDownloader:\n@@ -558,7 +559,12 @@ class YoutubeDL(object):\n         Returns the resolved ie_result.\n         \"\"\"\n \n-        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n+        result_type = ie_result.get('_type', 'video')\n+\n+        if self.params.get('extract_flat', False):\n+            if result_type in ('url', 'url_transparent'):\n+                return ie_result\n+\n         if result_type == 'video':\n             self.add_extra_info(ie_result, extra_info)\n             return self.process_video_result(ie_result, download=download)\n",
          "files_name_in_blame_commit": [
            "test_download.py",
            "helper.py",
            "YoutubeDL.py"
          ]
        }
      },
      "b7ab05908440915c6c5faa541abe00c62a88bc27": {
        "commit": {
          "commit_id": "b7ab05908440915c6c5faa541abe00c62a88bc27",
          "commit_message": "Add infrastructure for paged lists\n\nThis commit allows to download pages in playlists as needed instead of all at once.\nBefore this commit,\n    youtube-dl http://www.youtube.com/user/ANNnewsCH/videos --playlist-end 2 --skip-download\ntook quite some time - now it's almost instantaneous.\nAs an example, the youtube:user extractor has been converted.\nFixes #2175",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-01-20 11:36:47",
          "commit_parent": "c91778f8c0ba120378cb806f694fdc3f94a5634c"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        if isinstance(ie_result['entries'], list):\n            n_all_entries = len(ie_result['entries'])\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Collected %d video ids (downloading %d of them)' % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        else:\n            assert isinstance(ie_result['entries'], PagedList)\n            entries = ie_result['entries'].getslice(playliststart, playlistend)\n            n_entries = len(entries)\n            self.to_screen('[%s] playlist %s: Downloading %d videos' % (ie_result['extractor'], playlist, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 525,
          "function_before_end_line": 630,
          "function_after_start_line": 526,
          "function_after_end_line": 639,
          "function_before_token_count": 461,
          "function_after_token_count": 520,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "add_progress_hook",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_all_files": [
            "list_formats",
            "_get_available_subtitles",
            "_static_decrypt_signature",
            "_extract_from_m3u8",
            "_confirm_age",
            "str_to_int",
            "extract_videos_from_page",
            "to_stderr",
            "hyphenate_date",
            "_print_sig_code",
            "deflate",
            "test_unescape_html",
            "_setup_opener",
            "remove_start",
            "clean_html",
            "format_bytes",
            "urlopen",
            "error",
            "unsmuggle_url",
            "month_by_name",
            "_parse_sig_js",
            "takewhile_inclusive",
            "add_post_processor",
            "_parse_sig_swf",
            "_parse_qsl",
            "handle_endtag",
            "compat_parse_qs",
            "prepare_filename",
            "sanitize_filename",
            "test_shell_quote",
            "save_console_title",
            "_match_entry",
            "get_meta_content",
            "__init__",
            "preferredencoding",
            "check_executable",
            "download",
            "write_json_file",
            "test_xpath_with_ns",
            "decodeOption",
            "http_response",
            "compat_print",
            "_extract_id",
            "_real_initialize",
            "test_smuggle_url",
            "select_format",
            "_real_extract",
            "record_download_archive",
            "write_string",
            "extract_info",
            "in_download_archive",
            "platform_name",
            "write",
            "fix_xml_all_ampersand",
            "_unquote",
            "format_traceback",
            "sanitize_open",
            "add_default_info_extractors",
            "report_rtmp_download",
            "prepend_extension",
            "__contains__",
            "report_unavailable_format",
            "process_ie_result",
            "post_process",
            "test_ordered_set",
            "addinfourl_wrapper",
            "_set_language",
            "to_console_title",
            "to_screen",
            "__str__",
            "day",
            "_lock_file",
            "htmlentity_transform",
            "_ids_to_results",
            "_extract_signature_function",
            "print_debug_header",
            "add_info_extractor",
            "test_url_basename",
            "shell_quote",
            "smuggle_url",
            "orderedSet",
            "test_sanitize_ids",
            "subtitles_filename",
            "test_sanitize_filename_restricted",
            "compat_ord",
            "test_meta_parser",
            "read",
            "find_startpos",
            "int_or_none",
            "test_paged_list",
            "_make_archive_id",
            "suitable",
            "__enter__",
            "trouble",
            "increment_downloads",
            "bytes_to_intlist",
            "parse_duration",
            "process_info",
            "unescapeHTML",
            "loads",
            "test_find_xpath_attr",
            "add_progress_hook",
            "report_information_extraction",
            "_FEED_TEMPLATE",
            "encodeFilename",
            "find_xpath_attr",
            "_login",
            "get_info_extractor",
            "_get_video_url_list",
            "_bidi_workaround",
            "process_video_result",
            "report_video_info_webpage_download",
            "_extract_mix",
            "formatSeconds",
            "test_daterange",
            "IE_NAME",
            "add_extra_info",
            "test_str_to_int",
            "restore_console_title",
            "report_warning",
            "make_HTTPS_handler",
            "handle_starttag",
            "unified_strdate",
            "__exit__",
            "determine_ext",
            "__iter__",
            "_extract_annotations",
            "test_unified_dates",
            "get_cachedir",
            "test_parse_duration",
            "get_result",
            "url_basename",
            "timeconvert",
            "_unlock_file",
            "date_from_str",
            "setproctitle",
            "get_method",
            "_get_n_results",
            "xpath_with_ns",
            "get_element_by_attribute",
            "__init",
            "getslice",
            "test_sanitize_filename",
            "_get_available_automatic_caption",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "http_request",
            "test_timeconvert",
            "get_term_width",
            "get_element_by_id",
            "intlist_to_bytes",
            "report_file_already_downloaded",
            "_decrypt_signature",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "_real_extract",
            "test_paged_list",
            "__init__",
            "getslice"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 993,
          "file_complexity": 291,
          "file_token_count": 6469,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert type(message) == type('')\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type('')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = 'WARNING:'\n        warning_message = '%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'webpage_url_basename': url_basename(url),\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                \"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict: \n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself, \n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self)\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = ''\n            if fdict.get('ext') in ['f4f', 'f4m']:\n                res += '(unsupported) '\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + ' '\n            if fdict.get('tbr') is not None:\n                res += '%4dk ' % fdict['tbr']\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += '%-5s' % fdict['vcodec']\n                if fdict.get('vbr') is not None:\n                    res += '@'\n            elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n                res += 'video@'\n            if fdict.get('vbr') is not None:\n                res += '%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += ', '\n                res += '%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += ', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += '@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += ', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PagedList,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n    prepend_extension,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .postprocessor import FFmpegMergerPP\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n\n    The following options are used by the post processors:\n    prefer_ffmpeg:     If True, use ffmpeg instead of avconv if both are available,\n                       otherwise prefer avconv.\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert type(message) == type('')\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type('')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = 'WARNING:'\n        warning_message = '%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'webpage_url_basename': url_basename(url),\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            if isinstance(ie_result['entries'], list):\n                n_all_entries = len(ie_result['entries'])\n                entries = ie_result['entries'][playliststart:playlistend]\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n            else:\n                assert isinstance(ie_result['entries'], PagedList)\n                entries = ie_result['entries'].getslice(\n                    playliststart, playlistend)\n                n_entries = len(entries)\n                self.to_screen(\n                    \"[%s] playlist %s: Downloading %d videos\" %\n                    (ie_result['extractor'], playlist, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict: \n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself, \n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requested in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                if re.match(r'.+?\\+.+?', rf) is not None:\n                    # Two formats have been requested like '137+139'\n                    format_1, format_2 = rf.split('+')\n                    formats_info = (self.select_format(format_1, formats),\n                        self.select_format(format_2, formats))\n                    if all(formats_info):\n                        selected_format = {\n                            'requested_formats': formats_info,\n                            'format': rf,\n                            'ext': formats_info[0]['ext'],\n                        }\n                    else:\n                        selected_format = None\n                else:\n                    selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    def dl(name, info):\n                        fd = get_suitable_downloader(info)(self, self.params)\n                        for ph in self._progress_hooks:\n                            fd.add_progress_hook(ph)\n                        return fd.download(name, info)\n                    if info_dict.get('requested_formats') is not None:\n                        downloaded = []\n                        success = True\n                        merger = FFmpegMergerPP(self)\n                        if not merger._get_executable():\n                            postprocessors = []\n                            self.report_warning('You have requested multiple '\n                                'formats but ffmpeg or avconv are not installed.'\n                                ' The formats won\\'t be merged')\n                        else:\n                            postprocessors = [merger]\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            new_info.update(f)\n                            fname = self.prepare_filename(new_info)\n                            fname = prepend_extension(fname, 'f%s' % f['format_id'])\n                            downloaded.append(fname)\n                            partial_success = dl(fname, new_info)\n                            success = success and partial_success\n                        info_dict['__postprocessors'] = postprocessors\n                        info_dict['__files_to_merge'] = downloaded\n                    else:\n                        # Just a single file\n                        success = dl(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        pps_chain = []\n        if ie_info.get('__postprocessors') is not None:\n            pps_chain.extend(ie_info['__postprocessors'])\n        pps_chain.extend(self._pps)\n        for pp in pps_chain:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = ''\n            if fdict.get('ext') in ['f4f', 'f4m']:\n                res += '(unsupported) '\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + ' '\n            if fdict.get('tbr') is not None:\n                res += '%4dk ' % fdict['tbr']\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += '%-5s' % fdict['vcodec']\n                if fdict.get('vbr') is not None:\n                    res += '@'\n            elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n                res += 'video@'\n            if fdict.get('vbr') is not None:\n                res += '%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += ', '\n                res += '%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += ', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += '@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += ', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_patch": "@@ -39,6 +39,7 @@ from .utils import (\n     locked_file,\n     make_HTTPS_handler,\n     MaxDownloadsReached,\n+    PagedList,\n     PostProcessingError,\n     platform_name,\n     preferredencoding,\n@@ -575,19 +576,27 @@ class YoutubeDL(object):\n \n             playlist_results = []\n \n-            n_all_entries = len(ie_result['entries'])\n             playliststart = self.params.get('playliststart', 1) - 1\n             playlistend = self.params.get('playlistend', None)\n             # For backwards compatibility, interpret -1 as whole list\n             if playlistend == -1:\n                 playlistend = None\n \n-            entries = ie_result['entries'][playliststart:playlistend]\n-            n_entries = len(entries)\n-\n-            self.to_screen(\n-                \"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n-                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n+            if isinstance(ie_result['entries'], list):\n+                n_all_entries = len(ie_result['entries'])\n+                entries = ie_result['entries'][playliststart:playlistend]\n+                n_entries = len(entries)\n+                self.to_screen(\n+                    \"[%s] playlist %s: Collected %d video ids (downloading %d of them)\" %\n+                    (ie_result['extractor'], playlist, n_all_entries, n_entries))\n+            else:\n+                assert isinstance(ie_result['entries'], PagedList)\n+                entries = ie_result['entries'].getslice(\n+                    playliststart, playlistend)\n+                n_entries = len(entries)\n+                self.to_screen(\n+                    \"[%s] playlist %s: Downloading %d videos\" %\n+                    (ie_result['extractor'], playlist, n_entries))\n \n             for i, entry in enumerate(entries, 1):\n                 self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n",
          "files_name_in_blame_commit": [
            "utils.py",
            "test_utils.py",
            "youtube.py",
            "YoutubeDL.py"
          ]
        }
      },
      "6febd1c1df02870bf8b529ca758d7155cf65ab35": {
        "commit": {
          "commit_id": "6febd1c1df02870bf8b529ca758d7155cf65ab35",
          "commit_message": "Prepare widespread unicode literal use",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2014-01-05 01:52:03",
          "commit_parent": "a7c26e7338ceed06b579775f315b078644a7482b"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen('[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen('[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 519,
          "function_before_end_line": 624,
          "function_after_start_line": 519,
          "function_after_end_line": 624,
          "function_before_token_count": 465,
          "function_after_token_count": 461,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "add_progress_hook",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "add_progress_hook",
            "to_console_title",
            "to_screen",
            "test_all_files",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "extract_info",
            "report_warning",
            "restore_console_title",
            "_make_archive_id",
            "trouble",
            "process_info",
            "post_process",
            "prepare_filename",
            "to_console_title",
            "save_console_title",
            "_match_entry",
            "download_with_info_file",
            "__init__",
            "format_resolution",
            "report_error",
            "download",
            "print_debug_header",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "to_stdout"
          ],
          "functions_name_co_evolved_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "extract_info",
            "report_warning",
            "restore_console_title",
            "_make_archive_id",
            "trouble",
            "process_info",
            "post_process",
            "prepare_filename",
            "to_console_title",
            "test_all_files",
            "save_console_title",
            "_match_entry",
            "download_with_info_file",
            "__init__",
            "format_resolution",
            "report_error",
            "download",
            "print_debug_header",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "to_stdout"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 934,
          "file_complexity": 281,
          "file_token_count": 6137,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert type(message) == type(u'')\n        line_count = message.count(u'\\n') + 1\n        self._output_process.stdin.write((message + u'\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = u''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len(u'\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + u'\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return u'%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'webpage_url_basename': url_basename(url),\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict: \n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself, \n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + u'.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen(u'[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + u'.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen(u'[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen(u'[info] Video description metadata is already present')\n            else:\n                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    fd = get_suitable_downloader(info_dict)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    success = fd.download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        elif format.get('width') is not None:\n            res = u'?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('ext') in ['f4f', 'f4m']:\n                res += u'(unsupported) '\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if fdict.get('tbr') is not None:\n                res += u'%4dk ' % fdict['tbr']\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s@' % fdict['vcodec']\n            elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n                res += u'video@'\n            if fdict.get('vbr') is not None:\n                res += u'%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            'resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .downloader import get_suitable_downloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n    debug_printtraffic:Print out sent and received HTTP traffic\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        if params is None:\n            params = {}\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                sp_kwargs = dict(\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                try:\n                    self._output_process = subprocess.Popen(\n                        ['bidiv'] + width_args, **sp_kwargs\n                    )\n                except OSError:\n                    self._output_process = subprocess.Popen(\n                        ['fribidi', '-c', 'UTF-8'] + width_args, **sp_kwargs)\n                self._output_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                'Assuming --restrict-filenames since file system encoding '\n                'cannot encode all charactes. '\n                'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def add_progress_hook(self, ph):\n        \"\"\"Add the progress hook (currently only for the file downloader)\"\"\"\n        self._progress_hooks.append(ph)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_output_channel'):\n            return message\n\n        assert hasattr(self, '_output_process')\n        assert type(message) == type('')\n        line_count = message.count('\\n') + 1\n        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n        self._output_process.stdin.flush()\n        res = ''.join(self._output_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len('\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = ['\\n', ''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type('')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + '\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string('\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string('\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string('\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = 'WARNING:'\n        warning_message = '%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = '\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = 'ERROR:'\n        error_message = '%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen('[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen('[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == 'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return 'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return '%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning('The program functionality for this site has been marked as broken, '\n                                    'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'webpage_url_basename': url_basename(url),\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error('no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen('[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                \"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen('[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = ['mp4', 'flv', 'webm', '3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in ['Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n\n        # TODO Central sorting goes here\n\n        if formats[0] is not info_dict: \n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself, \n            # wich can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + '...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen('[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error('unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + '.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen('[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning('There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + '.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error('Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + '.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen('[info] Video description metadata is already present')\n            else:\n                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    write_json_file(info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    fd = get_suitable_downloader(info_dict)(self, self.params)\n                    for ph in self._progress_hooks:\n                        fd.add_progress_hook(ph)\n                    success = fd.download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error('unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error('postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error('unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen('[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning('Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + ' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + '\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('resolution') is not None:\n            return format['resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = '%sx%s' % (format['width'], format['height'])\n            else:\n                res = '%sp' % format['height']\n        elif format.get('width') is not None:\n            res = '?x%d' % format['width']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = ''\n            if fdict.get('ext') in ['f4f', 'f4m']:\n                res += '(unsupported) '\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + ' '\n            if fdict.get('tbr') is not None:\n                res += '%4dk ' % fdict['tbr']\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += '%-5s@' % fdict['vcodec']\n            elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n                res += 'video@'\n            if fdict.get('vbr') is not None:\n                res += '%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += ', '\n                res += '%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += ', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += '@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += ', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len('format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': 'format code', 'ext': 'extension',\n            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string('[debug] Git HEAD: ' + out + '\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string('[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + '\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n\n        debuglevel = 1 if self.params.get('debug_printtraffic') else 0\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False), debuglevel=debuglevel)\n        ydlh = YoutubeDLHandler(debuglevel=debuglevel)\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, ydlh)\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_patch": "@@ -1,7 +1,7 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n-from __future__ import absolute_import\n+from __future__ import absolute_import, unicode_literals\n \n import collections\n import errno\n@@ -200,7 +200,7 @@ class YoutubeDL(object):\n                 self._output_channel = os.fdopen(master, 'rb')\n             except OSError as ose:\n                 if ose.errno == 2:\n-                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n+                    self.report_warning('Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                 else:\n                     raise\n \n@@ -209,13 +209,13 @@ class YoutubeDL(object):\n                 and not params['restrictfilenames']):\n             # On Python 3, the Unicode filesystem API will throw errors (#1474)\n             self.report_warning(\n-                u'Assuming --restrict-filenames since file system encoding '\n-                u'cannot encode all charactes. '\n-                u'Set the LC_ALL environment variable to fix this.')\n+                'Assuming --restrict-filenames since file system encoding '\n+                'cannot encode all charactes. '\n+                'Set the LC_ALL environment variable to fix this.')\n             self.params['restrictfilenames'] = True\n \n         if '%(stitle)s' in self.params.get('outtmpl', ''):\n-            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n+            self.report_warning('%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n \n         self._setup_opener()\n \n@@ -258,13 +258,13 @@ class YoutubeDL(object):\n             return message\n \n         assert hasattr(self, '_output_process')\n-        assert type(message) == type(u'')\n-        line_count = message.count(u'\\n') + 1\n-        self._output_process.stdin.write((message + u'\\n').encode('utf-8'))\n+        assert type(message) == type('')\n+        line_count = message.count('\\n') + 1\n+        self._output_process.stdin.write((message + '\\n').encode('utf-8'))\n         self._output_process.stdin.flush()\n-        res = u''.join(self._output_channel.readline().decode('utf-8')\n+        res = ''.join(self._output_channel.readline().decode('utf-8')\n                        for _ in range(line_count))\n-        return res[:-len(u'\\n')]\n+        return res[:-len('\\n')]\n \n     def to_screen(self, message, skip_eol=False):\n         \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n@@ -276,19 +276,19 @@ class YoutubeDL(object):\n             self.params['logger'].debug(message)\n         elif not check_quiet or not self.params.get('quiet', False):\n             message = self._bidi_workaround(message)\n-            terminator = [u'\\n', u''][skip_eol]\n+            terminator = ['\\n', ''][skip_eol]\n             output = message + terminator\n \n             write_string(output, self._screen_file)\n \n     def to_stderr(self, message):\n         \"\"\"Print message to stderr.\"\"\"\n-        assert type(message) == type(u'')\n+        assert type(message) == type('')\n         if self.params.get('logger'):\n             self.params['logger'].error(message)\n         else:\n             message = self._bidi_workaround(message)\n-            output = message + u'\\n'\n+            output = message + '\\n'\n             write_string(output, self._err_file)\n \n     def to_console_title(self, message):\n@@ -299,21 +299,21 @@ class YoutubeDL(object):\n             # already of type unicode()\n             ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n         elif 'TERM' in os.environ:\n-            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n+            write_string('\\033]0;%s\\007' % message, self._screen_file)\n \n     def save_console_title(self):\n         if not self.params.get('consoletitle', False):\n             return\n         if 'TERM' in os.environ:\n             # Save the title on stack\n-            write_string(u'\\033[22;0t', self._screen_file)\n+            write_string('\\033[22;0t', self._screen_file)\n \n     def restore_console_title(self):\n         if not self.params.get('consoletitle', False):\n             return\n         if 'TERM' in os.environ:\n             # Restore the title from stack\n-            write_string(u'\\033[23;0t', self._screen_file)\n+            write_string('\\033[23;0t', self._screen_file)\n \n     def __enter__(self):\n         self.save_console_title()\n@@ -339,13 +339,13 @@ class YoutubeDL(object):\n         if self.params.get('verbose'):\n             if tb is None:\n                 if sys.exc_info()[0]:  # if .trouble has been called from an except block\n-                    tb = u''\n+                    tb = ''\n                     if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n-                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n+                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                     tb += compat_str(traceback.format_exc())\n                 else:\n                     tb_data = traceback.format_list(traceback.extract_stack())\n-                    tb = u''.join(tb_data)\n+                    tb = ''.join(tb_data)\n             self.to_stderr(tb)\n         if not self.params.get('ignoreerrors', False):\n             if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n@@ -361,10 +361,10 @@ class YoutubeDL(object):\n         If stderr is a tty file the 'WARNING:' will be colored\n         '''\n         if self._err_file.isatty() and os.name != 'nt':\n-            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n+            _msg_header = '\\033[0;33mWARNING:\\033[0m'\n         else:\n-            _msg_header = u'WARNING:'\n-        warning_message = u'%s %s' % (_msg_header, message)\n+            _msg_header = 'WARNING:'\n+        warning_message = '%s %s' % (_msg_header, message)\n         self.to_stderr(warning_message)\n \n     def report_error(self, message, tb=None):\n@@ -373,18 +373,18 @@ class YoutubeDL(object):\n         in red if stderr is a tty file.\n         '''\n         if self._err_file.isatty() and os.name != 'nt':\n-            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n+            _msg_header = '\\033[0;31mERROR:\\033[0m'\n         else:\n-            _msg_header = u'ERROR:'\n-        error_message = u'%s %s' % (_msg_header, message)\n+            _msg_header = 'ERROR:'\n+        error_message = '%s %s' % (_msg_header, message)\n         self.trouble(error_message, tb)\n \n     def report_file_already_downloaded(self, file_name):\n         \"\"\"Report file has already been fully downloaded.\"\"\"\n         try:\n-            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n+            self.to_screen('[download] %s has already been downloaded' % file_name)\n         except UnicodeEncodeError:\n-            self.to_screen(u'[download] The file has already been downloaded')\n+            self.to_screen('[download] The file has already been downloaded')\n \n     def increment_downloads(self):\n         \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n@@ -399,61 +399,61 @@ class YoutubeDL(object):\n             autonumber_size = self.params.get('autonumber_size')\n             if autonumber_size is None:\n                 autonumber_size = 5\n-            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n+            autonumber_templ = '%0' + str(autonumber_size) + 'd'\n             template_dict['autonumber'] = autonumber_templ % self._num_downloads\n             if template_dict.get('playlist_index') is not None:\n-                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n+                template_dict['playlist_index'] = '%05d' % template_dict['playlist_index']\n \n             sanitize = lambda k, v: sanitize_filename(\n                 compat_str(v),\n                 restricted=self.params.get('restrictfilenames'),\n-                is_id=(k == u'id'))\n+                is_id=(k == 'id'))\n             template_dict = dict((k, sanitize(k, v))\n                                  for k, v in template_dict.items()\n                                  if v is not None)\n-            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n+            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n \n             tmpl = os.path.expanduser(self.params['outtmpl'])\n             filename = tmpl % template_dict\n             return filename\n         except ValueError as err:\n-            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n+            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n             return None\n \n     def _match_entry(self, info_dict):\n         \"\"\" Returns None iff the file should be downloaded \"\"\"\n \n-        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n+        video_title = info_dict.get('title', info_dict.get('id', 'video'))\n         if 'title' in info_dict:\n             # This can happen when we're just evaluating the playlist\n             title = info_dict['title']\n             matchtitle = self.params.get('matchtitle', False)\n             if matchtitle:\n                 if not re.search(matchtitle, title, re.IGNORECASE):\n-                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n+                    return '\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n             rejecttitle = self.params.get('rejecttitle', False)\n             if rejecttitle:\n                 if re.search(rejecttitle, title, re.IGNORECASE):\n-                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n+                    return '\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n         date = info_dict.get('upload_date', None)\n         if date is not None:\n             dateRange = self.params.get('daterange', DateRange())\n             if date not in dateRange:\n-                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n+                return '%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n         view_count = info_dict.get('view_count', None)\n         if view_count is not None:\n             min_views = self.params.get('min_views')\n             if min_views is not None and view_count < min_views:\n-                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n+                return 'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n             max_views = self.params.get('max_views')\n             if max_views is not None and view_count > max_views:\n-                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n+                return 'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n         age_limit = self.params.get('age_limit')\n         if age_limit is not None:\n             if age_limit < info_dict.get('age_limit', 0):\n-                return u'Skipping \"' + title + '\" because it is age restricted'\n+                return 'Skipping \"' + title + '\" because it is age restricted'\n         if self.in_download_archive(info_dict):\n-            return u'%s has already been recorded in archive' % video_title\n+            return '%s has already been recorded in archive' % video_title\n         return None\n \n     @staticmethod\n@@ -480,8 +480,8 @@ class YoutubeDL(object):\n                 continue\n \n             if not ie.working():\n-                self.report_warning(u'The program functionality for this site has been marked as broken, '\n-                                    u'and will probably not work.')\n+                self.report_warning('The program functionality for this site has been marked as broken, '\n+                                    'and will probably not work.')\n \n             try:\n                 ie_result = ie.extract(url)\n@@ -514,7 +514,7 @@ class YoutubeDL(object):\n                 else:\n                     raise\n         else:\n-            self.report_error(u'no suitable InfoExtractor: %s' % url)\n+            self.report_error('no suitable InfoExtractor: %s' % url)\n \n     def process_ie_result(self, ie_result, download=True, extra_info={}):\n         \"\"\"\n@@ -565,7 +565,7 @@ class YoutubeDL(object):\n         elif result_type == 'playlist':\n             # We process each entry in the playlist\n             playlist = ie_result.get('title', None) or ie_result.get('id', None)\n-            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n+            self.to_screen('[download] Downloading playlist: %s' % playlist)\n \n             playlist_results = []\n \n@@ -580,11 +580,11 @@ class YoutubeDL(object):\n             n_entries = len(entries)\n \n             self.to_screen(\n-                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n+                \"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                 (ie_result['extractor'], playlist, n_all_entries, n_entries))\n \n             for i, entry in enumerate(entries, 1):\n-                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n+                self.to_screen('[download] Downloading video #%s of %s' % (i, n_entries))\n                 extra = {\n                     'playlist': playlist,\n                     'playlist_index': i + playliststart,\n@@ -596,7 +596,7 @@ class YoutubeDL(object):\n \n                 reason = self._match_entry(entry)\n                 if reason is not None:\n-                    self.to_screen(u'[download] ' + reason)\n+                    self.to_screen('[download] ' + reason)\n                     continue\n \n                 entry_result = self.process_ie_result(entry,\n@@ -629,7 +629,7 @@ class YoutubeDL(object):\n         elif format_spec == 'worst':\n             return available_formats[0]\n         else:\n-            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n+            extensions = ['mp4', 'flv', 'webm', '3gp']\n             if format_spec in extensions:\n                 filter_f = lambda f: f['ext'] == format_spec\n             else:\n@@ -648,7 +648,7 @@ class YoutubeDL(object):\n             info_dict['playlist_index'] = None\n \n         # This extractors handle format selection themselves\n-        if info_dict['extractor'] in [u'Youku']:\n+        if info_dict['extractor'] in ['Youku']:\n             if download:\n                 self.process_info(info_dict)\n             return info_dict\n@@ -665,10 +665,10 @@ class YoutubeDL(object):\n             if format.get('format_id') is None:\n                 format['format_id'] = compat_str(i)\n             if format.get('format') is None:\n-                format['format'] = u'{id} - {res}{note}'.format(\n+                format['format'] = '{id} - {res}{note}'.format(\n                     id=format['format_id'],\n                     res=self.format_resolution(format),\n-                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n+                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                 )\n             # Automatically determine file extension if missing\n             if 'ext' not in format:\n@@ -709,12 +709,12 @@ class YoutubeDL(object):\n                     formats_to_download = [selected_format]\n                     break\n         if not formats_to_download:\n-            raise ExtractorError(u'requested format not available',\n+            raise ExtractorError('requested format not available',\n                                  expected=True)\n \n         if download:\n             if len(formats_to_download) > 1:\n-                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n+                self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n             for format in formats_to_download:\n                 new_info = dict(info_dict)\n                 new_info.update(format)\n@@ -732,7 +732,7 @@ class YoutubeDL(object):\n \n         info_dict['fulltitle'] = info_dict['title']\n         if len(info_dict['title']) > 200:\n-            info_dict['title'] = info_dict['title'][:197] + u'...'\n+            info_dict['title'] = info_dict['title'][:197] + '...'\n \n         # Keep for backwards compatibility\n         info_dict['stitle'] = info_dict['title']\n@@ -742,7 +742,7 @@ class YoutubeDL(object):\n \n         reason = self._match_entry(info_dict)\n         if reason is not None:\n-            self.to_screen(u'[download] ' + reason)\n+            self.to_screen('[download] ' + reason)\n             return\n \n         max_downloads = self.params.get('max_downloads')\n@@ -759,7 +759,7 @@ class YoutubeDL(object):\n             self.to_stdout(info_dict['id'])\n         if self.params.get('forceurl', False):\n             # For RTMP URLs, also include the playpath\n-            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n+            self.to_stdout(info_dict['url'] + info_dict.get('play_path', ''))\n         if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n             self.to_stdout(info_dict['thumbnail'])\n         if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n@@ -786,37 +786,37 @@ class YoutubeDL(object):\n             if dn != '' and not os.path.exists(dn):\n                 os.makedirs(dn)\n         except (OSError, IOError) as err:\n-            self.report_error(u'unable to create directory ' + compat_str(err))\n+            self.report_error('unable to create directory ' + compat_str(err))\n             return\n \n         if self.params.get('writedescription', False):\n-            descfn = filename + u'.description'\n+            descfn = filename + '.description'\n             if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n-                self.to_screen(u'[info] Video description is already present')\n+                self.to_screen('[info] Video description is already present')\n             else:\n                 try:\n-                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n+                    self.to_screen('[info] Writing video description to: ' + descfn)\n                     with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                         descfile.write(info_dict['description'])\n                 except (KeyError, TypeError):\n-                    self.report_warning(u'There\\'s no description to write.')\n+                    self.report_warning('There\\'s no description to write.')\n                 except (OSError, IOError):\n-                    self.report_error(u'Cannot write description file ' + descfn)\n+                    self.report_error('Cannot write description file ' + descfn)\n                     return\n \n         if self.params.get('writeannotations', False):\n-            annofn = filename + u'.annotations.xml'\n+            annofn = filename + '.annotations.xml'\n             if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n-                self.to_screen(u'[info] Video annotations are already present')\n+                self.to_screen('[info] Video annotations are already present')\n             else:\n                 try:\n-                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n+                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                     with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                         annofile.write(info_dict['annotations'])\n                 except (KeyError, TypeError):\n-                    self.report_warning(u'There are no annotations to write.')\n+                    self.report_warning('There are no annotations to write.')\n                 except (OSError, IOError):\n-                    self.report_error(u'Cannot write annotations file: ' + annofn)\n+                    self.report_error('Cannot write annotations file: ' + annofn)\n                     return\n \n         subtitles_are_requested = any([self.params.get('writesubtitles', False),\n@@ -834,45 +834,45 @@ class YoutubeDL(object):\n                 try:\n                     sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                     if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n-                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n+                        self.to_screen('[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                     else:\n-                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n+                        self.to_screen('[info] Writing video subtitles to: ' + sub_filename)\n                         with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                 subfile.write(sub)\n                 except (OSError, IOError):\n-                    self.report_error(u'Cannot write subtitles file ' + descfn)\n+                    self.report_error('Cannot write subtitles file ' + descfn)\n                     return\n \n         if self.params.get('writeinfojson', False):\n-            infofn = os.path.splitext(filename)[0] + u'.info.json'\n+            infofn = os.path.splitext(filename)[0] + '.info.json'\n             if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n-                self.to_screen(u'[info] Video description metadata is already present')\n+                self.to_screen('[info] Video description metadata is already present')\n             else:\n-                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n+                self.to_screen('[info] Writing video description metadata as JSON to: ' + infofn)\n                 try:\n                     write_json_file(info_dict, encodeFilename(infofn))\n                 except (OSError, IOError):\n-                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n+                    self.report_error('Cannot write metadata to JSON file ' + infofn)\n                     return\n \n         if self.params.get('writethumbnail', False):\n             if info_dict.get('thumbnail') is not None:\n-                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n-                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n+                thumb_format = determine_ext(info_dict['thumbnail'], 'jpg')\n+                thumb_filename = os.path.splitext(filename)[0] + '.' + thumb_format\n                 if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n-                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n+                    self.to_screen('[%s] %s: Thumbnail is already present' %\n                                    (info_dict['extractor'], info_dict['id']))\n                 else:\n-                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n+                    self.to_screen('[%s] %s: Downloading thumbnail ...' %\n                                    (info_dict['extractor'], info_dict['id']))\n                     try:\n                         uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                         with open(thumb_filename, 'wb') as thumbf:\n                             shutil.copyfileobj(uf, thumbf)\n-                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n+                        self.to_screen('[%s] %s: Writing thumbnail to: %s' %\n                             (info_dict['extractor'], info_dict['id'], thumb_filename))\n                     except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n-                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n+                        self.report_warning('Unable to download thumbnail \"%s\": %s' %\n                             (info_dict['thumbnail'], compat_str(err)))\n \n         if not self.params.get('skip_download', False):\n@@ -885,19 +885,19 @@ class YoutubeDL(object):\n                         fd.add_progress_hook(ph)\n                     success = fd.download(filename, info_dict)\n                 except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n-                    self.report_error(u'unable to download video data: %s' % str(err))\n+                    self.report_error('unable to download video data: %s' % str(err))\n                     return\n                 except (OSError, IOError) as err:\n                     raise UnavailableVideoError(err)\n                 except (ContentTooShortError, ) as err:\n-                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n+                    self.report_error('content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                     return\n \n             if success:\n                 try:\n                     self.post_process(filename, info_dict)\n                 except (PostProcessingError) as err:\n-                    self.report_error(u'postprocessing: %s' % str(err))\n+                    self.report_error('postprocessing: %s' % str(err))\n                     return\n \n         self.record_download_archive(info_dict)\n@@ -914,9 +914,9 @@ class YoutubeDL(object):\n                 #It also downloads the videos\n                 self.extract_info(url)\n             except UnavailableVideoError:\n-                self.report_error(u'unable to download video')\n+                self.report_error('unable to download video')\n             except MaxDownloadsReached:\n-                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n+                self.to_screen('[info] Maximum number of downloaded files reached.')\n                 raise\n \n         return self._download_retcode\n@@ -929,7 +929,7 @@ class YoutubeDL(object):\n         except DownloadError:\n             webpage_url = info.get('webpage_url')\n             if webpage_url is not None:\n-                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n+                self.report_warning('The info failed to download, trying with \"%s\"' % webpage_url)\n                 return self.download([webpage_url])\n             else:\n                 raise\n@@ -953,10 +953,10 @@ class YoutubeDL(object):\n                 self.report_error(e.msg)\n         if keep_video is False and not self.params.get('keepvideo', False):\n             try:\n-                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n+                self.to_screen('Deleting original file %s (pass -k to keep)' % filename)\n                 os.remove(encodeFilename(filename))\n             except (IOError, OSError):\n-                self.report_warning(u'Unable to remove downloaded video file')\n+                self.report_warning('Unable to remove downloaded video file')\n \n     def _make_archive_id(self, info_dict):\n         # Future-proof against any change in case\n@@ -967,7 +967,7 @@ class YoutubeDL(object):\n                 extractor = info_dict.get('ie_key')  # key in a playlist\n         if extractor is None:\n             return None  # Incomplete video information\n-        return extractor.lower() + u' ' + info_dict['id']\n+        return extractor.lower() + ' ' + info_dict['id']\n \n     def in_download_archive(self, info_dict):\n         fn = self.params.get('download_archive')\n@@ -995,7 +995,7 @@ class YoutubeDL(object):\n         vid_id = self._make_archive_id(info_dict)\n         assert vid_id\n         with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n-            archive_file.write(vid_id + u'\\n')\n+            archive_file.write(vid_id + '\\n')\n \n     @staticmethod\n     def format_resolution(format, default='unknown'):\n@@ -1005,49 +1005,49 @@ class YoutubeDL(object):\n             return format['resolution']\n         if format.get('height') is not None:\n             if format.get('width') is not None:\n-                res = u'%sx%s' % (format['width'], format['height'])\n+                res = '%sx%s' % (format['width'], format['height'])\n             else:\n-                res = u'%sp' % format['height']\n+                res = '%sp' % format['height']\n         elif format.get('width') is not None:\n-            res = u'?x%d' % format['width']\n+            res = '?x%d' % format['width']\n         else:\n             res = default\n         return res\n \n     def list_formats(self, info_dict):\n         def format_note(fdict):\n-            res = u''\n+            res = ''\n             if fdict.get('ext') in ['f4f', 'f4m']:\n-                res += u'(unsupported) '\n+                res += '(unsupported) '\n             if fdict.get('format_note') is not None:\n-                res += fdict['format_note'] + u' '\n+                res += fdict['format_note'] + ' '\n             if fdict.get('tbr') is not None:\n-                res += u'%4dk ' % fdict['tbr']\n+                res += '%4dk ' % fdict['tbr']\n             if (fdict.get('vcodec') is not None and\n                     fdict.get('vcodec') != 'none'):\n-                res += u'%-5s@' % fdict['vcodec']\n+                res += '%-5s@' % fdict['vcodec']\n             elif fdict.get('vbr') is not None and fdict.get('abr') is not None:\n-                res += u'video@'\n+                res += 'video@'\n             if fdict.get('vbr') is not None:\n-                res += u'%4dk' % fdict['vbr']\n+                res += '%4dk' % fdict['vbr']\n             if fdict.get('acodec') is not None:\n                 if res:\n-                    res += u', '\n-                res += u'%-5s' % fdict['acodec']\n+                    res += ', '\n+                res += '%-5s' % fdict['acodec']\n             elif fdict.get('abr') is not None:\n                 if res:\n-                    res += u', '\n+                    res += ', '\n                 res += 'audio'\n             if fdict.get('abr') is not None:\n-                res += u'@%3dk' % fdict['abr']\n+                res += '@%3dk' % fdict['abr']\n             if fdict.get('filesize') is not None:\n                 if res:\n-                    res += u', '\n+                    res += ', '\n                 res += format_bytes(fdict['filesize'])\n             return res\n \n         def line(format, idlen=20):\n-            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n+            return (('%-' + compat_str(idlen + 1) + 's%-10s%-12s%s') % (\n                 format['format_id'],\n                 format['ext'],\n                 self.format_resolution(format),\n@@ -1055,7 +1055,7 @@ class YoutubeDL(object):\n             ))\n \n         formats = info_dict.get('formats', [info_dict])\n-        idlen = max(len(u'format code'),\n+        idlen = max(len('format code'),\n                     max(len(f['format_id']) for f in formats))\n         formats_s = [line(f, idlen) for f in formats]\n         if len(formats) > 1:\n@@ -1063,10 +1063,10 @@ class YoutubeDL(object):\n             formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n \n         header_line = line({\n-            'format_id': u'format code', 'ext': u'extension',\n-            'resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n-        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n-                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n+            'format_id': 'format code', 'ext': 'extension',\n+            'resolution': 'resolution', 'format_note': 'note'}, idlen=idlen)\n+        self.to_screen('[info] Available formats for %s:\\n%s\\n%s' %\n+                       (info_dict['id'], header_line, '\\n'.join(formats_s)))\n \n     def urlopen(self, req):\n         \"\"\" Start an HTTP download \"\"\"\n@@ -1075,7 +1075,7 @@ class YoutubeDL(object):\n     def print_debug_header(self):\n         if not self.params.get('verbose'):\n             return\n-        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n+        write_string('[debug] youtube-dl version ' + __version__ + '\\n')\n         try:\n             sp = subprocess.Popen(\n                 ['git', 'rev-parse', '--short', 'HEAD'],\n@@ -1084,20 +1084,20 @@ class YoutubeDL(object):\n             out, err = sp.communicate()\n             out = out.decode().strip()\n             if re.match('[0-9a-f]+', out):\n-                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n+                write_string('[debug] Git HEAD: ' + out + '\\n')\n         except:\n             try:\n                 sys.exc_clear()\n             except:\n                 pass\n-        write_string(u'[debug] Python version %s - %s' %\n-                     (platform.python_version(), platform_name()) + u'\\n')\n+        write_string('[debug] Python version %s - %s' %\n+                     (platform.python_version(), platform_name()) + '\\n')\n \n         proxy_map = {}\n         for handler in self._opener.handlers:\n             if hasattr(handler, 'proxies'):\n                 proxy_map.update(handler.proxies)\n-        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n+        write_string('[debug] Proxy map: ' + compat_str(proxy_map) + '\\n')\n \n     def _setup_opener(self):\n         timeout_val = self.params.get('socket_timeout')\n",
          "files_name_in_blame_commit": [
            "setup.py",
            "test_unicode_literals.py",
            "YoutubeDL.py"
          ]
        }
      },
      "29eb5174031cfc0b5de556da3da7761ac377de4e": {
        "commit": {
          "commit_id": "29eb5174031cfc0b5de556da3da7761ac377de4e",
          "commit_message": "Add webpage_url_basename info_dict field (Fixes #1938)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2013-12-17 04:13:36",
          "commit_parent": "44c471c3b873473157adb8ba8a55667ab54b2602"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'urlhandle', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'urlhandle', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'webpage_url_basename': url_basename(ie_result['webpage_url']), 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 505,
          "function_before_end_line": 608,
          "function_after_start_line": 507,
          "function_after_end_line": 612,
          "function_before_token_count": 455,
          "function_after_token_count": 465,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_all_files": [
            "list_formats",
            "str_to_int",
            "to_stderr",
            "deflate",
            "test_unescape_html",
            "_setup_opener",
            "remove_start",
            "clean_html",
            "format_bytes",
            "urlopen",
            "error",
            "unsmuggle_url",
            "month_by_name",
            "takewhile_inclusive",
            "add_post_processor",
            "_parse_qsl",
            "handle_endtag",
            "prepare_filename",
            "sanitize_filename",
            "test_shell_quote",
            "save_console_title",
            "_match_entry",
            "get_meta_content",
            "__init__",
            "preferredencoding",
            "download",
            "write_json_file",
            "test_xpath_with_ns",
            "decodeOption",
            "http_response",
            "compat_print",
            "test_smuggle_url",
            "select_format",
            "record_download_archive",
            "write_string",
            "extract_info",
            "in_download_archive",
            "platform_name",
            "write",
            "fix_xml_all_ampersand",
            "_unquote",
            "format_traceback",
            "sanitize_open",
            "add_default_info_extractors",
            "__contains__",
            "process_ie_result",
            "post_process",
            "test_ordered_set",
            "addinfourl_wrapper",
            "to_console_title",
            "to_screen",
            "__str__",
            "day",
            "_lock_file",
            "htmlentity_transform",
            "print_debug_header",
            "add_info_extractor",
            "test_url_basename",
            "shell_quote",
            "smuggle_url",
            "orderedSet",
            "test_sanitize_ids",
            "subtitles_filename",
            "test_sanitize_filename_restricted",
            "compat_ord",
            "test_meta_parser",
            "read",
            "find_startpos",
            "_make_archive_id",
            "__enter__",
            "trouble",
            "increment_downloads",
            "bytes_to_intlist",
            "process_info",
            "unescapeHTML",
            "loads",
            "test_find_xpath_attr",
            "encodeFilename",
            "find_xpath_attr",
            "get_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "formatSeconds",
            "test_daterange",
            "add_extra_info",
            "test_str_to_int",
            "restore_console_title",
            "report_warning",
            "make_HTTPS_handler",
            "handle_starttag",
            "unified_strdate",
            "__exit__",
            "determine_ext",
            "__iter__",
            "test_unified_dates",
            "get_cachedir",
            "get_result",
            "url_basename",
            "timeconvert",
            "_unlock_file",
            "date_from_str",
            "setproctitle",
            "xpath_with_ns",
            "get_element_by_attribute",
            "__init",
            "test_sanitize_filename",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "http_request",
            "test_timeconvert",
            "get_term_width",
            "get_element_by_id",
            "intlist_to_bytes",
            "report_file_already_downloaded",
            "compat_parse_qs",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [
            "extract_info"
          ],
          "functions_name_co_evolved_all_files": [
            "test_url_basename",
            "extract_info",
            "url_basename"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 919,
          "file_complexity": 277,
          "file_token_count": 6194,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {} if params is None else params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                self._fribidi = subprocess.Popen(\n                    ['fribidi', '-c', 'UTF-8'] + width_args,\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                self._fribidi_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_fribidi_channel'):\n            return message\n\n        assert type(message) == type(u'')\n        line_count = message.count(u'\\n') + 1\n        self._fribidi.stdin.write((message + u'\\n').encode('utf-8'))\n        self._fribidi.stdin.flush()\n        res = u''.join(self._fribidi_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len(u'\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + u'\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return u'%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'urlhandle', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + u'.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen(u'[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + u'.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen(u'[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen(u'[info] Video description metadata is already present')\n            else:\n                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                    write_json_file(json_info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    url_basename,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {} if params is None else params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                self._fribidi = subprocess.Popen(\n                    ['fribidi', '-c', 'UTF-8'] + width_args,\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                self._fribidi_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_fribidi_channel'):\n            return message\n\n        assert type(message) == type(u'')\n        line_count = message.count(u'\\n') + 1\n        self._fribidi.stdin.write((message + u'\\n').encode('utf-8'))\n        self._fribidi.stdin.flush()\n        res = u''.join(self._fribidi_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len(u'\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + u'\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return u'%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'webpage_url_basename': url_basename(url),\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'urlhandle', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + u'.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen(u'[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + u'.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen(u'[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen(u'[info] Video description metadata is already present')\n            else:\n                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                    write_json_file(json_info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(thumb_filename)):\n                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_patch": "@@ -47,6 +47,7 @@ from .utils import (\n     subtitles_filename,\n     takewhile_inclusive,\n     UnavailableVideoError,\n+    url_basename,\n     write_json_file,\n     write_string,\n     YoutubeDLHandler,\n@@ -484,6 +485,7 @@ class YoutubeDL(object):\n                     {\n                         'extractor': ie.IE_NAME,\n                         'webpage_url': url,\n+                        'webpage_url_basename': url_basename(url),\n                         'extractor_key': ie.ie_key(),\n                     })\n                 if process:\n@@ -576,6 +578,7 @@ class YoutubeDL(object):\n                     'playlist_index': i + playliststart,\n                     'extractor': ie_result['extractor'],\n                     'webpage_url': ie_result['webpage_url'],\n+                    'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                     'extractor_key': ie_result['extractor_key'],\n                 }\n \n@@ -596,6 +599,7 @@ class YoutubeDL(object):\n                     {\n                         'extractor': ie_result['extractor'],\n                         'webpage_url': ie_result['webpage_url'],\n+                        'webpage_url_basename': url_basename(ie_result['webpage_url']),\n                         'extractor_key': ie_result['extractor_key'],\n                     })\n                 return r\n",
          "files_name_in_blame_commit": [
            "utils.py",
            "test_utils.py",
            "YoutubeDL.py"
          ]
        }
      },
      "a19fd00cc4f799215a942c92fd5c722b3ea499cd": {
        "commit": {
          "commit_id": "a19fd00cc4f799215a942c92fd5c722b3ea499cd",
          "commit_message": "Simplify --playlist-start / --playlist-end interface",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2013-12-16 13:16:20",
          "commit_parent": "d66152a8982261f930c2a324c1fc3ba3b3324134"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'urlhandle', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'urlhandle', 'ie_key', 'duration', 'subtitles', 'annotations', 'format', 'thumbnail', 'thumbnails'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', None)\n        if playlistend == -1:\n            playlistend = None\n        entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 505,
          "function_before_end_line": 608,
          "function_after_start_line": 505,
          "function_after_end_line": 608,
          "function_before_token_count": 465,
          "function_after_token_count": 455,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "parseOpts",
            "main",
            "__enter__",
            "trouble",
            "_real_main",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "save_console_title",
            "_match_entry",
            "__init__",
            "download_with_info_file",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "_bidi_workaround",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__",
            "to_stdout"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "_real_main",
            "parseOpts"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 915,
          "file_complexity": 277,
          "file_token_count": 6165,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {} if params is None else params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                self._fribidi = subprocess.Popen(\n                    ['fribidi', '-c', 'UTF-8'] + width_args,\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                self._fribidi_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_fribidi_channel'):\n            return message\n\n        assert type(message) == type(u'')\n        line_count = message.count(u'\\n') + 1\n        self._fribidi.stdin.write((message + u'\\n').encode('utf-8'))\n        self._fribidi.stdin.flush()\n        res = u''.join(self._fribidi_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len(u'\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + u'\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return u'%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'urlhandle', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + u'.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen(u'[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + u'.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen(u'[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen(u'[info] Video description metadata is already present')\n            else:\n                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                    write_json_file(json_info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport collections\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    formatSeconds,\n    get_term_width,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forceduration:     Force printing duration.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    min_views:         An integer representing the minimum view count the video\n                       must have in order to not be skipped.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    max_views:         An integer representing the maximum view count.\n                       Videos that are more popular than that are not\n                       downloaded.\n                       Videos without view count information are always\n                       downloaded. None for no limit.\n    download_archive:  File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n    bidi_workaround:   Work around buggy terminals without bidirectional text\n                       support, using fridibi\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self._err_file = sys.stderr\n        self.params = {} if params is None else params\n\n        if params.get('bidi_workaround', False):\n            try:\n                import pty\n                master, slave = pty.openpty()\n                width = get_term_width()\n                if width is None:\n                    width_args = []\n                else:\n                    width_args = ['-w', str(width)]\n                self._fribidi = subprocess.Popen(\n                    ['fribidi', '-c', 'UTF-8'] + width_args,\n                    stdin=subprocess.PIPE,\n                    stdout=slave,\n                    stderr=self._err_file)\n                self._fribidi_channel = os.fdopen(master, 'rb')\n            except OSError as ose:\n                if ose.errno == 2:\n                    self.report_warning(u'Could not find fribidi executable, ignoring --bidi-workaround . Make sure that  fribidi  is an executable file in one of the directories in your $PATH.')\n                else:\n                    raise\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def _bidi_workaround(self, message):\n        if not hasattr(self, '_fribidi_channel'):\n            return message\n\n        assert type(message) == type(u'')\n        line_count = message.count(u'\\n') + 1\n        self._fribidi.stdin.write((message + u'\\n').encode('utf-8'))\n        self._fribidi.stdin.flush()\n        res = u''.join(self._fribidi_channel.readline().decode('utf-8')\n                       for _ in range(line_count))\n        return res[:-len(u'\\n')]\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        return self.to_stdout(message, skip_eol, check_quiet=True)\n\n    def to_stdout(self, message, skip_eol=False, check_quiet=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not check_quiet or not self.params.get('quiet', False):\n            message = self._bidi_workaround(message)\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            message = self._bidi_workaround(message)\n            output = message + u'\\n'\n            write_string(output, self._err_file)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if self._err_file.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items()\n                                 if v is not None)\n            template_dict = collections.defaultdict(lambda: u'NA', template_dict)\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        video_title = info_dict.get('title', info_dict.get('id', u'video'))\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'%s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        view_count = info_dict.get('view_count', None)\n        if view_count is not None:\n            min_views = self.params.get('min_views')\n            if min_views is not None and view_count < min_views:\n                return u'Skipping %s, because it has not reached minimum view count (%d/%d)' % (video_title, view_count, min_views)\n            max_views = self.params.get('max_views')\n            if max_views is not None and view_count > max_views:\n                return u'Skipping %s, because it has exceeded the maximum view count (%d/%d)' % (video_title, view_count, max_views)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return u'%s has already been recorded in archive' % video_title\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'urlhandle', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format',\n                          'thumbnail', 'thumbnails'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', None)\n            # For backwards compatibility, interpret -1 as whole list\n            if playlistend == -1:\n                playlistend = None\n\n            entries = ie_result['entries'][playliststart:playlistend]\n            n_entries = len(entries)\n\n            self.to_screen(\n                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            self.to_stdout(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            self.to_stdout(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            self.to_stdout(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            self.to_stdout(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            self.to_stdout(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            self.to_stdout(filename)\n        if self.params.get('forceduration', False) and info_dict.get('duration') is not None:\n            self.to_stdout(formatSeconds(info_dict['duration']))\n        if self.params.get('forceformat', False):\n            self.to_stdout(info_dict['format'])\n        if self.params.get('forcejson', False):\n            info_dict['_filename'] = filename\n            self.to_stdout(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            descfn = filename + u'.description'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(descfn)):\n                self.to_screen(u'[info] Video description is already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video description to: ' + descfn)\n                    with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                        descfile.write(info_dict['description'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There\\'s no description to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write description file ' + descfn)\n                    return\n\n        if self.params.get('writeannotations', False):\n            annofn = filename + u'.annotations.xml'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen(u'[info] Video annotations are already present')\n            else:\n                try:\n                    self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n                    with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning(u'There are no annotations to write.')\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write annotations file: ' + annofn)\n                    return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(sub_filename)):\n                        self.to_screen(u'[info] Video subtitle %s.%s is already_present' % (sub_lang, sub_format))\n                    else:\n                        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                self.to_screen(u'[info] Video description metadata is already present')\n            else:\n                self.to_screen(u'[info] Writing video description metadata as JSON to: ' + infofn)\n                try:\n                    json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                    write_json_file(json_info_dict, encodeFilename(infofn))\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                    return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = os.path.splitext(filename)[0] + u'.' + thumb_format\n                if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(infofn)):\n                    self.to_screen(u'[%s] %s: Thumbnail is already present' %\n                                   (info_dict['extractor'], info_dict['id']))\n                else:\n                    self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                                   (info_dict['extractor'], info_dict['id']))\n                    try:\n                        uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                        with open(thumb_filename, 'wb') as thumbf:\n                            shutil.copyfileobj(uf, thumbf)\n                        self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                            (info_dict['extractor'], info_dict['id'], thumb_filename))\n                    except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                        self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                            (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def download_with_info_file(self, info_filename):\n        with io.open(info_filename, 'r', encoding='utf-8') as f:\n            info = json.load(f)\n        try:\n            self.process_ie_result(info, download=True)\n        except DownloadError:\n            webpage_url = info.get('webpage_url')\n            if webpage_url is not None:\n                self.report_warning(u'The info failed to download, trying with \"%s\"' % webpage_url)\n                return self.download([webpage_url])\n            else:\n                raise\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_patch": "@@ -557,16 +557,16 @@ class YoutubeDL(object):\n \n             n_all_entries = len(ie_result['entries'])\n             playliststart = self.params.get('playliststart', 1) - 1\n-            playlistend = self.params.get('playlistend', -1)\n-\n+            playlistend = self.params.get('playlistend', None)\n+            # For backwards compatibility, interpret -1 as whole list\n             if playlistend == -1:\n-                entries = ie_result['entries'][playliststart:]\n-            else:\n-                entries = ie_result['entries'][playliststart:playlistend]\n+                playlistend = None\n \n+            entries = ie_result['entries'][playliststart:playlistend]\n             n_entries = len(entries)\n \n-            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n+            self.to_screen(\n+                u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                 (ie_result['extractor'], playlist, n_all_entries, n_entries))\n \n             for i, entry in enumerate(entries, 1):\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "YoutubeDL.py"
          ]
        }
      },
      "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98": {
        "commit": {
          "commit_id": "7fc3fa0545f8a07414e8c97be9862a3c2f79bb98",
          "commit_message": "[9gag] Add extractor",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2013-12-05 14:29:08",
          "commit_parent": "29030c0a4c2f4dded5a310add940aae0791f9d73"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n\n        def make_result(embedded_info):\n            new_result = ie_result.copy()\n            for f in ('_type', 'url', 'ext', 'player_url', 'formats', 'entries', 'urlhandle', 'ie_key', 'duration', 'subtitles', 'annotations', 'format'):\n                if f in new_result:\n                    del new_result[f]\n                if f in embedded_info:\n                    new_result[f] = embedded_info[f]\n            return new_result\n        new_result = make_result(info)\n        assert new_result.get('_type') != 'url_transparent'\n        if new_result.get('_type') == 'compat_list':\n            new_result['entries'] = [make_result(e) for e in new_result['entries']]\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 457,
          "function_before_end_line": 535,
          "function_after_start_line": 461,
          "function_after_end_line": 563,
          "function_before_token_count": 368,
          "function_after_token_count": 465,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "report_writedescription",
            "save_console_title",
            "_match_entry",
            "__init__",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "_real_extract",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "_setup_opener",
            "restore_console_title",
            "report_warning",
            "_make_archive_id",
            "add_default_info_extractors",
            "urlopen",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "report_writedescription",
            "save_console_title",
            "_match_entry",
            "__init__",
            "report_error",
            "format_resolution",
            "download",
            "print_debug_header",
            "get_info_extractor",
            "gen_extractors",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "extract_info"
          ],
          "functions_name_co_evolved_all_files": [
            "extract_info",
            "_real_extract"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 836,
          "file_complexity": 255,
          "file_token_count": 5576,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_print,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    download_archive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self.params = {} if params is None else params\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            output = message + u'\\n'\n            if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n                output = output.encode(preferredencoding())\n            sys.stderr.write(output)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%s has already been recorded in archive'\n                    % info_dict.get('title', info_dict.get('id', u'video')))\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n        if self.params.get('forcejson', False):\n            compat_print(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport json\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_cookiejar,\n    compat_http_client,\n    compat_print,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    format_bytes,\n    locked_file,\n    make_HTTPS_handler,\n    MaxDownloadsReached,\n    PostProcessingError,\n    platform_name,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n    YoutubeDLHandler,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\nfrom .version import __version__\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logger:            Log messages to a logging.Logger instance.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    download_archive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n    cookiefile:        File name where cookies should be read from and dumped to.\n    nocheckcertificate:Do not verify SSL certificates\n    proxy:             URL of the proxy server to use\n    socket_timeout:    Time to wait for unresponsive hosts, in seconds\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params=None):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self.params = {} if params is None else params\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            self.params['restrictfilenames'] = True\n\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params.get('outtmpl', ''):\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n        self._setup_opener()\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if self.params.get('logger'):\n            self.params['logger'].debug(message)\n        elif not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        if self.params.get('logger'):\n            self.params['logger'].error(message)\n        else:\n            output = message + u'\\n'\n            if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n                output = output.encode(preferredencoding())\n            sys.stderr.write(output)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n    \n        if self.params.get('cookiefile') is not None:\n            self.cookiejar.save()\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%s has already been recorded in archive'\n                    % info_dict.get('title', info_dict.get('id', u'video')))\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n                     process=True):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                if process:\n                    return self.process_ie_result(ie_result, download, extra_info)\n                else:\n                    return ie_result\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'url_transparent':\n            # Use the information from the embedding page\n            info = self.extract_info(\n                ie_result['url'], ie_key=ie_result.get('ie_key'),\n                extra_info=extra_info, download=False, process=False)\n\n            def make_result(embedded_info):\n                new_result = ie_result.copy()\n                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n                          'entries', 'urlhandle', 'ie_key', 'duration',\n                          'subtitles', 'annotations', 'format'):\n                    if f in new_result:\n                        del new_result[f]\n                    if f in embedded_info:\n                        new_result[f] = embedded_info[f]\n                return new_result\n            new_result = make_result(info)\n\n            assert new_result.get('_type') != 'url_transparent'\n            if new_result.get('_type') == 'compat_list':\n                new_result['entries'] = [\n                    make_result(e) for e in new_result['entries']]\n\n            return self.process_ie_result(\n                new_result, download=download, extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n        if self.params.get('forcejson', False):\n            compat_print(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if (len(url_list) > 1 and\n                '%' not in self.params['outtmpl']\n                and self.params.get('max_downloads') != 1):\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def _make_archive_id(self, info_dict):\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = info_dict.get('extractor_key')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return None  # Incomplete video information\n        return extractor.lower() + u' ' + info_dict['id']\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n\n        vid_id = self._make_archive_id(info_dict)\n        if vid_id is None:\n            return False  # Incomplete video information\n\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = self._make_archive_id(info_dict)\n        assert vid_id\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('vcodec') == 'none':\n            return 'audio only'\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            res = u''\n            if fdict.get('format_note') is not None:\n                res += fdict['format_note'] + u' '\n            if (fdict.get('vcodec') is not None and\n                    fdict.get('vcodec') != 'none'):\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            if fdict.get('filesize') is not None:\n                if res:\n                    res += u', '\n                res += format_bytes(fdict['filesize'])\n            return res\n\n        def line(format, idlen=20):\n            return ((u'%-' + compat_str(idlen + 1) + u's%-10s%-12s%s') % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n            ))\n\n        formats = info_dict.get('formats', [info_dict])\n        idlen = max(len(u'format code'),\n                    max(len(f['format_id']) for f in formats))\n        formats_s = [line(f, idlen) for f in formats]\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'}, idlen=idlen)\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n\n    def urlopen(self, req):\n        \"\"\" Start an HTTP download \"\"\"\n        return self._opener.open(req)\n\n    def print_debug_header(self):\n        if not self.params.get('verbose'):\n            return\n        write_string(u'[debug] youtube-dl version ' + __version__ + u'\\n')\n        try:\n            sp = subprocess.Popen(\n                ['git', 'rev-parse', '--short', 'HEAD'],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                cwd=os.path.dirname(os.path.abspath(__file__)))\n            out, err = sp.communicate()\n            out = out.decode().strip()\n            if re.match('[0-9a-f]+', out):\n                write_string(u'[debug] Git HEAD: ' + out + u'\\n')\n        except:\n            try:\n                sys.exc_clear()\n            except:\n                pass\n        write_string(u'[debug] Python version %s - %s' %\n                     (platform.python_version(), platform_name()) + u'\\n')\n\n        proxy_map = {}\n        for handler in self._opener.handlers:\n            if hasattr(handler, 'proxies'):\n                proxy_map.update(handler.proxies)\n        write_string(u'[debug] Proxy map: ' + compat_str(proxy_map) + u'\\n')\n\n    def _setup_opener(self):\n        timeout_val = self.params.get('socket_timeout')\n        timeout = 600 if timeout_val is None else float(timeout_val)\n\n        opts_cookiefile = self.params.get('cookiefile')\n        opts_proxy = self.params.get('proxy')\n\n        if opts_cookiefile is None:\n            self.cookiejar = compat_cookiejar.CookieJar()\n        else:\n            self.cookiejar = compat_cookiejar.MozillaCookieJar(\n                opts_cookiefile)\n            if os.access(opts_cookiefile, os.R_OK):\n                self.cookiejar.load()\n\n        cookie_processor = compat_urllib_request.HTTPCookieProcessor(\n            self.cookiejar)\n        if opts_proxy is not None:\n            if opts_proxy == '':\n                proxies = {}\n            else:\n                proxies = {'http': opts_proxy, 'https': opts_proxy}\n        else:\n            proxies = compat_urllib_request.getproxies()\n            # Set HTTPS proxy to HTTP one if given (https://github.com/rg3/youtube-dl/issues/805)\n            if 'http' in proxies and 'https' not in proxies:\n                proxies['https'] = proxies['http']\n        proxy_handler = compat_urllib_request.ProxyHandler(proxies)\n        https_handler = make_HTTPS_handler(\n            self.params.get('nocheckcertificate', False))\n        opener = compat_urllib_request.build_opener(\n            https_handler, proxy_handler, cookie_processor, YoutubeDLHandler())\n        # Delete the default user-agent header, which would otherwise apply in\n        # cases where our custom HTTP handler doesn't come into play\n        # (See https://github.com/rg3/youtube-dl/issues/1309 for details)\n        opener.addheaders = []\n        self._opener = opener\n\n        # TODO remove this global modification\n        compat_urllib_request.install_opener(opener)\n        socket.setdefaulttimeout(timeout)\n",
          "file_patch": "@@ -405,7 +405,8 @@ class YoutubeDL(object):\n         for key, value in extra_info.items():\n             info_dict.setdefault(key, value)\n \n-    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n+    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n+                     process=True):\n         '''\n         Returns a list with a dictionary for each video we find.\n         If 'download', also downloads the videos.\n@@ -441,7 +442,10 @@ class YoutubeDL(object):\n                         'webpage_url': url,\n                         'extractor_key': ie.ie_key(),\n                     })\n-                return self.process_ie_result(ie_result, download, extra_info)\n+                if process:\n+                    return self.process_ie_result(ie_result, download, extra_info)\n+                else:\n+                    return ie_result\n             except ExtractorError as de: # An error we somewhat expected\n                 self.report_error(compat_str(de), de.format_traceback())\n                 break\n@@ -474,8 +478,32 @@ class YoutubeDL(object):\n                                      download,\n                                      ie_key=ie_result.get('ie_key'),\n                                      extra_info=extra_info)\n+        elif result_type == 'url_transparent':\n+            # Use the information from the embedding page\n+            info = self.extract_info(\n+                ie_result['url'], ie_key=ie_result.get('ie_key'),\n+                extra_info=extra_info, download=False, process=False)\n+\n+            def make_result(embedded_info):\n+                new_result = ie_result.copy()\n+                for f in ('_type', 'url', 'ext', 'player_url', 'formats',\n+                          'entries', 'urlhandle', 'ie_key', 'duration',\n+                          'subtitles', 'annotations', 'format'):\n+                    if f in new_result:\n+                        del new_result[f]\n+                    if f in embedded_info:\n+                        new_result[f] = embedded_info[f]\n+                return new_result\n+            new_result = make_result(info)\n+\n+            assert new_result.get('_type') != 'url_transparent'\n+            if new_result.get('_type') == 'compat_list':\n+                new_result['entries'] = [\n+                    make_result(e) for e in new_result['entries']]\n+\n+            return self.process_ie_result(\n+                new_result, download=download, extra_info=extra_info)\n         elif result_type == 'playlist':\n-\n             # We process each entry in the playlist\n             playlist = ie_result.get('title', None) or ie_result.get('id', None)\n             self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "ninegag.py",
            "YoutubeDL.py"
          ]
        }
      },
      "7012b23c947fc1ed146e314a30d3c70a5fde70e7": {
        "commit": {
          "commit_id": "7012b23c947fc1ed146e314a30d3c70a5fde70e7",
          "commit_message": "Match --download-archive during playlist processing (Fixes #1745)",
          "commit_author": "Philipp Hagemeister",
          "commit_date": "2013-11-22 22:46:46",
          "commit_parent": "50123be4211e2c16aa5d2fc9ebadbaf72a9becce"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            reason = self._match_entry(entry)\n            if reason is not None:\n                self.to_screen(u'[download] ' + reason)\n                continue\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 436,
          "function_before_end_line": 508,
          "function_after_start_line": 438,
          "function_after_end_line": 516,
          "function_before_token_count": 352,
          "function_after_token_count": 368,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "restore_console_title",
            "report_warning",
            "add_default_info_extractors",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_console_title",
            "to_screen",
            "report_writedescription",
            "save_console_title",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded",
            "__exit__"
          ],
          "functions_name_all_files": [
            "list_formats",
            "_get_available_subtitles",
            "_static_decrypt_signature",
            "_extract_from_m3u8",
            "_confirm_age",
            "test_issue_673",
            "extract_videos_from_page",
            "to_stderr",
            "test_youtube_show",
            "_print_sig_code",
            "playlist_result",
            "report_lang",
            "_media_rating_search",
            "test_youtube_playlist_with_deleted",
            "_get_login_info",
            "_parse_sig_js",
            "add_post_processor",
            "_dc_search_uploader",
            "_parse_sig_swf",
            "_og_search_title",
            "prepare_filename",
            "_download_webpage_handle",
            "test_youtube_playlist_long",
            "_html_search_meta",
            "_make_valid_url",
            "set_downloader",
            "save_console_title",
            "_match_entry",
            "test_youtube_playlist",
            "__init__",
            "report_video_webpage_download",
            "fixed_template",
            "download",
            "report_writeinfojson",
            "_extract_id",
            "_rta_search",
            "test_youtube_playlist_empty",
            "_print_formats",
            "_real_initialize",
            "select_format",
            "_real_extract",
            "record_download_archive",
            "report_writeannotations",
            "test_youtube_playlist_noplaylist",
            "extract_info",
            "in_download_archive",
            "report_login",
            "report_extraction",
            "_request_webpage",
            "add_default_info_extractors",
            "report_rtmp_download",
            "report_unavailable_format",
            "_og_search_video_url",
            "_download_webpage",
            "process_ie_result",
            "post_process",
            "_set_language",
            "to_console_title",
            "to_screen",
            "_og_search_thumbnail",
            "_extract_signature_function",
            "_html_search_regex",
            "add_info_extractor",
            "test_youtube_safe_search",
            "working",
            "ie_key",
            "initialize",
            "suitable",
            "__enter__",
            "trouble",
            "increment_downloads",
            "process_info",
            "report_download_page",
            "_FEED_TEMPLATE",
            "report_information_extraction",
            "url_result",
            "_og_regexes",
            "_login",
            "get_info_extractor",
            "_get_video_url_list",
            "process_video_result",
            "_search_regex",
            "extract",
            "report_video_info_webpage_download",
            "SEARCH_KEY",
            "IE_NAME",
            "assertIsPlaylist",
            "add_extra_info",
            "report_age_confirmation",
            "restore_console_title",
            "report_warning",
            "_extract_annotations",
            "_get_n_results",
            "report_writedescription",
            "report_download_webpage",
            "_decrypt_signature",
            "_og_search_property",
            "test_youtube_user",
            "_get_available_automatic_caption",
            "report_error",
            "format_resolution",
            "report_writesubtitles",
            "test_youtube_course",
            "test_youtube_channel",
            "report_file_already_downloaded",
            "_og_search_description",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "in_download_archive",
            "_match_entry"
          ],
          "functions_name_co_evolved_all_files": [
            "test_youtube_user",
            "in_download_archive",
            "_real_extract",
            "_get_n_results",
            "test_youtube_channel",
            "url_result",
            "_match_entry"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 719,
          "file_complexity": 219,
          "file_token_count": 4764,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_http_client,\n    compat_print,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    locked_file,\n    MaxDownloadsReached,\n    PostProcessingError,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n        if self.params.get('forcejson', False):\n            compat_print(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            if fdict.get('format_note') is not None:\n                return fdict['format_note']\n            res = u''\n            if fdict.get('vcodec') is not None:\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            return res\n\n        def line(format):\n            return (u'%-20s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nif os.name == 'nt':\n    import ctypes\n\nfrom .utils import (\n    compat_http_client,\n    compat_print,\n    compat_str,\n    compat_urllib_error,\n    compat_urllib_request,\n    ContentTooShortError,\n    date_from_str,\n    DateRange,\n    determine_ext,\n    DownloadError,\n    encodeFilename,\n    ExtractorError,\n    locked_file,\n    MaxDownloadsReached,\n    PostProcessingError,\n    preferredencoding,\n    SameFileError,\n    sanitize_filename,\n    subtitles_filename,\n    takewhile_inclusive,\n    UnavailableVideoError,\n    write_json_file,\n    write_string,\n)\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    forcejson:         Force printing info_dict as JSON.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def to_console_title(self, message):\n        if not self.params.get('consoletitle', False):\n            return\n        if os.name == 'nt' and ctypes.windll.kernel32.GetConsoleWindow():\n            # c_wchar_p() might not be necessary if `message` is\n            # already of type unicode()\n            ctypes.windll.kernel32.SetConsoleTitleW(ctypes.c_wchar_p(message))\n        elif 'TERM' in os.environ:\n            write_string(u'\\033]0;%s\\007' % message, self._screen_file)\n\n    def save_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Save the title on stack\n            write_string(u'\\033[22;0t', self._screen_file)\n\n    def restore_console_title(self):\n        if not self.params.get('consoletitle', False):\n            return\n        if 'TERM' in os.environ:\n            # Restore the title from stack\n            write_string(u'\\033[23;0t', self._screen_file)\n\n    def __enter__(self):\n        self.save_console_title()\n        return self\n\n    def __exit__(self, *args):\n        self.restore_console_title()\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except UnicodeEncodeError:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        if 'title' in info_dict:\n            # This can happen when we're just evaluating the playlist\n            title = info_dict['title']\n            matchtitle = self.params.get('matchtitle', False)\n            if matchtitle:\n                if not re.search(matchtitle, title, re.IGNORECASE):\n                    return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n            rejecttitle = self.params.get('rejecttitle', False)\n            if rejecttitle:\n                if re.search(rejecttitle, title, re.IGNORECASE):\n                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%s has already been recorded in archive'\n                    % info_dict.get('title', info_dict.get('id', u'video')))\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n\n                reason = self._match_entry(entry)\n                if reason is not None:\n                    self.to_screen(u'[download] ' + reason)\n                    continue\n\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['fulltitle'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n        if self.params.get('forcejson', False):\n            compat_print(json.dumps(info_dict))\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = os.path.splitext(filename)[0] + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        extractor = info_dict.get('extractor_id')\n        if extractor is None:\n            if 'id' in info_dict:\n                extractor = info_dict.get('ie_key')  # key in a playlist\n        if extractor is None:\n            return False  # Incomplete video information\n        # Future-proof against any change in case\n        # and backwards compatibility with prior versions\n        extractor = extractor.lower()\n        vid_id = extractor + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def format_note(fdict):\n            if fdict.get('format_note') is not None:\n                return fdict['format_note']\n            res = u''\n            if fdict.get('vcodec') is not None:\n                res += u'%-5s' % fdict['vcodec']\n            elif fdict.get('vbr') is not None:\n                res += u'video'\n            if fdict.get('vbr') is not None:\n                res += u'@%4dk' % fdict['vbr']\n            if fdict.get('acodec') is not None:\n                if res:\n                    res += u', '\n                res += u'%-5s' % fdict['acodec']\n            elif fdict.get('abr') is not None:\n                if res:\n                    res += u', '\n                res += 'audio'\n            if fdict.get('abr') is not None:\n                res += u'@%3dk' % fdict['abr']\n            return res\n\n        def line(format):\n            return (u'%-20s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format_note(format),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if format_note(formats[0]) else '') + '(worst)'\n            formats_s[-1] += (' ' if format_note(formats[-1]) else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_patch": "@@ -355,15 +355,17 @@ class YoutubeDL(object):\n     def _match_entry(self, info_dict):\n         \"\"\" Returns None iff the file should be downloaded \"\"\"\n \n-        title = info_dict['title']\n-        matchtitle = self.params.get('matchtitle', False)\n-        if matchtitle:\n-            if not re.search(matchtitle, title, re.IGNORECASE):\n-                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n-        rejecttitle = self.params.get('rejecttitle', False)\n-        if rejecttitle:\n-            if re.search(rejecttitle, title, re.IGNORECASE):\n-                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n+        if 'title' in info_dict:\n+            # This can happen when we're just evaluating the playlist\n+            title = info_dict['title']\n+            matchtitle = self.params.get('matchtitle', False)\n+            if matchtitle:\n+                if not re.search(matchtitle, title, re.IGNORECASE):\n+                    return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n+            rejecttitle = self.params.get('rejecttitle', False)\n+            if rejecttitle:\n+                if re.search(rejecttitle, title, re.IGNORECASE):\n+                    return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n         date = info_dict.get('upload_date', None)\n         if date is not None:\n             dateRange = self.params.get('daterange', DateRange())\n@@ -374,8 +376,8 @@ class YoutubeDL(object):\n             if age_limit < info_dict.get('age_limit', 0):\n                 return u'Skipping \"' + title + '\" because it is age restricted'\n         if self.in_download_archive(info_dict):\n-            return (u'%(title)s has already been recorded in archive'\n-                    % info_dict)\n+            return (u'%s has already been recorded in archive'\n+                    % info_dict.get('title', info_dict.get('id', u'video')))\n         return None\n \n     @staticmethod\n@@ -454,7 +456,7 @@ class YoutubeDL(object):\n                                      ie_key=ie_result.get('ie_key'),\n                                      extra_info=extra_info)\n         elif result_type == 'playlist':\n-            self.add_extra_info(ie_result, extra_info)\n+\n             # We process each entry in the playlist\n             playlist = ie_result.get('title', None) or ie_result.get('id', None)\n             self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n@@ -484,6 +486,12 @@ class YoutubeDL(object):\n                     'webpage_url': ie_result['webpage_url'],\n                     'extractor_key': ie_result['extractor_key'],\n                 }\n+\n+                reason = self._match_entry(entry)\n+                if reason is not None:\n+                    self.to_screen(u'[download] ' + reason)\n+                    continue\n+\n                 entry_result = self.process_ie_result(entry,\n                                                       download=download,\n                                                       extra_info=extra)\n@@ -810,7 +818,16 @@ class YoutubeDL(object):\n         fn = self.params.get('download_archive')\n         if fn is None:\n             return False\n-        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n+        extractor = info_dict.get('extractor_id')\n+        if extractor is None:\n+            if 'id' in info_dict:\n+                extractor = info_dict.get('ie_key')  # key in a playlist\n+        if extractor is None:\n+            return False  # Incomplete video information\n+        # Future-proof against any change in case\n+        # and backwards compatibility with prior versions\n+        extractor = extractor.lower()\n+        vid_id = extractor + u' ' + info_dict['id']\n         try:\n             with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                 for line in archive_file:\n",
          "files_name_in_blame_commit": [
            "common.py",
            "test_youtube_lists.py",
            "youtube.py",
            "YoutubeDL.py"
          ]
        }
      },
      "feee2ecfa9fbc6fd34246c7e167ac9542ae7def2": {
        "commit": {
          "commit_id": "feee2ecfa9fbc6fd34246c7e167ac9542ae7def2",
          "commit_message": "Pass the 'download' argument to 'process_video_result' (fixes #1769)",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2013-11-15 11:04:26",
          "commit_parent": "a25a5cfeecc1c6371ab28d6d458cd066baf7013d"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 376,
          "function_before_end_line": 448,
          "function_after_start_line": 376,
          "function_after_end_line": 448,
          "function_before_token_count": 348,
          "function_after_token_count": 352,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 635,
          "file_complexity": 190,
          "file_token_count": 4292,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-20s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result, download=download)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat', 'srt')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-20s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_patch": "@@ -385,7 +385,7 @@ class YoutubeDL(object):\n         result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n         if result_type == 'video':\n             self.add_extra_info(ie_result, extra_info)\n-            return self.process_video_result(ie_result)\n+            return self.process_video_result(ie_result, download=download)\n         elif result_type == 'url':\n             # We have to add extra_info to the results because it may be\n             # contained in a playlist\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py"
          ]
        }
      },
      "be97abc247d26bc36d1ef8cad5c17fc2a99d9101": {
        "commit": {
          "commit_id": "be97abc247d26bc36d1ef8cad5c17fc2a99d9101",
          "commit_message": "Set the 'extractor_key' field in the info_dict\n\nIt's the string returned by the class method 'ie_key', which allows to retrieve the extractor with 'get_info_extractor'",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2013-11-03 12:14:44",
          "commit_parent": "9103bbc5cd11957de2e906e4401dcf4df9511d28"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url'], 'extractor_key': ie_result['extractor_key']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 375,
          "function_before_end_line": 445,
          "function_after_start_line": 376,
          "function_after_end_line": 448,
          "function_before_token_count": 341,
          "function_after_token_count": 348,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "generator",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "_file_md5",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "setUp",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_co_evolved_modified_file": [
            "extract_info"
          ],
          "functions_name_co_evolved_all_files": [
            "extract_info",
            "generator"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 635,
          "file_complexity": 190,
          "file_token_count": 4286,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url,\n                        'extractor_key': ie.ie_key(),\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                    'extractor_key': ie_result['extractor_key'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                        'extractor_key': ie_result['extractor_key'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_patch": "@@ -357,7 +357,8 @@ class YoutubeDL(object):\n                 self.add_extra_info(ie_result,\n                     {\n                         'extractor': ie.IE_NAME,\n-                        'webpage_url': url\n+                        'webpage_url': url,\n+                        'extractor_key': ie.ie_key(),\n                     })\n                 return self.process_ie_result(ie_result, download, extra_info)\n             except ExtractorError as de: # An error we somewhat expected\n@@ -421,6 +422,7 @@ class YoutubeDL(object):\n                     'playlist_index': i + playliststart,\n                     'extractor': ie_result['extractor'],\n                     'webpage_url': ie_result['webpage_url'],\n+                    'extractor_key': ie_result['extractor_key'],\n                 }\n                 entry_result = self.process_ie_result(entry,\n                                                       download=download,\n@@ -434,6 +436,7 @@ class YoutubeDL(object):\n                     {\n                         'extractor': ie_result['extractor'],\n                         'webpage_url': ie_result['webpage_url'],\n+                        'extractor_key': ie_result['extractor_key'],\n                     })\n                 return r\n             ie_result['entries'] = [\n",
          "files_name_in_blame_commit": [
            "test_download.py",
            "YoutubeDL.py"
          ]
        }
      },
      "9103bbc5cd11957de2e906e4401dcf4df9511d28": {
        "commit": {
          "commit_id": "9103bbc5cd11957de2e906e4401dcf4df9511d28",
          "commit_message": "Add the 'webpage_url' field to info_dict\n\nThe url for the video page, it must allow to reproduce the result.\nIt's automatically set by YoutubeDL if it's missing.",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2013-11-03 12:11:13",
          "commit_parent": "b6c45014aed4b3176be1142958be98d7cb9dbaff"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor'], 'webpage_url': ie_result['webpage_url']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 372,
          "function_before_end_line": 438,
          "function_after_start_line": 375,
          "function_after_end_line": 445,
          "function_before_token_count": 334,
          "function_after_token_count": 341,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_all_files": [
            "_verify_video_password",
            "list_formats",
            "_get_available_subtitles",
            "_static_decrypt_signature",
            "_extract_from_m3u8",
            "_confirm_age",
            "extract_videos_from_page",
            "to_stderr",
            "_print_sig_code",
            "playlist_result",
            "report_lang",
            "_get_login_info",
            "_parse_sig_js",
            "add_post_processor",
            "_parse_sig_swf",
            "_og_search_title",
            "prepare_filename",
            "_download_webpage_handle",
            "_make_valid_url",
            "set_downloader",
            "_match_entry",
            "report_video_webpage_download",
            "setUp",
            "__init__",
            "fixed_template",
            "download",
            "report_writeinfojson",
            "_extract_id",
            "_rta_search",
            "_print_formats",
            "_real_initialize",
            "select_format",
            "_real_extract",
            "record_download_archive",
            "generator",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_login",
            "report_extraction",
            "_request_webpage",
            "add_default_info_extractors",
            "report_rtmp_download",
            "report_unavailable_format",
            "_og_search_video_url",
            "_download_webpage",
            "process_ie_result",
            "post_process",
            "_set_language",
            "_file_md5",
            "to_screen",
            "_og_search_thumbnail",
            "_extract_signature_function",
            "_html_search_regex",
            "add_info_extractor",
            "working",
            "ie_key",
            "initialize",
            "suitable",
            "trouble",
            "increment_downloads",
            "process_info",
            "_og_regex",
            "report_download_page",
            "_FEED_TEMPLATE",
            "report_information_extraction",
            "url_result",
            "_login",
            "get_info_extractor",
            "_get_video_url_list",
            "process_video_result",
            "_search_regex",
            "extract",
            "report_video_info_webpage_download",
            "SEARCH_KEY",
            "IE_NAME",
            "add_extra_info",
            "report_age_confirmation",
            "report_warning",
            "_extract_annotations",
            "_get_n_results",
            "report_writedescription",
            "report_download_webpage",
            "_og_search_property",
            "_get_available_automatic_caption",
            "report_error",
            "format_resolution",
            "report_writesubtitles",
            "report_file_already_downloaded",
            "_og_search_description",
            "_decrypt_signature"
          ],
          "functions_name_co_evolved_modified_file": [
            "extract_info"
          ],
          "functions_name_co_evolved_all_files": [
            "extract_info",
            "generator",
            "_real_extract"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 632,
          "file_complexity": 190,
          "file_token_count": 4263,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                if 'extractor' not in ie_result:\n                    ie_result['extractor'] = ie.IE_NAME\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {'extractor': ie_result['extractor']})\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                self.add_extra_info(ie_result,\n                    {\n                        'extractor': ie.IE_NAME,\n                        'webpage_url': url\n                    })\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                    'webpage_url': ie_result['webpage_url'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {\n                        'extractor': ie_result['extractor'],\n                        'webpage_url': ie_result['webpage_url'],\n                    })\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_patch": "@@ -354,8 +354,11 @@ class YoutubeDL(object):\n                         '_type': 'compat_list',\n                         'entries': ie_result,\n                     }\n-                if 'extractor' not in ie_result:\n-                    ie_result['extractor'] = ie.IE_NAME\n+                self.add_extra_info(ie_result,\n+                    {\n+                        'extractor': ie.IE_NAME,\n+                        'webpage_url': url\n+                    })\n                 return self.process_ie_result(ie_result, download, extra_info)\n             except ExtractorError as de: # An error we somewhat expected\n                 self.report_error(compat_str(de), de.format_traceback())\n@@ -417,6 +420,7 @@ class YoutubeDL(object):\n                     'playlist': playlist,\n                     'playlist_index': i + playliststart,\n                     'extractor': ie_result['extractor'],\n+                    'webpage_url': ie_result['webpage_url'],\n                 }\n                 entry_result = self.process_ie_result(entry,\n                                                       download=download,\n@@ -427,7 +431,10 @@ class YoutubeDL(object):\n         elif result_type == 'compat_list':\n             def _fixup(r):\n                 self.add_extra_info(r,\n-                    {'extractor': ie_result['extractor']})\n+                    {\n+                        'extractor': ie_result['extractor'],\n+                        'webpage_url': ie_result['webpage_url'],\n+                    })\n                 return r\n             ie_result['entries'] = [\n                 self.process_ie_result(_fixup(r), download, extra_info)\n",
          "files_name_in_blame_commit": [
            "common.py",
            "vimeo.py",
            "YoutubeDL.py",
            "test_download.py",
            "youtube.py"
          ]
        }
      },
      "b6c45014aed4b3176be1142958be98d7cb9dbaff": {
        "commit": {
          "commit_id": "b6c45014aed4b3176be1142958be98d7cb9dbaff",
          "commit_message": "Set the extra_info inside YoutubeDL.process_ie_result and set only if the keys are missing",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2013-11-03 11:57:04",
          "commit_parent": "3e56add7c9acf659d984be5aef1b8fb6e42599c6"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        ie_result.update(extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart}\n            if not 'extractor' in entry:\n                entry['extractor'] = ie_result['extractor']\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            r.setdefault('extractor', ie_result['extractor'])\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download=download) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        self.add_extra_info(ie_result, extra_info)\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart, 'extractor': ie_result['extractor']}\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            self.add_extra_info(r, {'extractor': ie_result['extractor']})\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download, extra_info) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": 370,
          "function_before_end_line": 438,
          "function_after_start_line": 372,
          "function_after_end_line": 438,
          "function_before_token_count": 332,
          "function_after_token_count": 334,
          "functions_name_modified_file": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_all_files": [
            "list_formats",
            "select_format",
            "to_stderr",
            "record_download_archive",
            "add_extra_info",
            "report_writeannotations",
            "extract_info",
            "in_download_archive",
            "report_warning",
            "test_add_extra_info",
            "test_format_selection",
            "add_default_info_extractors",
            "trouble",
            "increment_downloads",
            "test_prefer_free_formats",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "format_resolution",
            "download",
            "get_info_extractor",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "test_format_limit",
            "process_video_result",
            "report_file_already_downloaded"
          ],
          "functions_name_co_evolved_modified_file": [
            "extract_info",
            "add_extra_info"
          ],
          "functions_name_co_evolved_all_files": [
            "extract_info",
            "add_extra_info",
            "test_add_extra_info"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 625,
          "file_complexity": 191,
          "file_token_count": 4244,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    for result in ie_result:\n                        result.update(extra_info)\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                else:\n                    ie_result.update(extra_info)\n                if 'extractor' not in ie_result:\n                    ie_result['extractor'] = ie.IE_NAME\n                return self.process_ie_result(ie_result, download=download)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            ie_result.update(extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                }\n                if not 'extractor' in entry:\n                    # We set the extractor, if it's an url it will be set then to\n                    # the new extractor, but if it's already a video we must make\n                    # sure it's present: see issue #877\n                    entry['extractor'] = ie_result['extractor']\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                r.setdefault('extractor', ie_result['extractor'])\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download=download)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport errno\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor, gen_extractors\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    videopassword:     Password for acces a video.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writeannotations:  Write the video annotations to a .annotations.xml file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    writeautomaticsub: Write the automatic subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n                       (requires writesubtitles or writeautomaticsub)\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [srt/sbv/vtt] (default=srt)\n    subtitleslangs:    List of languages of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    cachedir:          Location of the cache files in the filesystem.\n                       None to disable filesystem cache.\n    noplaylist:        Download single video instead of a playlist if in doubt.\n    age_limit:         An integer representing the user's age in years.\n                       Unsuitable videos for the given age are skipped.\n    downloadarchive:   File name of a file where all downloads are recorded.\n                       Videos already present in the file are not downloaded\n                       again.\n\n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._ies_instances = {}\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n\n        if (sys.version_info >= (3,) and sys.platform != 'win32' and\n                sys.getfilesystemencoding() in ['ascii', 'ANSI_X3.4-1968']\n                and not params['restrictfilenames']):\n            # On Python 3, the Unicode filesystem API will throw errors (#1474)\n            self.report_warning(\n                u'Assuming --restrict-filenames since file system encoding '\n                u'cannot encode all charactes. '\n                u'Set the LC_ALL environment variable to fix this.')\n            params['restrictfilenames'] = True\n\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        self._ies_instances[ie.ie_key()] = ie\n        ie.set_downloader(self)\n\n    def get_info_extractor(self, ie_key):\n        \"\"\"\n        Get an instance of an IE with name ie_key, it will try to get one from\n        the _ies list, if there's no instance it will create a new one and add\n        it to the extractor list.\n        \"\"\"\n        ie = self._ies_instances.get(ie_key)\n        if ie is None:\n            ie = get_info_extractor(ie_key)()\n            self.add_info_extractor(ie)\n        return ie\n\n    def add_default_info_extractors(self):\n        \"\"\"\n        Add the InfoExtractors returned by gen_extractors to the end of the list\n        \"\"\"\n        for ie in gen_extractors():\n            self.add_info_extractor(ie)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            write_string(output, self._screen_file)\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header = u'WARNING:'\n        warning_message = u'%s %s' % (_msg_header, message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_writeannotations(self, annofn):\n        \"\"\" Report that the annotations file has been written. \"\"\"\n        self.to_screen(u'[info] Writing video annotations to: ' + annofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict.get('playlist_index') is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k, v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k == u'id'))\n            template_dict = dict((k, sanitize(k, v))\n                                 for k, v in template_dict.items())\n\n            tmpl = os.path.expanduser(self.params['outtmpl'])\n            filename = tmpl % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Error in output template: ' + str(err) + u' (encoding: ' + repr(preferredencoding()) + ')')\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        age_limit = self.params.get('age_limit')\n        if age_limit is not None:\n            if age_limit < info_dict.get('age_limit', 0):\n                return u'Skipping \"' + title + '\" because it is age restricted'\n        if self.in_download_archive(info_dict):\n            return (u'%(title)s has already been recorded in archive'\n                    % info_dict)\n        return None\n\n    @staticmethod\n    def add_extra_info(info_dict, extra_info):\n        '''Set the keys from extra_info in info dict if they are missing'''\n        for key, value in extra_info.items():\n            info_dict.setdefault(key, value)\n\n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n\n        if ie_key:\n            ies = [self.get_info_extractor(ie_key)]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                if 'extractor' not in ie_result:\n                    ie_result['extractor'] = ie.IE_NAME\n                return self.process_ie_result(ie_result, download, extra_info)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n\n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            self.add_extra_info(ie_result, extra_info)\n            return self.process_video_result(ie_result)\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            self.add_extra_info(ie_result, extra_info)\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i, entry in enumerate(entries, 1):\n                self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n                extra = {\n                    'playlist': playlist,\n                    'playlist_index': i + playliststart,\n                    'extractor': ie_result['extractor'],\n                }\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                self.add_extra_info(r,\n                    {'extractor': ie_result['extractor']})\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download, extra_info)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def select_format(self, format_spec, available_formats):\n        if format_spec == 'best' or format_spec is None:\n            return available_formats[-1]\n        elif format_spec == 'worst':\n            return available_formats[0]\n        else:\n            extensions = [u'mp4', u'flv', u'webm', u'3gp']\n            if format_spec in extensions:\n                filter_f = lambda f: f['ext'] == format_spec\n            else:\n                filter_f = lambda f: f['format_id'] == format_spec\n            matches = list(filter(filter_f, available_formats))\n            if matches:\n                return matches[-1]\n        return None\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n\n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n\n        # This extractors handle format selection themselves\n        if info_dict['extractor'] in [u'youtube', u'Youku']:\n            if download:\n                self.process_info(info_dict)\n            return info_dict\n\n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n\n        # We check that all the formats have the format and format_id fields\n        for (i, format) in enumerate(formats):\n            if format.get('format_id') is None:\n                format['format_id'] = compat_str(i)\n            if format.get('format') is None:\n                format['format'] = u'{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=u' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if 'ext' not in format:\n                format['ext'] = determine_ext(format['url'])\n\n        if self.params.get('listformats', None):\n            self.list_formats(info_dict)\n            return\n\n        format_limit = self.params.get('format_limit', None)\n        if format_limit:\n            formats = list(takewhile_inclusive(\n                lambda f: f['format_id'] != format_limit, formats\n            ))\n        if self.params.get('prefer_free_formats'):\n            def _free_formats_key(f):\n                try:\n                    ext_ord = [u'flv', u'mp4', u'webm'].index(f['ext'])\n                except ValueError:\n                    ext_ord = -1\n                # We only compare the extension if they have the same height and width\n                return (f.get('height'), f.get('width'), ext_ord)\n            formats = sorted(formats, key=_free_formats_key)\n\n        req_format = self.params.get('format', 'best')\n        if req_format is None:\n            req_format = 'best'\n        formats_to_download = []\n        # The -1 is for supporting YoutubeIE\n        if req_format in ('-1', 'all'):\n            formats_to_download = formats\n        else:\n            # We can accept formats requestd in the format: 34/5/best, we pick\n            # the first that is available, starting from left\n            req_formats = req_format.split('/')\n            for rf in req_formats:\n                selected_format = self.select_format(rf, formats)\n                if selected_format is not None:\n                    formats_to_download = [selected_format]\n                    break\n        if not formats_to_download:\n            raise ExtractorError(u'requested format not available',\n                                 expected=True)\n\n        if download:\n            if len(formats_to_download) > 1:\n                self.to_screen(u'[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n            for format in formats_to_download:\n                new_info = dict(info_dict)\n                new_info.update(format)\n                self.process_info(new_info)\n        # We update the info dict with the best quality format (backwards compatibility)\n        info_dict.update(formats_to_download[-1])\n        return info_dict\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            # For RTMP URLs, also include the playpath\n            compat_print(info_dict['url'] + info_dict.get('play_path', u''))\n        if self.params.get('forcethumbnail', False) and info_dict.get('thumbnail') is not None:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and info_dict.get('description') is not None:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There\\'s no description to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writeannotations', False):\n            try:\n                annofn = filename + u'.annotations.xml'\n                self.report_writeannotations(annofn)\n                with io.open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                    annofile.write(info_dict['annotations'])\n            except (KeyError, TypeError):\n                self.report_warning(u'There are no annotations to write.')\n            except (OSError, IOError):\n                self.report_error(u'Cannot write annotations file: ' + annofn)\n                return\n\n        subtitles_are_requested = any([self.params.get('writesubtitles', False),\n                                       self.params.get('writeautomaticsub')])\n\n        if subtitles_are_requested and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for sub_lang in subtitles.keys():\n                sub = subtitles[sub_lang]\n                if sub is None:\n                    continue\n                try:\n                    sub_filename = subtitles_filename(filename, sub_lang, sub_format)\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                            subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k, v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if info_dict.get('thumbnail') is not None:\n                thumb_format = determine_ext(info_dict['thumbnail'], u'jpg')\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                try:\n                    uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                    with open(thumb_filename, 'wb') as thumbf:\n                        shutil.copyfileobj(uf, thumbf)\n                    self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                        (info_dict['extractor'], info_dict['id'], thumb_filename))\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_warning(u'Unable to download thumbnail \"%s\": %s' %\n                        (info_dict['thumbnail'], compat_str(err)))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError(err)\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n        self.record_download_archive(info_dict)\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish, new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.report_error(e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n\n    def in_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return False\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        try:\n            with locked_file(fn, 'r', encoding='utf-8') as archive_file:\n                for line in archive_file:\n                    if line.strip() == vid_id:\n                        return True\n        except IOError as ioe:\n            if ioe.errno != errno.ENOENT:\n                raise\n        return False\n\n    def record_download_archive(self, info_dict):\n        fn = self.params.get('download_archive')\n        if fn is None:\n            return\n        vid_id = info_dict['extractor'] + u' ' + info_dict['id']\n        with locked_file(fn, 'a', encoding='utf-8') as archive_file:\n            archive_file.write(vid_id + u'\\n')\n\n    @staticmethod\n    def format_resolution(format, default='unknown'):\n        if format.get('_resolution') is not None:\n            return format['_resolution']\n        if format.get('height') is not None:\n            if format.get('width') is not None:\n                res = u'%sx%s' % (format['width'], format['height'])\n            else:\n                res = u'%sp' % format['height']\n        else:\n            res = default\n        return res\n\n    def list_formats(self, info_dict):\n        def line(format):\n            return (u'%-15s%-10s%-12s%s' % (\n                format['format_id'],\n                format['ext'],\n                self.format_resolution(format),\n                format.get('format_note', ''),\n                )\n            )\n\n        formats = info_dict.get('formats', [info_dict])\n        formats_s = list(map(line, formats))\n        if len(formats) > 1:\n            formats_s[0] += (' ' if formats[0].get('format_note') else '') + '(worst)'\n            formats_s[-1] += (' ' if formats[-1].get('format_note') else '') + '(best)'\n\n        header_line = line({\n            'format_id': u'format code', 'ext': u'extension',\n            '_resolution': u'resolution', 'format_note': u'note'})\n        self.to_screen(u'[info] Available formats for %s:\\n%s\\n%s' %\n                       (info_dict['id'], header_line, u\"\\n\".join(formats_s)))\n",
          "file_patch": "@@ -318,6 +318,12 @@ class YoutubeDL(object):\n                     % info_dict)\n         return None\n \n+    @staticmethod\n+    def add_extra_info(info_dict, extra_info):\n+        '''Set the keys from extra_info in info dict if they are missing'''\n+        for key, value in extra_info.items():\n+            info_dict.setdefault(key, value)\n+\n     def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n         '''\n         Returns a list with a dictionary for each video we find.\n@@ -344,17 +350,13 @@ class YoutubeDL(object):\n                     break\n                 if isinstance(ie_result, list):\n                     # Backwards compatibility: old IE result format\n-                    for result in ie_result:\n-                        result.update(extra_info)\n                     ie_result = {\n                         '_type': 'compat_list',\n                         'entries': ie_result,\n                     }\n-                else:\n-                    ie_result.update(extra_info)\n                 if 'extractor' not in ie_result:\n                     ie_result['extractor'] = ie.IE_NAME\n-                return self.process_ie_result(ie_result, download=download)\n+                return self.process_ie_result(ie_result, download, extra_info)\n             except ExtractorError as de: # An error we somewhat expected\n                 self.report_error(compat_str(de), de.format_traceback())\n                 break\n@@ -378,7 +380,7 @@ class YoutubeDL(object):\n \n         result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n         if result_type == 'video':\n-            ie_result.update(extra_info)\n+            self.add_extra_info(ie_result, extra_info)\n             return self.process_video_result(ie_result)\n         elif result_type == 'url':\n             # We have to add extra_info to the results because it may be\n@@ -388,6 +390,7 @@ class YoutubeDL(object):\n                                      ie_key=ie_result.get('ie_key'),\n                                      extra_info=extra_info)\n         elif result_type == 'playlist':\n+            self.add_extra_info(ie_result, extra_info)\n             # We process each entry in the playlist\n             playlist = ie_result.get('title', None) or ie_result.get('id', None)\n             self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n@@ -413,12 +416,8 @@ class YoutubeDL(object):\n                 extra = {\n                     'playlist': playlist,\n                     'playlist_index': i + playliststart,\n+                    'extractor': ie_result['extractor'],\n                 }\n-                if not 'extractor' in entry:\n-                    # We set the extractor, if it's an url it will be set then to\n-                    # the new extractor, but if it's already a video we must make\n-                    # sure it's present: see issue #877\n-                    entry['extractor'] = ie_result['extractor']\n                 entry_result = self.process_ie_result(entry,\n                                                       download=download,\n                                                       extra_info=extra)\n@@ -427,10 +426,11 @@ class YoutubeDL(object):\n             return ie_result\n         elif result_type == 'compat_list':\n             def _fixup(r):\n-                r.setdefault('extractor', ie_result['extractor'])\n+                self.add_extra_info(r,\n+                    {'extractor': ie_result['extractor']})\n                 return r\n             ie_result['entries'] = [\n-                self.process_ie_result(_fixup(r), download=download)\n+                self.process_ie_result(_fixup(r), download, extra_info)\n                 for r in ie_result['entries']\n             ]\n             return ie_result\n",
          "files_name_in_blame_commit": [
            "test_YoutubeDL.py",
            "YoutubeDL.py"
          ]
        }
      },
      "8222d8de88bd23c063500c246676ed028a9aa073": {
        "commit": {
          "commit_id": "8222d8de88bd23c063500c246676ed028a9aa073",
          "commit_message": "Split FileDownloader in two classes: FileDownloader and YoutubeDL\n\nYoutubeDL is the class that coordinates everything\nFileDownloader gets a filename and an info dict and downloads the video.",
          "commit_author": "Jaime Marqui\u0301nez Ferra\u0301ndiz",
          "commit_date": "2013-06-24 10:21:43",
          "commit_parent": "c7253e2e8c10ac537defea4a6ba4bb183b9db1e7"
        },
        "function": {
          "function_name": "process_ie_result",
          "function_code_before": "",
          "function_code_after": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n    result_type = ie_result.get('_type', 'video')\n    if result_type == 'video':\n        if 'playlist' not in ie_result:\n            ie_result['playlist'] = None\n            ie_result['playlist_index'] = None\n        if download:\n            self.process_info(ie_result)\n        return ie_result\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'playlist':\n        playlist = ie_result.get('title', None) or ie_result.get('id', None)\n        self.to_screen(u'[download] Downloading playlist: %s' % playlist)\n        playlist_results = []\n        n_all_entries = len(ie_result['entries'])\n        playliststart = self.params.get('playliststart', 1) - 1\n        playlistend = self.params.get('playlistend', -1)\n        if playlistend == -1:\n            entries = ie_result['entries'][playliststart:]\n        else:\n            entries = ie_result['entries'][playliststart:playlistend]\n        n_entries = len(entries)\n        self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" % (ie_result['extractor'], playlist, n_all_entries, n_entries))\n        for (i, entry) in enumerate(entries, 1):\n            self.to_screen(u'[download] Downloading video #%s of %s' % (i, n_entries))\n            extra = {'playlist': playlist, 'playlist_index': i + playliststart}\n            if not 'extractor' in entry:\n                entry['extractor'] = ie_result['extractor']\n            entry_result = self.process_ie_result(entry, download=download, extra_info=extra)\n            playlist_results.append(entry_result)\n        ie_result['entries'] = playlist_results\n        return ie_result\n    elif result_type == 'compat_list':\n\n        def _fixup(r):\n            r.setdefault('extractor', ie_result['extractor'])\n            return r\n        ie_result['entries'] = [self.process_ie_result(_fixup(r), download=download) for r in ie_result['entries']]\n        return ie_result\n    else:\n        raise Exception('Invalid result type: %s' % result_type)",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 331,
          "function_after_end_line": 404,
          "function_before_token_count": 0,
          "function_after_token_count": 348,
          "functions_name_modified_file": [
            "slow_down",
            "to_stderr",
            "extract_info",
            "report_warning",
            "trouble",
            "increment_downloads",
            "process_info",
            "process_ie_result",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "download",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "report_file_already_downloaded"
          ],
          "functions_name_all_files": [
            "tearDown",
            "_hook_progress",
            "temp_name",
            "slow_down",
            "report_destination",
            "calc_eta",
            "calc_speed",
            "to_stderr",
            "generator",
            "report_retry",
            "_try_rm",
            "extract_info",
            "report_warning",
            "report_unable_to_resume",
            "format_bytes",
            "parseOpts",
            "main",
            "report_progress",
            "trouble",
            "_real_main",
            "increment_downloads",
            "undo_temp_name",
            "to_cons_title",
            "process_info",
            "try_rename",
            "process_ie_result",
            "post_process",
            "_do_download",
            "add_post_processor",
            "_download_with_rtmpdump",
            "try_utime",
            "parse_bytes",
            "add_progress_hook",
            "prepare_filename",
            "_file_md5",
            "to_screen",
            "best_block_size",
            "report_writedescription",
            "_match_entry",
            "report_finish",
            "setUp",
            "__init__",
            "test_info_json",
            "report_error",
            "fixed_template",
            "download",
            "report_resuming_byte",
            "add_info_extractor",
            "report_writeinfojson",
            "calc_percent",
            "report_writesubtitles",
            "report_file_already_downloaded",
            "_download_with_mplayer"
          ],
          "functions_name_co_evolved_modified_file": [
            "slow_down",
            "to_stderr",
            "extract_info",
            "report_warning",
            "trouble",
            "increment_downloads",
            "process_info",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "fixed_template",
            "report_error",
            "download",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "report_file_already_downloaded"
          ],
          "functions_name_co_evolved_all_files": [
            "slow_down",
            "to_stderr",
            "generator",
            "extract_info",
            "report_warning",
            "trouble",
            "_real_main",
            "increment_downloads",
            "process_info",
            "post_process",
            "add_post_processor",
            "prepare_filename",
            "to_screen",
            "report_writedescription",
            "_match_entry",
            "__init__",
            "test_info_json",
            "report_error",
            "fixed_template",
            "download",
            "add_info_extractor",
            "report_writeinfojson",
            "report_writesubtitles",
            "report_file_already_downloaded"
          ]
        },
        "file": {
          "file_name": "YoutubeDL.py",
          "file_nloc": 468,
          "file_complexity": 143,
          "file_token_count": 3158,
          "file_before": null,
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport sys\nimport time\nimport traceback\n\nfrom .utils import *\nfrom .extractor import get_info_extractor\nfrom .FileDownloader import FileDownloader\n\n\nclass YoutubeDL(object):\n    \"\"\"YoutubeDL class.\n\n    YoutubeDL objects are the ones responsible of downloading the\n    actual video file and writing it to disk if the user has requested\n    it, among some other tasks. In most cases there should be one per\n    program. As, given a video URL, the downloader doesn't know how to\n    extract all the needed information, task that InfoExtractors do, it\n    has to pass the URL to one of them.\n\n    For this, YoutubeDL objects have a method that allows\n    InfoExtractors to be registered in a given order. When it is passed\n    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n    finds that reports being able to handle it. The InfoExtractor extracts\n    all the information about the video or videos the URL refers to, and\n    YoutubeDL process the extracted information, possibly using a File\n    Downloader to download the video.\n\n    YoutubeDL objects accept a lot of parameters. In order not to saturate\n    the object constructor with arguments, it receives a dictionary of\n    options instead. These options are available through the params\n    attribute for the InfoExtractors to use. The YoutubeDL also\n    registers itself as the downloader in charge for the InfoExtractors\n    that are added to it, so this is a \"mutual registration\".\n\n    Available options:\n\n    username:          Username for authentication purposes.\n    password:          Password for authentication purposes.\n    usenetrc:          Use netrc for authentication instead.\n    verbose:           Print additional info to stdout.\n    quiet:             Do not print messages to stdout.\n    forceurl:          Force printing final URL.\n    forcetitle:        Force printing title.\n    forceid:           Force printing ID.\n    forcethumbnail:    Force printing thumbnail URL.\n    forcedescription:  Force printing description.\n    forcefilename:     Force printing final filename.\n    simulate:          Do not download the video files.\n    format:            Video format code.\n    format_limit:      Highest quality format to try.\n    outtmpl:           Template for output names.\n    restrictfilenames: Do not allow \"&\" and spaces in file names\n    ignoreerrors:      Do not stop on download errors.\n    nooverwrites:      Prevent overwriting files.\n    playliststart:     Playlist item to start at.\n    playlistend:       Playlist item to end at.\n    matchtitle:        Download only matching titles.\n    rejecttitle:       Reject downloads for matching titles.\n    logtostderr:       Log messages to stderr instead of stdout.\n    writedescription:  Write the video description to a .description file\n    writeinfojson:     Write the video description to a .info.json file\n    writethumbnail:    Write the thumbnail image to a file\n    writesubtitles:    Write the video subtitles to a file\n    allsubtitles:      Downloads all the subtitles of the video\n    listsubtitles:     Lists all available subtitles for the video\n    subtitlesformat:   Subtitle format [sbv/srt] (default=srt)\n    subtitleslang:     Language of the subtitles to download\n    keepvideo:         Keep the video file after post-processing\n    daterange:         A DateRange object, download only if the upload_date is in the range.\n    skip_download:     Skip the actual download of the video file\n    \n    The following parameters are not used by YoutubeDL itself, they are used by\n    the FileDownloader:\n    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n    noresizebuffer, retries, continuedl, noprogress, consoletitle\n    \"\"\"\n\n    params = None\n    _ies = []\n    _pps = []\n    _download_retcode = None\n    _num_downloads = None\n    _screen_file = None\n\n    def __init__(self, params):\n        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n        self._ies = []\n        self._pps = []\n        self._progress_hooks = []\n        self._download_retcode = 0\n        self._num_downloads = 0\n        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n        self.params = params\n        self.fd = FileDownloader(self, self.params)\n\n        if '%(stitle)s' in self.params['outtmpl']:\n            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n\n    def add_info_extractor(self, ie):\n        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n        self._ies.append(ie)\n        ie.set_downloader(self)\n\n    def add_post_processor(self, pp):\n        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n        self._pps.append(pp)\n        pp.set_downloader(self)\n\n    def to_screen(self, message, skip_eol=False):\n        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n        assert type(message) == type(u'')\n        if not self.params.get('quiet', False):\n            terminator = [u'\\n', u''][skip_eol]\n            output = message + terminator\n            if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n                output = output.encode(preferredencoding(), 'ignore')\n            self._screen_file.write(output)\n            self._screen_file.flush()\n\n    def to_stderr(self, message):\n        \"\"\"Print message to stderr.\"\"\"\n        assert type(message) == type(u'')\n        output = message + u'\\n'\n        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n            output = output.encode(preferredencoding())\n        sys.stderr.write(output)\n\n    def fixed_template(self):\n        \"\"\"Checks if the output template is fixed.\"\"\"\n        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n\n    def trouble(self, message=None, tb=None):\n        \"\"\"Determine action to take when a download problem appears.\n\n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n\n        tb, if given, is additional traceback information.\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = u''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = u''.join(tb_data)\n            self.to_stderr(tb)\n        if not self.params.get('ignoreerrors', False):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n            raise DownloadError(message, exc_info)\n        self._download_retcode = 1\n\n    def report_warning(self, message):\n        '''\n        Print the message to stderr, it will be prefixed with 'WARNING:'\n        If stderr is a tty file the 'WARNING:' will be colored\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header=u'\\033[0;33mWARNING:\\033[0m'\n        else:\n            _msg_header=u'WARNING:'\n        warning_message=u'%s %s' % (_msg_header,message)\n        self.to_stderr(warning_message)\n\n    def report_error(self, message, tb=None):\n        '''\n        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n        in red if stderr is a tty file.\n        '''\n        if sys.stderr.isatty() and os.name != 'nt':\n            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n        else:\n            _msg_header = u'ERROR:'\n        error_message = u'%s %s' % (_msg_header, message)\n        self.trouble(error_message, tb)\n\n    def slow_down(self, start_time, byte_counter):\n        \"\"\"Sleep if the download speed is over the rate limit.\"\"\"\n        rate_limit = self.params.get('ratelimit', None)\n        if rate_limit is None or byte_counter == 0:\n            return\n        now = time.time()\n        elapsed = now - start_time\n        if elapsed <= 0.0:\n            return\n        speed = float(byte_counter) / elapsed\n        if speed > rate_limit:\n            time.sleep((byte_counter - rate_limit * (now - start_time)) / rate_limit)\n\n    def report_writedescription(self, descfn):\n        \"\"\" Report that the description file is being written \"\"\"\n        self.to_screen(u'[info] Writing video description to: ' + descfn)\n\n    def report_writesubtitles(self, sub_filename):\n        \"\"\" Report that the subtitles file is being written \"\"\"\n        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n\n    def report_writeinfojson(self, infofn):\n        \"\"\" Report that the metadata file has been written \"\"\"\n        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n\n    def report_file_already_downloaded(self, file_name):\n        \"\"\"Report file has already been fully downloaded.\"\"\"\n        try:\n            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n        except (UnicodeEncodeError) as err:\n            self.to_screen(u'[download] The file has already been downloaded')\n\n    def increment_downloads(self):\n        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n        self._num_downloads += 1\n\n    def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            template_dict = dict(info_dict)\n\n            template_dict['epoch'] = int(time.time())\n            autonumber_size = self.params.get('autonumber_size')\n            if autonumber_size is None:\n                autonumber_size = 5\n            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n            if template_dict['playlist_index'] is not None:\n                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n\n            sanitize = lambda k,v: sanitize_filename(\n                u'NA' if v is None else compat_str(v),\n                restricted=self.params.get('restrictfilenames'),\n                is_id=(k==u'id'))\n            template_dict = dict((k, sanitize(k, v)) for k,v in template_dict.items())\n\n            filename = self.params['outtmpl'] % template_dict\n            return filename\n        except KeyError as err:\n            self.report_error(u'Erroneous output template')\n            return None\n        except ValueError as err:\n            self.report_error(u'Insufficient system charset ' + repr(preferredencoding()))\n            return None\n\n    def _match_entry(self, info_dict):\n        \"\"\" Returns None iff the file should be downloaded \"\"\"\n\n        title = info_dict['title']\n        matchtitle = self.params.get('matchtitle', False)\n        if matchtitle:\n            if not re.search(matchtitle, title, re.IGNORECASE):\n                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n        rejecttitle = self.params.get('rejecttitle', False)\n        if rejecttitle:\n            if re.search(rejecttitle, title, re.IGNORECASE):\n                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n        date = info_dict.get('upload_date', None)\n        if date is not None:\n            dateRange = self.params.get('daterange', DateRange())\n            if date not in dateRange:\n                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n        return None\n        \n    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n        '''\n        Returns a list with a dictionary for each video we find.\n        If 'download', also downloads the videos.\n        extra_info is a dict containing the extra values to add to each result\n         '''\n        \n        if ie_key:\n            ie = get_info_extractor(ie_key)()\n            ie.set_downloader(self)\n            ies = [ie]\n        else:\n            ies = self._ies\n\n        for ie in ies:\n            if not ie.suitable(url):\n                continue\n\n            if not ie.working():\n                self.report_warning(u'The program functionality for this site has been marked as broken, '\n                                    u'and will probably not work.')\n\n            try:\n                ie_result = ie.extract(url)\n                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n                    break\n                if isinstance(ie_result, list):\n                    # Backwards compatibility: old IE result format\n                    for result in ie_result:\n                        result.update(extra_info)\n                    ie_result = {\n                        '_type': 'compat_list',\n                        'entries': ie_result,\n                    }\n                else:\n                    ie_result.update(extra_info)\n                if 'extractor' not in ie_result:\n                    ie_result['extractor'] = ie.IE_NAME\n                return self.process_ie_result(ie_result, download=download)\n            except ExtractorError as de: # An error we somewhat expected\n                self.report_error(compat_str(de), de.format_traceback())\n                break\n            except Exception as e:\n                if self.params.get('ignoreerrors', False):\n                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n                    break\n                else:\n                    raise\n        else:\n            self.report_error(u'no suitable InfoExtractor: %s' % url)\n        \n    def process_ie_result(self, ie_result, download=True, extra_info={}):\n        \"\"\"\n        Take the result of the ie(may be modified) and resolve all unresolved\n        references (URLs, playlist items).\n\n        It will also download the videos if 'download'.\n        Returns the resolved ie_result.\n        \"\"\"\n\n        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n        if result_type == 'video':\n            if 'playlist' not in ie_result:\n                # It isn't part of a playlist\n                ie_result['playlist'] = None\n                ie_result['playlist_index'] = None\n            if download:\n                self.process_info(ie_result)\n            return ie_result\n        elif result_type == 'url':\n            # We have to add extra_info to the results because it may be\n            # contained in a playlist\n            return self.extract_info(ie_result['url'],\n                                     download,\n                                     ie_key=ie_result.get('ie_key'),\n                                     extra_info=extra_info)\n        elif result_type == 'playlist':\n            # We process each entry in the playlist\n            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n            self.to_screen(u'[download] Downloading playlist: %s'  % playlist)\n\n            playlist_results = []\n\n            n_all_entries = len(ie_result['entries'])\n            playliststart = self.params.get('playliststart', 1) - 1\n            playlistend = self.params.get('playlistend', -1)\n\n            if playlistend == -1:\n                entries = ie_result['entries'][playliststart:]\n            else:\n                entries = ie_result['entries'][playliststart:playlistend]\n\n            n_entries = len(entries)\n\n            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n\n            for i,entry in enumerate(entries,1):\n                self.to_screen(u'[download] Downloading video #%s of %s' %(i, n_entries))\n                extra = {\n                         'playlist': playlist, \n                         'playlist_index': i + playliststart,\n                         }\n                if not 'extractor' in entry:\n                    # We set the extractor, if it's an url it will be set then to\n                    # the new extractor, but if it's already a video we must make\n                    # sure it's present: see issue #877\n                    entry['extractor'] = ie_result['extractor']\n                entry_result = self.process_ie_result(entry,\n                                                      download=download,\n                                                      extra_info=extra)\n                playlist_results.append(entry_result)\n            ie_result['entries'] = playlist_results\n            return ie_result\n        elif result_type == 'compat_list':\n            def _fixup(r):\n                r.setdefault('extractor', ie_result['extractor'])\n                return r\n            ie_result['entries'] = [\n                self.process_ie_result(_fixup(r), download=download)\n                for r in ie_result['entries']\n            ]\n            return ie_result\n        else:\n            raise Exception('Invalid result type: %s' % result_type)\n\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result.\"\"\"\n\n        assert info_dict.get('_type', 'video') == 'video'\n        #We increment the download the download count here to match the previous behaviour.\n        self.increment_downloads()\n\n        info_dict['fulltitle'] = info_dict['title']\n        if len(info_dict['title']) > 200:\n            info_dict['title'] = info_dict['title'][:197] + u'...'\n\n        # Keep for backwards compatibility\n        info_dict['stitle'] = info_dict['title']\n\n        if not 'format' in info_dict:\n            info_dict['format'] = info_dict['ext']\n\n        reason = self._match_entry(info_dict)\n        if reason is not None:\n            self.to_screen(u'[download] ' + reason)\n            return\n\n        max_downloads = self.params.get('max_downloads')\n        if max_downloads is not None:\n            if self._num_downloads > int(max_downloads):\n                raise MaxDownloadsReached()\n\n        filename = self.prepare_filename(info_dict)\n\n        # Forced printings\n        if self.params.get('forcetitle', False):\n            compat_print(info_dict['title'])\n        if self.params.get('forceid', False):\n            compat_print(info_dict['id'])\n        if self.params.get('forceurl', False):\n            compat_print(info_dict['url'])\n        if self.params.get('forcethumbnail', False) and 'thumbnail' in info_dict:\n            compat_print(info_dict['thumbnail'])\n        if self.params.get('forcedescription', False) and 'description' in info_dict:\n            compat_print(info_dict['description'])\n        if self.params.get('forcefilename', False) and filename is not None:\n            compat_print(filename)\n        if self.params.get('forceformat', False):\n            compat_print(info_dict['format'])\n\n        # Do nothing else if in simulate mode\n        if self.params.get('simulate', False):\n            return\n\n        if filename is None:\n            return\n\n        try:\n            dn = os.path.dirname(encodeFilename(filename))\n            if dn != '' and not os.path.exists(dn):\n                os.makedirs(dn)\n        except (OSError, IOError) as err:\n            self.report_error(u'unable to create directory ' + compat_str(err))\n            return\n\n        if self.params.get('writedescription', False):\n            try:\n                descfn = filename + u'.description'\n                self.report_writedescription(descfn)\n                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n                    descfile.write(info_dict['description'])\n            except (OSError, IOError):\n                self.report_error(u'Cannot write description file ' + descfn)\n                return\n\n        if self.params.get('writesubtitles', False) and 'subtitles' in info_dict and info_dict['subtitles']:\n            # subtitles download errors are already managed as troubles in relevant IE\n            # that way it will silently go on when used with unsupporting IE\n            subtitle = info_dict['subtitles'][0]\n            (sub_error, sub_lang, sub) = subtitle\n            sub_format = self.params.get('subtitlesformat')\n            if sub_error:\n                self.report_warning(\"Some error while getting the subtitles\")\n            else:\n                try:\n                    sub_filename = filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n                    self.report_writesubtitles(sub_filename)\n                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                        subfile.write(sub)\n                except (OSError, IOError):\n                    self.report_error(u'Cannot write subtitles file ' + descfn)\n                    return\n\n        if self.params.get('allsubtitles', False) and 'subtitles' in info_dict and info_dict['subtitles']:\n            subtitles = info_dict['subtitles']\n            sub_format = self.params.get('subtitlesformat')\n            for subtitle in subtitles:\n                (sub_error, sub_lang, sub) = subtitle\n                if sub_error:\n                    self.report_warning(\"Some error while getting the subtitles\")\n                else:\n                    try:\n                        sub_filename = filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n                        self.report_writesubtitles(sub_filename)\n                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n                                subfile.write(sub)\n                    except (OSError, IOError):\n                        self.report_error(u'Cannot write subtitles file ' + descfn)\n                        return\n\n        if self.params.get('writeinfojson', False):\n            infofn = filename + u'.info.json'\n            self.report_writeinfojson(infofn)\n            try:\n                json_info_dict = dict((k, v) for k,v in info_dict.items() if not k in ['urlhandle'])\n                write_json_file(json_info_dict, encodeFilename(infofn))\n            except (OSError, IOError):\n                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n                return\n\n        if self.params.get('writethumbnail', False):\n            if 'thumbnail' in info_dict:\n                thumb_format = info_dict['thumbnail'].rpartition(u'/')[2].rpartition(u'.')[2]\n                if not thumb_format:\n                    thumb_format = 'jpg'\n                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n                               (info_dict['extractor'], info_dict['id']))\n                uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n                with open(thumb_filename, 'wb') as thumbf:\n                    shutil.copyfileobj(uf, thumbf)\n                self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n                               (info_dict['extractor'], info_dict['id'], thumb_filename))\n\n        if not self.params.get('skip_download', False):\n            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n                success = True\n            else:\n                try:\n                    success = self.fd._do_download(filename, info_dict)\n                except (OSError, IOError) as err:\n                    raise UnavailableVideoError()\n                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n                    self.report_error(u'unable to download video data: %s' % str(err))\n                    return\n                except (ContentTooShortError, ) as err:\n                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n                    return\n\n            if success:\n                try:\n                    self.post_process(filename, info_dict)\n                except (PostProcessingError) as err:\n                    self.report_error(u'postprocessing: %s' % str(err))\n                    return\n\n    def download(self, url_list):\n        \"\"\"Download a given list of URLs.\"\"\"\n        if len(url_list) > 1 and self.fixed_template():\n            raise SameFileError(self.params['outtmpl'])\n\n        for url in url_list:\n            try:\n                #It also downloads the videos\n                videos = self.extract_info(url)\n            except UnavailableVideoError:\n                self.report_error(u'unable to download video')\n            except MaxDownloadsReached:\n                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n                raise\n\n        return self._download_retcode\n\n    def post_process(self, filename, ie_info):\n        \"\"\"Run all the postprocessors on the given file.\"\"\"\n        info = dict(ie_info)\n        info['filepath'] = filename\n        keep_video = None\n        for pp in self._pps:\n            try:\n                keep_video_wish,new_info = pp.run(info)\n                if keep_video_wish is not None:\n                    if keep_video_wish:\n                        keep_video = keep_video_wish\n                    elif keep_video is None:\n                        # No clear decision yet, let IE decide\n                        keep_video = keep_video_wish\n            except PostProcessingError as e:\n                self.to_stderr(u'ERROR: ' + e.msg)\n        if keep_video is False and not self.params.get('keepvideo', False):\n            try:\n                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n                os.remove(encodeFilename(filename))\n            except (IOError, OSError):\n                self.report_warning(u'Unable to remove downloaded video file')\n",
          "file_patch": "@@ -0,0 +1,595 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+from __future__ import absolute_import\n+\n+import io\n+import os\n+import re\n+import shutil\n+import socket\n+import sys\n+import time\n+import traceback\n+\n+from .utils import *\n+from .extractor import get_info_extractor\n+from .FileDownloader import FileDownloader\n+\n+\n+class YoutubeDL(object):\n+    \"\"\"YoutubeDL class.\n+\n+    YoutubeDL objects are the ones responsible of downloading the\n+    actual video file and writing it to disk if the user has requested\n+    it, among some other tasks. In most cases there should be one per\n+    program. As, given a video URL, the downloader doesn't know how to\n+    extract all the needed information, task that InfoExtractors do, it\n+    has to pass the URL to one of them.\n+\n+    For this, YoutubeDL objects have a method that allows\n+    InfoExtractors to be registered in a given order. When it is passed\n+    a URL, the YoutubeDL object handles it to the first InfoExtractor it\n+    finds that reports being able to handle it. The InfoExtractor extracts\n+    all the information about the video or videos the URL refers to, and\n+    YoutubeDL process the extracted information, possibly using a File\n+    Downloader to download the video.\n+\n+    YoutubeDL objects accept a lot of parameters. In order not to saturate\n+    the object constructor with arguments, it receives a dictionary of\n+    options instead. These options are available through the params\n+    attribute for the InfoExtractors to use. The YoutubeDL also\n+    registers itself as the downloader in charge for the InfoExtractors\n+    that are added to it, so this is a \"mutual registration\".\n+\n+    Available options:\n+\n+    username:          Username for authentication purposes.\n+    password:          Password for authentication purposes.\n+    usenetrc:          Use netrc for authentication instead.\n+    verbose:           Print additional info to stdout.\n+    quiet:             Do not print messages to stdout.\n+    forceurl:          Force printing final URL.\n+    forcetitle:        Force printing title.\n+    forceid:           Force printing ID.\n+    forcethumbnail:    Force printing thumbnail URL.\n+    forcedescription:  Force printing description.\n+    forcefilename:     Force printing final filename.\n+    simulate:          Do not download the video files.\n+    format:            Video format code.\n+    format_limit:      Highest quality format to try.\n+    outtmpl:           Template for output names.\n+    restrictfilenames: Do not allow \"&\" and spaces in file names\n+    ignoreerrors:      Do not stop on download errors.\n+    nooverwrites:      Prevent overwriting files.\n+    playliststart:     Playlist item to start at.\n+    playlistend:       Playlist item to end at.\n+    matchtitle:        Download only matching titles.\n+    rejecttitle:       Reject downloads for matching titles.\n+    logtostderr:       Log messages to stderr instead of stdout.\n+    writedescription:  Write the video description to a .description file\n+    writeinfojson:     Write the video description to a .info.json file\n+    writethumbnail:    Write the thumbnail image to a file\n+    writesubtitles:    Write the video subtitles to a file\n+    allsubtitles:      Downloads all the subtitles of the video\n+    listsubtitles:     Lists all available subtitles for the video\n+    subtitlesformat:   Subtitle format [sbv/srt] (default=srt)\n+    subtitleslang:     Language of the subtitles to download\n+    keepvideo:         Keep the video file after post-processing\n+    daterange:         A DateRange object, download only if the upload_date is in the range.\n+    skip_download:     Skip the actual download of the video file\n+    \n+    The following parameters are not used by YoutubeDL itself, they are used by\n+    the FileDownloader:\n+    nopart, updatetime, buffersize, ratelimit, min_filesize, max_filesize, test,\n+    noresizebuffer, retries, continuedl, noprogress, consoletitle\n+    \"\"\"\n+\n+    params = None\n+    _ies = []\n+    _pps = []\n+    _download_retcode = None\n+    _num_downloads = None\n+    _screen_file = None\n+\n+    def __init__(self, params):\n+        \"\"\"Create a FileDownloader object with the given options.\"\"\"\n+        self._ies = []\n+        self._pps = []\n+        self._progress_hooks = []\n+        self._download_retcode = 0\n+        self._num_downloads = 0\n+        self._screen_file = [sys.stdout, sys.stderr][params.get('logtostderr', False)]\n+        self.params = params\n+        self.fd = FileDownloader(self, self.params)\n+\n+        if '%(stitle)s' in self.params['outtmpl']:\n+            self.report_warning(u'%(stitle)s is deprecated. Use the %(title)s and the --restrict-filenames flag(which also secures %(uploader)s et al) instead.')\n+\n+    def add_info_extractor(self, ie):\n+        \"\"\"Add an InfoExtractor object to the end of the list.\"\"\"\n+        self._ies.append(ie)\n+        ie.set_downloader(self)\n+\n+    def add_post_processor(self, pp):\n+        \"\"\"Add a PostProcessor object to the end of the chain.\"\"\"\n+        self._pps.append(pp)\n+        pp.set_downloader(self)\n+\n+    def to_screen(self, message, skip_eol=False):\n+        \"\"\"Print message to stdout if not in quiet mode.\"\"\"\n+        assert type(message) == type(u'')\n+        if not self.params.get('quiet', False):\n+            terminator = [u'\\n', u''][skip_eol]\n+            output = message + terminator\n+            if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n+                output = output.encode(preferredencoding(), 'ignore')\n+            self._screen_file.write(output)\n+            self._screen_file.flush()\n+\n+    def to_stderr(self, message):\n+        \"\"\"Print message to stderr.\"\"\"\n+        assert type(message) == type(u'')\n+        output = message + u'\\n'\n+        if 'b' in getattr(self._screen_file, 'mode', '') or sys.version_info[0] < 3: # Python 2 lies about the mode of sys.stdout/sys.stderr\n+            output = output.encode(preferredencoding())\n+        sys.stderr.write(output)\n+\n+    def fixed_template(self):\n+        \"\"\"Checks if the output template is fixed.\"\"\"\n+        return (re.search(u'(?u)%\\\\(.+?\\\\)s', self.params['outtmpl']) is None)\n+\n+    def trouble(self, message=None, tb=None):\n+        \"\"\"Determine action to take when a download problem appears.\n+\n+        Depending on if the downloader has been configured to ignore\n+        download errors or not, this method may throw an exception or\n+        not when errors are found, after printing the message.\n+\n+        tb, if given, is additional traceback information.\n+        \"\"\"\n+        if message is not None:\n+            self.to_stderr(message)\n+        if self.params.get('verbose'):\n+            if tb is None:\n+                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n+                    tb = u''\n+                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n+                        tb += u''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n+                    tb += compat_str(traceback.format_exc())\n+                else:\n+                    tb_data = traceback.format_list(traceback.extract_stack())\n+                    tb = u''.join(tb_data)\n+            self.to_stderr(tb)\n+        if not self.params.get('ignoreerrors', False):\n+            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n+                exc_info = sys.exc_info()[1].exc_info\n+            else:\n+                exc_info = sys.exc_info()\n+            raise DownloadError(message, exc_info)\n+        self._download_retcode = 1\n+\n+    def report_warning(self, message):\n+        '''\n+        Print the message to stderr, it will be prefixed with 'WARNING:'\n+        If stderr is a tty file the 'WARNING:' will be colored\n+        '''\n+        if sys.stderr.isatty() and os.name != 'nt':\n+            _msg_header=u'\\033[0;33mWARNING:\\033[0m'\n+        else:\n+            _msg_header=u'WARNING:'\n+        warning_message=u'%s %s' % (_msg_header,message)\n+        self.to_stderr(warning_message)\n+\n+    def report_error(self, message, tb=None):\n+        '''\n+        Do the same as trouble, but prefixes the message with 'ERROR:', colored\n+        in red if stderr is a tty file.\n+        '''\n+        if sys.stderr.isatty() and os.name != 'nt':\n+            _msg_header = u'\\033[0;31mERROR:\\033[0m'\n+        else:\n+            _msg_header = u'ERROR:'\n+        error_message = u'%s %s' % (_msg_header, message)\n+        self.trouble(error_message, tb)\n+\n+    def slow_down(self, start_time, byte_counter):\n+        \"\"\"Sleep if the download speed is over the rate limit.\"\"\"\n+        rate_limit = self.params.get('ratelimit', None)\n+        if rate_limit is None or byte_counter == 0:\n+            return\n+        now = time.time()\n+        elapsed = now - start_time\n+        if elapsed <= 0.0:\n+            return\n+        speed = float(byte_counter) / elapsed\n+        if speed > rate_limit:\n+            time.sleep((byte_counter - rate_limit * (now - start_time)) / rate_limit)\n+\n+    def report_writedescription(self, descfn):\n+        \"\"\" Report that the description file is being written \"\"\"\n+        self.to_screen(u'[info] Writing video description to: ' + descfn)\n+\n+    def report_writesubtitles(self, sub_filename):\n+        \"\"\" Report that the subtitles file is being written \"\"\"\n+        self.to_screen(u'[info] Writing video subtitles to: ' + sub_filename)\n+\n+    def report_writeinfojson(self, infofn):\n+        \"\"\" Report that the metadata file has been written \"\"\"\n+        self.to_screen(u'[info] Video description metadata as JSON to: ' + infofn)\n+\n+    def report_file_already_downloaded(self, file_name):\n+        \"\"\"Report file has already been fully downloaded.\"\"\"\n+        try:\n+            self.to_screen(u'[download] %s has already been downloaded' % file_name)\n+        except (UnicodeEncodeError) as err:\n+            self.to_screen(u'[download] The file has already been downloaded')\n+\n+    def increment_downloads(self):\n+        \"\"\"Increment the ordinal that assigns a number to each file.\"\"\"\n+        self._num_downloads += 1\n+\n+    def prepare_filename(self, info_dict):\n+        \"\"\"Generate the output filename.\"\"\"\n+        try:\n+            template_dict = dict(info_dict)\n+\n+            template_dict['epoch'] = int(time.time())\n+            autonumber_size = self.params.get('autonumber_size')\n+            if autonumber_size is None:\n+                autonumber_size = 5\n+            autonumber_templ = u'%0' + str(autonumber_size) + u'd'\n+            template_dict['autonumber'] = autonumber_templ % self._num_downloads\n+            if template_dict['playlist_index'] is not None:\n+                template_dict['playlist_index'] = u'%05d' % template_dict['playlist_index']\n+\n+            sanitize = lambda k,v: sanitize_filename(\n+                u'NA' if v is None else compat_str(v),\n+                restricted=self.params.get('restrictfilenames'),\n+                is_id=(k==u'id'))\n+            template_dict = dict((k, sanitize(k, v)) for k,v in template_dict.items())\n+\n+            filename = self.params['outtmpl'] % template_dict\n+            return filename\n+        except KeyError as err:\n+            self.report_error(u'Erroneous output template')\n+            return None\n+        except ValueError as err:\n+            self.report_error(u'Insufficient system charset ' + repr(preferredencoding()))\n+            return None\n+\n+    def _match_entry(self, info_dict):\n+        \"\"\" Returns None iff the file should be downloaded \"\"\"\n+\n+        title = info_dict['title']\n+        matchtitle = self.params.get('matchtitle', False)\n+        if matchtitle:\n+            if not re.search(matchtitle, title, re.IGNORECASE):\n+                return u'[download] \"' + title + '\" title did not match pattern \"' + matchtitle + '\"'\n+        rejecttitle = self.params.get('rejecttitle', False)\n+        if rejecttitle:\n+            if re.search(rejecttitle, title, re.IGNORECASE):\n+                return u'\"' + title + '\" title matched reject pattern \"' + rejecttitle + '\"'\n+        date = info_dict.get('upload_date', None)\n+        if date is not None:\n+            dateRange = self.params.get('daterange', DateRange())\n+            if date not in dateRange:\n+                return u'[download] %s upload date is not in range %s' % (date_from_str(date).isoformat(), dateRange)\n+        return None\n+        \n+    def extract_info(self, url, download=True, ie_key=None, extra_info={}):\n+        '''\n+        Returns a list with a dictionary for each video we find.\n+        If 'download', also downloads the videos.\n+        extra_info is a dict containing the extra values to add to each result\n+         '''\n+        \n+        if ie_key:\n+            ie = get_info_extractor(ie_key)()\n+            ie.set_downloader(self)\n+            ies = [ie]\n+        else:\n+            ies = self._ies\n+\n+        for ie in ies:\n+            if not ie.suitable(url):\n+                continue\n+\n+            if not ie.working():\n+                self.report_warning(u'The program functionality for this site has been marked as broken, '\n+                                    u'and will probably not work.')\n+\n+            try:\n+                ie_result = ie.extract(url)\n+                if ie_result is None: # Finished already (backwards compatibility; listformats and friends should be moved here)\n+                    break\n+                if isinstance(ie_result, list):\n+                    # Backwards compatibility: old IE result format\n+                    for result in ie_result:\n+                        result.update(extra_info)\n+                    ie_result = {\n+                        '_type': 'compat_list',\n+                        'entries': ie_result,\n+                    }\n+                else:\n+                    ie_result.update(extra_info)\n+                if 'extractor' not in ie_result:\n+                    ie_result['extractor'] = ie.IE_NAME\n+                return self.process_ie_result(ie_result, download=download)\n+            except ExtractorError as de: # An error we somewhat expected\n+                self.report_error(compat_str(de), de.format_traceback())\n+                break\n+            except Exception as e:\n+                if self.params.get('ignoreerrors', False):\n+                    self.report_error(compat_str(e), tb=compat_str(traceback.format_exc()))\n+                    break\n+                else:\n+                    raise\n+        else:\n+            self.report_error(u'no suitable InfoExtractor: %s' % url)\n+        \n+    def process_ie_result(self, ie_result, download=True, extra_info={}):\n+        \"\"\"\n+        Take the result of the ie(may be modified) and resolve all unresolved\n+        references (URLs, playlist items).\n+\n+        It will also download the videos if 'download'.\n+        Returns the resolved ie_result.\n+        \"\"\"\n+\n+        result_type = ie_result.get('_type', 'video') # If not given we suppose it's a video, support the default old system\n+        if result_type == 'video':\n+            if 'playlist' not in ie_result:\n+                # It isn't part of a playlist\n+                ie_result['playlist'] = None\n+                ie_result['playlist_index'] = None\n+            if download:\n+                self.process_info(ie_result)\n+            return ie_result\n+        elif result_type == 'url':\n+            # We have to add extra_info to the results because it may be\n+            # contained in a playlist\n+            return self.extract_info(ie_result['url'],\n+                                     download,\n+                                     ie_key=ie_result.get('ie_key'),\n+                                     extra_info=extra_info)\n+        elif result_type == 'playlist':\n+            # We process each entry in the playlist\n+            playlist = ie_result.get('title', None) or ie_result.get('id', None)\n+            self.to_screen(u'[download] Downloading playlist: %s'  % playlist)\n+\n+            playlist_results = []\n+\n+            n_all_entries = len(ie_result['entries'])\n+            playliststart = self.params.get('playliststart', 1) - 1\n+            playlistend = self.params.get('playlistend', -1)\n+\n+            if playlistend == -1:\n+                entries = ie_result['entries'][playliststart:]\n+            else:\n+                entries = ie_result['entries'][playliststart:playlistend]\n+\n+            n_entries = len(entries)\n+\n+            self.to_screen(u\"[%s] playlist '%s': Collected %d video ids (downloading %d of them)\" %\n+                (ie_result['extractor'], playlist, n_all_entries, n_entries))\n+\n+            for i,entry in enumerate(entries,1):\n+                self.to_screen(u'[download] Downloading video #%s of %s' %(i, n_entries))\n+                extra = {\n+                         'playlist': playlist, \n+                         'playlist_index': i + playliststart,\n+                         }\n+                if not 'extractor' in entry:\n+                    # We set the extractor, if it's an url it will be set then to\n+                    # the new extractor, but if it's already a video we must make\n+                    # sure it's present: see issue #877\n+                    entry['extractor'] = ie_result['extractor']\n+                entry_result = self.process_ie_result(entry,\n+                                                      download=download,\n+                                                      extra_info=extra)\n+                playlist_results.append(entry_result)\n+            ie_result['entries'] = playlist_results\n+            return ie_result\n+        elif result_type == 'compat_list':\n+            def _fixup(r):\n+                r.setdefault('extractor', ie_result['extractor'])\n+                return r\n+            ie_result['entries'] = [\n+                self.process_ie_result(_fixup(r), download=download)\n+                for r in ie_result['entries']\n+            ]\n+            return ie_result\n+        else:\n+            raise Exception('Invalid result type: %s' % result_type)\n+\n+    def process_info(self, info_dict):\n+        \"\"\"Process a single resolved IE result.\"\"\"\n+\n+        assert info_dict.get('_type', 'video') == 'video'\n+        #We increment the download the download count here to match the previous behaviour.\n+        self.increment_downloads()\n+\n+        info_dict['fulltitle'] = info_dict['title']\n+        if len(info_dict['title']) > 200:\n+            info_dict['title'] = info_dict['title'][:197] + u'...'\n+\n+        # Keep for backwards compatibility\n+        info_dict['stitle'] = info_dict['title']\n+\n+        if not 'format' in info_dict:\n+            info_dict['format'] = info_dict['ext']\n+\n+        reason = self._match_entry(info_dict)\n+        if reason is not None:\n+            self.to_screen(u'[download] ' + reason)\n+            return\n+\n+        max_downloads = self.params.get('max_downloads')\n+        if max_downloads is not None:\n+            if self._num_downloads > int(max_downloads):\n+                raise MaxDownloadsReached()\n+\n+        filename = self.prepare_filename(info_dict)\n+\n+        # Forced printings\n+        if self.params.get('forcetitle', False):\n+            compat_print(info_dict['title'])\n+        if self.params.get('forceid', False):\n+            compat_print(info_dict['id'])\n+        if self.params.get('forceurl', False):\n+            compat_print(info_dict['url'])\n+        if self.params.get('forcethumbnail', False) and 'thumbnail' in info_dict:\n+            compat_print(info_dict['thumbnail'])\n+        if self.params.get('forcedescription', False) and 'description' in info_dict:\n+            compat_print(info_dict['description'])\n+        if self.params.get('forcefilename', False) and filename is not None:\n+            compat_print(filename)\n+        if self.params.get('forceformat', False):\n+            compat_print(info_dict['format'])\n+\n+        # Do nothing else if in simulate mode\n+        if self.params.get('simulate', False):\n+            return\n+\n+        if filename is None:\n+            return\n+\n+        try:\n+            dn = os.path.dirname(encodeFilename(filename))\n+            if dn != '' and not os.path.exists(dn):\n+                os.makedirs(dn)\n+        except (OSError, IOError) as err:\n+            self.report_error(u'unable to create directory ' + compat_str(err))\n+            return\n+\n+        if self.params.get('writedescription', False):\n+            try:\n+                descfn = filename + u'.description'\n+                self.report_writedescription(descfn)\n+                with io.open(encodeFilename(descfn), 'w', encoding='utf-8') as descfile:\n+                    descfile.write(info_dict['description'])\n+            except (OSError, IOError):\n+                self.report_error(u'Cannot write description file ' + descfn)\n+                return\n+\n+        if self.params.get('writesubtitles', False) and 'subtitles' in info_dict and info_dict['subtitles']:\n+            # subtitles download errors are already managed as troubles in relevant IE\n+            # that way it will silently go on when used with unsupporting IE\n+            subtitle = info_dict['subtitles'][0]\n+            (sub_error, sub_lang, sub) = subtitle\n+            sub_format = self.params.get('subtitlesformat')\n+            if sub_error:\n+                self.report_warning(\"Some error while getting the subtitles\")\n+            else:\n+                try:\n+                    sub_filename = filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n+                    self.report_writesubtitles(sub_filename)\n+                    with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n+                        subfile.write(sub)\n+                except (OSError, IOError):\n+                    self.report_error(u'Cannot write subtitles file ' + descfn)\n+                    return\n+\n+        if self.params.get('allsubtitles', False) and 'subtitles' in info_dict and info_dict['subtitles']:\n+            subtitles = info_dict['subtitles']\n+            sub_format = self.params.get('subtitlesformat')\n+            for subtitle in subtitles:\n+                (sub_error, sub_lang, sub) = subtitle\n+                if sub_error:\n+                    self.report_warning(\"Some error while getting the subtitles\")\n+                else:\n+                    try:\n+                        sub_filename = filename.rsplit('.', 1)[0] + u'.' + sub_lang + u'.' + sub_format\n+                        self.report_writesubtitles(sub_filename)\n+                        with io.open(encodeFilename(sub_filename), 'w', encoding='utf-8') as subfile:\n+                                subfile.write(sub)\n+                    except (OSError, IOError):\n+                        self.report_error(u'Cannot write subtitles file ' + descfn)\n+                        return\n+\n+        if self.params.get('writeinfojson', False):\n+            infofn = filename + u'.info.json'\n+            self.report_writeinfojson(infofn)\n+            try:\n+                json_info_dict = dict((k, v) for k,v in info_dict.items() if not k in ['urlhandle'])\n+                write_json_file(json_info_dict, encodeFilename(infofn))\n+            except (OSError, IOError):\n+                self.report_error(u'Cannot write metadata to JSON file ' + infofn)\n+                return\n+\n+        if self.params.get('writethumbnail', False):\n+            if 'thumbnail' in info_dict:\n+                thumb_format = info_dict['thumbnail'].rpartition(u'/')[2].rpartition(u'.')[2]\n+                if not thumb_format:\n+                    thumb_format = 'jpg'\n+                thumb_filename = filename.rpartition('.')[0] + u'.' + thumb_format\n+                self.to_screen(u'[%s] %s: Downloading thumbnail ...' %\n+                               (info_dict['extractor'], info_dict['id']))\n+                uf = compat_urllib_request.urlopen(info_dict['thumbnail'])\n+                with open(thumb_filename, 'wb') as thumbf:\n+                    shutil.copyfileobj(uf, thumbf)\n+                self.to_screen(u'[%s] %s: Writing thumbnail to: %s' %\n+                               (info_dict['extractor'], info_dict['id'], thumb_filename))\n+\n+        if not self.params.get('skip_download', False):\n+            if self.params.get('nooverwrites', False) and os.path.exists(encodeFilename(filename)):\n+                success = True\n+            else:\n+                try:\n+                    success = self.fd._do_download(filename, info_dict)\n+                except (OSError, IOError) as err:\n+                    raise UnavailableVideoError()\n+                except (compat_urllib_error.URLError, compat_http_client.HTTPException, socket.error) as err:\n+                    self.report_error(u'unable to download video data: %s' % str(err))\n+                    return\n+                except (ContentTooShortError, ) as err:\n+                    self.report_error(u'content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))\n+                    return\n+\n+            if success:\n+                try:\n+                    self.post_process(filename, info_dict)\n+                except (PostProcessingError) as err:\n+                    self.report_error(u'postprocessing: %s' % str(err))\n+                    return\n+\n+    def download(self, url_list):\n+        \"\"\"Download a given list of URLs.\"\"\"\n+        if len(url_list) > 1 and self.fixed_template():\n+            raise SameFileError(self.params['outtmpl'])\n+\n+        for url in url_list:\n+            try:\n+                #It also downloads the videos\n+                videos = self.extract_info(url)\n+            except UnavailableVideoError:\n+                self.report_error(u'unable to download video')\n+            except MaxDownloadsReached:\n+                self.to_screen(u'[info] Maximum number of downloaded files reached.')\n+                raise\n+\n+        return self._download_retcode\n+\n+    def post_process(self, filename, ie_info):\n+        \"\"\"Run all the postprocessors on the given file.\"\"\"\n+        info = dict(ie_info)\n+        info['filepath'] = filename\n+        keep_video = None\n+        for pp in self._pps:\n+            try:\n+                keep_video_wish,new_info = pp.run(info)\n+                if keep_video_wish is not None:\n+                    if keep_video_wish:\n+                        keep_video = keep_video_wish\n+                    elif keep_video is None:\n+                        # No clear decision yet, let IE decide\n+                        keep_video = keep_video_wish\n+            except PostProcessingError as e:\n+                self.to_stderr(u'ERROR: ' + e.msg)\n+        if keep_video is False and not self.params.get('keepvideo', False):\n+            try:\n+                self.to_screen(u'Deleting original file %s (pass -k to keep)' % filename)\n+                os.remove(encodeFilename(filename))\n+            except (IOError, OSError):\n+                self.report_warning(u'Unable to remove downloaded video file')\n",
          "files_name_in_blame_commit": [
            "YoutubeDL.py",
            "test_download.py",
            "FileDownloader.py",
            "__init__.py",
            "test_write_info_json.py"
          ]
        }
      }
    }
  }
}